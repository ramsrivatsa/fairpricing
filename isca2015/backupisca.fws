S'Fair Pricing in Data centers'
p0
.S'$title: Snapshot Shuttering for Fair Pricing in Data Centers'
p0
.I2
.S'Main Sections'
p0
.S'$cmt_off!'
p0
.I9
.S'Abstract'
p0
.S''
p0
.I2
.S'Problem'
p0
.S"$absp: Infrastructure as a service (IaaS) Cloud computing has recently emerged as a new paradigm for cost effectiveness that allows users to pay a flat hourly rate to run their applications on a virtual machine (VM) running on a server providing access to some combination of CPUs, memory and network resources. However, co-located workloads running on different user's VM's on the same physical node may interfere with one another. This situation might leads to an unfair scenario causing degradation to performance of the individual applications.  The magnitude of degradation is highly variable as it depends upon the nature of the co-located application. Since, there is no control over the nature of co-runner running in the same node, such a situation can lead to a biased pricing scenario where a user might end up paying more for running his application if he is co-located with a contentious co-runner. "
p0
.I0
.S'Solution'
p0
.S'$absp:To address this limitation, we present Fair Pricing, a dynamic, lightweight and robust runtime engine that accurately predicts the degradation due to co-location and charges users in a fair manner. Fair Pricing employs a methodology called Snapshot Shuttering which examines the runtime phases of applications with the help of multiple hardware Performance Monitoring Units (PMUs) and attempts to detect a phase change. It then uses this information to perform snapshot shuttering --- a technique to accurately deduce the interference due to co-runners. In this work, we show that we can accurately identify phase changes and predict inter application interference within 4\\% mean absolute error on SPEC benchmarks with a very low overhead around 1\\% when there exist up to 4 simultaneously running applications. \n'
p0
.I0
.S'Introduction'
p0
.S'$s:Introduction'
p0
.I15
.S'Resource utilization problem in current day datacenters'
p0
.S'$p:Low resource utilization in modern day data centers have become a primary concern \\cite{Barroso:2007:CEC:1339817.1339894}. Though there is significant potential for parallel execution of multiple applications across different cores, within a single node, most of them remain unutilized. Much of this is due to the degradation in performance of the induvidual applications as a result of sharing of resources like L3 cache and memory bandwidth \\cite{37124} \\cite{Zhuravlev:2010:ASR:1735971.1736036} \\cite{Zhuravlev:2010:ASR:1736020.1736036} \\cite{Zhuravlev:2010:ASR:1735970.1736036} \\cite{Govindan:2011:CQE:2038916.2038938}.'
p0
.I0
.S'State of the art solution to that problem'
p0
.S'$p:To tackle this situation, modern day Infrastructure as a Service (IaaS) cloud computing providers have separate billing schemes based on whether to allow co-location or not. For example amazon EC2 has On Demand instances and Reserved Instances which allow co-location of applications belonging to other users unlike Dedicated Instances which disallow co-location \\cite{amazon}. This lets the user choose schemes that are suitable for them based on their time and budget constraints \\cite{6133267} \\cite{5279594} \\cite{Farley:2012:MYM:2391229.2391249}.'
p0
.I0
.S'Pricing issues due to colocation'
p0
.S'$p: Although there seems to be advantages associated with these schemes, they gives rise to a new set of challenges one of which is fairness in pricing. Under such schemes, the nature of the co-runners are unknown due to the highly variable magnitude of performance degradation. In some cases, a cache contentious co-runner causes greater degradation to an application than a compute intensive co-runner would. In general the magnitude of performance degradation increases as the number of co-runners running on the same node increase. Current day pricing schemes in data centers do not take into account these factors. Such a situation might lead to a scenario in which the execution time of a particular application can vary significantly when run at different times under the same infrastructural setup. Since pricing in IaaS cloud is directly proportional to the execution time, this variability may incur drastic unwarranted penalties. \n\n'
p0
.I0
.S'Magnitude by which users are affect because of the issues'
p0
.S'$p: Figure \\ref{fig:comparecorun} shows the degradation due to co-location caused when a user is running  libquantum, a library for quantum computer simulation while co-locating 3 instances of the applications present in the xaxis. Under the current scheme a user running libquantum would end up paying 39\\% more when co-located with 3 more instances of libquantum as co-runner than when co-located with 3 instances of povray as a co-runner.   A possible remedy to this solution is to be able to accurately predict the degradation due to the interference caused by the co runners and to discount the applications accordingly. Since the vendors already benefit from the increased throughput per machine due to co location, these discounts can be viewed as passing over the saving from co-locations back to user whose Quality of Service has been degraded as a result \\cite{reqos} \\cite{mars13isca} \\cite{DBLP:journals/corr/abs-0909-1784}.\n'
p0
.I0
.S'$fig:comparecorun,1:'
p0
.S''
p0
.I0
.S'$graph:comparecorun:Price to be paid when running libquantum when co-located with 3 instances of the co-runners in the xaxis normalized to the price to be payed when running libquantum when co-located with 3 instances of povray:1'
p0
.S'from collections import defaultdict\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ncolocationListBaseline = [ \'colocating with perlbench\', \'colocating with astar\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with bzip2\', \'colocating with libquantum\' ]\nrunningList = [ \'libquantum\', \'colocating with astar\', \'libquantum\', \'colocating with perlbench\', \'libquantum\', \'colocating with omnetpp\', \'libquantum\', \'colocating with bzip2\', \'libquantum\', \'colocating with libquantum\' ]\nbenchListExperiments = [\'libquantum\']\nlibquantum=1.09\ndef autolabel(rects):\n    # attach some text labels\n    for rect in rects:\n        height = rect.get_height()\n        plt.text(rect.get_x()+rect.get_width()/2., 1.05*height, \'%.2f\'%float(height), size=\'15\')\n\ndef autolabel2(rects):\n    # attach some text labels\n    for rect in rects:\n        height = rect.get_height()\n        plt.text(rect.get_x()+rect.get_width()/2., 1.05*height, \'%.2f\'%float(height))\n\nfilename = \'shutter_cpi_5\'\nfList2 = [s.strip() for s in open(\'../../papergraphs/1.5intrograph/degradation_ground_truth/shutter_cpi_1000.txt\').readlines()]\n\ndictList_degradation_colocation = defaultdict(lambda  : defaultdict(list))\n\nfor (b,a) in enumerate(fList2):\n    if a in colocationListBaseline:\n        index = a\n    else:\n        if a in benchListExperiments:\n            dictList_degradation_colocation[index][a].append(float(fList2[b+1]))\n\nyaxis = ()\nxaxis = ()\n#sorting the ground truth values\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    xaxis = xaxis + (j[16:],)\n    yaxis = yaxis + (np.mean(dictList_degradation_colocation[j][i])/np.mean(dictList_degradation_colocation[\'colocating with povray\'][i]), )\n    #print j,i,dictList_degradation_colocation[j][i]\n\nwidth=0.5\nx = np.arange(len(yaxis))\nfig = plt.figure(figsize=(10, 5))\nbar1 = plt.bar( x, yaxis, width, color="g", label=\'libquantum with co-runners in the xaxis\')\n#bar2 = plt.bar( x+width, yaxis2, width, color="b", label=\'colocating with mcf  (avg = %.2f)\' %(np.mean(yaxis_abs2)))\nautolabel(bar1)\n#autolabel(bar2)\nplt.ylabel( \'Priced normalize to running with povray\' )\nplt.xticks(x + width/2.0, xaxis, rotation=\'30\',  ha=\'center\', size=\'20\')\nplt.ylim(-0.1,2)\nplt.xlim(-0.5,5)\nplt.grid()\nplt.tight_layout()\nplt.legend(prop={\'size\':20})\n#plt.savefig(\'comparecorun.png\', dpi=150)\n#plt.show()\n#plt.close()\n#plt.savefig(\'%s_error.png\' %(filename), dpi=125)\n\n'
p0
.I0
.S'Motivation towards a better solution'
p0
.S'$p:Accurately predicting degradation due to co-location with a minimum overhead possess a significant challenge\\cite{6522315}. Move over, the impact on shared resources as the number of co-runners increase raises the difficulty in predicting the degradation due to co-location as shown in the Figure \\ref{fig:degradation}.'
p0
.I0
.S'$fig:degradation,1:'
p0
.S''
p0
.I0
.S'$graph:degradation:Increase in degradation due to co-location with increase in the number of co-runners(top). Increase in predicting degradation due to co-location by prior work with increase in the number of co-runners (bottom).:1'
p0
.S'from collections import defaultdict\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nbenchListBaseline = [ \'milc\', \'bwaves\', \'mcf\', \'astar\', \'bzip2\', \'h264ref\', \'tonto\', \'lbm\', \'xalancbmk\', \'omnetpp\', \'libquantum\' ]\n#benchListExperiments = [ \'perlbench\', \'astar\', \'soplex\', \'xalancbmk\', \'omnetpp\', \'bzip2\',\'povray\']\nbenchListExperiments = [ \'milc\', \'bwaves\', \'mcf\', \'astar\', \'bzip2\', \'h264ref\', \'tonto\', \'lbm\', \'xalancbmk\', \'omnetpp\', \'libquantum\' ]\n#benchListExperiments = [ \'perlbench\', \'astar\', \'soplex\', \'xalancbmk\', \'omnetpp\']\ncolocationListBaseline = [ \'colocating with lbm\', \'colocating with povray\', \'colocating with astar\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with mcf\' ]\ncolocationListExperiments = [ \'colocating with lbm\', \'colocating with povray\', \'colocating with perlbench\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with mcf\' ]\n#benchListBaseline = [ \'gcc\', \'perlbench\', \'mcf\', \'leslie3d\', \'povray\', \'libquantum\', \'astar\', \'bzip2\', \'milc\', \'namd\', \'calculix\', \'h264ref\', \'zeusmp\', \'gobmk\', \'hmmer\', \'tonto\', \'sphinx3\', \'bwaves\', \'gromacs\', \'dealII\', \'sjeng\', \'lbm\', \'xalancbmk\', \'gamess\', \'cactusADM\', \'soplex\', \'GemsFDTD\', \'omnetpp\' ]\n#benchListExperiments = [ \'gcc\', \'perlbench\', \'astar\', \'soplex\', \'xalancbmk\', \'omnetpp\']\n#colocationListBaseline = [ \'colocating with gcc\', \'colocating with mcf\', \'colocating with perlbench\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with bzip2\' ]\nrunningList = [ \'milc\', \'colocating with libquantum\', \'astar\', \'colocating with libquantum\', \'omnetpp\', \'colocating with libquantum\', \'mcf\', \'colocating with libquantum\', \'libquantum\', \'colocating with libquantum\', \'xalancbmk\', \'colocating with libquantum\', \'lbm\', \'colocating with libquantum\'  ]\n#colocationListOracle = [ \'colocating with gcc\', \'colocating with colocating with mcf\', \'colocating with perlbench\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with bzip2\' ]\n\ndef autolabel(rects):\n    # attach some text labels\n    for rect in rects:\n        height = rect.get_height()\n        plt.text(rect.get_x()+rect.get_width()/2., 1.1*height, \'%.2f\'%float(height), fontsize=8, ha=\'center\', va= \'bottom\')\n\ndef autolabel2(rects):\n    # attach some text labels\n    for rect in rects:\n        height = rect.get_height()\n        plt.text(rect.get_x()+rect.get_width()/2., -1.1*height, \'%.1f\'%float(height), fontsize=8, ha=\'center\', va= \'top\')\n\nfilename = \'shutter_cpi_1000\'\nfilename2 = \'shutter_cpi_4\'\nfList = [s.strip() for s in open(\'../../papergraphs/1.intrograph/single_vm_ground_truth/shutter_cpi_1000.txt\').readlines()]\nfList2 = [s.strip() for s in open(\'../../papergraphs/1.intrograph/2_degradation_ground_truth/%s.txt\' % filename).readlines()]\nfList3 = [s.strip() for s in open(\'../../papergraphs/1.intrograph/3_degradation_ground_truth/%s.txt\' % filename).readlines()]\nfList4 = [s.strip() for s in open(\'../../papergraphs/1.intrograph/degradation_ground_truth/%s.txt\' % filename).readlines()]\nfList5 = [s.strip() for s in open(\'../../papergraphs/1.intrograph/prior_work/2_vm_prior_work/%s.txt\' % filename2).readlines()]\nfList6 = [s.strip() for s in open(\'../../papergraphs/1.intrograph/prior_work/3_vm_prior_work/%s.txt\' % filename2).readlines()]\nfList7 = [s.strip() for s in open(\'../../papergraphs/1.intrograph/prior_work/4_vm_prior_work/%s.txt\' % filename2).readlines()]\n\ndictList_single_vm = defaultdict(list)\ndictList_single_vm_mean = defaultdict(float)\ndictList_degradation_colocation = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter2 = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter_prev = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter_prev2 = defaultdict(lambda  : defaultdict(list))\nfinal_degradation = defaultdict(lambda  : defaultdict(list))\nplot_degradation = defaultdict(dict)\nplot_degradation_error = defaultdict(dict)\n\nfor (b,a) in enumerate(fList):\n    if a in benchListBaseline:\n        dictList_single_vm[a].append(fList[b+1])\n\n#SORTING LIST CONTAING VALUES OF SINGLE SPEC RUNS INSIDE VMs\nfor i in benchListBaseline:\n    dictList_single_vm[i].sort()\n    dictList_single_vm_mean[i] = sum(float(item) for item in dictList_single_vm[i])/len(dictList_single_vm[i])\n#    numerator1 = sum(float(n) for (m,n) in enumerate(dictList_degradation_colocation[j][i]))/(len(dictList_degradation_colocation[j][i]))\n    #print i,dictList_single_vm_mean[i]\n\n    #print i,dictList_single_vm[i]\n\nglobal index\nfor (b,a) in enumerate(fList2):\n    #print a\n    if a in colocationListBaseline:\n       #print a\n       index = a\n    else:\n        if a in benchListExperiments:\n            #print a\n            dictList_degradation_colocation[index][a].append(fList2[b+1])\n#sorting the ground truth values\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    #dictList_degradation_colocation[j][i].sort()\n    #print j,i,dictList_degradation_colocation[j][i]\n\n#for a in xrange(0,len(runningList),2):\n#    j = runningList[a+1]\n#    i = runningList[a]\n#    numerator1 = sum(float(n) for (m,n) in enumerate(dictList_degradation_colocation[j][i]) if m!=0 and m!=len(dictList_degradation_colocation[j][i])-1)/(len(dictList_degradation_colocation[j][i])-2)\n#    print numerator1\n#    #print dictList_degradation_colocation[runningList[a+1]][runningList[a]]\n#    #print numerator1\n\n#APPENDING DEGRADATION SHUTTER\nfor (b,a) in enumerate(fList3):\n    if a in colocationListExperiments:\n        index = a\n    else:\n        if a in benchListExperiments:\n            dictList_degradation_shutter[index][a].append(fList3[b+1])\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    #dictList_degradation_colocation[j][i].sort()\n    #print j,i,dictList_degradation_shutter[j][i]\n\nfor (b,a) in enumerate(fList4):\n    if a in colocationListExperiments:\n        index = a\n    else:\n        if a in benchListExperiments:\n            dictList_degradation_shutter2[index][a].append(fList4[b+1])\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    #dictList_degradation_colocation[j][i].sort()\n    #print j,i,dictList_degradation_shutter2[j][i]\n\n\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    #dictList_degradation_colocation[j][i].sort()\n    #print j,i,dictList_degradation_shutter2[j][i]\n    sum_of = []\n    for n in dictList_degradation_colocation[j][i]:\n        sum_of.append(float(n))\n    #print np.mean(sum_of)\n    final_degradation[j][i].append(np.mean(sum_of))\n    del sum_of\n\n    sum_of = []\n    for n in dictList_degradation_shutter[j][i]:\n        sum_of.append(float(n))\n    #print np.mean(sum_of)\n    final_degradation[j][i].append(np.mean(sum_of))\n    del sum_of\n\n    sum_of = []\n    for n in dictList_degradation_shutter2[j][i]:\n        sum_of.append(float(n))\n    #print np.mean(sum_of)\n    final_degradation[j][i].append(np.mean(sum_of))\n    del sum_of\n\nxaxis = ()\nvm2 = ()\nvm3 = ()\nvm4 = ()\n#fig, ax = plt.subplots()\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    plot_list = []\n    xaxis = xaxis + (i,)\n    for (count,item) in enumerate(final_degradation[j][i]):\n        #print count\n        if count == 0:\n            vm2 = vm2 + (final_degradation[j][i][0]/dictList_single_vm_mean[i] ,)\n        if count == 1:\n            vm3 = vm3 + (final_degradation[j][i][1]/dictList_single_vm_mean[i], )\n        if count == 2:\n            vm4 = vm4 + (final_degradation[j][i][2]/dictList_single_vm_mean[i], )\n    #for item in final_degradation[j][i]:\n    #    plot_list.append(item/final_degradation[j][i][0])\n    #print i,j,final_degradation[j][i]\n    #x = np.arange(2,len(plot_list)+2,1)\n    #ax.plot(np.arange(2,len(plot_list)+2,1), plot_list, label=\'%s\' %(i))\n    #ax.set_xticks(np.arange(min(x), max(x)+1, 1.0))\n    #del plot_list\n\nprint vm2\nprint vm3\nprint vm4\n\n\nshutter_vm2 = ()\nshutter_vm3 = ()\nshutter_vm4 = ()\n\n\nfor (b,a) in enumerate(fList5):\n    if a in colocationListExperiments:\n        index = a\n    else:\n        if a in benchListExperiments:\n            dictList_degradation_shutter_prev[index][a].append(fList5[b+1])\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    for elem in dictList_degradation_shutter_prev[j][i]:\n        dictList_degradation_shutter_prev2[j][i].extend(elem.strip().split(\'\\t\'))\n    #print dictList_degradation_shutter_prev2[j][i]\n\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    #print i\n    denominator1 = sum(float(n) for (m,n) in enumerate(dictList_single_vm[i]))/(len(dictList_single_vm[i]))\n    numerator1 = sum(float(n) for (m,n) in enumerate(dictList_degradation_colocation[j][i]))/(len(dictList_degradation_colocation[j][i]))\n    shutter_temp_list = []\n    colo_temp_list = []\n    degradation_temp_list = []\n    error_temp_list = []\n    #print numerator1\n    #print denominator1\n    for (count,item) in enumerate(dictList_degradation_shutter_prev2[j][i]):\n        #print item\n        if count%2==0:\n            colo_temp_list.append(item)\n        if count%2==1:\n            shutter_temp_list.append(item)\n\n    for (count,item) in enumerate(shutter_temp_list):\n        degradation_temp_list.append(abs((((float(shutter_temp_list[count])/float(colo_temp_list[count]))-(numerator1/denominator1))/(float(shutter_temp_list[count])/float(colo_temp_list[count])))*100))\n\n    shutter_temp_list.sort()\n    colo_temp_list.sort()\n    #print shutter_temp_list\n    #print colo_temp_list\n    #print dictList_degradation_shutter2[j][i]\n    denominator2 = sum(float(n) for (m,n) in enumerate(shutter_temp_list) if m!=0 and m!=len(shutter_temp_list)-1)/(len(shutter_temp_list)-2)\n    #print len(colo_temp_list)\n    #print len(shutter_temp_list)\n    numerator2 = sum(float(n) for (m,n) in enumerate(colo_temp_list) if m!=0 and m!=len(colo_temp_list)-1)/(len(colo_temp_list)-2)\n    for (m,n) in enumerate(shutter_temp_list):\n        ratio=float(n)/float(colo_temp_list[m])\n        error_temp_list.append(abs((((ratio)-(numerator1/denominator1))/(numerator1/denominator1))*100))\n    plot_degradation_error[j][i]=np.std(error_temp_list)\n\n    #print numerator2\n    #print denominator2\n    del shutter_temp_list\n    del colo_temp_list\n    del degradation_temp_list\n    plot_degradation[j][i] = abs((((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100)\n    shutter_vm2 = shutter_vm2 + (plot_degradation[j][i]*-1,)\n    #print denominator2/numerator2\n    #print j,i,plot_degradation[j][i]\n            #print (((numerator2/denominator2)-(numerator1/denominator1))/(numerator2/denominator2))*100\n\nprint shutter_vm2\n\n\ndel dictList_degradation_shutter_prev\ndel dictList_degradation_shutter_prev2\ndel plot_degradation\ndel plot_degradation_error\n\ndictList_degradation_shutter_prev = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter_prev2 = defaultdict(lambda  : defaultdict(list))\nplot_degradation = defaultdict(dict)\nplot_degradation_error = defaultdict(dict)\n\n\nfor (b,a) in enumerate(fList6):\n    if a in colocationListExperiments:\n        index = a\n    else:\n        if a in benchListExperiments:\n            dictList_degradation_shutter_prev[index][a].append(fList6[b+1])\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    for elem in dictList_degradation_shutter_prev[j][i]:\n        dictList_degradation_shutter_prev2[j][i].extend(elem.strip().split(\'\\t\'))\n    #print dictList_degradation_shutter_prev2[j][i]\n\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    #print i\n    denominator1 = sum(float(n) for (m,n) in enumerate(dictList_single_vm[i]))/(len(dictList_single_vm[i]))\n    numerator1 = sum(float(n) for (m,n) in enumerate(dictList_degradation_shutter[j][i]))/(len(dictList_degradation_shutter[j][i]))\n    shutter_temp_list = []\n    colo_temp_list = []\n    degradation_temp_list = []\n    error_temp_list = []\n    #print numerator1\n    #print denominator1\n    for (count,item) in enumerate(dictList_degradation_shutter_prev2[j][i]):\n        #print item\n        if count%2==0:\n            colo_temp_list.append(item)\n        if count%2==1:\n            shutter_temp_list.append(item)\n\n    for (count,item) in enumerate(shutter_temp_list):\n        degradation_temp_list.append(abs((((float(shutter_temp_list[count])/float(colo_temp_list[count]))-(numerator1/denominator1))/(float(shutter_temp_list[count])/float(colo_temp_list[count])))*100))\n\n    shutter_temp_list.sort()\n    colo_temp_list.sort()\n    #print shutter_temp_list\n    #print colo_temp_list\n    #print dictList_degradation_shutter2[j][i]\n    denominator2 = sum(float(n) for (m,n) in enumerate(shutter_temp_list) if m!=0 and m!=len(shutter_temp_list)-1)/(len(shutter_temp_list)-2)\n    #print len(colo_temp_list)\n    #print len(shutter_temp_list)\n    numerator2 = sum(float(n) for (m,n) in enumerate(colo_temp_list) if m!=0 and m!=len(colo_temp_list)-1)/(len(colo_temp_list)-2)\n    for (m,n) in enumerate(shutter_temp_list):\n        ratio=float(n)/float(colo_temp_list[m])\n        error_temp_list.append(abs((((ratio)-(numerator1/denominator1))/(numerator1/denominator1))*100))\n    plot_degradation_error[j][i]=np.std(error_temp_list)\n\n    #print numerator2\n    #print denominator2\n    del shutter_temp_list\n    del colo_temp_list\n    del degradation_temp_list\n    plot_degradation[j][i] = abs((((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100)\n    shutter_vm3 = shutter_vm3 + (plot_degradation[j][i]*-1,)\n    #print denominator2/numerator2\n    #print j,i,plot_degradation[j][i]\n            #print (((numerator2/denominator2)-(numerator1/denominator1))/(numerator2/denominator2))*100\n\nprint shutter_vm3\n\n\nfor (b,a) in enumerate(fList7):\n    if a in colocationListExperiments:\n        index = a\n    else:\n        if a in benchListExperiments:\n            dictList_degradation_shutter_prev[index][a].append(fList7[b+1])\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    for elem in dictList_degradation_shutter_prev[j][i]:\n        dictList_degradation_shutter_prev2[j][i].extend(elem.strip().split(\'\\t\'))\n    #print dictList_degradation_shutter_prev2[j][i]\n\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    #print i\n    denominator1 = sum(float(n) for (m,n) in enumerate(dictList_single_vm[i]))/(len(dictList_single_vm[i]))\n    numerator1 = sum(float(n) for (m,n) in enumerate(dictList_degradation_shutter2[j][i]))/(len(dictList_degradation_shutter2[j][i]))\n    shutter_temp_list = []\n    colo_temp_list = []\n    degradation_temp_list = []\n    error_temp_list = []\n    #print numerator1\n    #print denominator1\n    for (count,item) in enumerate(dictList_degradation_shutter_prev2[j][i]):\n        #print item\n        if count%2==0:\n            colo_temp_list.append(item)\n        if count%2==1:\n            shutter_temp_list.append(item)\n\n    for (count,item) in enumerate(shutter_temp_list):\n        degradation_temp_list.append(abs((((float(shutter_temp_list[count])/float(colo_temp_list[count]))-(numerator1/denominator1))/(float(shutter_temp_list[count])/float(colo_temp_list[count])))*100))\n\n    shutter_temp_list.sort()\n    colo_temp_list.sort()\n    #print shutter_temp_list\n    #print colo_temp_list\n    #print dictList_degradation_shutter2[j][i]\n    denominator2 = sum(float(n) for (m,n) in enumerate(shutter_temp_list) if m!=0 and m!=len(shutter_temp_list)-1)/(len(shutter_temp_list)-2)\n    #print len(colo_temp_list)\n    #print len(shutter_temp_list)\n    numerator2 = sum(float(n) for (m,n) in enumerate(colo_temp_list) if m!=0 and m!=len(colo_temp_list)-1)/(len(colo_temp_list)-2)\n    for (m,n) in enumerate(shutter_temp_list):\n        ratio=float(n)/float(colo_temp_list[m])\n        error_temp_list.append(abs((((ratio)-(numerator1/denominator1))/(numerator1/denominator1))*100))\n    plot_degradation_error[j][i]=np.std(error_temp_list)\n\n    #print numerator2\n    #print denominator2\n    del shutter_temp_list\n    del colo_temp_list\n    del degradation_temp_list\n    plot_degradation[j][i] = abs((((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100)\n    shutter_vm4 = shutter_vm4 + (plot_degradation[j][i]*-1,)\n    #print denominator2/numerator2\n    #print j,i,plot_degradation[j][i]\n            #print (((numerator2/denominator2)-(numerator1/denominator1))/(numerator2/denominator2))*100\nprint shutter_vm4\n\ndel dictList_degradation_shutter_prev\ndel dictList_degradation_shutter_prev2\ndel plot_degradation\ndel plot_degradation_error\n\ndictList_degradation_shutter_prev = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter_prev2 = defaultdict(lambda  : defaultdict(list))\nplot_degradation = defaultdict(dict)\nplot_degradation_error = defaultdict(dict)\n\n\nwidth=0.2\nx = np.arange(len(vm2))\nplt.figure(figsize=(6, 4))\nplt.subplot(2, 1, 1)\nplt.bar( x, vm2, width, color="r", label=\'2 corunners running libquantum\' )\n#plt.text(0.5, 0.5, ha=\'center\', va=\'center\', size=24, alpha=.5)\nplt.bar( x+width, vm3, width, color="b", label=\'3 corunners running libquantum \' )\nplt.bar( x+width+width, vm4, width, color="g", label=\'4 corunners running libquantum \')\nplt.ylim(0,6)\nplt.ylabel( \'Degradation\' )\nplt.yticks(np.arange(0, 6, 1))\nplt.xticks(())\nplt.legend(prop={\'size\':8})\n#plt.xticks(x + width, xaxis, rotation=\'30\', size=\'8\')\n\nplt.subplot(2, 1, 2)\nbar4 = plt.bar( x, shutter_vm2, width, color="r", label=\'2 corunners running libquantum\' )\nbar5 = plt.bar( x+width, shutter_vm3, width, color="b", label=\'3 corunners running libquantum \' )\nbar6 = plt.bar( x+width+width, shutter_vm4, width, color="g", label=\'4 corunners running libquantum \')\n#plt.yticks(())\n#plt.text(0.5, 0.5, \'subplot(2,1,2)\', ha=\'center\', va=\'center\',\n#        size=24, alpha=.5)\n\nplt.tight_layout()\nplt.ylabel( \'Percentage Error\' )\nplt.xticks(x + width, xaxis, rotation=\'30\', size=\'12\')\nplt.ylim(-30,0)\nplt.yticks(np.arange(-30, 0, 10))\nplt.tight_layout()\n#plt.tight_layout()\n## default scale is 1 in your original case, scales with other cases:\n##plt.show()\nplt.savefig(\'%s_degradation_colocation.png\' %(filename),  dpi=125)\n\n#plt.show()'
p0
.I0
.S'Prior Work'
p0
.S'$p:There are a number of prior work that try to address this problem. Bubble Up \\cite{bubbleup} uses static techniques to predict the degradation due to co-location. While these might be suitable for applications whose nature is well defined, in scenarios like Amazon EC2 where you would be unaware of the nature of applications running, usage of static techniques might not be an effective solution. Prior work targeted at enabling fair pricing HPC \\cite{fairpricing} systems uses a technique called precise shuttering. One of the issues that it failed to address is the effectiveness of their solution when the number of co-runners increase. Hence, we need a runtime which is accurate, dynamic, lightweight and robust even when number of co-runners scale up.'
p0
.I0
.S'Proposed Solution'
p0
.S"$p:To address these three challenges, we propose a novel Fair Pricing Runtime Engine. It is a dynamic, lightweight approach which at runtime effectively detects an application's degradation due to co-runners with high accuracy and low overhead. We have designed a deployable lightweight software solution which can work well across multiple architectures which does not require changes to the current production system software in deployment. "
p0
.I0
.S'Techniques used'
p0
.S'$p:The key techniques that we have used in this paper is called Snapshot Shuttering. This consists for two parts :- phase detection and ground truth estimation. It examines the runtime phases of the application portrayed by multiple performance counter types to detect phase changes\\cite{1598119}\\cite{1528455}\\cite{1238018}. Once a change in the runtime phase of an application has been detected, it then estimates the ground truth for standalone execution for the respective VM by pausing VMs running the co-running applications. Once an application completes execution, it then predicts the CPI of the application for standalone execution by aggregating the weighted sum of  individual CPIs during every phase, the weights being the time for which an application stays for in every phase. \n'
p0
.I0
.S'Contribution'
p0
.S'$p:To the best of our knowledge, this paper is the first to address the concern due to the challenges present in Fair Pricing of users running applications when the number of co-running applications scale up. The contributions  of our paper are as follows :-\n\\begin{itemize}\n\\item Fair Pricing Runtime Engine - a lightweight, robust and deployable runtime system that enables Fair Pricing in Data centers. \n\\item Snapshot Shuttering - Performance Monitoring Units (PMU) based phase examination technique to estimate ground truth of standalone execution of an application. \n\\item Phase changing mechanism - We also have introduced a Queue based multivariate binary classification technique, motivated from prior work [cite][cite] so as to capture phase change at a finer granularity as well as to discard noise which examining applications to detect phase change.\n\\end{itemize}\n'
p0
.I0
.S'Results discussion'
p0
.S'$p: Using snapshot shuttering, we are able to precisely predict the performance degradation due to co-locations of SPEC applications \\cite{Henning:2006:SCB:1186736.1186737} with a mean absolute error of around 2.8 \\% and often less than 1\\% and with a very small amount of overhead.\n'
p0
.I0
.S'Section Organization'
p0
.S''
p0
.I0
.S'Background and Motivation'
p0
.S'$s: Background and Motivation'
p0
.I3
.S'Overview'
p0
.S'$p: In this section, we briefly describe the broad classification of compute based instances that Amazon Web Services (AWS) provide for customers. We then discuss the pricing strategies of Amazon Web Services and the solution proposed in the prior work for enabling Fair Pricing in HPC systems.\n'
p0
.I0
.S'Amazon Web Services'
p0
.S'$s: Amazon Web Services'
p0
.I3
.S'AMS descriptions'
p0
.S"$p: \\vspace{-2 mm} Amazon Web Services (AWS) provides services for on-demand computing resources in the cloud, with a pay-as-you-go pricing scheme. Clients typically rent Virtual Machines called instances where each instance can be configured reasonably based on the user's requirements. These instance types can be broadly categorized into Compute Optimized, Memory Optimized, GPUs etc. Within those broader categories clients can choose sub categories which are defined by their coarse grained micro architectural configurations namely number of VCPUs, size of RAM and SSD Storage. "
p0
.I0
.S'Types of instances'
p0
.S'$p: With respect to co-location, Amazon broadly classifies its instances into two categories based on whether to allow co-location or not. AWS Dedicated Instances are instances that do not share hardware with other AWS clients, which clearly denies the possibility of a co-location scenario. Unlike Dedicated Instances, AWS Reserved / On-Demand Instances allows co-location of applications belonging to other users in the same node. The payment of these instances range from a few cents to a few dollars, per hour, per running instance.\n'
p0
.I0
.S'Problem with respect to Amazon'
p0
.S'$p:Current day datacenters house individual nodes with numerous cores. A high level execution manager is responsible for scheduling applications belonging to multiple users in the same node based on some resource utilization heuristics. This co-location of multiple applications might lead to a situation where the applications might start running slower due to the contention of shared resources like last level cache and bandwidth to memory. For example, the degradation of user facing applications like web search, maps, email and other Internet services which latency-sensitive can be measured directly to see if extensive co-location hinders the application?s QoS target, as negotiated by the client and the service provider if there exists such policies. On the other hand a broad category of applications which are batch type, do not have a well defined performance metric like latency-sensitive applications to quantify their degradation. Also, in many cases the nature of the application is unknown before its execution. One cannot assign fixed QoS target, based on application specific metrics, to such a class of applications. As a result of this datacenter operators and system designers typically disallow co-locations which results in unnecessary over-provisioning of compute resources reducing the overall resource utilization of datacenters.'
p0
.I0
.S'Prior Work and its limitations'
p0
.S'$s:Prior work and its limitations\n'
p0
.I2
.S'Intro to fair Pricing'
p0
.S'$p:To address the prediction of degradation due to co-location, prior work presents Fair Pricing on HPC Systems, a runtime technique to precisely predict the degradation due to co-location in High Performance Computing applications.\n'
p0
.I0
.S'Explain their methedology'
p0
.S''
p0
.I2
.S'explanation'
p0
.S'$p: Prior work uses the help of a centralized controller which monitors all the applications that are running in a single node. Its principle responsibility is to conduct shuttering, a mechanism to measure and quantify the performance interference among the co-running applications \\cite{fairpricing} \\cite{Gupta_QualityTime_ISPASS_2014}. In essence, the controller periodically pauses all but one application for a very short period and monitors the performance impact on the lone application. This is being done in a round robin fashion to all the applications that are co-running to estimate the performance impact on every individual lone application. To measure this, their controller probes Performance Monitoring Units of each active job to acquire the performance data and logs it.'
p0
.I0
.S'limitations'
p0
.S'$p:Fair Pricing is shown to be effective at predicting degradation due to co-locations for pairs of HPC applications. However, there are several primary limitations of this work. As the number or co-runners scale up, the prediction error increases enormously. This is due to the fact that the frequency at which every individual application running in the node is sampled in order to estimate ground truth decreases directly impacting the accuracy of estimation. Another limitation with prior work is when it tries to predict degradation for applications whose execution phases are flat, their shuttering technique repeatedly estimates ground truth unnecessarily for the entire execution as the variation among the estimated samples at subsequent intervals are very low within noise range throughout its execution period, meaning that estimation need not be repeated.\n'
p0
.I0
.S'Fair Pricing Overview'
p0
.S'$s: Snapshot Shuttering to build a Fair Pricing Runtime Engine'
p0
.I7
.S'Overview'
p0
.S'$p: In this section we give an overview of our proposed Snapshot Shuttering technique for building a Fair Pricing Runtime Engine. Fair Pricing Runtime Engine is a lightweight and accurate runtime to measure the cross core interference on shared resources across multiple applications so as to effectively predict the degradation due to co-location. It runs on top of the host operating system monitoring the performance of VMs executing different applications belonging to different users as shown in Figure \\ref{fig:FPRE_stack}.'
p0
.I0
.S'Figure explain'
p0
.S'$p: From Figure \\ref{fig:FPRE_stack} we can see that every virtual machine is associated with 2 physical cores and its own private main memory. Fair Pricing runtime engine runs on the host operating system which monitors the VMs that are running on that node.\n'
p0
.I0
.S'$fig:FPRE_stack,1:'
p0
.S''
p0
.I0
.S'$pdf_fig:FPRE_stack:Overview of fair pricing runtime engine in the software stack\\vspace{-3 mm}:1'
p0
.S''
p0
.I0
.S'How we do it?'
p0
.S'$p: The principle methodology which we employ for Fair Pricing is by use of a technique called snapshot shuttering. The primary objective of snapshot shuttering is to periodically pause all the co-runners but one for a short time interval and to measure the performance interval of on the lone running application.\n'
p0
.I0
.S'Employing Phase Changing to shuttering'
p0
.S'$s: Phase changing mechanism'
p0
.I6
.S'Why phase changing'
p0
.S'$p: Batch applications exhibit time varying behavior. To capture such time varying behavior, researchers have proposed detecting program phases[cite][cite] where a phase is defined as a period of execution with stable behavior. We know that the CPI of the application in a particular phase is quite constant. So, we dynamically try to detect phase changes in the applications that are co-located with each other to obtain an indication for significant CPI variations of that application. When there is a phase change detected, we pause the co-runners and estimate the ground truth CPI for the application whose phase has been changed. We use that as an estimated CPI throughout a particular phase for the application. By this way, we greatly reduce the overhead that is caused by constantly pausing the co-runners at unnecessary frequent intervals even within a single phase as employed by the prior work \\cite{fairpricing}.\n'
p0
.I0
.S'How phase changing'
p0
.S'$p: There is considerable prior work done for static and dynamic detection of runtime phases in applications \\cite{sembrand2011iiswc} \\cite{Lukefahr:2012:CCP:2457472.2457508} \\cite{6114207} \\cite{Balasubramonian:2000:MHR:360128.360153} \\cite{1402088} \\cite{Sherwood:2003:PTP:871656.859657} \\cite{Brankovic:2014:AOP:2597917.2597937}. We employ a dynamic, low overhead phase detection technique using hardware Performance Monitoring Units (PMUs) that is inspired from prior work to suit our system. We study the characteristics of multiple performance events of every single application over time to identify phase changes among individual applications that are co-located. We demonstrate that these events should exhibit significant variation in their behavior of an application so as to be detected as a phase change for that application. '
p0
.I0
.S'Explanation of figures'
p0
.S'$p: Figure \\ref{fig:phasechanging} illustrates how phase changing mechanism works. The top part of Figure \\ref{fig:phasechanging} shows the phases of 3 application with time. The bottom part of Figure \\ref{fig:phasechanging} shows how snapshot shuttering works when phase changing is being detected. We can see that whenever a phase change is detected on a particular VM, the runtime pauses the execution of the other co-locating applications and tries to estimate the ground truth of the standalone run of the application.\n'
p0
.I0
.S'$fig*:phasechanging,1:noise,1:'
p0
.S''
p0
.I0
.S'$pdf_fig:phasechanging:Shows how shuttering is done based on phase changing methedology \\vspace{-2 mm}:1'
p0
.S''
p0
.I0
.S'$pdf_fig:noise:Overview of noise elimination in runtime \\vspace{-12 mm}:1'
p0
.S''
p0
.I0
.S'Noise elimination'
p0
.S'$s:Noise elimination'
p0
.I6
.S'What is noise'
p0
.S'$p: With the help of performance monitoring counters, we are able to obtain the phase characteristics of multiple applications over time. We obtain them by measuring their characteristics at coarse grained intervals of one second and plotting them with respect to time. Even for such coarse grained intervals we observe frequent spikes in the reported CPI of execution. These spikes are short but significant variation in execution characteristics due to some micro architectural behavior limitation like cache warm up or page fault, for a short interval of time. Given as such, the phase changing methodology that we employ should not classify them as a new phase.\n'
p0
.I0
.S'Solution - data structure'
p0
.S'$p: To address this challenge, we employ a binary classification technique. As shown in the \\ref{fig:noise}, we use separate queues for different PMU types of a particular application. Each queue has a window of size $k$ which stores the $k$ latest events that has been reported by PMUs for that application. '
p0
.I0
.S'Solution algorithm'
p0
.S'$p:At the start of every phase we estimate ground truth. We declare a phase change in the application whenever a significant number of the elements present in the queue show high variation compared to the ground truth. In, this way we are able to eliminate incorrect phase change classification due to short durational variations in the program.'
p0
.I0
.S'$omit!:$fig:noise,1:'
p0
.S''
p0
.I0
.S'Noise Elimination overview'
p0
.S''
p0
.I0
.S'Figure explanation'
p0
.S'$p: Figure \\ref{fig:noise} illustrates how binary classification is done for every individual PMU type corresponding to individual application. Binary classification is done separately for PMU type of every application and whenever there is a phase change observed by either of the PMU types, then ground truth for that application for which phase change is detected is being estimated. \n'
p0
.I0
.S'Fair Pricing Methodology'
p0
.S'$s:Snapshot Shuttering Methodology in Fair Pricing Runtime Engine'
p0
.I5
.S'Algorithm for Fair Pricing'
p0
.S'$s:Algorithms present in Fair Pricing Runtime Engine\n'
p0
.I7
.S'$omit!:Fair Pricing Runtime Engine'
p0
.S'$t:\n\\begin{algorithm}[H]\n\\caption{Fair Pricing Runtime Engine}\n\\label{FPRE}\n\\While{ture}{\nMeasure(\\&A,T,\\&C)\\;\nPC\\_A=BinaryClassification(\\&QueueVM,\\&C)\\;\n\\For{VM in A} {\n\\For{counter in counterType} {\n\t\\If{PC\\_A[VM][counter]}{\n\tGetGroundTruth(VM)\\;\n\tbreak\\;\n\t}\n}\n}\n}\n\n\\end{algorithm}\n'
p0
.I0
.S'Introduction of Algorithm Description'
p0
.S'$p: In this section, we present the algorithms that constitute the Fair Pricing Runtime Engine. The main core routine is Algorithm 1s. The other algorithms are being invoked as function call from the core routine algorithm.  '
p0
.I0
.S'Data structures used'
p0
.S'$p:\nBelow, we define a list of common data structures and constants used by the algorithms.\n\\begin{itemize}\n  \\item A [ ], an array of co-located VMs running applications\n  \\item C [ ], an array of counter types \n  \\item T, the length of measurements of performance counters in seconds\n  \\item The types of performance counters measured.\n  \\item Queue[ ][ ], a two dimensional array of performance counter measurements stored for every VM and its respective performance counter type.\n  \\item PC\\_A is a list of all VMs that have been classified by the Binary Classification algorithm to require a Phase Change.\n  \\item G\\_VM, the VM to get the ground truth.\n  \\item $ \\delta_{counter} $ Threshold uniqe to each counter so as to issue phase change\n\\end{itemize}'
p0
.I0
.S'Fair Pricing Runtime Engine'
p0
.S'$t:\n\\begin{algorithm}\n\\caption{Fair Pricing Runtime Engine}\n\\begin{algorithmic}[1]\n\\label{FPRE}\n%\\Procedure{Fair Pricing Runtime Engine}{}\n\\While{true}\n\\State Measure(\\&A,T,\\&C)\\;\n\\State PC\\_A=BinaryClassification(\\&QueueVM,\\&C)\\;\n\\For{VM in A} \n\\For{counter in counterType} \n\t\\If{PC\\_A[VM][counter]}\n\tGetGroundTruth(VM)\\;\n\tbreak\\;\n\t\\EndIf\n\\EndFor\n\\EndFor\n\n\\EndWhile\n%\\EndProcedure\n\\end{algorithmic}\n\\end{algorithm}'
p0
.I0
.S'Measure Performance Counters'
p0
.S'$t:\n\\begin{algorithm}\n\\caption{Measure(A[ ], T, C[ ])}\n\\begin{algorithmic}[1]\n\\For{VM in A} \n\\For{counter in counterType} \n\\State StartCounterMeasurement \\;\n\\EndFor\n\\EndFor\n\\textit{sleep S seconds}\\;\n\\For{VM in A} \n\\For{counter in counterType} \n\\State\tStopCounterMeasurement \\;\n\\State\tQueue[VM][counter].enqueue(MeasuredCounterValue)\\;\n\\State\tQueue[VM][counter].dequeue()\\;\n\\EndFor\n\\EndFor\n\\end{algorithmic}\n\\end{algorithm}'
p0
.I0
.S'Binary Classification'
p0
.S'$t:\n\\begin{algorithm}\n\\caption{BinaryClassification(QueueVM[],C[])}\n\\begin{algorithmic}[1]\n\\label{BC}\n\\For{VM in A} \n\\For{counter in counterType} \n\t\\If{$70 \\% of the elements in queue >= \\delta_{counter} $}\n\tPC\\_A[VM][counter] = true;\n\tbreak\\;\n\t\\EndIf\n\\EndFor\n\\EndFor\n\\end{algorithmic}\n\\end{algorithm}'
p0
.I0
.S'Getting Ground truth'
p0
.S'$t:\n\\begin{algorithm}\n\\caption{Getting Ground Truth(G\\_VM)}\n\\begin{algorithmic}[1]\n\\label{alg:groundtruth}\n\\For{VM in A} \n\\For{counter in counterType} \n\t\\If{G\\_VM != VM }\n\t\\State\tpause VM\\;\n\t\\EndIf\n\\EndFor\n\\EndFor\n\\State Measure(\\&G\\_VM, T, C[ ])\\;\n\\For{VM in A} \n\\For{counter in counterType} \n\t\\If{G\\_VM != VM }\n\t\\State\tresume VM\\;\n\t\\EndIf\n\\EndFor\n\\EndFor\n\\textit{sleep S seconds}\\;\n%\\For{VM in A} {\n%\\For{counter in counterType} {\n\n%}\n%}\n\\end{algorithmic}\n\\end{algorithm}'
p0
.I0
.S'Algorithm Description'
p0
.S'$s:Description of Algorithms in Fair Pricing Runtime Engine'
p0
.I5
.S'Explanation - measurement'
p0
.S'$p: At start of every iteration, the core routine algorithm obtains the Performance Monitoring Unit (PMU) measurements for each PMU type for an interval of 1 second for every application which is co-located. It then appends every single measurement to their respective queues for specific PMU types of that application and discards the oldest value for every queue.'
p0
.I0
.S'Explanation - binary classification'
p0
.S'$p:The queue is then subjected to a binary classification technique as shown in Algorithm 3. This technique tells whether a significant portion of the elements present in that queue is different from so as to indicate a phase change. In a situation where it declares a phase change, it obtains the average of the elements in the queue. Subsequent PMU measurements will now be compared against this average to indicate variations in phase changes. '
p0
.I0
.S'Explanation - noise elimination'
p0
.S'$p:It is to be noted that we are using more than one PMU type to indicate phase change as shown in Figure \\ref{fig:noise}. The reason behind this is based on the following observation. Even with coarse granular intervals between for measurements we could observe in some applications spikes in execution. These do not attribute to a phase change and using a single value prediction might mis-classify them   as a phase change. Hence we need a queue based phase detection mechanism.'
p0
.I0
.S'Examples'
p0
.S'$p:From Figure \\ref{fig:noise} we can see that every application has its associated PMU. For every application, the PMUs maintains a queue of CPI, L1-Dcache Loads and LLC-stores as shown in the figure. It determines phase classification based on the the inputs given by each type of PMU. We use a conservative approach to detect phase changes by declaring a phase change whenever any of the PMU type declares a phase change. This is because missing out a phase which runs for a longer time would result in drastic increase in prediction accuracy. However predicting phase changes which are not causes no harm as the frequency of phase changes are very low and the resulting overhead associated with a few extra phase changes are bearable within tolerable overhead limits.'
p0
.I0
.S'Ground Truth estimation'
p0
.S'$p: In the event of phase change as declared by either of the PMU types corresponding to  particular application, Algorithm 4 tries to estimate the ground truth representing the CPI of the lone run of that application. It pauses all the other co-running applications and measures the performance statistics of the lone run of a single application. This is the estimated ground truth till the phase changes for that application. '
p0
.I0
.S'Tuning Snapshot shuttering mechanism'
p0
.S'$s: Tuning Snapshot shuttering mechanism'
p0
.I4
.S'Brief intro'
p0
.S'$p: The implementation of Snapshot Shuttering mechanism that we use presents a number of challenges. There are a lot of parametric decisions that we have to consider to achieve high prediction accuracy.'
p0
.I0
.S'PMC types'
p0
.S'$p: Perf profiler tool for linux based on \\texttt{perf\\_events} interface supports a list of measurable events. Selecting a subset of events to monitor the phase characteristics of a wide variety of applications for phase detection was a major challenge. Application specific micro-architectural insights towards choosing PMU types were very helpful for us. Most significant phase changes was explicitly portrayed by micro-architectural events like branch-misses, L1-data cache and LLC-loads. The explanation towards that is as follows:-\n'
p0
.I1
.S'explain'
p0
.S'$p: A single procedures or code segment that executes the same basic blocks repeatedly show similar CPI measurements with time and they constitute what defines as a single phase. Typical examples of these are iterative processing applications performing different tasks. When a they are being executed iteratively, PMC measurements like branches, L1-Dcache accesses remain fairly same due to the execution of repetitive code segments. When a there is a change in the executing code segment, PMU measurements change as the the control flow and the data flow characteristics of the newly executing code segments will be different to the previous one. This might be reflected at different granularities by CPI measurements for different phase changes within applications, they are hugely reflected  by such PMU measurements and hence can be useful information to detect phase changes for varying granularity. In our experiments we observed that L1-dcache accesses and Last Level Cache characteristics are able to identify phase changes across applications in a much accurate manner. '
p0
.I0
.S'Frequency of shuttering'
p0
.S'$p: In the prior work, shuttering has been done once every 200ms for the individual applications in a round robin fashion. In our work, we check for phase changes at a much coarser granularity of about once every 1 second for all applications. We use this the snapshot of phase of the application to observe phase changes and to decide whether to perform shuttering or not. The size of the Queues for PMC type is 7 recent samples. The runtime engine declares a phase change if 5 of them are significantly out of phase. The magnitude by which each PMC type should be off is different for individual PMC types in a particular architecture. Every time a phase change is being declared, we wait 5ms before we start to measure. This serves as a cache warm up time for sampling the performance characteristics of the lone application.'
p0
.I0
.S'Cache warm up time'
p0
.S''
p0
.I0
.S'$fig*:accuracy,2:!'
p0
.S''
p0
.I0
.S'$graph:accuracy:Accuracy in prediction of degradation due to co-location using Snapshot Shuttering technique:1'
p0
.S'\n\nfrom collections import defaultdict\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nbenchListBaseline = [ \'gcc\', \'perlbench\', \'leslie3d\', \'povray\', \'libquantum\', \'astar\', \'bzip2\', \'milc\', \'namd\', \'calculix\', \'h264ref\', \'sphinx3\', \'zeusmp\', \'gobmk\', \'hmmer\', \'tonto\', \'bwaves\', \'gromacs\', \'dealII\', \'sjeng\', \'lbm\', \'xalancbmk\', \'gamess\', \'cactusADM\', \'soplex\', \'GemsFDTD\', \'omnetpp\', \'mcf\' ]\nbenchListExperiments = [ \'gcc\', \'perlbench\', \'leslie3d\', \'povray\', \'libquantum\', \'astar\', \'bzip2\', \'milc\', \'namd\', \'calculix\', \'h264ref\', \'sphinx3\', \'zeusmp\', \'gobmk\', \'hmmer\', \'tonto\', \'bwaves\', \'gromacs\', \'dealII\', \'sjeng\', \'lbm\', \'xalancbmk\', \'gamess\', \'cactusADM\', \'soplex\', \'GemsFDTD\', \'omnetpp\', \'mcf\' ]\ncolocationListBaseline = [ \'colocating with lbm\', \'colocating with povray\', \'colocating with astar\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with mcf\' ]\ncolocationListExperiments = [ \'colocating with lbm\', \'colocating with povray\', \'colocating with perlbench\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with mcf\' ]\nrunningList = [  \'perlbench\', \'colocating with libquantum\', \'mcf\', \'colocating with libquantum\', \'leslie3d\', \'colocating with libquantum\', \'povray\', \'colocating with libquantum\', \'libquantum\', \'colocating with libquantum\', \'astar\', \'colocating with libquantum\', \'bzip2\', \'colocating with libquantum\', \'milc\', \'colocating with libquantum\', \'namd\', \'colocating with libquantum\', \'calculix\', \'colocating with libquantum\', \'h264ref\', \'colocating with libquantum\', \'gobmk\', \'colocating with libquantum\', \'hmmer\', \'colocating with libquantum\', \'tonto\', \'colocating with libquantum\', \'sphinx3\', \'colocating with libquantum\', \'bwaves\', \'colocating with libquantum\', \'gromacs\', \'colocating with libquantum\', \'dealII\', \'colocating with libquantum\', \'sjeng\', \'colocating with libquantum\', \'lbm\', \'colocating with libquantum\', \'xalancbmk\', \'colocating with libquantum\', \'gamess\', \'colocating with libquantum\', \'cactusADM\', \'colocating with libquantum\', \'soplex\', \'colocating with libquantum\', \'GemsFDTD\', \'colocating with libquantum\', \'omnetpp\', \'colocating with libquantum\' ]\nrunningList2 = [  \'perlbench\', \'colocating with mcf\', \'mcf\', \'colocating with mcf\', \'leslie3d\', \'colocating with mcf\', \'povray\', \'colocating with mcf\', \'libquantum\', \'colocating with mcf\', \'astar\', \'colocating with mcf\', \'bzip2\', \'colocating with mcf\', \'milc\', \'colocating with mcf\', \'namd\', \'colocating with mcf\', \'calculix\', \'colocating with mcf\', \'h264ref\', \'colocating with mcf\', \'gobmk\', \'colocating with mcf\', \'hmmer\', \'colocating with mcf\', \'tonto\', \'colocating with mcf\', \'sphinx3\', \'colocating with mcf\', \'bwaves\', \'colocating with mcf\', \'gromacs\', \'colocating with mcf\', \'dealII\', \'colocating with mcf\', \'sjeng\', \'colocating with mcf\', \'lbm\', \'colocating with mcf\', \'xalancbmk\', \'colocating with mcf\', \'gamess\', \'colocating with mcf\', \'cactusADM\', \'colocating with mcf\', \'soplex\', \'colocating with mcf\', \'GemsFDTD\', \'colocating with mcf\', \'omnetpp\', \'colocating with mcf\' ]\n\n\ndef autolabel(rects):\n    # attach some text labels\n    for rect in rects:\n        height = rect.get_height()\n        plt.text(rect.get_x()+rect.get_width()/2., 1.05*height, \'%.2f\'%float(height))\n\ndef autolabel2(rects):\n    # attach some text labels\n    for rect in rects:\n        height = rect.get_height()\n        plt.text(rect.get_x()+rect.get_width()/2., 1.05*height, \'%.2f\'%float(height))\n\nfilename = \'shutter_cpi_5\'\nfList = [s.strip() for s in open(\'../../papergraphs/2.fullspec/accuracy/libquantumcorunner/single_vm_ground_truth/shutter_cpi_1000.txt\').readlines()]\nfList2 = [s.strip() for s in open(\'../../papergraphs/2.fullspec/accuracy/libquantumcorunner/degradation_ground_truth/shutter_cpi_1000.txt\').readlines()]\nfList3 = [s.strip() for s in open(\'../../papergraphs/2.fullspec/accuracy/libquantumcorunner/experiment_1/%s.txt\' % filename).readlines()]\n\nfList4 = [s.strip() for s in open(\'../../papergraphs/2.fullspec/accuracy/mcfcorunner/single_vm_ground_truth/shutter_cpi_1000.txt\').readlines()]\nfList5 = [s.strip() for s in open(\'../../papergraphs/2.fullspec/accuracy/mcfcorunner/degradation_ground_truth_mcf/shutter_cpi_1000.txt\').readlines()]\nfList6 = [s.strip() for s in open(\'../../papergraphs/2.fullspec/accuracy/mcfcorunner/experiment_1_mcf/%s.txt\' % filename).readlines()]\n\nfList7 = [s.strip() for s in open(\'../../papergraphs/2.fullspec/accuracy/sphinx3corunner/single_vm_ground_truth/shutter_cpi_1000.txt\').readlines()]\nfList8 = [s.strip() for s in open(\'../../papergraphs/2.fullspec/accuracy/sphinx3corunner/degradation_ground_truth_sphinx3/shutter_cpi_1000.txt\').readlines()]\nfList9 = [s.strip() for s in open(\'../../papergraphs/2.fullspec/accuracy/sphinx3corunner/experiment_1_sphinx3/%s.txt\' % filename).readlines()]\n\ndictList_single_vm = defaultdict(list)\ndictList_degradation_colocation = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter2 = defaultdict(lambda  : defaultdict(list))\nplot_degradation = defaultdict(dict)\nplot_degradation_abs = defaultdict(dict)\nplot_degradation_error = defaultdict(dict)\n\nfor (b,a) in enumerate(fList):\n    if a in benchListBaseline:\n        dictList_single_vm[a].append(fList[b+1])\n\n#SORTING LIST CONTAING VALUES OF SINGLE SPEC RUNS INSIDE VMs\nfor i in benchListBaseline:\n    dictList_single_vm[i].sort()\n    #print i,dictList_single_vm[i]\n\nglobal index\nfor (b,a) in enumerate(fList2):\n    #print a\n    if a in colocationListBaseline:\n       #print a\n       index = a\n    else:\n        if a in benchListExperiments:\n            #print a\n            dictList_degradation_colocation[index][a].append(fList2[b+1])\n\n#sorting the ground truth values\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    dictList_degradation_colocation[j][i].sort()\n    #print j,i,dictList_degradation_colocation[j][i]\n\n#for a in xrange(0,len(runningList),2):\n#    j = runningList[a+1]\n#    i = runningList[a]\n#    numerator1 = sum(float(n) for (m,n) in enumerate(dictList_degradation_colocation[j][i]) if m!=0 and m!=len(dictList_degradation_colocation[j][i])-1)/(len(dictList_degradation_colocation[j][i])-2)\n#    print numerator1\n#    #print dictList_degradation_colocation[runningList[a+1]][runningList[a]]\n#    #print numerator1\n\n#APPENDING DEGRADATION SHUTTER\nfor (b,a) in enumerate(fList3):\n    if a in colocationListExperiments:\n        index = a\n    else:\n        if a in benchListExperiments:\n            dictList_degradation_shutter[index][a].append(fList3[b+1])\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    #print i,j,dictList_degradation_shutter[j][i]\n#APPENDING DEGRADATION SHUTTER2 as shutter and colocation values are tab separated\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    for elem in dictList_degradation_shutter[j][i]:\n        dictList_degradation_shutter2[j][i].extend(elem.strip().split(\'\\t\'))\n    #print dictList_degradation_shutter2[j][i]\n\nyaxis = ()\nyaxis_abs = ()\nerror = ()\nxaxis = ()\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    #print i,j\n    #print dictList_single_vm[i]\n    #print dictList_degradation_colocation[j][i]\n    #print dictList_degradation_shutter2[j][i]\n    denominator1 = sum(float(n) for (m,n) in enumerate(dictList_single_vm[i]) if m!=0 and m!=len(dictList_single_vm[i])-1)/(len(dictList_single_vm[i])-2)\n    numerator1 = sum(float(n) for (m,n) in enumerate(dictList_degradation_colocation[j][i]) if m!=0 and m!=len(dictList_degradation_colocation[j][i])-1)/(len(dictList_degradation_colocation[j][i])-2)\n    shutter_temp_list = []\n    colo_temp_list = []\n    degradation_temp_list = []\n    error_temp_list = []\n    #print numerator1\n    #print denominator1\n    for (count,item) in enumerate(dictList_degradation_shutter2[j][i]):\n        if count%2==0:\n            colo_temp_list.append(item)\n        if count%2==1:\n            shutter_temp_list.append(item)\n\n    for (count,item) in enumerate(shutter_temp_list):\n        degradation_temp_list.append(abs((((float(shutter_temp_list[count])/float(colo_temp_list[count]))-(numerator1/denominator1))/(float(shutter_temp_list[count])/float(colo_temp_list[count])))*100))\n\n    shutter_temp_list.sort()\n    colo_temp_list.sort()\n    #print shutter_temp_list\n    #print colo_temp_list\n    #print dictList_degradation_shutter2[j][i]\n    denominator2 = sum(float(n) for (m,n) in enumerate(shutter_temp_list) if m!=0 and m!=len(shutter_temp_list)-1)/(len(shutter_temp_list)-2)\n    numerator2 = sum(float(n) for (m,n) in enumerate(colo_temp_list) if m!=0 and m!=len(colo_temp_list)-1)/(len(colo_temp_list)-2)\n    for (m,n) in enumerate(shutter_temp_list):\n        ratio=float(n)/float(colo_temp_list[m])\n        error_temp_list.append(abs((((ratio)-(numerator1/denominator1))/(numerator1/denominator1))*100))\n    plot_degradation_error[j][i]=np.std(error_temp_list)\n\n    #print numerator2\n    #print denominator2\n    del shutter_temp_list\n    del colo_temp_list\n    del degradation_temp_list\n    plot_degradation[j][i] = (((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100\n    plot_degradation_abs[j][i] = abs((((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100)\n    #print j,i,plot_degradation[j][i]\n    #print plot_degradation_error[j][i]\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    xaxis = xaxis + (i,)\n    yaxis = yaxis + (plot_degradation[j][i],)\n    yaxis_abs = yaxis_abs + (plot_degradation_abs[j][i],)\n    error = error + (plot_degradation_error[j][i],)\n    #print numerator2,denominator2,numerator2/denominator2\n    #print denominator2/numerator2\n    #print j,i,plot_degradation[j][i]\n            #print (((numerator2/denominator2)-(numerator1/denominator1))/(numerator2/denominator2))*100\n\n#print xaxis\nprint np.mean(yaxis)\n#print error\n\n\ndel dictList_single_vm\ndel dictList_degradation_colocation\ndel dictList_degradation_shutter\ndel dictList_degradation_shutter2\ndel plot_degradation\ndel plot_degradation_error\n\ndictList_single_vm = defaultdict(list)\ndictList_degradation_colocation = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter2 = defaultdict(lambda  : defaultdict(list))\nplot_degradation = defaultdict(dict)\nplot_degradation_error = defaultdict(dict)\n\nfor (b,a) in enumerate(fList4):\n    if a in benchListBaseline:\n        dictList_single_vm[a].append(fList4[b+1])\n\n#SORTING LIST CONTAING VALUES OF SINGLE SPEC RUNS INSIDE VMs\nfor i in benchListBaseline:\n    dictList_single_vm[i].sort()\n    #print i,dictList_single_vm[i]\n\nfor (b,a) in enumerate(fList5):\n    #print a\n    if a in colocationListBaseline:\n       #print a\n       index = a\n    else:\n        if a in benchListExperiments:\n            #print a\n            dictList_degradation_colocation[index][a].append(fList5[b+1])\n\n#sorting the ground truth values\nfor a in xrange(0,len(runningList2),2):\n    j = runningList2[a+1]\n    i = runningList2[a]\n    dictList_degradation_colocation[j][i].sort()\n    #print j,i,dictList_degradation_colocation[j][i]\n\n#for a in xrange(0,len(runningList),2):\n#    j = runningList[a+1]\n#    i = runningList[a]\n#    numerator1 = sum(float(n) for (m,n) in enumerate(dictList_degradation_colocation[j][i]) if m!=0 and m!=len(dictList_degradation_colocation[j][i])-1)/(len(dictList_degradation_colocation[j][i])-2)\n#    print numerator1\n#    #print dictList_degradation_colocation[runningList[a+1]][runningList[a]]\n#    #print numerator1\n\n#APPENDING DEGRADATION SHUTTER\nfor (b,a) in enumerate(fList6):\n    if a in colocationListExperiments:\n        index = a\n    else:\n        if a in benchListExperiments:\n            dictList_degradation_shutter[index][a].append(fList6[b+1])\n\nfor a in xrange(0,len(runningList2),2):\n    j = runningList2[a+1]\n    i = runningList2[a]\n    #print i,j,dictList_degradation_shutter[j][i]\n#APPENDING DEGRADATION SHUTTER2 as shutter and colocation values are tab separated\nfor a in xrange(0,len(runningList2),2):\n    j = runningList2[a+1]\n    i = runningList2[a]\n    for elem in dictList_degradation_shutter[j][i]:\n        dictList_degradation_shutter2[j][i].extend(elem.strip().split(\'\\t\'))\n    #print dictList_degradation_shutter2[j][i]\n\nyaxis2 = ()\nyaxis_abs2 = ()\nerror2 = ()\nxaxis2 = ()\nfor a in xrange(0,len(runningList2),2):\n    j = runningList2[a+1]\n    i = runningList2[a]\n    #print i,j\n    #print dictList_single_vm[i]\n    #print dictList_degradation_colocation[j][i]\n    #print dictList_degradation_shutter2[j][i]\n    denominator1 = sum(float(n) for (m,n) in enumerate(dictList_single_vm[i]) if m!=0 and m!=len(dictList_single_vm[i])-1)/(len(dictList_single_vm[i])-2)\n    numerator1 = sum(float(n) for (m,n) in enumerate(dictList_degradation_colocation[j][i]) if m!=0 and m!=len(dictList_degradation_colocation[j][i])-1)/(len(dictList_degradation_colocation[j][i])-2)\n    shutter_temp_list = []\n    colo_temp_list = []\n    degradation_temp_list = []\n    error_temp_list = []\n    #print numerator1\n    #print denominator1\n    for (count,item) in enumerate(dictList_degradation_shutter2[j][i]):\n        if count%2==0:\n            colo_temp_list.append(item)\n        if count%2==1:\n            shutter_temp_list.append(item)\n\n    for (count,item) in enumerate(shutter_temp_list):\n        degradation_temp_list.append(abs((((float(shutter_temp_list[count])/float(colo_temp_list[count]))-(numerator1/denominator1))/(float(shutter_temp_list[count])/float(colo_temp_list[count])))*100))\n\n    shutter_temp_list.sort()\n    colo_temp_list.sort()\n    #print shutter_temp_list\n    #print colo_temp_list\n    #print dictList_degradation_shutter2[j][i]\n    denominator2 = sum(float(n) for (m,n) in enumerate(shutter_temp_list) if m!=0 and m!=len(shutter_temp_list)-1)/(len(shutter_temp_list)-2)\n    numerator2 = sum(float(n) for (m,n) in enumerate(colo_temp_list) if m!=0 and m!=len(colo_temp_list)-1)/(len(colo_temp_list)-2)\n    for (m,n) in enumerate(shutter_temp_list):\n        ratio=float(n)/float(colo_temp_list[m])\n        error_temp_list.append(abs((((ratio)-(numerator1/denominator1))/(numerator1/denominator1))*100))\n    plot_degradation_error[j][i]=np.std(error_temp_list)\n\n    #print numerator2\n    #print denominator2\n    del shutter_temp_list\n    del colo_temp_list\n    del degradation_temp_list\n    plot_degradation[j][i] = (((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100\n    plot_degradation_abs[j][i] = abs((((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100)\n    #print j,i,plot_degradation[j][i]\n    #print plot_degradation_error[j][i]\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    xaxis2 = xaxis2 + (i,)\n    yaxis2 = yaxis2 + (plot_degradation[j][i],)\n    yaxis_abs2 = yaxis_abs2 + (plot_degradation_abs[j][i],)\n    error2 = error2 + (plot_degradation_error[j][i],)\n    #print numerator2,denominator2,numerator2/denominator2\n    #print denominator2/numerator2\n    #print j,i,plot_degradation[j][i]\n            #print (((numerator2/denominator2)-(numerator1/denominator1))/(numerator2/denominator2))*100\nprint np.mean(yaxis2)\n\n\n\ndel dictList_single_vm\ndel dictList_degradation_colocation\ndel dictList_degradation_shutter\ndel dictList_degradation_shutter2\ndel plot_degradation\ndel plot_degradation_error\n\ndictList_single_vm = defaultdict(list)\ndictList_degradation_colocation = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter2 = defaultdict(lambda  : defaultdict(list))\nplot_degradation = defaultdict(dict)\nplot_degradation_error = defaultdict(dict)\n\nfor (b,a) in enumerate(fList7):\n    if a in benchListBaseline:\n        dictList_single_vm[a].append(fList7[b+1])\n\n#SORTING LIST CONTAING VALUES OF SINGLE SPEC RUNS INSIDE VMs\nfor i in benchListBaseline:\n    dictList_single_vm[i].sort()\n    #print i,dictList_single_vm[i]\n\nfor (b,a) in enumerate(fList8):\n    #print a\n    if a in colocationListBaseline:\n       #print a\n       index = a\n    else:\n        if a in benchListExperiments:\n            #print a\n            dictList_degradation_colocation[index][a].append(fList8[b+1])\n\n#sorting the ground truth values\nfor a in xrange(0,len(runningList2),2):\n    j = runningList2[a+1]\n    i = runningList2[a]\n    dictList_degradation_colocation[j][i].sort()\n    #print j,i,dictList_degradation_colocation[j][i]\n\n#for a in xrange(0,len(runningList),2):\n#    j = runningList[a+1]\n#    i = runningList[a]\n#    numerator1 = sum(float(n) for (m,n) in enumerate(dictList_degradation_colocation[j][i]) if m!=0 and m!=len(dictList_degradation_colocation[j][i])-1)/(len(dictList_degradation_colocation[j][i])-2)\n#    print numerator1\n#    #print dictList_degradation_colocation[runningList[a+1]][runningList[a]]\n#    #print numerator1\n\n#APPENDING DEGRADATION SHUTTER\nfor (b,a) in enumerate(fList9):\n    if a in colocationListExperiments:\n        index = a\n    else:\n        if a in benchListExperiments:\n            dictList_degradation_shutter[index][a].append(fList9[b+1])\n\nfor a in xrange(0,len(runningList2),2):\n    j = runningList2[a+1]\n    i = runningList2[a]\n    #print i,j,dictList_degradation_shutter[j][i]\n#APPENDING DEGRADATION SHUTTER2 as shutter and colocation values are tab separated\nfor a in xrange(0,len(runningList2),2):\n    j = runningList2[a+1]\n    i = runningList2[a]\n    for elem in dictList_degradation_shutter[j][i]:\n        dictList_degradation_shutter2[j][i].extend(elem.strip().split(\'\\t\'))\n    #print dictList_degradation_shutter2[j][i]\n\nyaxis3 = ()\nyaxis_abs3 = ()\nerror3 = ()\nxaxis3 = ()\nfor a in xrange(0,len(runningList2),2):\n    j = runningList2[a+1]\n    i = runningList2[a]\n    #print i,j\n    #print dictList_single_vm[i]\n    #print dictList_degradation_colocation[j][i]\n    #print dictList_degradation_shutter2[j][i]\n    denominator1 = sum(float(n) for (m,n) in enumerate(dictList_single_vm[i]) if m!=0 and m!=len(dictList_single_vm[i])-1)/(len(dictList_single_vm[i])-2)\n    numerator1 = sum(float(n) for (m,n) in enumerate(dictList_degradation_colocation[j][i]) if m!=0 and m!=len(dictList_degradation_colocation[j][i])-1)/(len(dictList_degradation_colocation[j][i])-2)\n    shutter_temp_list = []\n    colo_temp_list = []\n    degradation_temp_list = []\n    error_temp_list = []\n    #print numerator1\n    #print denominator1\n    for (count,item) in enumerate(dictList_degradation_shutter2[j][i]):\n        if count%2==0:\n            colo_temp_list.append(item)\n        if count%2==1:\n            shutter_temp_list.append(item)\n\n    for (count,item) in enumerate(shutter_temp_list):\n        degradation_temp_list.append(abs((((float(shutter_temp_list[count])/float(colo_temp_list[count]))-(numerator1/denominator1))/(float(shutter_temp_list[count])/float(colo_temp_list[count])))*100))\n\n    shutter_temp_list.sort()\n    colo_temp_list.sort()\n    #print shutter_temp_list\n    #print colo_temp_list\n    #print dictList_degradation_shutter2[j][i]\n    denominator2 = sum(float(n) for (m,n) in enumerate(shutter_temp_list) )/(len(shutter_temp_list))\n    numerator2 = sum(float(n) for (m,n) in enumerate(colo_temp_list))/(len(colo_temp_list))\n    for (m,n) in enumerate(shutter_temp_list):\n        ratio=float(n)/float(colo_temp_list[m])\n        error_temp_list.append(abs((((ratio)-(numerator1/denominator1))/(numerator1/denominator1))*100))\n    plot_degradation_error[j][i]=np.std(error_temp_list)\n\n    #print numerator2\n    #print denominator2\n    del shutter_temp_list\n    del colo_temp_list\n    del degradation_temp_list\n    plot_degradation[j][i] = (((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100\n    plot_degradation_abs[j][i] = abs((((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100)\n    #print j,i,plot_degradation[j][i]\n    #print plot_degradation_error[j][i]\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    xaxis3 = xaxis3 + (i,)\n    yaxis3 = yaxis3 + (plot_degradation[j][i],)\n    yaxis_abs3 = yaxis_abs3 + (plot_degradation_abs[j][i],)\n    error3 = error3 + (plot_degradation_error[j][i],)\n    #print numerator2,denominator2,numerator2/denominator2\n    #print denominator2/numerator2\n    #print j,i,plot_degradation[j][i]\n            #print (((numerator2/denominator2)-(numerator1/denominator1))/(numerator2/denominator2))*100\nprint np.mean(yaxis3)\n\n\nwidth=0.25\nx = np.arange(len(yaxis))\nfig = plt.figure(figsize=(12, 5))\nbar1 = plt.bar( x, yaxis, width, color="r", label=\'colocating with libquatum (avg = %.2f)\' %(np.mean(yaxis_abs)))\nbar2 = plt.bar( x+width, yaxis2, width, color="b", label=\'colocating with mcf  (avg = %.2f)\' %(np.mean(yaxis_abs2)))\nbar3 = plt.bar( x+width+width, yaxis3, width, color="g", label=\'colocating with sphinx  (avg = %.2f)\' %(np.mean(yaxis_abs3)))\n#autolabel(bar1)\n#autolabel(bar2)\nplt.ylabel( \'Percentage Error\' )\nplt.title(\'Error in predicting degradation\')\nplt.xticks(x + width/2.0, xaxis, rotation=\'30\', size=\'10\',  ha=\'center\', va=\'top\')\nplt.ylim(-100,100)\nplt.xlim(-1,25)\nplt.grid()\nplt.tight_layout()\nplt.legend()\n#plt.savefig(\'accuracy.png\')\n#plt.show()\n#plt.savefig(\'%s_error.png\' %(filename), dpi=125)\n\n\n'
p0
.I0
.S'Estimating Overhead'
p0
.S'$s: Quantifying Overhead '
p0
.I3
.S'Writeup'
p0
.S'$p: In this section we present a theoretical model for calculating the overhead based on how prior work as well as Fair Pricing Runtime Engine is implemented.  '
p0
.I0
.S'Methodology for calculating degradation for precise shuttering'
p0
.S'$s: Methodology for calculating overhead for precise shuttering'
p0
.I2
.S'Writeup'
p0
.S"$p: The methodology by which the prior work calculates overhead is as follows. The precise shuttering mechanism works by alternating an application's execution environment between one where the co-runners are executing and another where they are effectively paused to estimate ground truth. After, every interval of time they pause all the co-runners except one and measure its CPI (shuttering). This is serves as the estimated CPI for the ground truth execution of that application. They perform shuttering for all the applications in a round robin fashion. To estimate degradation for an application, they calculate the ratio of CPI between when the co-runners are running and when the co-runners are paused. \n%The over head due to the precise shuttering mechanism is caused due to the time for which an application is paused when the runtime is trying to estimate the ground truth for the co-runners which can be obtained from experiments."
p0
.I0
.S'Mathematics'
p0
.S'$p: \\vspace{-0.8 mm}Mathematically the overhead due to precise shuttering runtime in seconds is as follows:- \\\\\n\\begin{equation}\\label{eq:1}\n\\frac{\\displaystyle\\sum_ {}{} t_{pause} X Num_{co-runner}}{Freq_{shutter} X Num_{application}} \n\\end{equation}\n\\\\\nwhere, \\\\\n$t_{pause}$ - Time (in milli seconds) for which every co runner would pause during shuttering \\\\\n$Num_{application} $ - Total number of applications running \\\\\n$Num_{co-runner}$ - Number of co-runners \\\\\n$Freq_{shutter}$ - Time between subsequent shutters\n\n'
p0
.I0
.S'Methodology for calculating overhead for Snapshot Shuttering'
p0
.S'$s:Methodology for calculating overhead for Snapshot Shuttering'
p0
.I2
.S'Writeup'
p0
.S'$p: \\vspace{-0.5 mm} The experimental methodology by which overhead is calculated in the proposed Snapshot Shuttering technique is analogous to that of precise shuttering. The over head due to the Snapshot Shuttering mechanism is caused due to the time for which an application is paused whenever there is a phase change is either of the co-runners and that concerned application is trying to estimate its ground truth CPI. The amount of time spent as overhead in the previous technique is a function of execution time of the application while the amount of time spent as overhead in our technique is a function of number of phase changes in the co-runners.'
p0
.I0
.S'Mathematical Formulas'
p0
.S'$p: The generalized equation of overhead in seconds is as follows:- \n\\vspace{-3 mm}\n\\begin{equation} \n\\label{eq:2}\n\\frac{ t_{pause} \\displaystyle\\sum_ {i=1}^{Num_{corunners}}Num_{phases  _{i}}}{1000} \n\\end{equation}\n\nwhere, \\\\\n$t_{pause}$ - Time (in milli second) for which every co runner would pause during Snapshot Shuttering \\\\\n$Num_{co-runner}$ - Number of corunners \\\\\n$ Num_{phases  _{i}} $ - Frequency at which shuttering is performed'
p0
.I0
.S'Experimental setup'
p0
.S'$s:Experimental Setup'
p0
.I11
.S'Table Experiments'
p0
.S'$t:\n\\begin{table}[ht]\n\\caption{Machine Specification in our experimental results} % title of Table\n\\centering % used for centering table\n\\resizebox{\\columnwidth}{!}{%\n\\begin{tabular}{c c c} % centered columns (4 columns)\n\\hline\\hline %inserts double horizontal lines\nProcessor & Microarchitecture & Kernel  \\\\ [0.5ex] % inserts table \n%heading\n\\hline % inserts single horizontal line\nIntel(R) Xeon(R) CPU E5-2420 0 @ 1.90GHz& Sandy Bridge-EN & 3.8.0 \\\\ % inserting body of the table\nIntel(R) Xeon(R) CPU E5-2407 v2 @ 2.40GHz & Ivy Bridge &   3.11.0 \\\\\nIntel(R) Xeon(R) CPU E3-1240 v3 @ 3.40GHz & Haswell &   3.11.0 \\\\ [1ex] % [1ex] adds vertical space\n\\hline %inserts single line\n\\end{tabular}\n}\n\\label{table:hardware} % is used to refer this table in the text\n\\end{table}\n'
p0
.I0
.S'Brief Architecture'
p0
.S'$p: We evaluate Fair Pricing methodology on three commodity multi-core processors are shown in Table \\ref{table:hardware}.  We use SPEC CPU2006 \\cite{Henning:2006:SCB:1186736.1186737} with \\texttt{ref} inputs as our workloads. \n%The CPU frequency is set constant to 1.9Ghz for the first machine specification and 2.4Ghz for the second machine specification. \n'
p0
.I0
.S'Setting up VM guests using KVM'
p0
.S'$p: To mimic the nature of execution present in current day data centers, we run our applications inside Virtual Machines (VMs), assuming each VM belongs to a particular user. We setup VMs using Kernel-based Virtual Machine (KVM) \\cite{Qumranet2007} \\cite{Bellard:2005:QFP:1247360.1247401}. It is a full virtualization solution for Linux on x86 hardware containing virtualization extensions. Each Virtual Machine is called a KVM guest and has private virtualized hardware, network card and disk. '
p0
.I0
.S'Configuration of VMs'
p0
.S'$p:\nThe configuration of each KVM guests in our environment are as follows:-\n2 Virtual CPUs for every KVM guest.\n2GB of dedicated RAM for every KVM guest.\n16GB of dedicated disk space for every KVM guest.\nLinux version 3.2.0\n'
p0
.I0
.S'Perf tool for monitoring KVM guests'
p0
.S'$p: We use the linux perf tool to measure hardware Performance Monitoring Units (PMUs) \\cite{denew}.'
p0
.I0
.S'$fig*:milclibllc,1:milclibl1d,1:'
p0
.S''
p0
.I0
.S'$pdf_fig:milclibllc:Phase of the CPI of milc when it is running alone VS phase of LLC stores of milc there are 3 instance of libquantum co-runners running along:1'
p0
.S''
p0
.I0
.S'$pdf_fig:milclibl1d:Phase of the CPI of milc when it is running alone VS phase of L1-d-cache loads of milc there are 3 instance of libquantum co-runners running along\\vspace{-25 mm}:1'
p0
.S''
p0
.I0
.S'$fig*:mcflibllc,1:mcflibl1d,1:'
p0
.S''
p0
.I0
.S'$pdf_fig:mcflibllc:Phase of the CPI of mcf when it is running alone VS phase of LLC stores of mcf there are 3 instance of libquantum co-runners running along:1'
p0
.S''
p0
.I0
.S'$pdf_fig:mcflibl1d:Phase of the CPI of mcf when it is running alone VS phase of L1-d-cache loads of mcf there are 3 instance of libquantum co-runners running along:1'
p0
.S''
p0
.I0
.S'Evaluation'
p0
.S'$s:Evaluation'
p0
.I7
.S'Overview'
p0
.S'$p: In this section we evaluate the effectiveness of our Snapshot Shuttering technique to predict degradation due to co-location. We use metrics like accuracy, overhead, pricing fairness to evaluate our technique. We also compare our technique against precise shuttering methodology and show that we achieve a higher accuracy in predicting degradation due to co-location with the same amount of overhead.  '
p0
.I7
.S'Parameters taken into consideration'
p0
.S'$p: The values that we fix for our experimental parameters are as follows:-\n\\begin{itemize}\n\\item Performance counters are measured at a frequency of once every second. Phase change is also test for with the same frequency.\n\n\\item After every phase change, co-runners are paused for 105ms, with 5 ms being the cache warm up time and 100ms being the performance counter measurements to obtain ground truth for lone application run. \n\n\\item Queue window is assigned as a fixed stream of 7 recent performance counter measurements. \n\n\\item The performance counter types that we use to analyze runtime phases are LLC-stores, L1-dcache-loads. The runtime issues a phase change when 5 or more elements in the queue are either LLC-stores are 50\\% more than or 25\\% less than the average of the sample that is collected in the previous phase as detected by that counter. Similarly, the bounds with respect to L1-dcache-loads are 100\\% more or 50\\% less respectively. Phase change mechanism is executed if either of the PMC types issue a phase change.\n\\end{itemize}\n\\vspace{1.5 mm}'
p0
.I0
.S'$fig*:astarlibl1d,1:astarmcfl1d,1:'
p0
.S''
p0
.I0
.S'$pdf_fig:astarlibl1d:Phase of the CPI of astar when it is running alone VS phase of astar when trying to estimate ground truth CPI by pausing by Snapshot Shuttering technique when there are libquantum co-runners running along:1'
p0
.S''
p0
.I0
.S'$pdf_fig:astarmcfl1d:Phase of the CPI of astar when it is running alone VS phase of astar when trying to estimate ground truth CPI by pausing by Snapshot Shuttering technique when there are mcf co-runners running along:1'
p0
.S''
p0
.I0
.S'$fig*:astarlbml1d,1:astarlib2,1:'
p0
.S''
p0
.I0
.S'$pdf_fig:astarlbml1d:Phase of the CPI of xalancbmk when it is running alone VS phase of xalancbmk when trying to estimate ground truth CPI by pausing by Snapshot Shuttering technique when there are lbm co-runners running along:1'
p0
.S''
p0
.I0
.S'$pdf_fig:astarlib2:Phase of the CPI of astar when it is running alone VS phase of astar when trying to estimate ground truth CPI by pausing by Snapshot Shuttering technique when there are libquantum co-runners running along:1'
p0
.S''
p0
.I0
.S'Accuracy'
p0
.S'$s:Accuracy in prediction of degradation due to co-location by Fair Pricing Runtime Engine'
p0
.I20
.S'Explanation'
p0
.S'$p: In this sub-section we give a overview of how Snapshot Shuttering is able to accurately predict degradation due to co-location. For these experiments, we co-locate four SPEC benchmarks together and try to measure the effectiveness of our solution in predicting degradation due to co-location. Most of our experiments are with contentious co-runners as predicting degradation in the presence of contentious co-runners is much more difficult due to their impact on shared memory sub systems.'
p0
.I0
.S'Graphs explanation'
p0
.S'$p: Figure \\ref{fig:accuracy} describes the accuracy of SPEC applications when they are co-located with three different types of co-runners libquantum, mcf and sphinx3 respectively. A single instance of the applications in the xaxis is launched in a single VM along with 3 instances of the applications that are co-locating in 3 separate VMs. The yaxis represent the error that occurs in predicting degradation due to co-location. We obtain that be comparing our estimated degradation with the ground truth obtained by running application without our runtime. For our experiments we run each benchmark three times and take the average of the three runs to eliminate the minor run to run variability that exits while running SPEC applications. '
p0
.I0
.S'Interesting things'
p0
.S'$p: On observing these graphs we obtain several interesting results. One of the main insights that we get out of our experiments is that prediction becomes more difficult as the contentiousness of the co-runner increases. A simple case can be observed from Figure \\ref{fig:accuracy}. The average error with respect to predicting degradation due to co-location is around 3.36\\% when libquantum is the co-runner but it gets lesser and lesser when sphinx is the co-runner. It should be noted here that the magnitude of contentiousness arranged in the decreasing order is libquantum, mcf, sphinx respectively as shown clearly in \\cite{consen}.\n'
p0
.I0
.S'$fig*:mcflib,1:mcfmcf,1:'
p0
.S''
p0
.I0
.S'$pdf_fig:mcflib:Phase of the CPI of mcf when it is running alone VS phase of estimated CPI of mcf when by pausing libquantum co-runners using Snapshot Shuttering technique:1'
p0
.S''
p0
.I0
.S'$pdf_fig:mcfmcf:Phase of the CPI of mcf when it is running alone VS phase of estimated CPI of mcf when by pausing mcf co-runners using Snapshot Shuttering technique::1'
p0
.S''
p0
.I0
.S'$fig*:milclib,1:milcmcf,1:'
p0
.S''
p0
.I0
.S'$pdf_fig:milclib:Phase of the CPI of milc when it is running alone VS phase of estimated CPI of milc when by pausing libquantum co-runners using Snapshot Shuttering technique::1'
p0
.S''
p0
.I0
.S'$pdf_fig:milcmcf:Phase of the CPI of milc when it is running alone VS phase of estimated CPI of milc when by pausing mcf co-runners using Snapshot Shuttering technique::1'
p0
.S''
p0
.I0
.S'$fig*:omnetpplib,1:lbmlib,1:'
p0
.S''
p0
.I0
.S'$pdf_fig:omnetpplib:Phase of the CPI of omnetpp when it is running alone VS phase of estimated CPI of omnetpp when by pausing libquantum co-runners using Snapshot Shuttering technique::1'
p0
.S''
p0
.I0
.S'$pdf_fig:lbmlib:Phase of the CPI of lbm when it is running alone VS phase of estimated CPI of lbm when by pausing libquantum co-runners using Snapshot Shuttering technique::1'
p0
.S''
p0
.I0
.S'$fig*:overhead,2:!'
p0
.S''
p0
.I0
.S'$graph:overhead:Overhead due to Fair Pricing Runtime Engine when it tries to predict degradation due to co-location:1'
p0
.S'from collections import defaultdict\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n#benchList = [ \'gcc\', \'perlbench\', \'leslie3d\', \'povray\', \'libquantum\', \'astar\', \'bzip2\', \'milc\', \'namd\', \'calculix\', \'h264ref\', \'sphinx3\', \'zeusmp\', \'gobmk\', \'hmmer\', \'tonto\', \'bwaves\', \'gromacs\', \'dealII\', \'sjeng\', \'lbm\', \'xalancbmk\', \'gamess\', \'cactusADM\', \'soplex\', \'GemsFDTD\', \'omnetpp\' ]\n#benchList = [ \'gcc\', \'perlbench\', \'sjeng\', \'soplex\', \'astar\', \'libquantum\', \'tonto\', \'milc\', \'dealII\', \'xalancbmk\' ]\n#colocationList = [ \'colocating with milc\', \'colocating with libquantum\', \'colocating with astar\' ]\n#benchList = [ \'gcc\', \'perlbench\', \'sjeng\', \'soplex\', \'astar\', \'libquantum\' ]\n#benchList = [ \'perlbench\', \'sjeng\', \'soplex\', \'astar\', \'libquantum\' ]\n#benchList = [ \'gcc\', \'mcf\', \'perlbench\', \'astar\', \'libquantum\', \'povray\', \'omnetpp\', \'bzip2\' ]\n#colocationList = [ \'colocating with libquantum\', \'colocating with astar\' ]\n#colocationListBaseline = [ \'colocating with milc\', \'colocating with libquantum\', \'colocating with astar\' ]\n\nbenchList = [ \'gcc\', \'perlbench\', \'leslie3d\', \'povray\', \'libquantum\', \'astar\', \'bzip2\', \'milc\', \'namd\', \'calculix\', \'h264ref\', \'sphinx3\', \'zeusmp\', \'gobmk\', \'hmmer\', \'tonto\', \'bwaves\', \'gromacs\', \'dealII\', \'sjeng\', \'lbm\', \'xalancbmk\', \'gamess\', \'cactusADM\', \'soplex\', \'GemsFDTD\', \'omnetpp\', \'mcf\' ]\nbenchList2 = [ \'gcc\', \'perlbench\', \'leslie3d\', \'povray\', \'libquantum\', \'astar\', \'bzip2\', \'milc\', \'namd\', \'calculix\', \'h264ref\', \'sphinx3\', \'zeusmp\', \'gobmk\', \'hmmer\', \'tonto\', \'bwaves\', \'gromacs\', \'dealII\', \'sjeng\', \'lbm\', \'xalancbmk\', \'gamess\', \'cactusADM\', \'soplex\', \'GemsFDTD\', \'omnetpp\', \'mcf\' ]\n#benchList2 = [ \'gcc\', \'mcf\', \'perlbench\', \'astar\', \'libquantum\', \'povray\', \'bzip2\' ]\ncolocationList = [ \'colocating with libquantum\', \'colocating with mcf\',  \'colocating with sphinx3\']\ncolocationListBaseline = [ \'colocating with libquantum\', \'colocating with mcf\', \'colocating with sphinx3\' ]\n\n#runningList = [  \'gcc\', \'colocating with libquantum\', \'perlbench\', \'colocating with libquantum\', \'mcf\', \'colocating with libquantum\', \'leslie3d\', \'colocating with libquantum\', \'povray\', \'colocating with libquantum\', \'libquantum\', \'colocating with libquantum\', \'astar\', \'colocating with libquantum\', \'bzip2\', \'colocating with libquantum\', \'milc\', \'colocating with libquantum\', \'namd\', \'colocating with libquantum\', \'calculix\', \'colocating with libquantum\', \'h264ref\', \'colocating with libquantum\', \'gobmk\', \'colocating with libquantum\', \'hmmer\', \'colocating with libquantum\', \'tonto\', \'colocating with libquantum\', \'sphinx3\', \'colocating with libquantum\', \'bwaves\', \'colocating with libquantum\', \'gromacs\', \'colocating with libquantum\', \'dealII\', \'colocating with libquantum\', \'sjeng\', \'colocating with libquantum\', \'lbm\', \'colocating with libquantum\', \'xalancbmk\', \'colocating with libquantum\', \'gamess\', \'colocating with libquantum\', \'cactusADM\', \'colocating with libquantum\', \'soplex\', \'colocating with libquantum\', \'GemsFDTD\', \'colocating with libquantum\', \'omnetpp\', \'colocating with libquantum\' ]\nrunningList = [  \'perlbench\', \'colocating with libquantum\', \'mcf\', \'colocating with libquantum\', \'leslie3d\', \'colocating with libquantum\', \'povray\', \'colocating with libquantum\', \'libquantum\', \'colocating with libquantum\', \'astar\', \'colocating with libquantum\', \'bzip2\', \'colocating with libquantum\', \'milc\', \'colocating with libquantum\', \'namd\', \'colocating with libquantum\', \'calculix\', \'colocating with libquantum\', \'h264ref\', \'colocating with libquantum\', \'gobmk\', \'colocating with libquantum\', \'hmmer\', \'colocating with libquantum\', \'tonto\', \'colocating with libquantum\', \'sphinx3\', \'colocating with libquantum\', \'bwaves\', \'colocating with libquantum\', \'gromacs\', \'colocating with libquantum\', \'dealII\', \'colocating with libquantum\', \'sjeng\', \'colocating with libquantum\', \'lbm\', \'colocating with libquantum\', \'xalancbmk\', \'colocating with libquantum\', \'gamess\', \'colocating with libquantum\', \'cactusADM\', \'colocating with libquantum\', \'soplex\', \'colocating with libquantum\', \'GemsFDTD\', \'colocating with libquantum\', \'omnetpp\', \'colocating with libquantum\' ]\nrunningList2 = [  \'perlbench\', \'colocating with mcf\', \'mcf\', \'colocating with mcf\', \'leslie3d\', \'colocating with mcf\', \'povray\', \'colocating with mcf\', \'libquantum\', \'colocating with mcf\', \'astar\', \'colocating with mcf\', \'bzip2\', \'colocating with mcf\', \'milc\', \'colocating with mcf\', \'namd\', \'colocating with mcf\', \'calculix\', \'colocating with mcf\', \'h264ref\', \'colocating with mcf\', \'gobmk\', \'colocating with mcf\', \'hmmer\', \'colocating with mcf\', \'tonto\', \'colocating with mcf\', \'sphinx3\', \'colocating with mcf\', \'bwaves\', \'colocating with mcf\', \'gromacs\', \'colocating with mcf\', \'dealII\', \'colocating with mcf\', \'sjeng\', \'colocating with mcf\', \'lbm\', \'colocating with mcf\', \'xalancbmk\', \'colocating with mcf\', \'gamess\', \'colocating with mcf\', \'cactusADM\', \'colocating with mcf\', \'soplex\', \'colocating with mcf\', \'GemsFDTD\', \'colocating with mcf\', \'omnetpp\', \'colocating with mcf\' ]\nrunningList3 = [  \'perlbench\', \'colocating with sphinx3\', \'mcf\', \'colocating with sphinx3\', \'leslie3d\', \'colocating with sphinx3\', \'povray\', \'colocating with sphinx3\', \'libquantum\', \'colocating with sphinx3\', \'astar\', \'colocating with sphinx3\', \'bzip2\', \'colocating with sphinx3\', \'milc\', \'colocating with sphinx3\', \'namd\', \'colocating with sphinx3\', \'calculix\', \'colocating with sphinx3\', \'h264ref\', \'colocating with sphinx3\', \'gobmk\', \'colocating with sphinx3\', \'hmmer\', \'colocating with sphinx3\', \'tonto\', \'colocating with sphinx3\', \'sphinx3\', \'colocating with sphinx3\', \'bwaves\', \'colocating with sphinx3\', \'gromacs\', \'colocating with sphinx3\', \'dealII\', \'colocating with sphinx3\', \'sjeng\', \'colocating with sphinx3\', \'lbm\', \'colocating with sphinx3\', \'xalancbmk\', \'colocating with sphinx3\', \'gamess\', \'colocating with sphinx3\', \'cactusADM\', \'colocating with sphinx3\', \'soplex\', \'colocating with sphinx3\', \'GemsFDTD\', \'colocating with sphinx3\', \'omnetpp\', \'colocating with sphinx3\' ]\n\n#colocationListBaseline = [ \'colocating with gcc\', \'colocating with mcf\', \'colocating with perlbench\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with lbm\' ]\ndef autolabel(rects):\n    # attach some text labels\n    for rect in rects:\n        height = rect.get_height()\n        plt.text(rect.get_x()+rect.get_width()/2., 1.05*height, \'%.2f\'%float(height), fontsize=8 )\n\ndef autolabel2(rects):\n    # attach some text labels\n    for rect in rects:\n        height = rect.get_height()\n        plt.text(rect.get_x()+rect.get_width()/2., -1.25*height, \'%.2f\'%float(height),\n                ha=\'center\', va=\'top\', fontsize=8)\n        #plt.text(rect.get_x()+rect.get_width()/2., 1.05*height, \'%.2f\'%float(height))\n\n\nfilename = \'execution_time_5\'\nfList1 = [s.strip() for s in open(\'../../papergraphs/2.fullspec/overhead/experiment_libquantum/%s.txt\' % filename).readlines()]\nfList2 = [s.strip() for s in open(\'../../papergraphs/2.fullspec/overhead/experiment_libquantum/phase_changes_5.txt\').readlines()]\nfList3 = [s.strip() for s in open(\'../../papergraphs/2.fullspec/overhead/experiment_mcf/%s.txt\' % filename).readlines()]\nfList4 = [s.strip() for s in open(\'../../papergraphs/2.fullspec/overhead/experiment_mcf/phase_changes_5.txt\').readlines()]\nfList5 = [s.strip() for s in open(\'../../papergraphs/2.fullspec/overhead/experiment_sphinx3/%s.txt\' % filename).readlines()]\nfList6 = [s.strip() for s in open(\'../../papergraphs/2.fullspec/overhead/experiment_sphinx3/phase_changes_5.txt\').readlines()]\n#print fList1\n\n\nexecution_time_shutter = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter = defaultdict(lambda  : defaultdict(list))\navg_execution_time_shutter = defaultdict(dict)\ndictList_phase_change = defaultdict(lambda  : defaultdict(list))\ndictList_phase_change2 = defaultdict(lambda  : defaultdict(list))\n\nstd_execution_time = defaultdict(dict)\n\ndef print_elapsed_time_shutter(time_shutter):\n    for j in colocationList:\n        for i in benchList:\n            print \'%s ||||  %s\'%(j,i)\n            print time_shutter[j][i]\n\n\nsep = \'u\'\nfor (b,a) in enumerate(fList1):\n    #print a\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            execution_time_shutter[index][a].append((fList1[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_shutter[\'colocating with mcf\'][\'perlbench\']\n#print((s.split(start))[1].split(end)[0])\n\nfor j in colocationList:\n    for i in benchList:\n        for k in execution_time_shutter[j][i]:\n            m,s = [float (var) for var in k.split(\':\')]\n            temp = m*60 + s\n            execution_time_sec_shutter[j][i].append(temp)\n\n\nfor (b,a) in enumerate(fList2):\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            dictList_phase_change[index][a].append(fList2[b+1])\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    for elem in dictList_phase_change[j][i]:\n        dictList_phase_change2[j][i].extend(elem.strip().split(\'\\t\'))\n\nyaxis = ()\nyaxis_abs = ()\nerror = ()\nxaxis = ()\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    print i,j\n    shutter_temp_list = []\n    colo_temp_list = []\n    for (count,item) in enumerate(dictList_phase_change2[j][i]):\n        if count%2==1:\n            colo_temp_list.append(float(item))\n        if count%2==0:\n            shutter_temp_list.append(float(item))\n\n    shutter_avg = sum(shutter_temp_list)/len(shutter_temp_list)\n    colocation_avg = sum(colo_temp_list)/len(colo_temp_list)\n    del shutter_temp_list\n    del colo_temp_list\n\n    pause_period = ((colocation_avg ) + ((shutter_avg + (colocation_avg * 2)/3) * 3))/4\n    xaxis = xaxis + (i,)\n    print (pause_period/np.mean(execution_time_sec_shutter[j][i]))*10\n    yaxis = yaxis + ( (pause_period/np.mean(execution_time_sec_shutter[j][i]))*10  ,)\n\nprint yaxis\nprint np.mean(yaxis)\n\ndel execution_time_shutter\ndel execution_time_sec_shutter\ndel avg_execution_time_shutter\ndel dictList_phase_change\ndel dictList_phase_change2\n\nexecution_time_shutter = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter = defaultdict(lambda  : defaultdict(list))\navg_execution_time_shutter = defaultdict(dict)\ndictList_phase_change = defaultdict(lambda  : defaultdict(list))\ndictList_phase_change2 = defaultdict(lambda  : defaultdict(list))\nstd_execution_time = defaultdict(dict)\n\ndef print_elapsed_time_shutter(time_shutter):\n    for j in colocationList:\n        for i in benchList:\n            print \'%s ||||  %s\'%(j,i)\n            print time_shutter[j][i]\n\nsep = \'u\'\nfor (b,a) in enumerate(fList3):\n    #print a\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            execution_time_shutter[index][a].append((fList3[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_shutter[\'colocating with mcf\'][\'perlbench\']\n#print((s.split(start))[1].split(end)[0])\n\nfor j in colocationList:\n    for i in benchList:\n        for k in execution_time_shutter[j][i]:\n            m,s = [float (var) for var in k.split(\':\')]\n            temp = m*60 + s\n            execution_time_sec_shutter[j][i].append(temp)\n\n\nfor (b,a) in enumerate(fList4):\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            dictList_phase_change[index][a].append(fList4[b+1])\n        print dictList_phase_change2[j][i]\n            #print fList4[b+1]\n\n\nfor a in xrange(0,len(runningList2),2):\n    j = runningList2[a+1]\n    i = runningList2[a]\n    for elem in dictList_phase_change[j][i]:\n        dictList_phase_change2[j][i].extend(elem.strip().split(\'\\t\'))\n        #print dictList_phase_change2[j][i]\n\nyaxis2 = ()\nyaxis_abs2 = ()\nerror2 = ()\nxaxis2 = ()\nfor a in xrange(0,len(runningList2),2):\n    j = runningList2[a+1]\n    i = runningList2[a]\n    #print i,j\n    shutter_temp_list = []\n    colo_temp_list = []\n    print dictList_phase_change2[j][i]\n    for (count,item) in enumerate(dictList_phase_change2[j][i]):\n        if count%2==1:\n            colo_temp_list.append(float(item))\n        if count%2==0:\n            shutter_temp_list.append(float(item))\n\n    shutter_avg = sum(shutter_temp_list)/len(shutter_temp_list)\n    colocation_avg = sum(colo_temp_list)/len(colo_temp_list)\n    del shutter_temp_list\n    del colo_temp_list\n\n    pause_period = ((colocation_avg ) + ((shutter_avg + (colocation_avg * 2)/3) * 3))/4\n    xaxis2 = xaxis2 + (i,)\n    print (pause_period/np.mean(execution_time_sec_shutter[j][i]))*10\n    yaxis2 = yaxis2 + ( (pause_period/np.mean(execution_time_sec_shutter[j][i]))*10  ,)\n\nprint yaxis2\nprint np.mean(yaxis2)\n\ndel execution_time_shutter\ndel execution_time_sec_shutter\ndel avg_execution_time_shutter\ndel dictList_phase_change\ndel dictList_phase_change2\n\nexecution_time_shutter = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter = defaultdict(lambda  : defaultdict(list))\navg_execution_time_shutter = defaultdict(dict)\ndictList_phase_change = defaultdict(lambda  : defaultdict(list))\ndictList_phase_change2 = defaultdict(lambda  : defaultdict(list))\nstd_execution_time = defaultdict(dict)\n\ndef print_elapsed_time_shutter(time_shutter):\n    for j in colocationList:\n        for i in benchList:\n            print \'%s ||||  %s\'%(j,i)\n            print time_shutter[j][i]\n\nsep = \'u\'\nfor (b,a) in enumerate(fList5):\n    #print a\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            execution_time_shutter[index][a].append((fList5[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_shutter[\'colocating with mcf\'][\'perlbench\']\n#print((s.split(start))[1].split(end)[0])\n\nfor j in colocationList:\n    for i in benchList:\n        for k in execution_time_shutter[j][i]:\n            m,s = [float (var) for var in k.split(\':\')]\n            temp = m*60 + s\n            execution_time_sec_shutter[j][i].append(temp)\n\n\nfor (b,a) in enumerate(fList6):\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            dictList_phase_change[index][a].append(fList6[b+1])\n            #print dictList_phase_change[j][i]\n            #print fList4[b+1]\n\n\nfor a in xrange(0,len(runningList3),2):\n    j = runningList3[a+1]\n    i = runningList3[a]\n    for elem in dictList_phase_change[j][i]:\n        dictList_phase_change2[j][i].extend(elem.strip().split(\'\\t\'))\n        #print dictList_phase_change2[j][i]\n\nyaxis3 = ()\nyaxis_abs3 = ()\nerror3 = ()\nxaxis3 = ()\nfor a in xrange(0,len(runningList3),2):\n    j = runningList3[a+1]\n    i = runningList3[a]\n    print i,j\n    shutter_temp_list = []\n    colo_temp_list = []\n    #print dictList_phase_change2[j][i]\n    for (count,item) in enumerate(dictList_phase_change2[j][i]):\n        if count%2==1:\n            colo_temp_list.append(float(item))\n        if count%2==0:\n            shutter_temp_list.append(float(item))\n\n    shutter_avg = sum(shutter_temp_list)/len(shutter_temp_list)\n    colocation_avg = sum(colo_temp_list)/len(colo_temp_list)\n    del shutter_temp_list\n    del colo_temp_list\n\n    pause_period = ((colocation_avg ) + ((shutter_avg + (colocation_avg * 2)/3) * 3))/4\n    xaxis3 = xaxis3 + (i,)\n    print (pause_period/np.mean(execution_time_sec_shutter[j][i]))*10\n    yaxis3 = yaxis3 + ( (pause_period/np.mean(execution_time_sec_shutter[j][i]))*10  ,)\n\nprint yaxis3\nprint np.mean(yaxis3)\n\n\nwidth = 0.25\nx = np.arange(len(yaxis))\nfig = plt.figure(figsize=(12, 5))\nbar1 = plt.bar( x, yaxis, width, color="r", label=\' colocating with libquantum (avg = %.1f)\' %(np.mean(yaxis) ))\nbar2 = plt.bar( x+width, yaxis2, width, color="b", label=\' colocating with mcf (avg = %.1f)\' %(np.mean(yaxis2)))\nbar3 = plt.bar( x+width+width, yaxis3, width, color="g", label=\' colocating with sphinx3 (avg = %.1f)\' %(np.mean(yaxis3)))\n##bar3 = plt.bar( x+width+width, yaxis3, width, color="g", label=\'4 corunners (avg is %.1f)\' %(np.mean(yaxis3) ))\n##autolabel2(bar1)\n##autolabel(bar2)\n##autolabel2(bar3)\nplt.ylabel( \'Percentage Overhead\' )\nplt.title(\'Overhead due to fair Pricing runtime Engine\')\nplt.xticks(x + width/2.0, xaxis, rotation=\'30\', size=\'12\', ha=\'center\')\nplt.ylim(-100,100)\nplt.xlim(-1,25)\nplt.grid()\nplt.legend(prop={\'size\':6})\nplt.tight_layout()\n#plt.savefig(\'phase_chagnge_overhead.png\', dpi=125)\n\n\n\n\n'
p0
.I0
.S'Individual benchmarks'
p0
.S'$p: We also observe that the average error that is caused due to predicting degradation due to co-location for around 75\\% of the application is less than 1.5\\%. There are very few situations where the peak error exceeds more than 10\\%. One of them is when libquantum is co-located with 3 more instances of libquantum as co-runners. This is a tricky situation because the pressure on the shared memory subsystem by 4 instances of libquantum will be very high. Due to that estimation of CPI for the lone run of libuquantum becomes comparatively more challenging. '
p0
.I0
.S'Easy cases'
p0
.S'$p: We have also observed that for the applications which are less sensitive co-locations whose degradations are comparatively lesser, prediction becomes much easier. Though this is true for most of the common cases, certain applications like lbm show low error even though they are comparatively contentious applications. On performing phase analysis for lbm, we observe that the phase CPI of lbm is very flat and so is the phase as portrayed by its PMC types and hence prediction becomes much easier for us.'
p0
.I0
.S'$fig*:compareaccuracy,0.66:compareaccuracy2,0.66:compareaccuracy3,0.66:'
p0
.S''
p0
.I0
.S'$graph:compareaccuracy:Comaring accuracy between Snapshot Shuttering and precise shuttering technique when libquantum is the co-runner:1'
p0
.S'from collections import defaultdict\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\nbenchListBaseline = [ \'milc\', \'bwaves\', \'mcf\', \'astar\', \'bzip2\', \'h264ref\', \'tonto\', \'lbm\', \'xalancbmk\', \'omnetpp\', \'libquantum\' ]\nbenchListExperiments = [ \'milc\', \'bwaves\', \'mcf\', \'astar\', \'bzip2\', \'h264ref\', \'tonto\', \'lbm\', \'xalancbmk\', \'omnetpp\', \'libquantum\' ]\ncolocationListBaseline = [ \'colocating with lbm\', \'colocating with povray\', \'colocating with astar\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with mcf\' ]\ncolocationListExperiments = [ \'colocating with lbm\', \'colocating with povray\', \'colocating with perlbench\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with mcf\' ]\nrunningList = [ \'milc\', \'colocating with libquantum\', \'astar\', \'colocating with libquantum\', \'bzip2\', \'colocating with libquantum\', \'h264ref\', \'colocating with libquantum\', \'tonto\', \'colocating with libquantum\', \'lbm\', \'colocating with libquantum\', \'xalancbmk\', \'colocating with libquantum\', \'omnetpp\', \'colocating with libquantum\', \'mcf\', \'colocating with libquantum\', \'bwaves\', \'colocating with libquantum\', \'milc\', \'colocating with mcf\', \'astar\', \'colocating with mcf\', \'bzip2\',\n\'colocating with mcf\', \'h264ref\', \'colocating with mcf\', \'tonto\', \'colocating with mcf\', \'lbm\', \'colocating with mcf\', \'xalancbmk\', \'colocating with mcf\', \'omnetpp\', \'colocating with mcf\', \'mcf\', \'colocating with mcf\', \'bwaves\', \'colocating with mcf\', \'milc\', \'colocating with lbm\', \'astar\', \'colocating with lbm\', \'bzip2\', \'colocating with lbm\', \'h264ref\', \'colocating with lbm\', \'tonto\', \'colocating with lbm\', \'lbm\', \'colocating with lbm\', \'xalancbmk\', \'colocating with lbm\',\n\'omnetpp\', \'colocating with lbm\', \'mcf\', \'colocating with lbm\', \'bwaves\', \'colocating with lbm\', \'libquantum\', \'colocating with libquantum\', \'libquantum\', \'colocating with mcf\', \'libquantum\', \'colocating with lbm\',  ]\n\n\ndef autolabel(rects):\n    # attach some text labels\n    for rect in rects:\n        height = rect.get_height()\n        plt.text(rect.get_x()+rect.get_width()/2., 1.05*height, \'%.2f\'%float(height), fontsize=8)\n\ndef autolabel2(rects):\n    # attach some text labels\n    for rect in rects:\n        height = rect.get_height()\n        plt.text(rect.get_x()+rect.get_width()/2., 1.05*height, \'%.2f\'%float(height))\n\nfilename = \'shutter_cpi_5\'\nfList = [s.strip() for s in open(\'../../papergraphs/3.compareprior/accuracy/phasechange/single_vm_ground_truth/shutter_cpi_1000.txt\').readlines()]\nfList2 = [s.strip() for s in open(\'../../papergraphs/3.compareprior/accuracy/phasechange/degradation_ground_truth/shutter_cpi_1000.txt\').readlines()]\nfList3 = [s.strip() for s in open(\'../../papergraphs/3.compareprior/accuracy/phasechange/experiment/%s.txt\' % filename).readlines()]\nfList4 = [s.strip() for s in open(\'../../papergraphs/3.compareprior/accuracy/shuttering/experiment/shutter_cpi_3.txt\').readlines()]\n\ndictList_single_vm = defaultdict(list)\ndictList_degradation_colocation = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter_prev = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter2 = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter_prev2 = defaultdict(lambda  : defaultdict(list))\nplot_degradation = defaultdict(dict)\nplot_degradation_error = defaultdict(dict)\n\nfor (b,a) in enumerate(fList):\n    if a in benchListBaseline:\n        dictList_single_vm[a].append(fList[b+1])\n\n#SORTING LIST CONTAING VALUES OF SINGLE SPEC RUNS INSIDE VMs\nfor i in benchListBaseline:\n    dictList_single_vm[i].sort()\n    #print i,dictList_single_vm[i]\n\nglobal index\nfor (b,a) in enumerate(fList2):\n    #print a\n    if a in colocationListBaseline:\n       #print a\n       index = a\n    else:\n        if a in benchListExperiments:\n            #print a\n            dictList_degradation_colocation[index][a].append(fList2[b+1])\n\n#sorting the ground truth values\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    dictList_degradation_colocation[j][i].sort()\n    #print j,i,dictList_degradation_colocation[j][i]\n\n#for a in xrange(0,len(runningList),2):\n#    j = runningList[a+1]\n#    i = runningList[a]\n#    numerator1 = sum(float(n) for (m,n) in enumerate(dictList_degradation_colocation[j][i]) if m!=0 and m!=len(dictList_degradation_colocation[j][i])-1)/(len(dictList_degradation_colocation[j][i])-2)\n#    print numerator1\n#    #print dictList_degradation_colocation[runningList[a+1]][runningList[a]]\n#    #print numerator1\n\n#APPENDING DEGRADATION SHUTTER\nfor (b,a) in enumerate(fList3):\n    if a in colocationListExperiments:\n        index = a\n    else:\n        if a in benchListExperiments:\n            dictList_degradation_shutter[index][a].append(fList3[b+1])\n\nfor (b,a) in enumerate(fList4):\n    if a in colocationListExperiments:\n        index = a\n    else:\n        if a in benchListExperiments:\n            dictList_degradation_shutter_prev[index][a].append(fList4[b+1])\n\n#for a in xrange(0,len(runningList),2):\n#    j = runningList[a+1]\n#    i = runningList[a]\n#    print i,j,dictList_degradation_shutter[j][i]\n#APPENDING DEGRADATION SHUTTER2 as shutter and colocation values are tab separated\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    for elem in dictList_degradation_shutter[j][i]:\n        dictList_degradation_shutter2[j][i].extend(elem.strip().split(\'\\t\'))\n    #print dictList_degradation_shutter2[j][i]\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    for elem in dictList_degradation_shutter_prev[j][i]:\n        dictList_degradation_shutter_prev2[j][i].extend(elem.strip().split(\'\\t\'))\n    #print dictList_degradation_shutter2[j][i]\nyaxis = ()\nerror = ()\nxaxis = ()\nyaxis2 = ()\nerror2 = ()\nxaxis2 = ()\nyaxis3 = ()\nerror3 = ()\nxaxis3 = ()\nsum_val = 0\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    denominator1 = sum(float(n) for (m,n) in enumerate(dictList_single_vm[i]))/(len(dictList_single_vm[i]))\n    numerator1 = sum(float(n) for (m,n) in enumerate(dictList_degradation_colocation[j][i]))/(len(dictList_degradation_colocation[j][i]))\n    shutter_temp_list = []\n    colo_temp_list = []\n    degradation_temp_list = []\n    error_temp_list = []\n    #print numerator1\n    #print denominator1\n    for (count,item) in enumerate(dictList_degradation_shutter2[j][i]):\n        if count%2==0:\n            colo_temp_list.append(item)\n        if count%2==1:\n            shutter_temp_list.append(item)\n\n    for (count,item) in enumerate(shutter_temp_list):\n        degradation_temp_list.append(abs((((float(shutter_temp_list[count])/float(colo_temp_list[count]))-(numerator1/denominator1))/(float(shutter_temp_list[count])/float(colo_temp_list[count])))*100))\n\n    shutter_temp_list.sort()\n    colo_temp_list.sort()\n    #print shutter_temp_list\n    #print colo_temp_list\n    #print dictList_degradation_shutter2[j][i]\n    denominator2 = sum(float(n) for (m,n) in enumerate(shutter_temp_list) if m!=0 and m!=len(shutter_temp_list)-1)/(len(shutter_temp_list)-2)\n    numerator2 = sum(float(n) for (m,n) in enumerate(colo_temp_list) if m!=0 and m!=len(colo_temp_list)-1)/(len(colo_temp_list)-2)\n    for (m,n) in enumerate(shutter_temp_list):\n        ratio=float(n)/float(colo_temp_list[m])\n        error_temp_list.append(abs((((ratio)-(numerator1/denominator1))/(numerator1/denominator1))*100))\n    plot_degradation_error[j][i]=np.std(error_temp_list)\n\n    #print numerator2\n    #print denominator2\n    del shutter_temp_list\n    del colo_temp_list\n    del degradation_temp_list\n    plot_degradation[j][i] = abs((((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100)\n    sum_val = sum_val + float(plot_degradation[j][i])\n    #print j,i,plot_degradation[j][i]\n    #print plot_degradation_error[j][i]\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    if j == \'colocating with libquantum\':\n        xaxis = xaxis + (i,)\n        yaxis = yaxis + (plot_degradation[j][i],)\n        error = error + (plot_degradation_error[j][i],)\n    if j == \'colocating with mcf\':\n        xaxis2 = xaxis2 + (i,)\n        yaxis2 = yaxis2 + (plot_degradation[j][i],)\n        error2 = error2 + (plot_degradation_error[j][i],)\n    if j == \'colocating with lbm\':\n        xaxis3 = xaxis3 + (i,)\n        yaxis3 = yaxis3 + (plot_degradation[j][i],)\n        error3 = error3 + (plot_degradation_error[j][i],)\n    #print numerator2,denominator2,numerator2/denominator2\n    #print denominator2/numerator2\n    #print j,i,plot_degradation[j][i]\n            #print (((numerator2/denominator2)-(numerator1/denominator1))/(numerator2/denominator2))*100\n\n\ndel plot_degradation\ndel plot_degradation_error\n\nplot_degradation = defaultdict(dict)\nplot_degradation_error = defaultdict(dict)\nyaxis4 = ()\nerror4 = ()\nxaxis4 = ()\nyaxis5 = ()\nerror5 = ()\nxaxis5 = ()\nyaxis6 = ()\nerror6 = ()\nxaxis6 = ()\nsum_val = 0\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    #print i\n    denominator1 = sum(float(n) for (m,n) in enumerate(dictList_single_vm[i]))/(len(dictList_single_vm[i]))\n    numerator1 = sum(float(n) for (m,n) in enumerate(dictList_degradation_colocation[j][i]))/(len(dictList_degradation_colocation[j][i]))\n    shutter_temp_list = []\n    colo_temp_list = []\n    degradation_temp_list = []\n    error_temp_list = []\n    #print numerator1\n    #print denominator1\n    for (count,item) in enumerate(dictList_degradation_shutter_prev2[j][i]):\n        if count%2==0:\n            colo_temp_list.append(item)\n        if count%2==1:\n            shutter_temp_list.append(item)\n\n    for (count,item) in enumerate(shutter_temp_list):\n        degradation_temp_list.append(abs((((float(shutter_temp_list[count])/float(colo_temp_list[count]))-(numerator1/denominator1))/(float(shutter_temp_list[count])/float(colo_temp_list[count])))*100))\n\n    shutter_temp_list.sort()\n    colo_temp_list.sort()\n    #print shutter_temp_list\n    #print colo_temp_list\n    #print dictList_degradation_shutter2[j][i]\n    denominator2 = sum(float(n) for (m,n) in enumerate(shutter_temp_list) if m!=0 and m!=len(shutter_temp_list)-1)/(len(shutter_temp_list)-2)\n    numerator2 = sum(float(n) for (m,n) in enumerate(colo_temp_list) if m!=0 and m!=len(colo_temp_list)-1)/(len(colo_temp_list)-2)\n    for (m,n) in enumerate(shutter_temp_list):\n        ratio=float(n)/float(colo_temp_list[m])\n        error_temp_list.append(abs((((ratio)-(numerator1/denominator1))/(numerator1/denominator1))*100))\n    plot_degradation_error[j][i]=np.std(error_temp_list)\n\n    #print numerator2\n    #print denominator2\n    del shutter_temp_list\n    del colo_temp_list\n    del degradation_temp_list\n    plot_degradation[j][i] = abs((((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100)\n    sum_val = sum_val + float(plot_degradation[j][i])\n    #print j,i,plot_degradation[j][i]\n    #print plot_degradation_error[j][i]\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    if j == \'colocating with libquantum\':\n        xaxis4 = xaxis4 + (i,)\n        yaxis4 = yaxis4 + (plot_degradation[j][i],)\n        error4 = error4 + (plot_degradation_error[j][i],)\n    if j == \'colocating with mcf\':\n        xaxis5 = xaxis5 + (i,)\n        yaxis5 = yaxis5 + (plot_degradation[j][i],)\n        error5 = error5 + (plot_degradation_error[j][i],)\n    if j == \'colocating with lbm\':\n        xaxis6 = xaxis6 + (i,)\n        yaxis6 = yaxis6 + (plot_degradation[j][i],)\n        error6 = error6 + (plot_degradation_error[j][i],)\n    #print numerator2,denominator2,numerator2/denominator2\n    #print denominator2/numerator2\n    print j,i,plot_degradation[j][i]\n            #print (((numerator2/denominator2)-(numerator1/denominator1))/(numerator2/denominator2))*100\n\n#print xaxis\n#print yaxis\n#print error\n#print np.mean(yaxis)\n#print np.mean(yaxis2)\n#print np.mean(yaxis3)\n#print np.mean(sum_val)\n#\nwidth=0.25\nx = np.arange(len(yaxis))\nfig = plt.figure(figsize=(12, 5))\nbar1 = plt.bar( x+width, yaxis, width, color="r", yerr=error, label=\'Snapshot Shuttering (avg is %.1f)\' % (np.mean(yaxis)))\nbar2 = plt.bar( x, yaxis4, width, color="b", yerr=error2,label=\'Precise Shuttering (avg is %.1f)\' % (np.mean(yaxis4)))\n#bar3 = plt.bar( x+width+width, yaxis3, width, color="g", yerr=error3, label=\'lbm as corunner (avg is 4.0)\')\n#autolabel(bar1)\n#autolabel(bar2)\n#autolabel(bar3)\nplt.ylabel( \'Percentage Error\' )\n#plt.title(\'Error in predicting degradation when libquantum is the corunner \')\nplt.xticks(x + width, xaxis, rotation=\'30\', size=\'20\')\nplt.xlim(-1,11)\nplt.ylim(-1,40)\nplt.legend(prop={\'size\':18})\nplt.tight_layout()\nplt.grid()\n# default scale is 1 in your original case, scales with other cases:\n#plt.show()\nplt.savefig(\'%s_error_libquantum.png\' %(filename),  dpi=125)\n\n'
p0
.I0
.S'$graph:compareaccuracy2:Comaring accuracy between Snapshot Shuttering and precise shuttering technique when mcf is the co-runner:1'
p0
.S'from collections import defaultdict\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\nbenchListBaseline = [ \'milc\', \'bwaves\', \'mcf\', \'astar\', \'bzip2\', \'h264ref\', \'tonto\', \'lbm\', \'xalancbmk\', \'omnetpp\', \'libquantum\' ]\nbenchListExperiments = [ \'milc\', \'bwaves\', \'mcf\', \'astar\', \'bzip2\', \'h264ref\', \'tonto\', \'lbm\', \'xalancbmk\', \'omnetpp\', \'libquantum\' ]\ncolocationListBaseline = [ \'colocating with lbm\', \'colocating with povray\', \'colocating with astar\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with mcf\' ]\ncolocationListExperiments = [ \'colocating with lbm\', \'colocating with povray\', \'colocating with perlbench\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with mcf\' ]\nrunningList = [ \'milc\', \'colocating with libquantum\', \'astar\', \'colocating with libquantum\', \'bzip2\', \'colocating with libquantum\', \'h264ref\', \'colocating with libquantum\', \'tonto\', \'colocating with libquantum\', \'lbm\', \'colocating with libquantum\', \'xalancbmk\', \'colocating with libquantum\', \'omnetpp\', \'colocating with libquantum\', \'mcf\', \'colocating with libquantum\', \'bwaves\', \'colocating with libquantum\', \'milc\', \'colocating with mcf\', \'astar\', \'colocating with mcf\', \'bzip2\',\n\'colocating with mcf\', \'h264ref\', \'colocating with mcf\', \'tonto\', \'colocating with mcf\', \'lbm\', \'colocating with mcf\', \'xalancbmk\', \'colocating with mcf\', \'omnetpp\', \'colocating with mcf\', \'mcf\', \'colocating with mcf\', \'bwaves\', \'colocating with mcf\', \'milc\', \'colocating with lbm\', \'astar\', \'colocating with lbm\', \'bzip2\', \'colocating with lbm\', \'h264ref\', \'colocating with lbm\', \'tonto\', \'colocating with lbm\', \'lbm\', \'colocating with lbm\', \'xalancbmk\', \'colocating with lbm\',\n\'omnetpp\', \'colocating with lbm\', \'mcf\', \'colocating with lbm\', \'bwaves\', \'colocating with lbm\', \'libquantum\', \'colocating with libquantum\', \'libquantum\', \'colocating with mcf\', \'libquantum\', \'colocating with lbm\',  ]\n\n\ndef autolabel(rects):\n    # attach some text labels\n    for rect in rects:\n        height = rect.get_height()\n        plt.text(rect.get_x()+rect.get_width()/2., 1.05*height, \'%.2f\'%float(height), fontsize=8)\n\ndef autolabel2(rects):\n    # attach some text labels\n    for rect in rects:\n        height = rect.get_height()\n        plt.text(rect.get_x()+rect.get_width()/2., 1.05*height, \'%.2f\'%float(height))\n\nfilename = \'shutter_cpi_5\'\nfList = [s.strip() for s in open(\'../../papergraphs/3.compareprior/accuracy/phasechange/single_vm_ground_truth/shutter_cpi_1000.txt\').readlines()]\nfList2 = [s.strip() for s in open(\'../../papergraphs/3.compareprior/accuracy/phasechange/degradation_ground_truth/shutter_cpi_1000.txt\').readlines()]\nfList3 = [s.strip() for s in open(\'../../papergraphs/3.compareprior/accuracy/phasechange/experiment/%s.txt\' % filename).readlines()]\nfList4 = [s.strip() for s in open(\'../../papergraphs/3.compareprior/accuracy/shuttering/experiment/shutter_cpi_3.txt\').readlines()]\n\ndictList_single_vm = defaultdict(list)\ndictList_degradation_colocation = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter_prev = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter2 = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter_prev2 = defaultdict(lambda  : defaultdict(list))\nplot_degradation = defaultdict(dict)\nplot_degradation_error = defaultdict(dict)\n\nfor (b,a) in enumerate(fList):\n    if a in benchListBaseline:\n        dictList_single_vm[a].append(fList[b+1])\n\n#SORTING LIST CONTAING VALUES OF SINGLE SPEC RUNS INSIDE VMs\nfor i in benchListBaseline:\n    dictList_single_vm[i].sort()\n    #print i,dictList_single_vm[i]\n\nglobal index\nfor (b,a) in enumerate(fList2):\n    #print a\n    if a in colocationListBaseline:\n       #print a\n       index = a\n    else:\n        if a in benchListExperiments:\n            #print a\n            dictList_degradation_colocation[index][a].append(fList2[b+1])\n\n#sorting the ground truth values\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    dictList_degradation_colocation[j][i].sort()\n    #print j,i,dictList_degradation_colocation[j][i]\n\n#for a in xrange(0,len(runningList),2):\n#    j = runningList[a+1]\n#    i = runningList[a]\n#    numerator1 = sum(float(n) for (m,n) in enumerate(dictList_degradation_colocation[j][i]) if m!=0 and m!=len(dictList_degradation_colocation[j][i])-1)/(len(dictList_degradation_colocation[j][i])-2)\n#    print numerator1\n#    #print dictList_degradation_colocation[runningList[a+1]][runningList[a]]\n#    #print numerator1\n\n#APPENDING DEGRADATION SHUTTER\nfor (b,a) in enumerate(fList3):\n    if a in colocationListExperiments:\n        index = a\n    else:\n        if a in benchListExperiments:\n            dictList_degradation_shutter[index][a].append(fList3[b+1])\n\nfor (b,a) in enumerate(fList4):\n    if a in colocationListExperiments:\n        index = a\n    else:\n        if a in benchListExperiments:\n            dictList_degradation_shutter_prev[index][a].append(fList4[b+1])\n\n#for a in xrange(0,len(runningList),2):\n#    j = runningList[a+1]\n#    i = runningList[a]\n#    print i,j,dictList_degradation_shutter[j][i]\n#APPENDING DEGRADATION SHUTTER2 as shutter and colocation values are tab separated\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    for elem in dictList_degradation_shutter[j][i]:\n        dictList_degradation_shutter2[j][i].extend(elem.strip().split(\'\\t\'))\n    #print dictList_degradation_shutter2[j][i]\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    for elem in dictList_degradation_shutter_prev[j][i]:\n        dictList_degradation_shutter_prev2[j][i].extend(elem.strip().split(\'\\t\'))\n    #print dictList_degradation_shutter2[j][i]\nyaxis = ()\nerror = ()\nxaxis = ()\nyaxis2 = ()\nerror2 = ()\nxaxis2 = ()\nyaxis3 = ()\nerror3 = ()\nxaxis3 = ()\nsum_val = 0\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    denominator1 = sum(float(n) for (m,n) in enumerate(dictList_single_vm[i]))/(len(dictList_single_vm[i]))\n    numerator1 = sum(float(n) for (m,n) in enumerate(dictList_degradation_colocation[j][i]))/(len(dictList_degradation_colocation[j][i]))\n    shutter_temp_list = []\n    colo_temp_list = []\n    degradation_temp_list = []\n    error_temp_list = []\n    #print numerator1\n    #print denominator1\n    for (count,item) in enumerate(dictList_degradation_shutter2[j][i]):\n        if count%2==0:\n            colo_temp_list.append(item)\n        if count%2==1:\n            shutter_temp_list.append(item)\n\n    for (count,item) in enumerate(shutter_temp_list):\n        degradation_temp_list.append(abs((((float(shutter_temp_list[count])/float(colo_temp_list[count]))-(numerator1/denominator1))/(float(shutter_temp_list[count])/float(colo_temp_list[count])))*100))\n\n    shutter_temp_list.sort()\n    colo_temp_list.sort()\n    #print shutter_temp_list\n    #print colo_temp_list\n    #print dictList_degradation_shutter2[j][i]\n    denominator2 = sum(float(n) for (m,n) in enumerate(shutter_temp_list) if m!=0 and m!=len(shutter_temp_list)-1)/(len(shutter_temp_list)-2)\n    numerator2 = sum(float(n) for (m,n) in enumerate(colo_temp_list) if m!=0 and m!=len(colo_temp_list)-1)/(len(colo_temp_list)-2)\n    for (m,n) in enumerate(shutter_temp_list):\n        ratio=float(n)/float(colo_temp_list[m])\n        error_temp_list.append(abs((((ratio)-(numerator1/denominator1))/(numerator1/denominator1))*100))\n    plot_degradation_error[j][i]=np.std(error_temp_list)\n\n    #print numerator2\n    #print denominator2\n    del shutter_temp_list\n    del colo_temp_list\n    del degradation_temp_list\n    plot_degradation[j][i] = abs((((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100)\n    sum_val = sum_val + float(plot_degradation[j][i])\n    #print j,i,plot_degradation[j][i]\n    #print plot_degradation_error[j][i]\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    if j == \'colocating with libquantum\':\n        xaxis = xaxis + (i,)\n        yaxis = yaxis + (plot_degradation[j][i],)\n        error = error + (plot_degradation_error[j][i],)\n    if j == \'colocating with mcf\':\n        xaxis2 = xaxis2 + (i,)\n        yaxis2 = yaxis2 + (plot_degradation[j][i],)\n        error2 = error2 + (plot_degradation_error[j][i],)\n    if j == \'colocating with lbm\':\n        xaxis3 = xaxis3 + (i,)\n        yaxis3 = yaxis3 + (plot_degradation[j][i],)\n        error3 = error3 + (plot_degradation_error[j][i],)\n    #print numerator2,denominator2,numerator2/denominator2\n    #print denominator2/numerator2\n    #print j,i,plot_degradation[j][i]\n            #print (((numerator2/denominator2)-(numerator1/denominator1))/(numerator2/denominator2))*100\n\n\ndel plot_degradation\ndel plot_degradation_error\n\nplot_degradation = defaultdict(dict)\nplot_degradation_error = defaultdict(dict)\nyaxis4 = ()\nerror4 = ()\nxaxis4 = ()\nyaxis5 = ()\nerror5 = ()\nxaxis5 = ()\nyaxis6 = ()\nerror6 = ()\nxaxis6 = ()\nsum_val = 0\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    #print i\n    denominator1 = sum(float(n) for (m,n) in enumerate(dictList_single_vm[i]))/(len(dictList_single_vm[i]))\n    numerator1 = sum(float(n) for (m,n) in enumerate(dictList_degradation_colocation[j][i]))/(len(dictList_degradation_colocation[j][i]))\n    shutter_temp_list = []\n    colo_temp_list = []\n    degradation_temp_list = []\n    error_temp_list = []\n    #print numerator1\n    #print denominator1\n    for (count,item) in enumerate(dictList_degradation_shutter_prev2[j][i]):\n        if count%2==0:\n            colo_temp_list.append(item)\n        if count%2==1:\n            shutter_temp_list.append(item)\n\n    for (count,item) in enumerate(shutter_temp_list):\n        degradation_temp_list.append(abs((((float(shutter_temp_list[count])/float(colo_temp_list[count]))-(numerator1/denominator1))/(float(shutter_temp_list[count])/float(colo_temp_list[count])))*100))\n\n    shutter_temp_list.sort()\n    colo_temp_list.sort()\n    #print shutter_temp_list\n    #print colo_temp_list\n    #print dictList_degradation_shutter2[j][i]\n    denominator2 = sum(float(n) for (m,n) in enumerate(shutter_temp_list) if m!=0 and m!=len(shutter_temp_list)-1)/(len(shutter_temp_list)-2)\n    numerator2 = sum(float(n) for (m,n) in enumerate(colo_temp_list) if m!=0 and m!=len(colo_temp_list)-1)/(len(colo_temp_list)-2)\n    for (m,n) in enumerate(shutter_temp_list):\n        ratio=float(n)/float(colo_temp_list[m])\n        error_temp_list.append(abs((((ratio)-(numerator1/denominator1))/(numerator1/denominator1))*100))\n    plot_degradation_error[j][i]=np.std(error_temp_list)\n\n    #print numerator2\n    #print denominator2\n    del shutter_temp_list\n    del colo_temp_list\n    del degradation_temp_list\n    plot_degradation[j][i] = abs((((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100)\n    sum_val = sum_val + float(plot_degradation[j][i])\n    #print j,i,plot_degradation[j][i]\n    #print plot_degradation_error[j][i]\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    if j == \'colocating with libquantum\':\n        xaxis4 = xaxis4 + (i,)\n        yaxis4 = yaxis4 + (plot_degradation[j][i],)\n        error4 = error4 + (plot_degradation_error[j][i],)\n    if j == \'colocating with mcf\':\n        xaxis5 = xaxis5 + (i,)\n        yaxis5 = yaxis5 + (plot_degradation[j][i],)\n        error5 = error5 + (plot_degradation_error[j][i],)\n    if j == \'colocating with lbm\':\n        xaxis6 = xaxis6 + (i,)\n        yaxis6 = yaxis6 + (plot_degradation[j][i],)\n        error6 = error6 + (plot_degradation_error[j][i],)\n    #print numerator2,denominator2,numerator2/denominator2\n    #print denominator2/numerator2\n    print j,i,plot_degradation[j][i]\n            #print (((numerator2/denominator2)-(numerator1/denominator1))/(numerator2/denominator2))*100\n\n#print xaxis\n#print yaxis\n#print error\n#print np.mean(yaxis)\n#print np.mean(yaxis2)\n#print np.mean(yaxis3)\n#print np.mean(sum_val)\n#\n\n\nwidth=0.25\nx = np.arange(len(yaxis))\nfig = plt.figure(figsize=(12, 5))\nbar1 = plt.bar( x+width, yaxis2, width, color="r", yerr=error, label=\'Snapshot Shuttering (avg is %.1f)\' % (np.mean(yaxis2)))\nbar2 = plt.bar( x, yaxis5, width, color="b", yerr=error2,label=\'Precise Shuttering (avg is %.1f)\' % (np.mean(yaxis5)))\n#bar3 = plt.bar( x+width+width, yaxis3, width, color="g", yerr=error3, label=\'lbm as corunner (avg is 4.0)\')\n#autolabel(bar1)\n#autolabel(bar2)\n#autolabel(bar3)\n#plt.ylabel( \'Percentage Error\' )\n#plt.title(\'Error in predicting degradation when mcf is the corunner\')\nplt.xticks(x + width, xaxis, rotation=\'30\', size=\'20\')\nplt.xlim(-1,11)\nplt.ylim(-1,40)\nplt.legend(prop={\'size\':18})\nplt.tight_layout()\nplt.grid()\n# default scale is 1 in your original case, scales with other cases:\n#plt.show()\nplt.savefig(\'%s_error_mcf.png\' %(filename),  dpi=125)'
p0
.I0
.S'$graph:compareaccuracy3:Comaring accuracy between Snapshot Shuttering and precise shuttering technique when lbm is the co-runner:1'
p0
.S'from collections import defaultdict\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\nbenchListBaseline = [ \'milc\', \'bwaves\', \'mcf\', \'astar\', \'bzip2\', \'h264ref\', \'tonto\', \'lbm\', \'xalancbmk\', \'omnetpp\', \'libquantum\' ]\nbenchListExperiments = [ \'milc\', \'bwaves\', \'mcf\', \'astar\', \'bzip2\', \'h264ref\', \'tonto\', \'lbm\', \'xalancbmk\', \'omnetpp\', \'libquantum\' ]\ncolocationListBaseline = [ \'colocating with lbm\', \'colocating with povray\', \'colocating with astar\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with mcf\' ]\ncolocationListExperiments = [ \'colocating with lbm\', \'colocating with povray\', \'colocating with perlbench\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with mcf\' ]\nrunningList = [ \'milc\', \'colocating with libquantum\', \'astar\', \'colocating with libquantum\', \'bzip2\', \'colocating with libquantum\', \'h264ref\', \'colocating with libquantum\', \'tonto\', \'colocating with libquantum\', \'lbm\', \'colocating with libquantum\', \'xalancbmk\', \'colocating with libquantum\', \'omnetpp\', \'colocating with libquantum\', \'mcf\', \'colocating with libquantum\', \'bwaves\', \'colocating with libquantum\', \'milc\', \'colocating with mcf\', \'astar\', \'colocating with mcf\', \'bzip2\',\n\'colocating with mcf\', \'h264ref\', \'colocating with mcf\', \'tonto\', \'colocating with mcf\', \'lbm\', \'colocating with mcf\', \'xalancbmk\', \'colocating with mcf\', \'omnetpp\', \'colocating with mcf\', \'mcf\', \'colocating with mcf\', \'bwaves\', \'colocating with mcf\', \'milc\', \'colocating with lbm\', \'astar\', \'colocating with lbm\', \'bzip2\', \'colocating with lbm\', \'h264ref\', \'colocating with lbm\', \'tonto\', \'colocating with lbm\', \'lbm\', \'colocating with lbm\', \'xalancbmk\', \'colocating with lbm\',\n\'omnetpp\', \'colocating with lbm\', \'mcf\', \'colocating with lbm\', \'bwaves\', \'colocating with lbm\', \'libquantum\', \'colocating with libquantum\', \'libquantum\', \'colocating with mcf\', \'libquantum\', \'colocating with lbm\',  ]\n\n\ndef autolabel(rects):\n    # attach some text labels\n    for rect in rects:\n        height = rect.get_height()\n        plt.text(rect.get_x()+rect.get_width()/2., 1.05*height, \'%.2f\'%float(height), fontsize=8)\n\ndef autolabel2(rects):\n    # attach some text labels\n    for rect in rects:\n        height = rect.get_height()\n        plt.text(rect.get_x()+rect.get_width()/2., 1.05*height, \'%.2f\'%float(height))\n\nfilename = \'shutter_cpi_5\'\nfList = [s.strip() for s in open(\'../../papergraphs/3.compareprior/accuracy/phasechange/single_vm_ground_truth/shutter_cpi_1000.txt\').readlines()]\nfList2 = [s.strip() for s in open(\'../../papergraphs/3.compareprior/accuracy/phasechange/degradation_ground_truth/shutter_cpi_1000.txt\').readlines()]\nfList3 = [s.strip() for s in open(\'../../papergraphs/3.compareprior/accuracy/phasechange/experiment/%s.txt\' % filename).readlines()]\nfList4 = [s.strip() for s in open(\'../../papergraphs/3.compareprior/accuracy/shuttering/experiment/shutter_cpi_3.txt\').readlines()]\n\ndictList_single_vm = defaultdict(list)\ndictList_degradation_colocation = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter_prev = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter2 = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter_prev2 = defaultdict(lambda  : defaultdict(list))\nplot_degradation = defaultdict(dict)\nplot_degradation_error = defaultdict(dict)\n\nfor (b,a) in enumerate(fList):\n    if a in benchListBaseline:\n        dictList_single_vm[a].append(fList[b+1])\n\n#SORTING LIST CONTAING VALUES OF SINGLE SPEC RUNS INSIDE VMs\nfor i in benchListBaseline:\n    dictList_single_vm[i].sort()\n    #print i,dictList_single_vm[i]\n\nglobal index\nfor (b,a) in enumerate(fList2):\n    #print a\n    if a in colocationListBaseline:\n       #print a\n       index = a\n    else:\n        if a in benchListExperiments:\n            #print a\n            dictList_degradation_colocation[index][a].append(fList2[b+1])\n\n#sorting the ground truth values\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    dictList_degradation_colocation[j][i].sort()\n    #print j,i,dictList_degradation_colocation[j][i]\n\n#for a in xrange(0,len(runningList),2):\n#    j = runningList[a+1]\n#    i = runningList[a]\n#    numerator1 = sum(float(n) for (m,n) in enumerate(dictList_degradation_colocation[j][i]) if m!=0 and m!=len(dictList_degradation_colocation[j][i])-1)/(len(dictList_degradation_colocation[j][i])-2)\n#    print numerator1\n#    #print dictList_degradation_colocation[runningList[a+1]][runningList[a]]\n#    #print numerator1\n\n#APPENDING DEGRADATION SHUTTER\nfor (b,a) in enumerate(fList3):\n    if a in colocationListExperiments:\n        index = a\n    else:\n        if a in benchListExperiments:\n            dictList_degradation_shutter[index][a].append(fList3[b+1])\n\nfor (b,a) in enumerate(fList4):\n    if a in colocationListExperiments:\n        index = a\n    else:\n        if a in benchListExperiments:\n            dictList_degradation_shutter_prev[index][a].append(fList4[b+1])\n\n#for a in xrange(0,len(runningList),2):\n#    j = runningList[a+1]\n#    i = runningList[a]\n#    print i,j,dictList_degradation_shutter[j][i]\n#APPENDING DEGRADATION SHUTTER2 as shutter and colocation values are tab separated\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    for elem in dictList_degradation_shutter[j][i]:\n        dictList_degradation_shutter2[j][i].extend(elem.strip().split(\'\\t\'))\n    #print dictList_degradation_shutter2[j][i]\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    for elem in dictList_degradation_shutter_prev[j][i]:\n        dictList_degradation_shutter_prev2[j][i].extend(elem.strip().split(\'\\t\'))\n    #print dictList_degradation_shutter2[j][i]\nyaxis = ()\nerror = ()\nxaxis = ()\nyaxis2 = ()\nerror2 = ()\nxaxis2 = ()\nyaxis3 = ()\nerror3 = ()\nxaxis3 = ()\nsum_val = 0\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    denominator1 = sum(float(n) for (m,n) in enumerate(dictList_single_vm[i]))/(len(dictList_single_vm[i]))\n    numerator1 = sum(float(n) for (m,n) in enumerate(dictList_degradation_colocation[j][i]))/(len(dictList_degradation_colocation[j][i]))\n    shutter_temp_list = []\n    colo_temp_list = []\n    degradation_temp_list = []\n    error_temp_list = []\n    #print numerator1\n    #print denominator1\n    for (count,item) in enumerate(dictList_degradation_shutter2[j][i]):\n        if count%2==0:\n            colo_temp_list.append(item)\n        if count%2==1:\n            shutter_temp_list.append(item)\n\n    for (count,item) in enumerate(shutter_temp_list):\n        degradation_temp_list.append(abs((((float(shutter_temp_list[count])/float(colo_temp_list[count]))-(numerator1/denominator1))/(float(shutter_temp_list[count])/float(colo_temp_list[count])))*100))\n\n    shutter_temp_list.sort()\n    colo_temp_list.sort()\n    #print shutter_temp_list\n    #print colo_temp_list\n    #print dictList_degradation_shutter2[j][i]\n    denominator2 = sum(float(n) for (m,n) in enumerate(shutter_temp_list) if m!=0 and m!=len(shutter_temp_list)-1)/(len(shutter_temp_list)-2)\n    numerator2 = sum(float(n) for (m,n) in enumerate(colo_temp_list) if m!=0 and m!=len(colo_temp_list)-1)/(len(colo_temp_list)-2)\n    for (m,n) in enumerate(shutter_temp_list):\n        ratio=float(n)/float(colo_temp_list[m])\n        error_temp_list.append(abs((((ratio)-(numerator1/denominator1))/(numerator1/denominator1))*100))\n    plot_degradation_error[j][i]=np.std(error_temp_list)\n\n    #print numerator2\n    #print denominator2\n    del shutter_temp_list\n    del colo_temp_list\n    del degradation_temp_list\n    plot_degradation[j][i] = abs((((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100)\n    sum_val = sum_val + float(plot_degradation[j][i])\n    #print j,i,plot_degradation[j][i]\n    #print plot_degradation_error[j][i]\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    if j == \'colocating with libquantum\':\n        xaxis = xaxis + (i,)\n        yaxis = yaxis + (plot_degradation[j][i],)\n        error = error + (plot_degradation_error[j][i],)\n    if j == \'colocating with mcf\':\n        xaxis2 = xaxis2 + (i,)\n        yaxis2 = yaxis2 + (plot_degradation[j][i],)\n        error2 = error2 + (plot_degradation_error[j][i],)\n    if j == \'colocating with lbm\':\n        xaxis3 = xaxis3 + (i,)\n        yaxis3 = yaxis3 + (plot_degradation[j][i],)\n        error3 = error3 + (plot_degradation_error[j][i],)\n    #print numerator2,denominator2,numerator2/denominator2\n    #print denominator2/numerator2\n    #print j,i,plot_degradation[j][i]\n            #print (((numerator2/denominator2)-(numerator1/denominator1))/(numerator2/denominator2))*100\n\n\ndel plot_degradation\ndel plot_degradation_error\n\nplot_degradation = defaultdict(dict)\nplot_degradation_error = defaultdict(dict)\nyaxis4 = ()\nerror4 = ()\nxaxis4 = ()\nyaxis5 = ()\nerror5 = ()\nxaxis5 = ()\nyaxis6 = ()\nerror6 = ()\nxaxis6 = ()\nsum_val = 0\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    #print i\n    denominator1 = sum(float(n) for (m,n) in enumerate(dictList_single_vm[i]))/(len(dictList_single_vm[i]))\n    numerator1 = sum(float(n) for (m,n) in enumerate(dictList_degradation_colocation[j][i]))/(len(dictList_degradation_colocation[j][i]))\n    shutter_temp_list = []\n    colo_temp_list = []\n    degradation_temp_list = []\n    error_temp_list = []\n    #print numerator1\n    #print denominator1\n    for (count,item) in enumerate(dictList_degradation_shutter_prev2[j][i]):\n        if count%2==0:\n            colo_temp_list.append(item)\n        if count%2==1:\n            shutter_temp_list.append(item)\n\n    for (count,item) in enumerate(shutter_temp_list):\n        degradation_temp_list.append(abs((((float(shutter_temp_list[count])/float(colo_temp_list[count]))-(numerator1/denominator1))/(float(shutter_temp_list[count])/float(colo_temp_list[count])))*100))\n\n    shutter_temp_list.sort()\n    colo_temp_list.sort()\n    #print shutter_temp_list\n    #print colo_temp_list\n    #print dictList_degradation_shutter2[j][i]\n    denominator2 = sum(float(n) for (m,n) in enumerate(shutter_temp_list) if m!=0 and m!=len(shutter_temp_list)-1)/(len(shutter_temp_list)-2)\n    numerator2 = sum(float(n) for (m,n) in enumerate(colo_temp_list) if m!=0 and m!=len(colo_temp_list)-1)/(len(colo_temp_list)-2)\n    for (m,n) in enumerate(shutter_temp_list):\n        ratio=float(n)/float(colo_temp_list[m])\n        error_temp_list.append(abs((((ratio)-(numerator1/denominator1))/(numerator1/denominator1))*100))\n    plot_degradation_error[j][i]=np.std(error_temp_list)\n\n    #print numerator2\n    #print denominator2\n    del shutter_temp_list\n    del colo_temp_list\n    del degradation_temp_list\n    plot_degradation[j][i] = abs((((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100)\n    sum_val = sum_val + float(plot_degradation[j][i])\n    #print j,i,plot_degradation[j][i]\n    #print plot_degradation_error[j][i]\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    if j == \'colocating with libquantum\':\n        xaxis4 = xaxis4 + (i,)\n        yaxis4 = yaxis4 + (plot_degradation[j][i],)\n        error4 = error4 + (plot_degradation_error[j][i],)\n    if j == \'colocating with mcf\':\n        xaxis5 = xaxis5 + (i,)\n        yaxis5 = yaxis5 + (plot_degradation[j][i],)\n        error5 = error5 + (plot_degradation_error[j][i],)\n    if j == \'colocating with lbm\':\n        xaxis6 = xaxis6 + (i,)\n        yaxis6 = yaxis6 + (plot_degradation[j][i],)\n        error6 = error6 + (plot_degradation_error[j][i],)\n    #print numerator2,denominator2,numerator2/denominator2\n    #print denominator2/numerator2\n    print j,i,plot_degradation[j][i]\n            #print (((numerator2/denominator2)-(numerator1/denominator1))/(numerator2/denominator2))*100\n\n#print xaxis\n#print yaxis\n#print error\n#print np.mean(yaxis)\n#print np.mean(yaxis2)\n#print np.mean(yaxis3)\n#print np.mean(sum_val)\n#\n\n\nwidth=0.25\nx = np.arange(len(yaxis))\nfig = plt.figure(figsize=(12, 5))\nbar1 = plt.bar( x+width, yaxis3, width, color="r", yerr=error, label=\'Snapshot Shuttering (avg is %.1f)\' % (np.mean(yaxis3)))\nbar2 = plt.bar( x, yaxis6, width, color="b", yerr=error2,label=\'Precise Shuttering (avg is %.1f)\' % (np.mean(yaxis6)))\n\nplt.xticks(x + width, xaxis, rotation=\'30\', size=\'20\')\nplt.xlim(-1,11)\nplt.ylim(-1,40)\nplt.legend(prop={\'size\':18})\nplt.tight_layout()\nplt.grid()\n# default scale is 1 in your original case, scales with other cases:\n#plt.show()\nplt.savefig(\'%s_error_lbm.png\' %(filename),  dpi=125)'
p0
.I0
.S'Phase Level behavior'
p0
.S'$s:Phase Level behavior'
p0
.I15
.S'$omit!:fig:compareoverhead,1:'
p0
.S''
p0
.I0
.S'$omit!:graph:compareovehead:Comaring ovehead between smart shuttering and precise shuttering technique when libquantum is the co-runner:1'
p0
.S'from collections import defaultdict\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\nbenchList = [ \'milc\', \'mcf\', \'astar\', \'lbm\', \'xalancbmk\', \'libquantum\' ]\nbenchList2 = [ \'milc\', \'mcf\', \'astar\', \'lbm\', \'xalancbmk\', \'libquantum\' ]\n#benchList2 = [ \'gcc\', \'mcf\', \'perlbench\', \'astar\', \'libquantum\', \'povray\', \'bzip2\' ]\ncolocationList = [ \'colocating with libquantum\' ]\ncolocationListBaseline = [ \'colocating with libquantum\' ]\n#colocationListBaseline = [ \'colocating with gcc\', \'colocating with mcf\', \'colocating with perlbench\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with lbm\' ]\ndef autolabel(rects):\n    # attach some text labels\n    for rect in rects:\n        height = rect.get_height()\n        plt.text(rect.get_x()+rect.get_width()/2., 1.05*height, \'%.2f\'%float(height), fontsize=8 )\n\ndef autolabel2(rects):\n    # attach some text labels\n    for rect in rects:\n        height = rect.get_height()\n        plt.text(rect.get_x()+rect.get_width()/2., -1.25*height, \'%.2f\'%float(height),\n                ha=\'center\', va=\'top\', fontsize=8)\n        #plt.text(rect.get_x()+rect.get_width()/2., 1.05*height, \'%.2f\'%float(height))\n\n\nfilename = \'execution_time_4\'\nfList1 = [s.strip() for s in open(\'../../papergraphs/3.compareprior/overhead/shuttering/prior_work_new/2_vm/%s.txt\' % filename).readlines()]\nfList2 = [s.strip() for s in open(\'../../papergraphs/3.compareprior/overhead/shuttering/2_degradation_ground_truth/execution_time_1000.txt\').readlines()]\nfList3 = [s.strip() for s in open(\'../../papergraphs/3.compareprior/overhead/shuttering/prior_work_new/3_vm/%s.txt\' % filename).readlines()]\nfList4 = [s.strip() for s in open(\'../../papergraphs/3.compareprior/overhead/shuttering/3_degradation_ground_truth/execution_time_1000.txt\').readlines()]\nfList5 = [s.strip() for s in open(\'../../papergraphs/3.compareprior/overhead/shuttering/prior_work_new/4_vm/%s.txt\' % filename).readlines()]\nfList6 = [s.strip() for s in open(\'../../papergraphs/3.compareprior/overhead/shuttering/degradation_ground_truth/execution_time_1000.txt\').readlines()]\n#print fList1\n\n\nexecution_time_shutter = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter = defaultdict(lambda  : defaultdict(list))\navg_execution_time_shutter = defaultdict(dict)\n\nexecution_time_baseline = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_baseline = defaultdict(lambda  : defaultdict(list))\navg_execution_time_baseline = defaultdict(dict)\n\nstd_execution_time = defaultdict(dict)\n\ndef print_elapsed_time_shutter(time_shutter):\n    for j in colocationList:\n        for i in benchList:\n            print \'%s ||||  %s\'%(j,i)\n            print time_shutter[j][i]\n\n\ndef print_elapsed_time_baseline(time_baseline):\n    for j in colocationListBaseline:\n        for i in benchList:\n            print \'%s ||||  %s\'%(j,i)\n            print time_baseline[j][i]\n\nsep = \'u\'\nfor (b,a) in enumerate(fList1):\n    #print a\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            execution_time_shutter[index][a].append((fList1[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_shutter[\'colocating with mcf\'][\'perlbench\']\n#print((s.split(start))[1].split(end)[0])\n\nfor (b,a) in enumerate(fList2):\n    if a in colocationListBaseline:\n        #print a,\'1\'\n        index = a\n    else:\n        if a in benchList:\n            #print a,\'2\'\n            #print index,a\n            #execution_time2[index][a].append(fList2[b+4].split(\'u\',1)[0])\n            execution_time_baseline[index][a].append((fList2[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_baseline[\'colocating with mcf\'][\'perlbench\']\n#### PRINT EXECUTION TIME IN MINUTES ###########\n#print_elapsed_time_shutter(execution_time_shutter)\n#print \'***********************************************\'\n#print_elapsed_time_baseline(execution_time_baseline)\n\nfor j in colocationList:\n    for i in benchList:\n        for k in execution_time_shutter[j][i]:\n            m,s = [float (var) for var in k.split(\':\')]\n            temp = m*60 + s\n            execution_time_sec_shutter[j][i].append(temp)\n\nfor j in colocationListBaseline:\n    for i in benchList:\n        for k in execution_time_baseline[j][i]:\n            m,s = [float (var) for var in k.split(\':\')]\n            temp = m*60 + s\n            execution_time_sec_baseline[j][i].append(temp)\n\n\nxaxis = ()\nyaxis = ()\nerror = ()\nxaxis2 = ()\nyaxis2 = ()\nerror2 = ()\nxaxis3 = ()\nyaxis3 = ()\nerror3 = ()\n\nfor j in colocationList:\n    for i in benchList:\n        if len(execution_time_sec_shutter[j][i]) != 0:\n            #print j,i\n            temp_list = []\n            for item in execution_time_sec_shutter[j][i]:\n                temp_list.append(item)\n            temp_list.sort()\n            del temp_list[len(temp_list)-1]\n            del temp_list[0]\n            avg_execution_time_shutter[j][i] = np.mean(temp_list)\n            del temp_list\n            #print avg_execution_time_shutter[j][i]\n\n#print \'*************************\'\n\nfor j in colocationListBaseline:\n    for i in benchList:\n        if len(execution_time_sec_baseline[j][i]) != 0:\n            #print j,i\n            avg_execution_time_baseline[j][i] = np.mean(execution_time_sec_baseline[j][i])\n            #print avg_execution_time_baseline[j][i]\n\nfor j in colocationList:\n    for i in benchList2:\n        if len(execution_time_sec_shutter[j][i]) != 0:\n            if j == \'colocating with libquantum\':\n                yaxis = yaxis + ( abs(((avg_execution_time_shutter[j][i] - avg_execution_time_baseline[j][i])/avg_execution_time_baseline[j][i])*100), )\n                temp = ( ((avg_execution_time_shutter[j][i] - avg_execution_time_baseline[j][i])/avg_execution_time_baseline[j][i])*100, )\n                print j,i,( ((avg_execution_time_shutter[j][i] - avg_execution_time_baseline[j][i])/avg_execution_time_baseline[j][i])*100, )\n\nfor i in benchList:\n    xaxis = xaxis +(i,)\nwidth = 0.25       # the width of the bars\n\n\ndel execution_time_shutter\ndel execution_time_sec_shutter\ndel avg_execution_time_shutter\ndel execution_time_baseline\ndel execution_time_sec_baseline\ndel avg_execution_time_baseline\ndel std_execution_time\n\n\nexecution_time_shutter = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter = defaultdict(lambda  : defaultdict(list))\navg_execution_time_shutter = defaultdict(dict)\n\nexecution_time_baseline = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_baseline = defaultdict(lambda  : defaultdict(list))\navg_execution_time_baseline = defaultdict(dict)\n\nstd_execution_time = defaultdict(dict)\n\n\nsep = \'u\'\nfor (b,a) in enumerate(fList3):\n    #print a\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            execution_time_shutter[index][a].append((fList3[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_shutter[\'colocating with mcf\'][\'perlbench\']\n#print((s.split(start))[1].split(end)[0])\n\nfor (b,a) in enumerate(fList4):\n    if a in colocationListBaseline:\n        #print a,\'1\'\n        index = a\n    else:\n        if a in benchList:\n            #print a,\'2\'\n            #print index,a\n            #execution_time2[index][a].append(fList2[b+4].split(\'u\',1)[0])\n            execution_time_baseline[index][a].append((fList4[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_baseline[\'colocating with mcf\'][\'perlbench\']\n#### PRINT EXECUTION TIME IN MINUTES ###########\n#print_elapsed_time_shutter(execution_time_shutter)\n#print \'***********************************************\'\n#print_elapsed_time_baseline(execution_time_baseline)\n\nfor j in colocationList:\n    for i in benchList:\n        for k in execution_time_shutter[j][i]:\n            m,s = [float (var) for var in k.split(\':\')]\n            temp = m*60 + s\n            execution_time_sec_shutter[j][i].append(temp)\n\nfor j in colocationListBaseline:\n    for i in benchList:\n        for k in execution_time_baseline[j][i]:\n            m,s = [float (var) for var in k.split(\':\')]\n            temp = m*60 + s\n            execution_time_sec_baseline[j][i].append(temp)\n\nfor j in colocationList:\n    for i in benchList:\n        if len(execution_time_sec_shutter[j][i]) != 0:\n            #print j,i\n            temp_list = []\n            for item in execution_time_sec_shutter[j][i]:\n                temp_list.append(item)\n            temp_list.sort()\n            del temp_list[len(temp_list)-1]\n            del temp_list[0]\n            avg_execution_time_shutter[j][i] = np.mean(temp_list)\n            del temp_list\n            #print avg_execution_time_shutter[j][i]\n\n#print \'*************************\'\n\nfor j in colocationListBaseline:\n    for i in benchList:\n        if len(execution_time_sec_baseline[j][i]) != 0:\n            avg_execution_time_baseline[j][i] = np.min(execution_time_sec_baseline[j][i])\n\nfor j in colocationList:\n    for i in benchList2:\n        if len(execution_time_sec_shutter[j][i]) != 0:\n            if j == \'colocating with libquantum\':\n                yaxis2 = yaxis2 + ( abs(((avg_execution_time_shutter[j][i] - avg_execution_time_baseline[j][i])/avg_execution_time_baseline[j][i])*100), )\n                temp = ( ((avg_execution_time_shutter[j][i] - avg_execution_time_baseline[j][i])/avg_execution_time_baseline[j][i])*100, )\n                print j,i,( abs(((avg_execution_time_shutter[j][i] - avg_execution_time_baseline[j][i])/avg_execution_time_baseline[j][i])*100), )\n\n\ndel execution_time_shutter\ndel execution_time_sec_shutter\ndel avg_execution_time_shutter\ndel execution_time_baseline\ndel execution_time_sec_baseline\ndel avg_execution_time_baseline\ndel std_execution_time\n\n\nexecution_time_shutter = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter = defaultdict(lambda  : defaultdict(list))\navg_execution_time_shutter = defaultdict(dict)\n\nexecution_time_baseline = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_baseline = defaultdict(lambda  : defaultdict(list))\navg_execution_time_baseline = defaultdict(dict)\n\nstd_execution_time = defaultdict(dict)\n\n\nsep = \'u\'\nfor (b,a) in enumerate(fList5):\n    #print a\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            execution_time_shutter[index][a].append((fList5[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_shutter[\'colocating with mcf\'][\'perlbench\']\n#print((s.split(start))[1].split(end)[0])\n\nfor (b,a) in enumerate(fList6):\n    if a in colocationListBaseline:\n        #print a,\'1\'\n        index = a\n    else:\n        if a in benchList:\n            #print a,\'2\'\n            #print index,a\n            #execution_time2[index][a].append(fList2[b+4].split(\'u\',1)[0])\n            execution_time_baseline[index][a].append((fList6[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_baseline[\'colocating with mcf\'][\'perlbench\']\n#### PRINT EXECUTION TIME IN MINUTES ###########\n#print_elapsed_time_shutter(execution_time_shutter)\n#print \'***********************************************\'\n#print_elapsed_time_baseline(execution_time_baseline)\n\nfor j in colocationList:\n    for i in benchList:\n        for k in execution_time_shutter[j][i]:\n            m,s = [float (var) for var in k.split(\':\')]\n            temp = m*60 + s\n            execution_time_sec_shutter[j][i].append(temp)\n\nfor j in colocationListBaseline:\n    for i in benchList:\n        for k in execution_time_baseline[j][i]:\n            m,s = [float (var) for var in k.split(\':\')]\n            temp = m*60 + s\n            execution_time_sec_baseline[j][i].append(temp)\n\nfor j in colocationList:\n    for i in benchList:\n        if len(execution_time_sec_shutter[j][i]) != 0:\n            #print j,i\n            temp_list = []\n            for item in execution_time_sec_shutter[j][i]:\n                temp_list.append(item)\n            temp_list.sort()\n            del temp_list[len(temp_list)-1]\n            del temp_list[0]\n            avg_execution_time_shutter[j][i] = np.mean(temp_list)\n            del temp_list\n            #print avg_execution_time_shutter[j][i]\n\n#print \'*************************\'\n\nfor j in colocationListBaseline:\n    for i in benchList:\n        if len(execution_time_sec_baseline[j][i]) != 0:\n            avg_execution_time_baseline[j][i] = np.min(execution_time_sec_baseline[j][i])\n\nfor j in colocationList:\n    for i in benchList2:\n        if len(execution_time_sec_shutter[j][i]) != 0:\n            if j == \'colocating with libquantum\':\n                yaxis3 = yaxis3 + ( abs(((avg_execution_time_shutter[j][i] - avg_execution_time_baseline[j][i])/avg_execution_time_baseline[j][i])*100), )\n                temp = ( ((avg_execution_time_shutter[j][i] - avg_execution_time_baseline[j][i])/avg_execution_time_baseline[j][i])*100, )\n                print j,i,( abs(((avg_execution_time_shutter[j][i] - avg_execution_time_baseline[j][i])/avg_execution_time_baseline[j][i])*100), )\n\n#rects = plt.bar(np.arange(len(yaxis)), yaxis, width, color=\'r\', label=\'blah\')\n#plt.xticks( np.arange(len(yaxis)) + width/2.0, xaxis, rotation=\'45\' )\n#autolabel(rects)\n#plt.ylabel(\'Percentage\')\n#plt.title(\'Percentage Degradation in the execution time due to shuttering mechanism \\n for colocation time 2s shutter time 15ms\')\n#plt.savefig(\'error.png\', dpi=120, bbox_inches=\'tight\')\n\n#print np.mean(yaxis3)\n\nx = np.arange(len(yaxis))\nfig = plt.figure(figsize=(10, 5))\nbar1 = plt.bar( x, yaxis, width, color="r", label=\'2 corunners (avg is %.1f) \' %(np.mean(yaxis) ))\nbar2 = plt.bar( x+width, yaxis2, width, color="b", label=\'3 corunners (avg is %.1f)\' %(np.mean(yaxis2) ))\nbar3 = plt.bar( x+width+width, yaxis3, width, color="g", label=\'4 corunners (avg is %.1f)\' %(np.mean(yaxis3) ))\n#autolabel2(bar1)\n#autolabel(bar2)\n#autolabel2(bar3)\nplt.ylabel( \'Percentage Overhead\' )\nplt.title(\'Overhead due to fair Pricing runtime Engine\')\nplt.xticks(x + width/2.0, xaxis, rotation=\'30\', size=\'12\')\nplt.ylim(-1,10)\nplt.grid()\nplt.legend(prop={\'size\':15})\nplt.tight_layout()\nplt.savefig(\'%s_overhead.png\' %(filename), dpi=125)\n\n\n'
p0
.I0
.S'$fig*:xalshutter,1:xalphase,1:nl:compareoverhead3,1:bwaveslib,1:'
p0
.S''
p0
.I0
.S'$pdf_fig:xalshutter:Phase of the CPI of xalancbmk when it is running alone VS phase of xalancbmk when trying to estimate ground truth CPI by pausing by precise shuttering technique when there are co-runners running along:1'
p0
.S''
p0
.I0
.S'$pdf_fig:xalphase:Phase of the CPI of xalancbmk when it is running alone VS phase of xalancbmk when trying to estimate ground truth CPI by pausing by Snapshot Shuttering technique when there are co-runners running along:1'
p0
.S''
p0
.I0
.S'$omit!:$fig*:compareoverhead3,1:bwaveslib,1:'
p0
.S''
p0
.I0
.S'$graph:compareoverhead3:Overhead due to precise shuttering mechanism which is used by \\cite{fairpricing} to predict degradation due to co-location when libquantum is the co-runner \\vspace{-15 mm}:1'
p0
.S'from collections import defaultdict\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\nbenchList = [ \'milc\', \'mcf\', \'astar\', \'lbm\', \'libquantum\' ]\nbenchList2 = [ \'milc\', \'mcf\', \'astar\', \'lbm\', \'libquantum\' ]\n#benchList2 = [ \'gcc\', \'mcf\', \'perlbench\', \'astar\', \'libquantum\', \'povray\', \'bzip2\' ]\ncolocationList = [ \'colocating with libquantum\' ]\ncolocationListBaseline = [ \'colocating with libquantum\' ]\n#colocationListBaseline = [ \'colocating with gcc\', \'colocating with mcf\', \'colocating with perlbench\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with lbm\' ]\ndef autolabel(rects):\n    # attach some text labels\n    for rect in rects:\n        height = rect.get_height()\n        plt.text(rect.get_x()+rect.get_width()/2., 1.05*height, \'%.2f\'%float(height), fontsize=8 )\n\ndef autolabel2(rects):\n    # attach some text labels\n    for rect in rects:\n        height = rect.get_height()\n        plt.text(rect.get_x()+rect.get_width()/2., -1.25*height, \'%.2f\'%float(height),\n                ha=\'center\', va=\'top\', fontsize=8)\n        #plt.text(rect.get_x()+rect.get_width()/2., 1.05*height, \'%.2f\'%float(height))\n\n\nfilename = \'execution_time_4\'\nfList1 = [s.strip() for s in open(\'../../papergraphs/3.compareprior/overhead/shuttering/prior_work_new/2_vm/%s.txt\' % filename).readlines()]\nfList2 = [s.strip() for s in open(\'../../papergraphs/3.compareprior/overhead/shuttering/2_degradation_ground_truth/execution_time_1000.txt\').readlines()]\nfList3 = [s.strip() for s in open(\'../../papergraphs/3.compareprior/overhead/shuttering/prior_work_new/3_vm/%s.txt\' % filename).readlines()]\nfList4 = [s.strip() for s in open(\'../../papergraphs/3.compareprior/overhead/shuttering/3_degradation_ground_truth/execution_time_1000.txt\').readlines()]\nfList5 = [s.strip() for s in open(\'../../papergraphs/3.compareprior/overhead/shuttering/prior_work_new/4_vm/%s.txt\' % filename).readlines()]\nfList6 = [s.strip() for s in open(\'../../papergraphs/3.compareprior/overhead/shuttering/degradation_ground_truth/execution_time_1000.txt\').readlines()]\n#print fList1\n\n\nexecution_time_shutter = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter = defaultdict(lambda  : defaultdict(list))\navg_execution_time_shutter = defaultdict(dict)\n\nexecution_time_baseline = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_baseline = defaultdict(lambda  : defaultdict(list))\navg_execution_time_baseline = defaultdict(dict)\n\nstd_execution_time = defaultdict(dict)\n\ndef print_elapsed_time_shutter(time_shutter):\n    for j in colocationList:\n        for i in benchList:\n            print \'%s ||||  %s\'%(j,i)\n            print time_shutter[j][i]\n\n\ndef print_elapsed_time_baseline(time_baseline):\n    for j in colocationListBaseline:\n        for i in benchList:\n            print \'%s ||||  %s\'%(j,i)\n            print time_baseline[j][i]\n\nsep = \'u\'\nfor (b,a) in enumerate(fList1):\n    #print a\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            execution_time_shutter[index][a].append((fList1[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_shutter[\'colocating with mcf\'][\'perlbench\']\n#print((s.split(start))[1].split(end)[0])\n\nfor (b,a) in enumerate(fList2):\n    if a in colocationListBaseline:\n        #print a,\'1\'\n        index = a\n    else:\n        if a in benchList:\n            #print a,\'2\'\n            #print index,a\n            #execution_time2[index][a].append(fList2[b+4].split(\'u\',1)[0])\n            execution_time_baseline[index][a].append((fList2[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_baseline[\'colocating with mcf\'][\'perlbench\']\n#### PRINT EXECUTION TIME IN MINUTES ###########\n#print_elapsed_time_shutter(execution_time_shutter)\n#print \'***********************************************\'\n#print_elapsed_time_baseline(execution_time_baseline)\n\nfor j in colocationList:\n    for i in benchList:\n        for k in execution_time_shutter[j][i]:\n            m,s = [float (var) for var in k.split(\':\')]\n            temp = m*60 + s\n            execution_time_sec_shutter[j][i].append(temp)\n\nfor j in colocationListBaseline:\n    for i in benchList:\n        for k in execution_time_baseline[j][i]:\n            m,s = [float (var) for var in k.split(\':\')]\n            temp = m*60 + s\n            execution_time_sec_baseline[j][i].append(temp)\n\n\nxaxis = ()\nyaxis = ()\nerror = ()\nxaxis2 = ()\nyaxis2 = ()\nerror2 = ()\nxaxis3 = ()\nyaxis3 = ()\nerror3 = ()\n\nfor j in colocationList:\n    for i in benchList:\n        if len(execution_time_sec_shutter[j][i]) != 0:\n            #print j,i\n            temp_list = []\n            for item in execution_time_sec_shutter[j][i]:\n                temp_list.append(item)\n            temp_list.sort()\n            del temp_list[len(temp_list)-1]\n            del temp_list[0]\n            avg_execution_time_shutter[j][i] = np.mean(temp_list)\n            del temp_list\n            #print avg_execution_time_shutter[j][i]\n\n#print \'*************************\'\n\nfor j in colocationListBaseline:\n    for i in benchList:\n        if len(execution_time_sec_baseline[j][i]) != 0:\n            #print j,i\n            avg_execution_time_baseline[j][i] = np.mean(execution_time_sec_baseline[j][i])\n            #print avg_execution_time_baseline[j][i]\n\nfor j in colocationList:\n    for i in benchList2:\n        if len(execution_time_sec_shutter[j][i]) != 0:\n            if j == \'colocating with libquantum\':\n                yaxis = yaxis + ( abs(((avg_execution_time_shutter[j][i] - avg_execution_time_baseline[j][i])/avg_execution_time_baseline[j][i])*100), )\n                temp = ( ((avg_execution_time_shutter[j][i] - avg_execution_time_baseline[j][i])/avg_execution_time_baseline[j][i])*100, )\n                print j,i,( ((avg_execution_time_shutter[j][i] - avg_execution_time_baseline[j][i])/avg_execution_time_baseline[j][i])*100, )\n\nfor i in benchList:\n    xaxis = xaxis +(i,)\nwidth = 0.25       # the width of the bars\n\n\ndel execution_time_shutter\ndel execution_time_sec_shutter\ndel avg_execution_time_shutter\ndel execution_time_baseline\ndel execution_time_sec_baseline\ndel avg_execution_time_baseline\ndel std_execution_time\n\n\nexecution_time_shutter = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter = defaultdict(lambda  : defaultdict(list))\navg_execution_time_shutter = defaultdict(dict)\n\nexecution_time_baseline = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_baseline = defaultdict(lambda  : defaultdict(list))\navg_execution_time_baseline = defaultdict(dict)\n\nstd_execution_time = defaultdict(dict)\n\n\nsep = \'u\'\nfor (b,a) in enumerate(fList3):\n    #print a\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            execution_time_shutter[index][a].append((fList3[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_shutter[\'colocating with mcf\'][\'perlbench\']\n#print((s.split(start))[1].split(end)[0])\n\nfor (b,a) in enumerate(fList4):\n    if a in colocationListBaseline:\n        #print a,\'1\'\n        index = a\n    else:\n        if a in benchList:\n            #print a,\'2\'\n            #print index,a\n            #execution_time2[index][a].append(fList2[b+4].split(\'u\',1)[0])\n            execution_time_baseline[index][a].append((fList4[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_baseline[\'colocating with mcf\'][\'perlbench\']\n#### PRINT EXECUTION TIME IN MINUTES ###########\n#print_elapsed_time_shutter(execution_time_shutter)\n#print \'***********************************************\'\n#print_elapsed_time_baseline(execution_time_baseline)\n\nfor j in colocationList:\n    for i in benchList:\n        for k in execution_time_shutter[j][i]:\n            m,s = [float (var) for var in k.split(\':\')]\n            temp = m*60 + s\n            execution_time_sec_shutter[j][i].append(temp)\n\nfor j in colocationListBaseline:\n    for i in benchList:\n        for k in execution_time_baseline[j][i]:\n            m,s = [float (var) for var in k.split(\':\')]\n            temp = m*60 + s\n            execution_time_sec_baseline[j][i].append(temp)\n\nfor j in colocationList:\n    for i in benchList:\n        if len(execution_time_sec_shutter[j][i]) != 0:\n            #print j,i\n            temp_list = []\n            for item in execution_time_sec_shutter[j][i]:\n                temp_list.append(item)\n            temp_list.sort()\n            del temp_list[len(temp_list)-1]\n            del temp_list[0]\n            avg_execution_time_shutter[j][i] = np.mean(temp_list)\n            del temp_list\n            #print avg_execution_time_shutter[j][i]\n\n#print \'*************************\'\n\nfor j in colocationListBaseline:\n    for i in benchList:\n        if len(execution_time_sec_baseline[j][i]) != 0:\n            avg_execution_time_baseline[j][i] = np.min(execution_time_sec_baseline[j][i])\n\nfor j in colocationList:\n    for i in benchList2:\n        if len(execution_time_sec_shutter[j][i]) != 0:\n            if j == \'colocating with libquantum\':\n                yaxis2 = yaxis2 + ( abs(((avg_execution_time_shutter[j][i] - avg_execution_time_baseline[j][i])/avg_execution_time_baseline[j][i])*100), )\n                temp = ( ((avg_execution_time_shutter[j][i] - avg_execution_time_baseline[j][i])/avg_execution_time_baseline[j][i])*100, )\n                print j,i,( abs(((avg_execution_time_shutter[j][i] - avg_execution_time_baseline[j][i])/avg_execution_time_baseline[j][i])*100), )\n\n\ndel execution_time_shutter\ndel execution_time_sec_shutter\ndel avg_execution_time_shutter\ndel execution_time_baseline\ndel execution_time_sec_baseline\ndel avg_execution_time_baseline\ndel std_execution_time\n\n\nexecution_time_shutter = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter = defaultdict(lambda  : defaultdict(list))\navg_execution_time_shutter = defaultdict(dict)\n\nexecution_time_baseline = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_baseline = defaultdict(lambda  : defaultdict(list))\navg_execution_time_baseline = defaultdict(dict)\n\nstd_execution_time = defaultdict(dict)\n\n\nsep = \'u\'\nfor (b,a) in enumerate(fList5):\n    #print a\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            execution_time_shutter[index][a].append((fList5[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_shutter[\'colocating with mcf\'][\'perlbench\']\n#print((s.split(start))[1].split(end)[0])\n\nfor (b,a) in enumerate(fList6):\n    if a in colocationListBaseline:\n        #print a,\'1\'\n        index = a\n    else:\n        if a in benchList:\n            #print a,\'2\'\n            #print index,a\n            #execution_time2[index][a].append(fList2[b+4].split(\'u\',1)[0])\n            execution_time_baseline[index][a].append((fList6[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_baseline[\'colocating with mcf\'][\'perlbench\']\n#### PRINT EXECUTION TIME IN MINUTES ###########\n#print_elapsed_time_shutter(execution_time_shutter)\n#print \'***********************************************\'\n#print_elapsed_time_baseline(execution_time_baseline)\n\nfor j in colocationList:\n    for i in benchList:\n        for k in execution_time_shutter[j][i]:\n            m,s = [float (var) for var in k.split(\':\')]\n            temp = m*60 + s\n            execution_time_sec_shutter[j][i].append(temp)\n\nfor j in colocationListBaseline:\n    for i in benchList:\n        for k in execution_time_baseline[j][i]:\n            m,s = [float (var) for var in k.split(\':\')]\n            temp = m*60 + s\n            execution_time_sec_baseline[j][i].append(temp)\n\nfor j in colocationList:\n    for i in benchList:\n        if len(execution_time_sec_shutter[j][i]) != 0:\n            #print j,i\n            temp_list = []\n            for item in execution_time_sec_shutter[j][i]:\n                temp_list.append(item)\n            temp_list.sort()\n            del temp_list[len(temp_list)-1]\n            del temp_list[0]\n            avg_execution_time_shutter[j][i] = np.mean(temp_list)\n            del temp_list\n            #print avg_execution_time_shutter[j][i]\n\n#print \'*************************\'\n\nfor j in colocationListBaseline:\n    for i in benchList:\n        if len(execution_time_sec_baseline[j][i]) != 0:\n            avg_execution_time_baseline[j][i] = np.min(execution_time_sec_baseline[j][i])\n\nfor j in colocationList:\n    for i in benchList2:\n        if len(execution_time_sec_shutter[j][i]) != 0:\n            if j == \'colocating with libquantum\':\n                yaxis3 = yaxis3 + ( abs(((avg_execution_time_shutter[j][i] - avg_execution_time_baseline[j][i])/avg_execution_time_baseline[j][i])*100), )\n                temp = ( ((avg_execution_time_shutter[j][i] - avg_execution_time_baseline[j][i])/avg_execution_time_baseline[j][i])*100, )\n                print j,i,( abs(((avg_execution_time_shutter[j][i] - avg_execution_time_baseline[j][i])/avg_execution_time_baseline[j][i])*100), )\n\n#rects = plt.bar(np.arange(len(yaxis)), yaxis, width, color=\'r\', label=\'blah\')\n#plt.xticks( np.arange(len(yaxis)) + width/2.0, xaxis, rotation=\'45\' )\n#autolabel(rects)\n#plt.ylabel(\'Percentage\')\n#plt.title(\'Percentage Degradation in the execution time due to shuttering mechanism \\n for colocation time 2s shutter time 15ms\')\n#plt.savefig(\'error.png\', dpi=120, bbox_inches=\'tight\')\n\n#print np.mean(yaxis3)\n\nx = np.arange(len(yaxis))\nfig = plt.figure(figsize=(10, 5))\nbar1 = plt.bar( x, yaxis, width, color="r", label=\'2 corunners (avg is %.1f) \' %(np.mean(yaxis) ))\nbar2 = plt.bar( x+width, yaxis2, width, color="b", label=\'3 corunners (avg is %.1f)\' %(np.mean(yaxis2) ))\nbar3 = plt.bar( x+width+width, yaxis3, width, color="g", label=\'4 corunners (avg is %.1f)\' %(np.mean(yaxis3) ))\n#autolabel2(bar1)\n#autolabel(bar2)\n#autolabel2(bar3)\nplt.ylabel( \'Percentage Overhead\' )\nplt.title(\'Overhead due to fair Pricing runtime Engine\')\nplt.xticks(x + width/2.0, xaxis, rotation=\'30\', size=\'12\')\nplt.ylim(-1,10)\nplt.grid()\nplt.legend(prop={\'size\':15})\nplt.tight_layout()\nplt.savefig(\'%s_overhead.png\' %(filename), dpi=125)\n\nimport os as mars_awesome_os;\nimport matplotlib.pyplot as mars_awesome_plt;\nmars_awesome_plt.savefig(\'compareoverhead3.eps\', bbox_inches=\'tight\');\nmars_awesome_os.popen(\'epstopdf compareoverhead3.eps\');'
p0
.I0
.S'$pdf_fig:bwaveslib:Phase of the CPI of bwaves when it is running alone VS phase of bwaves when trying to estimate ground truth CPI by pausing by Snapshot Shuttering technique when there are co-runners running along:1'
p0
.S''
p0
.I0
.S'Overview'
p0
.S'$p: To first obtain such low error rates, we investigated the phase level behavior of the multiple applications based on a series of performance counter events that show how they were useful in determining phase changes across applications. '
p0
.I0
.S'Description of figures'
p0
.S'$p: Figure \\ref{fig:milclibllc} depicts the phase of CPI during standalone execution of milc over the phase of LLC stores of milc when milc is co-located with 3 instances of libquantum. Figure \\ref{fig:milclibl1d} depicts the phase of CPI for standalone execution of milc over the phase of L1-dcache-loads of milc when again milc is co-located with 3 instances of libquantum. \nFigure \\ref{fig:mcflibllc} and \\ref{fig:mcflibl1d} provide the same information as Figure \\ref{fig:milclibllc} and Figure \\ref{fig:milclibl1d} just that the main application that is being observed is mcf instead of milc. '
p0
.I0
.S'Insights'
p0
.S'$p: From Figure \\ref{fig:milclibllc} and Figure \\ref{fig:milclibl1d} we get to know that changes in the phase of lone execution of milc is is being depicted much significantly by the PMC type Last Level Cache Stores (LLC-stores) but, not as much by PMC type L1-d-cache misses. On the other hand, from Figure \\ref{fig:mcflibllc} and Figure \\ref{fig:mcflibl1d} we observe that changes in the phase of lone execution of mcf is is being depicted much significantly by the PMC type last L1-d-cache misses but, not as much by PMC type LLC-misses. This made us conclude that compared to a single PMC type, a subset of PMC types will be much more effective in accurately predicting phase changes in an application. '
p0
.I0
.S'Insight 2'
p0
.S'$p: Although we observed the need of more than one PMC type to predict phase changes, a general trend that followed is in our experiments is that whenever there is a phase change with respect to CPI in our applications, most of the micro-architectural events also change. However in some situations, where some applications portrait distinct irregularities, some specific PMC types are able to capture them much more effectively than the others. An analysis of the application characteristics of SPEC lead us to the conclusions that a very few subset of the PMC types are needed so as to capture distinct phase changes within applications. Though requirements for phase analysis for our purpose require methodologies which have negligible overhead, they need not be accurate and fine grained at the basic block level. So the methodology that we employ based on PMCs seem to fit very well in our system.'
p0
.I0
.S'Co runner phases'
p0
.S'$p: Another experiment that we felt was interesting for us to conduct was to see the effect on PMC measurements with different co-runners to see if varying co-runners affect PMC measurements and in turn phase prediction. Figure \\ref{fig:astarlibl1d},\\ref{fig:astarmcfl1d},\\ref{fig:astarlbml1d} shows the phase of CPI of standalone execution of astar versus the phase of L1-d-cache misses of astar when it is co-running with libquantum, mcf and lbm respectively. From those figures we are able to observe that even when the co-running application changes, the measurements that have been reported by the PMCs have been fairly consistent. Even though there might be slight variations with respect to phase prediction caused due to the run to run variations in the measurement of PMCs, the PMC types that we use are able to capture distinctive phase changes quite consistently. '
p0
.I0
.S'astar accuracy'
p0
.S'$p: Figure \\ref{fig:astarlib2} compares the phases of application astar when it is run alone versus the phase of the application when it co-runners are paused by using smart shuttering technique. We can clearly see in Figure \\ref{fig:astarlib2} how phase changes corresponding to the lone run of the application is being captured by the PMC event L1-dcache-loads at different points of time. The indication of such events marks the starting of new phase which is represented by flat red lines as shown in Figure \\ref{fig:astarlib2}. The error corresponding to this single run for predicting degradation was 4\\%.'
p0
.I0
.S'Flat versus phasy'
p0
.S'$p: Figure \\ref{fig:mcflib} and Figure \\ref{fig:milclib} shows the comparison of phases of CPI of standalone run of the application mcf with the phase of estimated CPI of standalone run of mcf with the help of smart shuttering technique. \n%Figure \\ref{fig:} Figure \\ref{fig:}'
p0
.I0
.S'Overhead'
p0
.S'$s:Overhead due to Fair Pricing Runtime Engine'
p0
.I3
.S'Explanation'
p0
.S'$p: Figure \\ref{fig:overhead} presents the overhead incurred in predicting degradation due to co-location by the Fair Pricing Runtime Engine. The overhead calculated here is the mean overhead due to phase changes in all the application co-located in the same node. The overhead is minimal. The overhead suffered by applications when they are co-locating with libquantum and sphinx3 are around 1\\%. This is due to the fact that libquantum have barely few phase changes. On the other hand, though sphinx3 has some phase changes they occur very rarely and hence there is barely any degradation due to co-location. '
p0
.I0
.S'mcf'
p0
.S'$p: The overhead when mcf is a co-runner is three times higher than the common case with respect to libquantum and sphinx3. This is probably the worst case scenario that we have faced in our experiments. This is due to the fact that mcf has many distinct phases and whenever there is a phase change being detected for either of the 3 applications running mcf, all the other applications will be paused. This adds to the increase in overhead when mcf in the co-runner. '
p0
.I0
.S'Individual benchmarks'
p0
.S'$p: We also observe that applications like namd,calculix and dealII which exhibit highly irregular phases show a slightly more overhead than the other typical applications. On an average around 60\\% of the applications when co-located along with libquantum and sphinx have overhead of less that 0.5\\% overhead. The reason why it happens is because these applications have a comparatively flat phase of execution. Hence when the applications start executing initially, ground truth is obtained once and this is used as the estimated ground throughout the execution period of the application. The estimated ground truth not only has low error in prediction, it also incurs a negligible overhead in the order of milliseconds when compared to the time for which the application runs. '
p0
.I0
.S'Comparison with shuttering'
p0
.S'$s:Comparison with shuttering'
p0
.I4
.S'Explanation'
p0
.S'$p: \\vspace{-3 mm} Figure \\ref{fig:compareaccuracy}, \\ref{fig:compareaccuracy2}, \\ref{fig:compareaccuracy3} shows the comparison when we use Fair Pricing runtime engine with smart shuttering as compared to the prior work which uses precise shuttering. We can clearly see that for almost all of the benchmarks Fair Pricing Runtime Engine does much better than precise shuttering. The only exceptional case is bwaves. The reason is due to the fact that the phase of bwaves even when observed at a comparatively coarse granular intervals of around one sample points at every one second, contains a lot of spikes. The binary classification technique that we use disregards these points of noise while predicting phase changes.  Though such points do not attribute to phase change, they manipulate towards the final average CPI of the application and discarding them will result in a prediction of degradation which is more than that of what it is actually is which results this unusual variability. Even at such a corner case, our runtime system is able to predict degradation within 10 \\% error. '
p0
.I0
.S'Compare phase'
p0
.S'$p: Figure \\ref{fig:xalshutter} and Figure \\ref{fig:xalphase} compares the phases of application xalancbmk when it is run alone versus the phase of the application when it is paused by using precise shuttering technique and when it is paused by using smart shuttering technique respective in the presence of co-runners. We can clearly see that in Figure \\ref{fig:xalshutter}, the phase of the pause periods of the application when paused by smart shuttering matches the ground truth execution phase of lone application much more than the phase the phase of the pause periods of the application when paused by precise shuttering. '
p0
.I0
.S'Overhead'
p0
.S'$p: Figure \\ref{fig:compareoverhead3} shows the overhead associated with predicting degradation due to co-location by precise shuttering technique. We can see that as the number of co-runner increases, the overhead of the prior technique increases drastically across all type of co-runners. This is due to the fact that frequent shuttering would constantly thrash the shared caches to fill up data corresponding to the application that was shuttered most recently. During longer though less frequent shuttering this scenario can be much avoided. Moreover when it comes to applications with flat phases, snapshot shuttering avoids pausing the co-runners for most of the time and hence overhead turns out to be much lesser. \\vspace{-1.9 mm}'
p0
.I0
.S'$omit:!graph:compareovehead:Comaring ovehead between smart shuttering and precise shuttering technique when libquantum is the co-runner:1'
p0
.S'from collections import defaultdict\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\nbenchList = [ \'milc\', \'mcf\', \'astar\', \'lbm\', \'xalancbmk\', \'libquantum\' ]\nbenchList2 = [ \'milc\', \'mcf\', \'astar\', \'lbm\', \'xalancbmk\', \'libquantum\' ]\n#benchList2 = [ \'gcc\', \'mcf\', \'perlbench\', \'astar\', \'libquantum\', \'povray\', \'bzip2\' ]\ncolocationList = [ \'colocating with libquantum\' ]\ncolocationListBaseline = [ \'colocating with libquantum\' ]\n#colocationListBaseline = [ \'colocating with gcc\', \'colocating with mcf\', \'colocating with perlbench\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with lbm\' ]\ndef autolabel(rects):\n    # attach some text labels\n    for rect in rects:\n        height = rect.get_height()\n        plt.text(rect.get_x()+rect.get_width()/2., 1.05*height, \'%.2f\'%float(height), fontsize=8 )\n\ndef autolabel2(rects):\n    # attach some text labels\n    for rect in rects:\n        height = rect.get_height()\n        plt.text(rect.get_x()+rect.get_width()/2., -1.25*height, \'%.2f\'%float(height),\n                ha=\'center\', va=\'top\', fontsize=8)\n        #plt.text(rect.get_x()+rect.get_width()/2., 1.05*height, \'%.2f\'%float(height))\n\n\nfilename = \'execution_time_4\'\nfList1 = [s.strip() for s in open(\'../../papergraphs/3.compareprior/overhead/shuttering/prior_work_new/2_vm/%s.txt\' % filename).readlines()]\nfList2 = [s.strip() for s in open(\'../../papergraphs/3.compareprior/overhead/shuttering/2_degradation_ground_truth/execution_time_1000.txt\').readlines()]\nfList3 = [s.strip() for s in open(\'../../papergraphs/3.compareprior/overhead/shuttering/prior_work_new/3_vm/%s.txt\' % filename).readlines()]\nfList4 = [s.strip() for s in open(\'../../papergraphs/3.compareprior/overhead/shuttering/3_degradation_ground_truth/execution_time_1000.txt\').readlines()]\nfList5 = [s.strip() for s in open(\'../../papergraphs/3.compareprior/overhead/shuttering/prior_work_new/4_vm/%s.txt\' % filename).readlines()]\nfList6 = [s.strip() for s in open(\'../../papergraphs/3.compareprior/overhead/shuttering/degradation_ground_truth/execution_time_1000.txt\').readlines()]\n#print fList1\n\n\nexecution_time_shutter = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter = defaultdict(lambda  : defaultdict(list))\navg_execution_time_shutter = defaultdict(dict)\n\nexecution_time_baseline = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_baseline = defaultdict(lambda  : defaultdict(list))\navg_execution_time_baseline = defaultdict(dict)\n\nstd_execution_time = defaultdict(dict)\n\ndef print_elapsed_time_shutter(time_shutter):\n    for j in colocationList:\n        for i in benchList:\n            print \'%s ||||  %s\'%(j,i)\n            print time_shutter[j][i]\n\n\ndef print_elapsed_time_baseline(time_baseline):\n    for j in colocationListBaseline:\n        for i in benchList:\n            print \'%s ||||  %s\'%(j,i)\n            print time_baseline[j][i]\n\nsep = \'u\'\nfor (b,a) in enumerate(fList1):\n    #print a\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            execution_time_shutter[index][a].append((fList1[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_shutter[\'colocating with mcf\'][\'perlbench\']\n#print((s.split(start))[1].split(end)[0])\n\nfor (b,a) in enumerate(fList2):\n    if a in colocationListBaseline:\n        #print a,\'1\'\n        index = a\n    else:\n        if a in benchList:\n            #print a,\'2\'\n            #print index,a\n            #execution_time2[index][a].append(fList2[b+4].split(\'u\',1)[0])\n            execution_time_baseline[index][a].append((fList2[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_baseline[\'colocating with mcf\'][\'perlbench\']\n#### PRINT EXECUTION TIME IN MINUTES ###########\n#print_elapsed_time_shutter(execution_time_shutter)\n#print \'***********************************************\'\n#print_elapsed_time_baseline(execution_time_baseline)\n\nfor j in colocationList:\n    for i in benchList:\n        for k in execution_time_shutter[j][i]:\n            m,s = [float (var) for var in k.split(\':\')]\n            temp = m*60 + s\n            execution_time_sec_shutter[j][i].append(temp)\n\nfor j in colocationListBaseline:\n    for i in benchList:\n        for k in execution_time_baseline[j][i]:\n            m,s = [float (var) for var in k.split(\':\')]\n            temp = m*60 + s\n            execution_time_sec_baseline[j][i].append(temp)\n\n\nxaxis = ()\nyaxis = ()\nerror = ()\nxaxis2 = ()\nyaxis2 = ()\nerror2 = ()\nxaxis3 = ()\nyaxis3 = ()\nerror3 = ()\n\nfor j in colocationList:\n    for i in benchList:\n        if len(execution_time_sec_shutter[j][i]) != 0:\n            #print j,i\n            temp_list = []\n            for item in execution_time_sec_shutter[j][i]:\n                temp_list.append(item)\n            temp_list.sort()\n            del temp_list[len(temp_list)-1]\n            del temp_list[0]\n            avg_execution_time_shutter[j][i] = np.mean(temp_list)\n            del temp_list\n            #print avg_execution_time_shutter[j][i]\n\n#print \'*************************\'\n\nfor j in colocationListBaseline:\n    for i in benchList:\n        if len(execution_time_sec_baseline[j][i]) != 0:\n            #print j,i\n            avg_execution_time_baseline[j][i] = np.mean(execution_time_sec_baseline[j][i])\n            #print avg_execution_time_baseline[j][i]\n\nfor j in colocationList:\n    for i in benchList2:\n        if len(execution_time_sec_shutter[j][i]) != 0:\n            if j == \'colocating with libquantum\':\n                yaxis = yaxis + ( abs(((avg_execution_time_shutter[j][i] - avg_execution_time_baseline[j][i])/avg_execution_time_baseline[j][i])*100), )\n                temp = ( ((avg_execution_time_shutter[j][i] - avg_execution_time_baseline[j][i])/avg_execution_time_baseline[j][i])*100, )\n                print j,i,( ((avg_execution_time_shutter[j][i] - avg_execution_time_baseline[j][i])/avg_execution_time_baseline[j][i])*100, )\n\nfor i in benchList:\n    xaxis = xaxis +(i,)\nwidth = 0.25       # the width of the bars\n\n\ndel execution_time_shutter\ndel execution_time_sec_shutter\ndel avg_execution_time_shutter\ndel execution_time_baseline\ndel execution_time_sec_baseline\ndel avg_execution_time_baseline\ndel std_execution_time\n\n\nexecution_time_shutter = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter = defaultdict(lambda  : defaultdict(list))\navg_execution_time_shutter = defaultdict(dict)\n\nexecution_time_baseline = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_baseline = defaultdict(lambda  : defaultdict(list))\navg_execution_time_baseline = defaultdict(dict)\n\nstd_execution_time = defaultdict(dict)\n\n\nsep = \'u\'\nfor (b,a) in enumerate(fList3):\n    #print a\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            execution_time_shutter[index][a].append((fList3[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_shutter[\'colocating with mcf\'][\'perlbench\']\n#print((s.split(start))[1].split(end)[0])\n\nfor (b,a) in enumerate(fList4):\n    if a in colocationListBaseline:\n        #print a,\'1\'\n        index = a\n    else:\n        if a in benchList:\n            #print a,\'2\'\n            #print index,a\n            #execution_time2[index][a].append(fList2[b+4].split(\'u\',1)[0])\n            execution_time_baseline[index][a].append((fList4[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_baseline[\'colocating with mcf\'][\'perlbench\']\n#### PRINT EXECUTION TIME IN MINUTES ###########\n#print_elapsed_time_shutter(execution_time_shutter)\n#print \'***********************************************\'\n#print_elapsed_time_baseline(execution_time_baseline)\n\nfor j in colocationList:\n    for i in benchList:\n        for k in execution_time_shutter[j][i]:\n            m,s = [float (var) for var in k.split(\':\')]\n            temp = m*60 + s\n            execution_time_sec_shutter[j][i].append(temp)\n\nfor j in colocationListBaseline:\n    for i in benchList:\n        for k in execution_time_baseline[j][i]:\n            m,s = [float (var) for var in k.split(\':\')]\n            temp = m*60 + s\n            execution_time_sec_baseline[j][i].append(temp)\n\nfor j in colocationList:\n    for i in benchList:\n        if len(execution_time_sec_shutter[j][i]) != 0:\n            #print j,i\n            temp_list = []\n            for item in execution_time_sec_shutter[j][i]:\n                temp_list.append(item)\n            temp_list.sort()\n            del temp_list[len(temp_list)-1]\n            del temp_list[0]\n            avg_execution_time_shutter[j][i] = np.mean(temp_list)\n            del temp_list\n            #print avg_execution_time_shutter[j][i]\n\n#print \'*************************\'\n\nfor j in colocationListBaseline:\n    for i in benchList:\n        if len(execution_time_sec_baseline[j][i]) != 0:\n            avg_execution_time_baseline[j][i] = np.min(execution_time_sec_baseline[j][i])\n\nfor j in colocationList:\n    for i in benchList2:\n        if len(execution_time_sec_shutter[j][i]) != 0:\n            if j == \'colocating with libquantum\':\n                yaxis2 = yaxis2 + ( abs(((avg_execution_time_shutter[j][i] - avg_execution_time_baseline[j][i])/avg_execution_time_baseline[j][i])*100), )\n                temp = ( ((avg_execution_time_shutter[j][i] - avg_execution_time_baseline[j][i])/avg_execution_time_baseline[j][i])*100, )\n                print j,i,( abs(((avg_execution_time_shutter[j][i] - avg_execution_time_baseline[j][i])/avg_execution_time_baseline[j][i])*100), )\n\n\ndel execution_time_shutter\ndel execution_time_sec_shutter\ndel avg_execution_time_shutter\ndel execution_time_baseline\ndel execution_time_sec_baseline\ndel avg_execution_time_baseline\ndel std_execution_time\n\n\nexecution_time_shutter = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter = defaultdict(lambda  : defaultdict(list))\navg_execution_time_shutter = defaultdict(dict)\n\nexecution_time_baseline = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_baseline = defaultdict(lambda  : defaultdict(list))\navg_execution_time_baseline = defaultdict(dict)\n\nstd_execution_time = defaultdict(dict)\n\n\nsep = \'u\'\nfor (b,a) in enumerate(fList5):\n    #print a\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            execution_time_shutter[index][a].append((fList5[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_shutter[\'colocating with mcf\'][\'perlbench\']\n#print((s.split(start))[1].split(end)[0])\n\nfor (b,a) in enumerate(fList6):\n    if a in colocationListBaseline:\n        #print a,\'1\'\n        index = a\n    else:\n        if a in benchList:\n            #print a,\'2\'\n            #print index,a\n            #execution_time2[index][a].append(fList2[b+4].split(\'u\',1)[0])\n            execution_time_baseline[index][a].append((fList6[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_baseline[\'colocating with mcf\'][\'perlbench\']\n#### PRINT EXECUTION TIME IN MINUTES ###########\n#print_elapsed_time_shutter(execution_time_shutter)\n#print \'***********************************************\'\n#print_elapsed_time_baseline(execution_time_baseline)\n\nfor j in colocationList:\n    for i in benchList:\n        for k in execution_time_shutter[j][i]:\n            m,s = [float (var) for var in k.split(\':\')]\n            temp = m*60 + s\n            execution_time_sec_shutter[j][i].append(temp)\n\nfor j in colocationListBaseline:\n    for i in benchList:\n        for k in execution_time_baseline[j][i]:\n            m,s = [float (var) for var in k.split(\':\')]\n            temp = m*60 + s\n            execution_time_sec_baseline[j][i].append(temp)\n\nfor j in colocationList:\n    for i in benchList:\n        if len(execution_time_sec_shutter[j][i]) != 0:\n            #print j,i\n            temp_list = []\n            for item in execution_time_sec_shutter[j][i]:\n                temp_list.append(item)\n            temp_list.sort()\n            del temp_list[len(temp_list)-1]\n            del temp_list[0]\n            avg_execution_time_shutter[j][i] = np.mean(temp_list)\n            del temp_list\n            #print avg_execution_time_shutter[j][i]\n\n#print \'*************************\'\n\nfor j in colocationListBaseline:\n    for i in benchList:\n        if len(execution_time_sec_baseline[j][i]) != 0:\n            avg_execution_time_baseline[j][i] = np.min(execution_time_sec_baseline[j][i])\n\nfor j in colocationList:\n    for i in benchList2:\n        if len(execution_time_sec_shutter[j][i]) != 0:\n            if j == \'colocating with libquantum\':\n                yaxis3 = yaxis3 + ( abs(((avg_execution_time_shutter[j][i] - avg_execution_time_baseline[j][i])/avg_execution_time_baseline[j][i])*100), )\n                temp = ( ((avg_execution_time_shutter[j][i] - avg_execution_time_baseline[j][i])/avg_execution_time_baseline[j][i])*100, )\n                print j,i,( abs(((avg_execution_time_shutter[j][i] - avg_execution_time_baseline[j][i])/avg_execution_time_baseline[j][i])*100), )\n\n#rects = plt.bar(np.arange(len(yaxis)), yaxis, width, color=\'r\', label=\'blah\')\n#plt.xticks( np.arange(len(yaxis)) + width/2.0, xaxis, rotation=\'45\' )\n#autolabel(rects)\n#plt.ylabel(\'Percentage\')\n#plt.title(\'Percentage Degradation in the execution time due to shuttering mechanism \\n for colocation time 2s shutter time 15ms\')\n#plt.savefig(\'error.png\', dpi=120, bbox_inches=\'tight\')\n\n#print np.mean(yaxis3)\n\nx = np.arange(len(yaxis))\nfig = plt.figure(figsize=(10, 5))\nbar1 = plt.bar( x, yaxis, width, color="r", label=\'2 corunners (avg is %.1f) \' %(np.mean(yaxis) ))\nbar2 = plt.bar( x+width, yaxis2, width, color="b", label=\'3 corunners (avg is %.1f)\' %(np.mean(yaxis2) ))\nbar3 = plt.bar( x+width+width, yaxis3, width, color="g", label=\'4 corunners (avg is %.1f)\' %(np.mean(yaxis3) ))\n#autolabel2(bar1)\n#autolabel(bar2)\n#autolabel2(bar3)\nplt.ylabel( \'Percentage Overhead\' )\nplt.title(\'Overhead due to fair Pricing runtime Engine\')\nplt.xticks(x + width/2.0, xaxis, rotation=\'30\', size=\'12\')\nplt.ylim(-1,10)\nplt.grid()\nplt.legend(prop={\'size\':15})\nplt.tight_layout()\nplt.savefig(\'%s_overhead.png\' %(filename), dpi=125)\n\n\n'
p0
.I0
.S'$omit!:Phase detection - co phase'
p0
.S''
p0
.I6
.S'$fig:lbmlib,1:'
p0
.S''
p0
.I0
.S'$pdf_fig:lbmlib:Overview of fair pricing runtime engine in the software stack:1'
p0
.S''
p0
.I0
.S'$fig:omnetpplib,1:'
p0
.S''
p0
.I0
.S'$pdf_fig:omnetpplib:Overview of fair pricing runtime engine in the software stack:1'
p0
.S''
p0
.I0
.S'$fig:astarlib,1:'
p0
.S''
p0
.I0
.S'$pdf_fig:astarlib:Overview of fair pricing runtime engine in the software stack:1'
p0
.S''
p0
.I0
.S'$omit!:Final Pricing Graphs'
p0
.S'$s:Final Pricing Graphs'
p0
.I0
.S'Conclusion'
p0
.S'$s: Conclusion \n'
p0
.I4
.S'our work'
p0
.S"$omit: This work introduces \\textbf{Sirius}, an open end-to-end intelligent personal assistant  application, modeled after popular IPA services such as Apple's Siri. Sirius leverages well established open infrastructures for speech recognition, computer vision, and question-and-answer systems. We use Sirius to investigate the cost, power, and performance implications of  hardware accelerator-based server architectures for future data center designs. We show that GPU- and FPGA-accelerated servers can significantly speed up the parallelizable portion of a query on average by 12x and 20x. Leveraging the latency reduction, GPU- and FPGA-accelerated servers can reduce the TCO by 2.1x and 1.5x, respectively."
p0
.I1
.S', and the end-to-end of the query by 6.6x and 8.2x'
p0
.S''
p0
.I0
.S'$cmt: Needs work'
p0
.S''
p0
.I0
.S'conclusion'
p0
.S'$p:\\vspace{-2 mm}This work presents Fair Pricing Runtime Engine, a novel approach to predict degradation due to co-location and to price users accordingly. The Fair Pricing Runtime Engine is has negligible performance overhead, operates without any special hardware or programmer support, and can accurately predict degradation due to co-location. These combination of features gives our Runtime the capability to predict real time applications with high precision and to price the users running them accordingly.\n\nUsing this mechanism we are able to predict the degradation due to co-location of applications with a mean absolute error of about 4\\% within an overhead of around 1\\%. This situation we feel would put users to a situation to use Reserved/On Demand Instances which can prevent over provisioning of resources and improve energy efficiency.\n\n%Using this lightweight dynamic compilation capability, we design Protean Code for Cache Contention in Datacenters (PC3D), a runtime approach to mitigating cache contention for live datacenter applications by dynamically inserting and removing software non-temporal cache hints, allowing batch applications to achieve high throughput while meeting latency-sensitive application QoS. On a spectrum of webservice and benchmark applications, PC3D achieves utilization improvements of up to 2.8x (average of 1.5x) higher than a recently published state-of-the-art contention mitigation runtime at a QoS target of 98\\%.'
p0
.I0
.S'Bibliography'
p0
.S'$bib:\n@article{Barroso:2007:CEC:1339817.1339894,\n author = {Barroso, Luiz Andr{\\\'e} and H\\"{o}lzle, Urs},\n title = {The Case for Energy-Proportional Computing},\n journal = {Computer},\n issue_date = {December 2007},\n volume = {40},\n number = {12},\n month = dec,\n year = {2007},\n issn = {0018-9162},\n pages = {33--37},\n numpages = {5},\n url = {http://dx.doi.org/10.1109/MC.2007.443},\n doi = {10.1109/MC.2007.443},\n acmid = {1339894},\n publisher = {IEEE Computer Society Press},\n address = {Los Alamitos, CA, USA},\n keywords = {energy-proportional computing, green computing, green computing, energy-proportional computing},\n} \n\n@inproceedings{Farley:2012:MYM:2391229.2391249,\n author = {Farley, Benjamin and Juels, Ari and Varadarajan, Venkatanathan and Ristenpart, Thomas and Bowers, Kevin D. and Swift, Michael M.},\n title = {More for Your Money: Exploiting Performance Heterogeneity in Public Clouds},\n booktitle = {Proceedings of the Third ACM Symposium on Cloud Computing},\n series = {SoCC \'12},\n year = {2012},\n isbn = {978-1-4503-1761-0},\n location = {San Jose, California},\n pages = {20:1--20:14},\n articleno = {20},\n numpages = {14},\n url = {http://doi.acm.org/10.1145/2391229.2391249},\n doi = {10.1145/2391229.2391249},\n acmid = {2391249},\n publisher = {ACM},\n address = {New York, NY, USA},\n keywords = {cloud computing, heterogeneity, virtual machine migration},\n} \n\n@article{Henning:2006:SCB:1186736.1186737,\n author = {Henning, John L.},\n title = {SPEC CPU2006 Benchmark Descriptions},\n journal = {SIGARCH Comput. Archit. News},\n issue_date = {September 2006},\n volume = {34},\n number = {4},\n month = sep,\n year = {2006},\n issn = {0163-5964},\n pages = {1--17},\n numpages = {17},\n url = {http://doi.acm.org/10.1145/1186736.1186737},\n doi = {10.1145/1186736.1186737},\n acmid = {1186737},\n publisher = {ACM},\n address = {New York, NY, USA},\n}\n\n@inproceedings{Brankovic:2014:AOP:2597917.2597937,\n author = {Brankovi\\\'{c}, Aleksandar and Stavrou, Kyriakos and Gibert, Enric and Gonz\\\'{a}lez, Antonio},\n title = {Accurate Off-line Phase Classification for HW/SW Co-designed Processors},\n booktitle = {Proceedings of the 11th ACM Conference on Computing Frontiers},\n series = {CF \'14},\n year = {2014},\n isbn = {978-1-4503-2870-8},\n location = {Cagliari, Italy},\n pages = {5:1--5:10},\n articleno = {5},\n numpages = {10},\n url = {http://doi.acm.org/10.1145/2597917.2597937},\n doi = {10.1145/2597917.2597937},\n acmid = {2597937},\n publisher = {ACM},\n address = {New York, NY, USA},\n keywords = {HW/SW co-designed processors, dynamic binary translation, simulation, warm-up methodology},\n} \n\n@article{DBLP:journals/corr/abs-0909-1784,\n  author    = {Stavros Harizopoulos and\n               Mehul A. Shah and\n               Justin Meza and\n               Parthasarathy Ranganathan},\n  title     = {Energy Efficiency: The New Holy Grail of Data Management Systems Research},\n  journal   = {CoRR},\n  volume    = {abs/0909.1784},\n  year      = {2009},\n  url       = {http://arxiv.org/abs/0909.1784},\n  timestamp = {Mon, 05 Dec 2011 18:05:25 +0100},\n  biburl    = {http://dblp.uni-trier.de/rec/bib/journals/corr/abs-0909-1784},\n  bibsource = {dblp computer science bibliography, http://dblp.org}\n}\n\n@inproceedings{Balasubramonian:2000:MHR:360128.360153,\n author = {Balasubramonian, Rajeev and Albonesi, David and Buyuktosunoglu, Alper and Dwarkadas, Sandhya},\n title = {Memory Hierarchy Reconfiguration for Energy and Performance in General-purpose Processor Architectures},\n booktitle = {Proceedings of the 33rd Annual ACM/IEEE International Symposium on Microarchitecture},\n series = {MICRO 33},\n year = {2000},\n isbn = {1-58113-196-8},\n location = {Monterey, California, USA},\n pages = {245--257},\n numpages = {13},\n url = {http://doi.acm.org/10.1145/360128.360153},\n doi = {10.1145/360128.360153},\n acmid = {360153},\n publisher = {ACM},\n address = {New York, NY, USA},\n} \n\n@INPROCEEDINGS{1402088, \nauthor={Nagpurkar, P. and Krintz, C. and Sherwood, T.}, \nbooktitle={Code Generation and Optimization, 2005. CGO 2005. International Symposium on}, \ntitle={Phase-aware remote profiling}, \nyear={2005}, \nmonth={March}, \npages={191-202}, \nkeywords={Internet;embedded systems;optimising compilers;ubiquitous computing;Internet;Web-enabled mobile phone;battery-powered device;embedded device technology;energy consumption;hardware-software scheme;intelligent online sampling;meta information;personal digital assistants;phase-aware remote profiling;ubiquitous computing;Computer science;Energy consumption;IP networks;Information analysis;Mobile handsets;Optimizing compilers;Personal digital assistants;Programming;Sampling methods;Ubiquitous computing}, \ndoi={10.1109/CGO.2005.26},}\n\n@inproceedings{Lukefahr:2012:CCP:2457472.2457508,\n author = {Lukefahr, Andrew and Padmanabha, Shruti and Das, Reetuparna and Sleiman, Faissal M. and Dreslinski, Ronald and Wenisch, Thomas F. and Mahlke, Scott},\n title = {Composite Cores: Pushing Heterogeneity Into a Core},\n booktitle = {Proceedings of the 2012 45th Annual IEEE/ACM International Symposium on Microarchitecture},\n series = {MICRO-45},\n year = {2012},\n isbn = {978-0-7695-4924-8},\n location = {Vancouver, B.C., CANADA},\n pages = {317--328},\n numpages = {12},\n url = {http://dx.doi.org/10.1109/MICRO.2012.37},\n doi = {10.1109/MICRO.2012.37},\n acmid = {2457508},\n publisher = {IEEE Computer Society},\n address = {Washington, DC, USA},\n keywords = {heterogeneous architecture, core microarchitecure, split pipelines, reactive controller},\n} \n\n@TECHREPORT{Qumranet2007,\n  author = {Qumranet},\n  title = {KVM: Kernel-based Virtualization Machine},\n  institution = {Qumranet},\n  year = {2007},\n  url = {http://www.qumranet.com/files/Qumranet_WhitePaper_03.pdf}\n}\n\n@INPROCEEDINGS{6114207, \nauthor={Sembrant, A. and Eklov, D. and Hagersten, E.}, \nbooktitle={Workload Characterization (IISWC), 2011 IEEE International Symposium on}, \ntitle={Efficient software-based online phase classification}, \nyear={2011}, \nmonth={Nov}, \npages={104-115}, \nkeywords={program diagnostics;sampling methods;ScarPhase;hardware-assisted phase detection;low overhead phase detection;online phase detection library;runtime data collection;runtime phases;sample-based analysis;sample-based classification;software-based online phase classification;time-varying behavior;Benchmark testing;Hardware;Phase detection;Radiation detectors;Runtime;Support vector machine classification;Vectors}, \ndoi={10.1109/IISWC.2011.6114207},}\n\n@inproceedings{sembrant2011iiswc,\n  title = {Efficient Software-based Online Phase Classification},\n  author = {Andreas Sembrant and David Eklov and Erik Hagersten},\n  booktitle = {Int. Symposium on Workload Characterization (IISWC)},\n  year = {2011}\n}\n\n@INPROCEEDINGS{6522315, \nauthor={Sandberg, A. and Sembrant, A. and Hagersten, E. and Black-Schaffer, D.}, \nbooktitle={High Performance Computer Architecture (HPCA2013), 2013 IEEE 19th International Symposium on}, \ntitle={Modeling performance variation due to cache sharing}, \nyear={2013}, \nmonth={Feb}, \npages={155-166}, \nkeywords={bandwidth allocation;cache storage;multiprocessing systems;performance evaluation;application phases;average relative error;bandwidth consumption;bandwidth demands;cache sharing;cache sharing performance model;contemporary multicore machine;corunning application bandwidth demands;performance interactions;performance variability effects;performance variation modeling;phase-aware isolation;shared cache contention;Bandwidth;Benchmark testing;Data models;Hardware;Interference;Phase detection;Vectors}, \ndoi={10.1109/HPCA.2013.6522315}, \nISSN={1530-0897},}\n\n@ARTICLE{1528455, \nauthor={Isci, C. and Buyuktosunoglu, A. and Martonosi, M.}, \njournal={Micro, IEEE}, \ntitle={Long-term workload phases: duration predictions and applications to DVFS}, \nyear={2005}, \nmonth={Sept}, \nvolume={25}, \nnumber={5}, \npages={39-51}, \nkeywords={resource allocation;system monitoring;DVFS;adaptive dynamic management;computer systems;duration predictions;hardware performance counters;long-term workload phases;server-class systems;system response prediction;workload behavior prediction;Adaptive systems;Benchmark testing;Costs;Dynamic voltage scaling;Extrapolation;Frequency;Large-scale systems;Load management;Prediction methods;Stability criteria;Adaptive dynamic management;DVFS;duration predictions;performance counters;prediction techniques;workload behavior}, \ndoi={10.1109/MM.2005.93}, \nISSN={0272-1732},}\n\n@INPROCEEDINGS{1238018, \nauthor={Duesterwald, E. and Torrellas, J. and Dwarkadas, S.}, \nbooktitle={Parallel Architectures and Compilation Techniques, 2003. PACT 2003. Proceedings. 12th International Conference on}, \ntitle={Characterizing and predicting program behavior and its variability}, \nyear={2003}, \nmonth={Sept}, \npages={220-231}, \nkeywords={adaptive systems;software metrics;system monitoring;SPECcpu 2000;adaptive systems;cross-metric predictors;hardware counters;instructions;microarchitectures;optimization;program time-varying behavior prediction;statistical predictors;table-based predictors;Adaptive systems;Aggregates;Application software;Computer architecture;Counting circuits;Energy efficiency;Hardware;Optimizing compilers;Resource management;Software systems}, \ndoi={10.1109/PACT.2003.1238018}, \nISSN={1089-795X},}\n\n@inproceedings{37124,\ntitle = {The Impact of Memory Subsystem Resource Sharing on Datacenter Applications},\nauthor  = {Lingjia Tang and Jason Mars and Neil Vachharajani and Robert Hundt and Mary-Lou Soffa},\nyear  = 2011,\nbooktitle = {ISCA}\n}\n\n@inproceedings{reqos,\nauthor = {Tang, Lingjia and Mars, Jason and Wang, Wei and Dey, Tanima and Soffa, Mary Lou},\ntitle = {ReQoS: Reactive Static/Dynamic Compilation for QoS in Warehouse Scale Computers},\nbooktitle = {Proceedings of the Eighteenth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS)},\nseries = {ASPLOS \'13},\nyear = {2013},\nisbn = {978-1-4503-1870-9},\nlocation = {Houston, Texas, USA},\npages = {89--100},\nnumpages = {12},\nurl = {http://doi.acm.org/10.1145/2451116.2451126},\ndoi = {10.1145/2451116.2451126},\nacmid = {2451126},\npublisher = {ACM},\naddress = {New York, NY, USA},\nkeywords = {compiler, contention, cross-core interference, datacenter, dynamic techniques, multicore, online adaptation, quality of service, runtime systems, warehouse scale computers},\nnote = {Acceptance Rate: 23%},\n}\n\n@inproceedings{mars13isca,\nauthor = {Mars, Jason and Tang, Lingjia},\ntitle = {Whare-map: Heterogeneity in "Homogeneous" Warehouse-scale Computers},\nbooktitle = {Proceedings of the 40th Annual International Symposium on Computer Architecture (ISCA)},\nseries = {ISCA \'13},\nyear = {2013},\nisbn = {978-1-4503-2079-5},\nlocation = {Tel-Aviv, Israel},\npages = {619--630},\nnumpages = {12},\nurl = {http://doi.acm.org/10.1145/2485922.2485975},\ndoi = {10.1145/2485922.2485975},\nacmid = {2485975},\npublisher = {ACM},\naddress = {New York, NY, USA},\nnote = {Acceptance Rate: 19% - Featured in Wired Magazine!},\n}\n@inproceedings{Govindan:2011:CQE:2038916.2038938,\n author = {Govindan, Sriram and Liu, Jie and Kansal, Aman and Sivasubramaniam, Anand},\n title = {Cuanta: Quantifying Effects of Shared On-chip Resource Interference for Consolidated Virtual Machines},\n booktitle = {Proceedings of the 2Nd ACM Symposium on Cloud Computing},\n series = {SOCC \'11},\n year = {2011},\n isbn = {978-1-4503-0976-9},\n location = {Cascais, Portugal},\n pages = {22:1--22:14},\n articleno = {22},\n numpages = {14},\n url = {http://doi.acm.org/10.1145/2038916.2038938},\n doi = {10.1145/2038916.2038938},\n acmid = {2038938},\n publisher = {ACM},\n address = {New York, NY, USA},\n keywords = {cache pressure clone, last-level cache, memory subsystem interference, performance estimation, resource contention, workload consolidation},\n} \n\n@inproceedings{Bellard:2005:QFP:1247360.1247401,\n author = {Bellard, Fabrice},\n title = {QEMU, a Fast and Portable Dynamic Translator},\n booktitle = {Proceedings of the Annual Conference on USENIX Annual Technical Conference},\n series = {ATEC \'05},\n year = {2005},\n location = {Anaheim, CA},\n pages = {41--41},\n numpages = {1},\n url = {http://dl.acm.org/citation.cfm?id=1247360.1247401},\n acmid = {1247401},\n publisher = {USENIX Association},\n address = {Berkeley, CA, USA},\n} \n\n\n@misc{amazon,\nannote = {$\\backslash$url\\{http://aws.amazon.com/ec2\\}},\nauthor = {{Amazon Inc.}},\nmonth = nov,\npublisher = {Amazon},\ntitle = {{Elastic Compute Cloud}},\nyear = {2008}\n}\n\n@INPROCEEDINGS{6621127, \nauthor={Gupta, A. and Sampson, J. and Taylor, M.B.}, \nbooktitle={Embedded Computer Systems: Architectures, Modeling, and Simulation (SAMOS XIII), 2013 International Conference on}, \ntitle={TimeCube: A manycore embedded processor with interference-agnostic progress tracking}, \nyear={2013}, \nmonth={July}, \npages={227-236}, \nkeywords={cloud computing;embedded systems;interference;microprocessor chips;multiprocessing systems;resource allocation;48-core SCC;CPU-time decorrelation;Progress Time;Tilera Tile Gx100;TimeCube processor;cloud services;dynamic execution isolation;embedded computing;interference-agnostic progress tracking;low-power embedded processors;manycore chips;manycore embedded processor;microarchitectural resources;microarchitectural structures;multicore processors;online architectural resource management;shadow performance modeling;space-multiplexed systems;throughput improvement;Bandwidth;Channel allocation;Embedded systems;Interference;Prefetching;Random access memory;Resource management}, \ndoi={10.1109/SAMOS.2013.6621127},}\n\n@inproceedings{Solihin:1999:SPQ:331532.331549,\n author = {Solihin, Yan and Lam, Vinh and Torrellas, Josep},\n title = {Scal-Tool: Pinpointing and Quantifying Scalability Bottlenecks in DSM Multiprocessors},\n booktitle = {Proceedings of the 1999 ACM/IEEE Conference on Supercomputing},\n series = {SC \'99},\n year = {1999},\n isbn = {1-58113-091-0},\n location = {Portland, Oregon, USA},\n articleno = {17},\n url = {http://doi.acm.org/10.1145/331532.331549},\n doi = {10.1145/331532.331549},\n acmid = {331549},\n publisher = {ACM},\n address = {New York, NY, USA},\n} \n\n@article{Zhuravlev:2010:ASR:1735971.1736036,\n author = {Zhuravlev, Sergey and Blagodurov, Sergey and Fedorova, Alexandra},\n title = {Addressing Shared Resource Contention in Multicore Processors via Scheduling},\n journal = {SIGPLAN Not.},\n issue_date = {March 2010},\n volume = {45},\n number = {3},\n month = mar,\n year = {2010},\n issn = {0362-1340},\n pages = {129--142},\n numpages = {14},\n url = {http://doi.acm.org/10.1145/1735971.1736036},\n doi = {10.1145/1735971.1736036},\n acmid = {1736036},\n publisher = {ACM},\n address = {New York, NY, USA},\n keywords = {multicore processors, scheduling, shared resource contention},\n} \n\n@article{denew,\n  title={The New Linux?perf?Tools},\n  author={de Melo, Arnaldo Carvalho}\n}\n\n@inproceedings{Gupta_QualityTime_ISPASS_2014,\n\ttitle = {QualityTime: A Simple Online Technique for Quantifying Multicore Execution Efficiency },\n\tauthor = {Anshuman Gupta and Jack Sampson and Michael Bedford Taylor},\n booktitle = {ISPASS},\n\tyear = {2014}\n}\n\n@inproceedings{Zhuravlev:2010:ASR:1736020.1736036,\n author = {Zhuravlev, Sergey and Blagodurov, Sergey and Fedorova, Alexandra},\n title = {Addressing Shared Resource Contention in Multicore Processors via Scheduling},\n booktitle = {Proceedings of the Fifteenth Edition of ASPLOS on Architectural Support for Programming Languages and Operating Systems},\n series = {ASPLOS XV},\n year = {2010},\n isbn = {978-1-60558-839-1},\n location = {Pittsburgh, Pennsylvania, USA},\n pages = {129--142},\n numpages = {14},\n url = {http://doi.acm.org/10.1145/1736020.1736036},\n doi = {10.1145/1736020.1736036},\n acmid = {1736036},\n publisher = {ACM},\n address = {New York, NY, USA},\n keywords = {multicore processors, scheduling, shared resource contention},\n} \n\n@ARTICLE{6133267, \nauthor={Ki-Woong Park and Jaesun Han and JaeWoong Chung and Kyu Ho Park}, \njournal={Services Computing, IEEE Transactions on}, \ntitle={THEMIS: A Mutually Verifiable Billing System for the Cloud Computing Environment}, \nyear={2013}, \nmonth={July}, \nvolume={6}, \nnumber={3}, \npages={300-313}, \nkeywords={cloud computing;security of data;software performance evaluation;system monitoring;trusted computing;PKI;S-Mon;THEMIS billing transaction;TPM;cloud computing environment;cloud computing service;cloud notary authority;computational overhead;forgery-resistive SLA monitoring mechanism;iCubeCloud;nonobstructive billing system;performance evaluation;security capability;service level agreement monitoring;trusted platform module;verifiable billing system;Cloud computing;Computer architecture;Digital signatures;Grid computing;Monitoring;Protocols;Records;and resource allocation;pricing;transaction processing;verification}, \ndoi={10.1109/TSC.2012.1}, \nISSN={1939-1374},}\n\n@INPROCEEDINGS{5279594, \nauthor={Elmroth, E. and Marquez, F.G. and Henriksson, D. and Ferrera, D.P.}, \nbooktitle={Grid and Cooperative Computing, 2009. GCC \'09. Eighth International Conference on}, \ntitle={Accounting and Billing for Federated Cloud Infrastructures}, \nyear={2009}, \nmonth={Aug}, \npages={268-275}, \nkeywords={resource allocation;virtual machines;RESERVOIR project;data center;federated cloud computing infrastructure;postpaid payment scheme;prepaid payment scheme;resources-services virtualization;service level agreement;usage scenario;Cloud computing;Collaboration;Computer architecture;Grid computing;Reservoirs;Resource virtualization;Subcontracting;Technology management;Time factors;Virtual machining;RESERVOIR;SGAS;accounting;billing;cloud computing;grid computing}, \ndoi={10.1109/GCC.2009.37},}\n\n@article{Zhuravlev:2010:ASR:1735970.1736036,\n author = {Zhuravlev, Sergey and Blagodurov, Sergey and Fedorova, Alexandra},\n title = {Addressing Shared Resource Contention in Multicore Processors via Scheduling},\n journal = {SIGARCH Comput. Archit. News},\n issue_date = {March 2010},\n volume = {38},\n number = {1},\n month = mar,\n year = {2010},\n issn = {0163-5964},\n pages = {129--142},\n numpages = {14},\n url = {http://doi.acm.org/10.1145/1735970.1736036},\n doi = {10.1145/1735970.1736036},\n acmid = {1736036},\n publisher = {ACM},\n address = {New York, NY, USA},\n keywords = {multicore processors, scheduling, shared resource contention},\n} \n\n\n@inproceedings{bubbleup,\nauthor = {Mars, Jason and Tang, Lingjia and Hundt, Robert and Skadron, Kevin and Soffa, Mary Lou},\ntitle = {Bubble-Up: Increasing Utilization in Modern Warehouse Scale Computers via Sensible Co-locations},\nbooktitle = {Proceedings of the 44th Annual IEEE/ACM International Symposium on Microarchitecture (MICRO)},\nseries = {MICRO-44},\nyear = {2011},\nisbn = {978-1-4503-1053-6},\nlocation = {Porto Alegre, Brazil},\npages = {248--259},\nnumpages = {12},\nurl = {http://doi.acm.org/10.1145/2155620.2155650},\ndoi = {10.1145/2155620.2155650},\nacmid = {2155650},\npublisher = {ACM},\naddress = {New York, NY, USA},\nnote = {Acceptance Rate: 21% - Selected for IEEE MICRO TOP PICKS},\n}\n\n@article{fairpricing,\nauthor = {Alex D. Breslow and\nAnanta Tiwari and\nMartin Schulz and\nLaura Carrington and\nLingjia Tang and\nJason Mars},\ntitle = {Enabling fair pricing on high performance computer systems with node\nsharing},\njournal = {Scientific Programming},\nyear = {2014},\nvolume = {22},\nnumber = {2},\npages = {59--74},\nurl = {http://dx.doi.org/10.3233/SPR-140387},\ndoi = {10.3233/SPR-140387},\ntimestamp = {Fri, 05 Sep 2014 13:19:44 +0200},\nbiburl = {http://dblp.uni-trier.de/rec/bib/journals/sp/BreslowTSCTM14},\nbibsource = {dblp computer science bibliography, http://dblp.org}\n}\n\n@inproceedings{Isci:2006:LRP:1194816.1194851,\n author = {Isci, Canturk and Contreras, Gilberto and Martonosi, Margaret},\n title = {Live, Runtime Phase Monitoring and Prediction on Real Systems with Application to Dynamic Power Management},\n booktitle = {Proceedings of the 39th Annual IEEE/ACM International Symposium on Microarchitecture},\n series = {MICRO 39},\n year = {2006},\n isbn = {0-7695-2732-9},\n pages = {359--370},\n numpages = {12},\n url = {http://dx.doi.org/10.1109/MICRO.2006.30},\n doi = {10.1109/MICRO.2006.30},\n acmid = {1194851},\n publisher = {IEEE Computer Society},\n address = {Washington, DC, USA},\n} \n@INPROCEEDINGS{1598119, \nauthor={Isci, C. and Martonosi, M.}, \nbooktitle={High-Performance Computer Architecture, 2006. The Twelfth International Symposium on}, \ntitle={Phase characterization for power: evaluating control-flow-based and event-counter-based techniques}, \nyear={2006}, \nmonth={Feb}, \npages={121-132}, \nkeywords={benchmark testing;computer architecture;performance evaluation;power consumption;SPEC2000 benchmark;basic block vector;code-oriented technique;control-flow sampling;event counter;mainstream desktop application;performance counter;power consumption;power phase characterization;real-system power measurement;Counting circuits;Energy consumption;Hardware;Performance analysis;Phase measurement;Power measurement;Power system management;Runtime;Sampling methods;Software systems}, \ndoi={10.1109/HPCA.2006.1598119}, \nISSN={1530-0897},}\n\n@inproceedings{consen,\nauthor = {Tang, Lingjia and Mars, Jason and Soffa, Mary Lou},\ntitle = {Contentiousness vs. sensitivity: improving contention aware runtime systems on multicore architectures},\nbooktitle = {Proceedings of the 1st International Workshop on Adaptive Self-Tuning Computing Systems for the Exaflop Era (co-located with PLDI 2011)},\nyear = {2011},\nisbn = {978-1-4503-0708-6},\nlocation = {San Jose, California},\npages = {12--21},\nnumpages = {10},\nurl = {http://doi.acm.org/10.1145/2000417.2000419},\ndoi = {http://doi.acm.org/10.1145/2000417.2000419},\nacmid = {2000419},\npublisher = {ACM},\naddress = {New York, NY, USA},\nkeywords = {contention aware runtimes, contentiousness vs sensitivity, memory subsystems, multicore processors, scheduling},\n}\n\n\n'
p0
.I0
.S'Latex config'
p0
.S''
p0
.I4
.S'Style'
p0
.S''
p0
.I4
.S'couriers'
p0
.S"$style_file: couriers\n%%\n%% This is file `couriers.sty',\n%%\n% This program may be distributed and/or modified under the\n% conditions of the LaTeX Project Public License, either version 1.2\n% of this license or (at your option) any later version.\n% The latest version of this license is in\n%   http://www.latex-project.org/lppl.txt\n% and version 1.2 or later is part of all distributions of LaTeX\n% version 1999/12/01 or later.\n\\ProvidesPackage{couriers}\n[2004/07/10 Scaled Courier\n(HS)\n]\n\\RequirePackage{keyval}\n\\define@key{Cou}{scaled}[0.95]{%\n  \\def\\Cr@scale{#1}}\n\\def\\ProcessOptionsWithKV#1{%\n  \\let\\@tempc\\relax\n  \\let\\Cr@tempa\\@empty\n  \\@for\\CurrentOption:=\\@classoptionslist\\do{%\n    \\@ifundefined{KV@#1@\\CurrentOption}%\n    {}%\n    {\\edef\\Cr@tempa{\\Cr@tempa,\\CurrentOption,}}%\n  }%\n  \\edef\\Cr@tempa{%\n    \\noexpand\\setkeys{#1}{%\n      \\Cr@tempa\\@ptionlist{\\@currname.\\@currext}%\n    }%\n  }%\n  \\Cr@tempa\n}\n\\ProcessOptionsWithKV{Cou}\n\\AtEndOfPackage{%\n  \\let\\@unprocessedoptions\\relax\n}\n\\renewcommand{\\ttdefault}{pcrs}\n\\endinput\n%%\n%% End of file `couriers.sty'.\n"
p0
.I0
.S'etoolbox'
p0
.S"$style_file: etoolbox\n% $Id: etoolbox.sty,v 2.1 2011/01/03 19:14:10 lehman stable $\n\n% Copyright (c) 2007-2011 Philipp Lehman.\n%\n% Permission is granted to copy, distribute and/or modify this\n% software under the terms of the LaTeX Project Public License\n% (LPPL), version 1.3.\n%\n% The LPPL maintenance status of this software is\n% 'author-maintained'.\n%\n% This software is provided 'as is', without warranty of any kind,\n% either expressed or implied, including, but not limited to, the\n% implied warranties of merchantability and fitness for a\n% particular purpose.\n\n\\def\\etb@rcsid$#1: #2 #3 #4 #5${#4 v#3}\n\n\\NeedsTeXFormat{LaTeX2e}\n\\ProvidesPackage{etoolbox}\n[\\etb@rcsid $Id: etoolbox.sty,v 2.1 2011/01/03 19:14:10 lehman stable $\n e-TeX tools for LaTeX]\n\n\\begingroup\n\\@ifundefined{eTeXversion}\n  {\\PackageError{etoolbox}\n     {Not running under e-TeX}\n     {This package requires e-TeX. Try compiling the document\n      with\\MessageBreak 'elatex' instead of 'latex'. When using\n      pdfTeX, try 'pdfelatex'\\MessageBreak instead of 'pdflatex'.\n      This is a fatal error. I'm aborting now.}%\n   \\aftergroup\\endinput}\n  {}\n\\endgroup\n\n\\RequirePackage{etex}\n\n\\def\\etb@catcodes{\\do\\&\\do\\|\\do\\:\\do\\-\\do\\=\\do\\<\\do\\>}\n\\def\\do#1{\\catcode\\number`#1=\\the\\catcode`#1\\relax}\n\\edef\\etb@catcodes{\\etb@catcodes}\n\\let\\do\\noexpand\n\\AtEndOfPackage{\\etb@catcodes\\undef\\etb@catcodes}\n\n\\catcode`\\&=3\n\\catcode`\\|=3\n\\@makeother\\:\n\\@makeother\\-\n\\@makeother\\=\n\\@makeother\\<\n\\@makeother\\>\n\n\\protected\\def\\etb@error{\\PackageError{etoolbox}}\n\\protected\\def\\etb@warning{\\PackageWarning{etoolbox}}\n\\protected\\def\\etb@info{\\PackageInfo{etoolbox}}\n\\newcount\\etb@tempcnta\n\n% {<cstoken>}[<arguments>][<optarg default>]{<definition>}\n\n\\newcommand*{\\newrobustcmd}{}\n\\protected\\def\\newrobustcmd{\\@star@or@long\\etb@new@command}\n\n\\def\\etb@new@command#1{\\@testopt{\\etb@newcommand#1}0}\n\n\\def\\etb@newcommand#1[#2]{%\n  \\@ifnextchar[%]\n    {\\etb@xargdef#1[#2]}\n    {\\ifx\\l@ngrel@x\\relax\n       \\let\\l@ngrel@x\\protected\n     \\else\n       \\protected\\def\\l@ngrel@x{\\protected\\long}%\n     \\fi\n     \\@argdef#1[#2]}}\n\n\\long\\def\\etb@xargdef#1[#2][#3]#4{%\n  \\@ifdefinable#1{%\n    \\expandafter\\protected\n    \\expandafter\\def\n    \\expandafter#1%\n    \\expandafter{%\n      \\expandafter\\@testopt\n      \\csname\\string#1\\endcsname{#3}}%\n    \\expandafter\\@yargdef\\csname\\string#1\\endcsname\\tw@{#2}{#4}}}\n\n% {<cstoken>}[<arguments>][<optarg default>]{<definition>}\n\n\\newrobustcmd*{\\renewrobustcmd}{\\@star@or@long\\etb@renew@command}\n\n\\def\\etb@renew@command#1{%\n  \\ifundef{#1}\n     {\\etb@error{\\string#1 undefined}\\@ehc}\n     {}%\n  \\let\\@ifdefinable\\@rc@ifdefinable\n  \\etb@new@command#1}\n\n% {<cstoken>}[<arguments>][<optarg default>]{<definition>}\n\n\\newrobustcmd*{\\providerobustcmd}{\\@star@or@long\\etb@provide@command}\n\n\\def\\etb@provide@command#1{%\n  \\ifundef{#1}\n    {\\def\\reserved@a{\\etb@new@command#1}}\n    {\\def\\reserved@a{\\etb@renew@command\\reserved@a}}%\n  \\reserved@a}\n\n% {<csname>}\n\n\\newrobustcmd*{\\csshow}[1]{%\n  \\begingroup\\expandafter\\endgroup\n  \\expandafter\\show\\csname#1\\endcsname}\n\n% {<cstoken>}{<true>}{<false>}\n\n\\newcommand{\\ifdef}[1]{%\n  \\ifdefined#1%\n    \\expandafter\\@firstoftwo\n  \\else\n    \\expandafter\\@secondoftwo\n  \\fi}\n\n% {<cstoken>}{<true>}{<false>}\n\n\\newcommand{\\ifundef}[1]{%\n  \\ifdefined#1%\n    \\ifx#1\\relax\n      \\expandafter\\expandafter\n      \\expandafter\\@firstoftwo\n    \\else\n      \\expandafter\\expandafter\n      \\expandafter\\@secondoftwo\n    \\fi\n  \\else\n    \\expandafter\\@firstoftwo\n  \\fi}\n\n% {<csname>}{<true>}{<false>}\n\n\\newcommand*{\\ifcsdef}[1]{%\n  \\ifcsname#1\\endcsname\n    \\expandafter\\@firstoftwo\n  \\else\n    \\expandafter\\@secondoftwo\n  \\fi}\n\n% {<csname>}{<true>}{<false>}\n\n\\newcommand*{\\ifcsundef}[1]{%\n  \\ifcsname#1\\endcsname\n    \\expandafter\\ifx\\csname#1\\endcsname\\relax\n      \\expandafter\\expandafter\n      \\expandafter\\@firstoftwo\n    \\else\n      \\expandafter\\expandafter\n      \\expandafter\\@secondoftwo\n    \\fi\n  \\else\n    \\expandafter\\@firstoftwo\n  \\fi}\n\n% {<cstoken>}{<true}{<false>}\n\n\\newcommand{\\ifdefmacro}{}\n\\long\\edef\\ifdefmacro#1{%\n  \\noexpand\\expandafter\\noexpand\\etb@ifdefmacro\n  \\noexpand\\meaning#1\\detokenize{macro}:&}\n\\edef\\etb@ifdefmacro{%\n  \\def\\noexpand\\etb@ifdefmacro##1\\detokenize{macro}:##2&}\n\\etb@ifdefmacro{\\notblank{#2}}\n\n% {<csname>}{<true>}{<false>}\n\n\\newcommand*{\\ifcsmacro}[1]{%\n  \\ifcsdef{#1}\n    {\\expandafter\\ifdefmacro\\csname#1\\endcsname}\n    {\\@secondoftwo}}\n\n% {<cstoken>}{<true}{<false>}\n\n\\newcommand{\\ifdefprefix}[1]{%\n  \\ifdefmacro{#1}\n    {\\etb@ifdefprefix{#1}}\n    {\\@secondoftwo}}\n\\long\\edef\\etb@ifdefprefix#1{%\n  \\noexpand\\expandafter\\noexpand\\etb@ifdefprefix@i\n  \\noexpand\\meaning#1\\detokenize{macro}:&}\n\\edef\\etb@ifdefprefix@i{%\n  \\def\\noexpand\\etb@ifdefprefix@i##1\\detokenize{macro}:##2&}\n\\etb@ifdefprefix@i{\\notblank{#1}}\n\n% {<csname>}{<true>}{<false>}\n\n\\newcommand*{\\ifcsprefix}[1]{%\n  \\ifcsdef{#1}\n    {\\expandafter\\ifdefprefix\\csname#1\\endcsname}\n    {\\@secondoftwo}}\n\n% {<cstoken>}{<true}{<false>}\n\n\\newcommand{\\ifdefparam}{}\n\\long\\edef\\ifdefparam#1{%\n  \\noexpand\\expandafter\\noexpand\\etb@ifdefparam\n  \\noexpand\\meaning#1\\detokenize{macro}:->&}\n\\edef\\etb@ifdefparam{%\n  \\def\\noexpand\\etb@ifdefparam##1\\detokenize{macro}:##2->##3&}\n\\etb@ifdefparam{\\notblank{#2}}\n\n% {<csname>}{<true>}{<false>}\n\n\\newcommand*{\\ifcsparam}[1]{%\n  \\ifcsdef{#1}\n    {\\expandafter\\ifdefparam\\csname#1\\endcsname}\n    {\\@secondoftwo}}\n\n% {<cstoken>}{<true}{<false>}\n\n\\newcommand{\\ifdefprotected}{}\n\\long\\edef\\ifdefprotected#1{%\n  \\noexpand\\expandafter\\noexpand\\etb@ifdefprotected\n  \\noexpand\\meaning#1\\string\\protected&}\n\\edef\\etb@ifdefprotected{%\n  \\def\\noexpand\\etb@ifdefprotected##1\\string\\protected##2&}\n\\etb@ifdefprotected{\\notblank{#2}}\n\n% {<csname>}{<true>}{<false>}\n\n\\newcommand*{\\ifcsprotected}[1]{%\n  \\ifcsdef{#1}\n    {\\expandafter\\ifdefprotected\\csname#1\\endcsname}\n    {\\@secondoftwo}}\n\n% {<cstoken>}{<true}{<false>}\n\n\\newrobustcmd{\\ifdefltxprotect}[1]{%\n  \\begingroup\n  \\edef\\etb@resrvda{%\n    \\noexpand\\protect\\expandafter\\noexpand\n    \\csname\\expandafter\\@gobble\\string#1 \\endcsname}%\n  \\expandafter\\endgroup\\ifx#1\\etb@resrvda\n    \\expandafter\\@firstoftwo\n  \\else\n    \\expandafter\\@secondoftwo\n  \\fi}\n\n% {<csname>}{<true>}{<false>}\n\n\\newrobustcmd*{\\ifcsltxprotect}[1]{%\n  \\ifcsdef{#1}\n    {\\expandafter\\ifdefltxprotect\\csname#1\\endcsname}\n    {\\@secondoftwo}}\n\n% {<cstoken>}{<true>}{<false>}\n\n\\newcommand{\\ifdefempty}[1]{%\n  \\ifundef{#1}\n    {\\@secondoftwo}\n    {\\ifdefmacro{#1}\n       {\\ifdefparam{#1}\n\t  {\\@secondoftwo}\n\t  {\\etb@ifdefempty{#1}}}\n       {\\@secondoftwo}}}\n\n\\def\\etb@ifdefempty#1{%\n  \\expandafter\\expandafter\n  \\expandafter\\ifblank\n  \\expandafter\\expandafter\n  \\expandafter{%\n  \\expandafter\\strip@prefix\\meaning#1}}\n\n% {<csname>}{<true>}{<false>}\n\n\\newcommand*{\\ifcsempty}[1]{%\n  \\ifcsundef{#1}\n    {\\@secondoftwo}\n    {\\expandafter\\ifdefparam\\csname#1\\endcsname\n       {\\@secondoftwo}\n       {\\expandafter\\etb@ifdefempty\\csname#1\\endcsname}}}\n\n% {<cstoken>}{<true>}{<false>}\n\n\\newcommand{\\ifdefvoid}[1]{%\n  \\ifundef{#1}\n    {\\@firstoftwo}\n    {\\ifdefmacro{#1}\n       {\\ifdefparam{#1}\n\t  {\\@secondoftwo}\n\t  {\\etb@ifdefempty{#1}}}\n       {\\@secondoftwo}}}\n\n% {<csname>}{<true>}{<false>}\n\n\\newcommand*{\\ifcsvoid}[1]{%\n  \\ifcsundef{#1}\n    {\\@firstoftwo}\n    {\\expandafter\\ifdefparam\\csname#1\\endcsname\n       {\\@secondoftwo}\n       {\\expandafter\\etb@ifdefempty\\csname#1\\endcsname}}}\n\n% {<cstoken1>}{<cstoken2>}{<true>}{<false>}\n\n\\newcommand{\\ifdefequal}[2]{%\n  \\ifundef{#1}\n    {\\@secondoftwo}\n    {\\ifundef{#2}\n       {\\@secondoftwo}\n       {\\ifx#1#2%\n          \\expandafter\\@firstoftwo\n        \\else\n          \\expandafter\\@secondoftwo\n        \\fi}}}\n\n% {<csname1>}{<csname2>}{<true>}{<false>}\n\n\\newcommand*{\\ifcsequal}[2]{%\n  \\ifcsundef{#1}\n    {\\@secondoftwo}\n    {\\ifcsundef{#2}\n       {\\@secondoftwo}\n       {\\expandafter\\ifx\n        \\csname#1\\expandafter\\endcsname\n        \\csname#2\\endcsname\n          \\expandafter\\@firstoftwo\n        \\else\n          \\expandafter\\@secondoftwo\n        \\fi}}}\n\n% {<cstoken1>}{<cstoken2>}{<true>}{<false>}\n\n\\newrobustcmd{\\ifdefstrequal}[2]{%\n  \\ifdefmacro{#1}\n    {\\ifdefmacro{#2}\n       {\\begingroup\n\t\\edef\\etb@tempa{\\expandafter\\strip@prefix\\meaning#1}%\n\t\\edef\\etb@tempb{\\expandafter\\strip@prefix\\meaning#2}%\n\t\\ifx\\etb@tempa\\etb@tempb\n\t  \\aftergroup\\@firstoftwo\n\t\\else\n\t  \\aftergroup\\@secondoftwo\n\t\\fi\n\t\\endgroup}\n       {\\@secondoftwo}}\n    {\\@secondoftwo}}\n\n% {<csname1>}{<csname2>}{<true>}{<false>}\n\n\\newcommand*{\\ifcsstrequal}[2]{%\n  \\ifcsundef{#1}\n    {\\@secondoftwo}\n    {\\ifcsundef{#2}\n       {\\@secondoftwo}\n       {\\expandafter\\ifdefstrequal\n        \\csname#1\\expandafter\\endcsname\n\t\\csname#2\\endcsname}}}\n\n% {<cstoken>}{<string>}{<true>}{<false>}\n\n\\newrobustcmd{\\ifdefstring}[2]{%\n  \\ifdefmacro{#1}\n    {\\begingroup\n     \\edef\\etb@tempa{\\expandafter\\strip@prefix\\meaning#1}%\n     \\edef\\etb@tempb{\\detokenize{#2}}%\n     \\ifx\\etb@tempa\\etb@tempb\n       \\aftergroup\\@firstoftwo\n     \\else\n       \\aftergroup\\@secondoftwo\n     \\fi\n     \\endgroup}\n    {\\@secondoftwo}}\n\n% {<csname>}{<string>}{<true>}{<false>}\n\n\\newrobustcmd{\\ifcsstring}[2]{%\n  \\ifcsundef{#1}\n    {\\@secondoftwo}\n    {\\expandafter\\ifdefstring\\csname#1\\endcsname{#2}}}\n\n% {<cstoken>}{<true}{<false>}\n\n\\newcommand{\\ifdefcounter}[1]{\\etb@ifcounter#1&}\n\\long\\def\\etb@ifcounter#1#2&{%\n  \\ifx\\count#1%\n    \\expandafter\\@secondoftwo\n  \\else\n    \\expandafter\\etb@ifcounter@i\\meaning#1:%\n  \\fi}\n\\edef\\etb@ifcounter@i#1:#2\\fi{\\noexpand\\fi\n  \\noexpand\\etb@ifcounter@ii#1\\string\\count&}\n\\edef\\etb@ifcounter@ii{%\n  \\def\\noexpand\\etb@ifcounter@ii##1\\string\\count##2&}\n\\etb@ifcounter@ii{\\ifblank{#1}}\n\n% {<csname>}{<true>}{<false>}\n\n\\newcommand*{\\ifcscounter}[1]{%\n  \\ifcsdef{#1}\n    {\\expandafter\\ifdefcounter\\csname#1\\endcsname}\n    {\\@secondoftwo}}\n\n% {<name>}{<true>}{<false>}\n\n\\newcommand*{\\ifltxcounter}[1]{%\n  \\ifcsdef{c@#1}\n    {\\expandafter\\ifdefcounter\\csname c@#1\\endcsname}\n    {\\@secondoftwo}}\n\n% {<cstoken>}{<true}{<false>}\n\n\\newcommand{\\ifdeflength}[1]{\\etb@iflength#1&}\n\\long\\def\\etb@iflength#1#2&{%\n  \\ifx\\skip#1%\n    \\expandafter\\@secondoftwo\n  \\else\n    \\expandafter\\etb@iflength@i\\meaning#1:%\n  \\fi}\n\\edef\\etb@iflength@i#1:#2\\fi{\\noexpand\\fi\n  \\noexpand\\etb@iflength@ii#1\\string\\skip&}\n\\edef\\etb@iflength@ii{%\n  \\def\\noexpand\\etb@iflength@ii##1\\string\\skip##2&}\n\\etb@iflength@ii{\\ifblank{#1}}\n\n% {<csname>}{<true>}{<false>}\n\n\\newcommand*{\\ifcslength}[1]{%\n  \\ifcsdef{#1}\n    {\\expandafter\\ifdeflength\\csname#1\\endcsname}\n    {\\@secondoftwo}}\n\n% {<cstoken>}{<true}{<false>}\n\n\\newcommand{\\ifdefdimen}[1]{\\etb@ifdimen#1&}\n\\long\\def\\etb@ifdimen#1#2&{%\n  \\ifx\\dimen#1%\n    \\expandafter\\@secondoftwo\n  \\else\n    \\expandafter\\etb@ifdimen@i\\meaning#1:%\n  \\fi}\n\\edef\\etb@ifdimen@i#1:#2\\fi{\\noexpand\\fi\n  \\noexpand\\etb@ifdimen@ii#1\\string\\dimen&}\n\\edef\\etb@ifdimen@ii{%\n  \\def\\noexpand\\etb@ifdimen@ii##1\\string\\dimen##2&}\n\\etb@ifdimen@ii{\\ifblank{#1}}\n\n% {<csname>}{<true>}{<false>}\n\n\\newcommand*{\\ifcsdimen}[1]{%\n  \\ifcsdef{#1}\n    {\\expandafter\\ifdefdimen\\csname#1\\endcsname}\n    {\\@secondoftwo}}\n\n% {<string1>}{<string2>}{<true>}{<false>}\n\n\\newrobustcmd{\\ifstrequal}[2]{%\n  \\begingroup\n  \\edef\\etb@tempa{\\detokenize{#1}}%\n  \\edef\\etb@tempb{\\detokenize{#2}}%\n  \\ifx\\etb@tempa\\etb@tempb\n    \\aftergroup\\@firstoftwo\n  \\else\n    \\aftergroup\\@secondoftwo\n  \\fi\n  \\endgroup}\n\n% {<string>}{<true>}{<false>}\n\n\\newcommand{\\ifstrempty}[1]{%\n  \\expandafter\\ifx\\expandafter&\\detokenize{#1}&%\n    \\expandafter\\@firstoftwo\n  \\else\n    \\expandafter\\@secondoftwo\n  \\fi}\n\n% {<string>}{<true>}{<false>}\n\n\\newcommand{\\ifblank}[1]{% from url.sty\n  \\etb@ifblank@i#1&&\\@secondoftwo\\@firstoftwo:}\n\\long\\def\\etb@ifblank@i#1#2&#3#4#5:{#4}\n\n\\newcommand{\\notblank}[1]{%\n  \\etb@ifblank@i#1&&\\@firstoftwo\\@secondoftwo:}\n\n% {<numexpr>}{<comp>}{<numexpr>}{<true>}{<false>}\n\n\\newcommand*{\\ifnumcomp}[3]{%\n  \\ifnum\\numexpr#1\\relax#2\\numexpr#3\\relax\n    \\expandafter\\@firstoftwo\n  \\else\n    \\expandafter\\@secondoftwo\n  \\fi}\n\n% {<numexpr>}{<numexpr>}{<true>}{<false>}\n\n\\newcommand*{\\ifnumequal}[1]{%\n  \\ifnumcomp{#1}=}\n\n\\newcommand*{\\ifnumgreater}[1]{%\n  \\ifnumcomp{#1}>}\n\n\\newcommand*{\\ifnumless}[1]{%\n  \\ifnumcomp{#1}<}\n\n% {<numexpr>}{<true>}{<false>}\n\n\\newcommand*{\\ifnumodd}[1]{%\n  \\ifodd\\numexpr#1\\relax\n    \\expandafter\\@firstoftwo\n  \\else\n    \\expandafter\\@secondoftwo\n  \\fi}\n\n% {<dimexpr>}{<comp>}{<dimexpr>}{<true>}{<false>}\n\n\\newcommand*{\\ifdimcomp}[3]{%\n  \\ifdim\\dimexpr#1\\relax#2\\dimexpr#3\\relax\n    \\expandafter\\@firstoftwo\n  \\else\n    \\expandafter\\@secondoftwo\n  \\fi}\n\n% {<dimexpr>}{<dimexpr>}{<true>}{<false>}\n\n\\newcommand*{\\ifdimequal}[1]{%\n  \\ifdimcomp{#1}=}\n\n\\newcommand*{\\ifdimgreater}[1]{%\n  \\ifdimcomp{#1}>}\n\n\\newcommand*{\\ifdimless}[1]{%\n  \\ifdimcomp{#1}<}\n\n% {<expr>}{<true>}{<false>}\n\n\\newcommand{\\ifboolexpe}[1]{%\n  \\etb@be@beg\\etb@be@bgroup#1(&\\etb@be@end}\n\n\\let\\etb@be@true\\@empty\n\\def\\etb@be@false{-\\@ne}\n\n\\def\\etb@be@beg{%\n  \\ifnum\\numexpr\\z@\\ifnum\\numexpr\\z@}\n\n\\def\\etb@be@end{%\n  <\\z@\n    \\expandafter\\etb@be@false\n  \\fi\n  <\\z@\n    \\expandafter\\@secondoftwo\n  \\else\n    \\expandafter\\@firstoftwo\n  \\fi}\n\n\\long\\def\\etb@be@bgroup#1(#2&{%\n  \\etb@be@egroup#1)&%\n  \\ifblank{#2}\n    {}\n    {\\etb@be@beg\n     \\etb@be@bgroup#2&}}\n\n\\long\\def\\etb@be@egroup#1)#2&{%\n  \\etb@be@and#1and&%\n  \\ifblank{#2}\n    {}\n    {\\etb@be@end\\etb@be@true\\etb@be@false\n     \\etb@be@egroup#2&}}\n\n\\long\\def\\etb@be@and#1and#2&{%\n  \\etb@be@or#1or&%\n  \\ifblank{#2}\n    {}\n    {<\\z@\n       \\expandafter\\@firstofone\n     \\else\n       \\expandafter\\@gobble\n     \\fi\n     {=\\z@\\fi\\ifnum\\numexpr\\m@ne}%\n     \\ifnum\\numexpr\\z@\n     \\etb@be@and#2&}}\n\n\\long\\def\\etb@be@or#1or#2&{%\n  \\etb@be@not#1not&%\n  \\ifblank{#2}\n    {}\n    {<\\z@\n       \\expandafter\\@secondoftwo\n     \\else\n       \\expandafter\\@firstoftwo\n     \\fi\n     {=\\z@\\fi\\ifnum\\numexpr\\z@\n      \\ifnum\\numexpr\\@ne}\n     {=\\z@\\fi\\ifnum\\numexpr\\z@\n      \\ifnum\\numexpr\\z@}%\n     \\etb@be@or#2&}}\n\n\\long\\def\\etb@be@not#1not#2&{%\n  \\etb@be@togl#1togl&%\n  \\ifblank{#2}\n    {}\n    {>\\z@\n       \\expandafter\\@firstoftwo\n     \\else\n       \\expandafter\\@secondoftwo\n     \\fi\n     {\\unless\\ifnum\\numexpr\\m@ne}\n     {\\unless\\ifnum\\numexpr\\z@}%\n     \\etb@be@not#2&}}\n\n\\long\\def\\etb@be@togl#1togl#2&{%\n  \\etb@be@bool#1bool&%\n  \\ifblank{#2}\n    {}\n    {\\etb@be@togl@i#2&}}\n\n\\long\\def\\etb@be@togl@i#1#2&{%\n  \\ifcsdef{etb@tgl@#1}\n    {\\csname etb@tgl@#1\\endcsname\\etb@be@true\\etb@be@false}\n    {\\etb@be@err{Toggle '#1' undefined}{}}%\n  \\etb@be@togl#2&}\n\n\\long\\def\\etb@be@bool#1bool#2&{%\n  \\etb@be@test#1test&%\n  \\ifblank{#2}\n    {}\n    {\\etb@be@bool@i#2&}}\n\n\\long\\def\\etb@be@bool@i#1#2&{%\n  \\ifcsundef{if#1}\n    {\\etb@be@err{Boolean '#1' undefined}{}}\n    {\\csname if#1\\endcsname\n     \\else\n       \\etb@be@false\n     \\fi}%\n  \\etb@be@bool#2&}\n\n\\long\\def\\etb@be@test#1test#2&{%\n  \\ifblank{#1}\n    {}\n    {\\etb@be@err{The invalid part is: '\\detokenize{#1}'}{}}%\n  \\ifblank{#2}\n    {}\n    {\\etb@be@test@i#2&}}\n\n\\long\\def\\etb@be@test@i#1#2&{%\n  #1\\etb@be@true\\etb@be@false\n  \\etb@be@test#2&}\n\n\\long\\def\\etb@be@err#1#2{%\n  \\expandafter\\ifnum\\the\\numexpr\n    \\expandafter\\ifnum\\the\\currentiftype=-3\n      \\expandafter\\thr@@\n    \\else\n      \\expandafter\\currentiftype\n    \\fi\n  =\\thr@@\n    \\expandafter\\@firstoftwo\n  \\else\n    \\expandafter\\@secondoftwo\n  \\fi\n  {=\\z@\\fi\n   \\etb@be@err{#1}{#2\\ifnum\\numexpr\\m@ne}}\n  {\\etb@err@expr{#1}#2}}\n\n% {<expr>}{<true>}{<false>}\n\n\\newrobustcmd{\\ifboolexpr}[1]{\\etb@boolexpr{#1}}\n\n\\long\\def\\etb@boolexpr#1{%\n  \\begingroup\n  \\let\\etb@br@neg\\@firstoftwo\n  \\etb@tempcnta\\z@\n  \\etb@br@beg\n  \\etb@br@bgroup#1(&%\n  \\etb@br@end\n  \\etb@br@eval}\n\n\\def\\etb@br@beg{%\n  \\begingroup\n  \\let\\etb@br@neg\\@firstoftwo\n  \\etb@tempcnta\\z@}\n\n\\def\\etb@br@end{%\n  \\etb@br@eval\\etb@br@true\\etb@br@false}\n\n\\def\\etb@br@eval{%\n  \\ifnum\\etb@tempcnta<\\z@\n    \\aftergroup\\@secondoftwo\n  \\else\n    \\aftergroup\\@firstoftwo\n  \\fi\n  \\endgroup}\n\n\\def\\etb@br@true{%\n  \\advance\\etb@tempcnta\\etb@br@neg\\z@\\m@ne\n  \\let\\etb@br@neg\\@firstoftwo}\n\n\\def\\etb@br@false{%\n  \\advance\\etb@tempcnta\\etb@br@neg\\m@ne\\z@\n  \\let\\etb@br@neg\\@firstoftwo}\n\n\\long\\def\\etb@br@bgroup#1(#2&{%\n  \\etb@br@egroup#1)&%\n  \\ifblank{#2}\n    {}\n    {\\etb@br@beg\n     \\etb@br@bgroup#2&}}\n\n\\long\\def\\etb@br@egroup#1)#2&{%\n  \\etb@br@and#1and&%\n  \\ifblank{#2}\n    {}\n    {\\etb@br@end\n     \\etb@br@egroup#2&}}\n\n\\long\\def\\etb@br@and#1and#2&{%\n  \\etb@br@or#1or&%\n  \\ifblank{#2}\n    {}\n    {\\ifnum\\etb@tempcnta<\\z@\n       \\etb@tempcnta\\m@ne\n     \\else\n       \\etb@tempcnta\\z@\n     \\fi\n     \\etb@br@and#2&}}\n\n\\long\\def\\etb@br@or#1or#2&{%\n  \\etb@br@not#1not&%\n  \\ifblank{#2}\n    {}\n    {\\ifnum\\etb@tempcnta<\\z@\n       \\etb@tempcnta\\z@\n     \\else\n       \\etb@tempcnta\\@ne\n     \\fi\n     \\etb@br@or#2&}}\n\n\\long\\def\\etb@br@not#1not#2&{%\n  \\etb@br@togl#1togl&%\n  \\ifblank{#2}\n    {}\n    {\\let\\etb@br@neg\\@secondoftwo\n     \\etb@br@not#2&}}\n\n\\long\\def\\etb@br@togl#1togl#2&{%\n  \\etb@br@bool#1bool&%\n  \\ifblank{#2}\n    {}\n    {\\etb@br@togl@i#2&}}\n\n\\long\\def\\etb@br@togl@i#1#2&{%\n  \\ifcsdef{etb@tgl@#1}\n    {\\csname etb@tgl@#1\\endcsname\\etb@br@true\\etb@br@false}\n    {\\etb@err@expr{Toggle '#1' undefined}\\etb@br@false}%\n  \\etb@br@togl#2&}\n\n\\long\\def\\etb@br@bool#1bool#2&{%\n  \\etb@br@test#1test&%\n  \\ifblank{#2}\n    {}\n    {\\etb@br@bool@i#2&}}\n\n\\long\\def\\etb@br@bool@i#1#2&{%\n  \\ifcsundef{if#1}\n    {\\etb@err@expr{Boolean '#1' undefined}\\etb@br@false}\n    {\\csname if#1\\endcsname\n       \\etb@br@true\n     \\else\n       \\etb@br@false\n     \\fi}%\n  \\etb@br@bool#2&}\n\n\\long\\def\\etb@br@test#1test#2&{%\n  \\ifblank{#1}\n    {}\n    {\\etb@err@expr{The invalid part is: '\\detokenize{#1}'}}%\n  \\ifblank{#2}\n    {}\n    {\\etb@br@test@i#2&}}\n\n\\long\\def\\etb@br@test@i#1#2&{%\n  \\ignorespaces#1\\etb@br@true\\etb@br@false\n  \\etb@br@test#2&}\n\n\\long\\def\\etb@err@expr#1{%\n  \\etb@error\n    {Invalid boolean expression}\n    {#1.}}\n\n% {<expr>}{<code>}\n\n\\newrobustcmd{\\whileboolexpr}[2]{%\n  \\etb@boolexpr{#1}{#2\\whileboolexpr{#1}{#2}}{}}\n\n% {<expr>}{<code>}\n\n\\newrobustcmd{\\unlessboolexpr}[2]{%\n  \\etb@boolexpr{#1}{}{#2\\unlessboolexpr{#1}{#2}}}\n\n% {<cstoken>}\n\n\\newcommand{\\expandonce}[1]{%\n  \\unexpanded\\expandafter{#1}}\n\n% {<csname>}\n\n\\newcommand*{\\csexpandonce}[1]{%\n  \\expandafter\\expandonce\\csname#1\\endcsname}\n\n% {<code>}\n\n\\newcommand*{\\protecting}{}\n\\def\\protecting#{%\n  \\ifx\\protect\\@typeset@protect\n    \\etb@protecting\\@firstofone\n  \\fi\n  \\ifx\\protect\\@unexpandable@protect\n    \\etb@protecting\\etb@unexpandable\n  \\fi\n  \\ifx\\protect\\noexpand\n    \\etb@protecting\\unexpanded\n  \\fi\n  \\ifx\\protect\\string\n    \\etb@protecting\\detokenize\n  \\fi\n  \\relax\\@firstofone}\n\n\\def\\etb@protecting#1#2\\relax\\@firstofone{\\fi#1}\n\\long\\def\\etb@unexpandable#1{\\unexpanded{\\protecting{#1}}}\n\n% {<csname>}\n\n\\newrobustcmd*{\\csdef}[1]{\\expandafter\\def\\csname#1\\endcsname}\n\\newrobustcmd*{\\csedef}[1]{\\expandafter\\edef\\csname#1\\endcsname}\n\\newrobustcmd*{\\csgdef}[1]{\\expandafter\\gdef\\csname#1\\endcsname}\n\\newrobustcmd*{\\csxdef}[1]{\\expandafter\\xdef\\csname#1\\endcsname}\n\\newrobustcmd*{\\protected@csedef}{\\etb@protected\\csedef}\n\\newrobustcmd*{\\protected@csxdef}{\\etb@protected\\csxdef}\n\n\\def\\etb@protected{%\n  \\let\\@@protect\\protect\n  \\let\\protect\\@unexpandable@protect\n  \\afterassignment\\restore@protect}\n\n% {<csname>}{<cstoken>}\n\n\\newrobustcmd{\\cslet}[2]{%\n  \\expandafter\\let\\csname#1\\endcsname#2}\n\n% {<cstoken>}{<csname>}\n\n\\newrobustcmd{\\letcs}[2]{%\n  \\ifcsdef{#2}\n    {\\expandafter\\let\\expandafter#1\\csname#2\\endcsname}\n    {\\undef#1}}\n\n% {<csname>}{<csname>}\n\n\\newrobustcmd*{\\csletcs}[2]{%\n  \\ifcsdef{#2}\n    {\\expandafter\\let\n     \\csname#1\\expandafter\\endcsname\n     \\csname#2\\endcsname}\n    {\\csundef{#1}}}\n\n% {<csname>}\n\n\\newcommand*{\\csuse}[1]{%\n  \\ifcsname#1\\endcsname\n    \\csname#1\\expandafter\\endcsname\n  \\fi}\n\n% {<cstoken>}\n\n\\newrobustcmd{\\undef}[1]{\\let#1\\etb@undefined}\n\n% {<csname>}\n\n\\newrobustcmd*{\\csundef}[1]{\\cslet{#1}\\etb@undefined}\n\n% {<cstoken>}{<code>}\n\n\\newrobustcmd{\\appto}[2]{%\n  \\ifundef{#1}\n    {\\edef#1{\\unexpanded{#2}}}\n    {\\edef#1{\\expandonce#1\\unexpanded{#2}}}}\n\\newrobustcmd{\\eappto}[2]{%\n  \\ifundef{#1}\n    {\\edef#1{#2}}\n    {\\edef#1{\\expandonce#1#2}}}\n\\newrobustcmd{\\gappto}[2]{%\n  \\ifundef{#1}\n    {\\xdef#1{\\unexpanded{#2}}}\n    {\\xdef#1{\\expandonce#1\\unexpanded{#2}}}}\n\\newrobustcmd{\\xappto}[2]{%\n  \\ifundef{#1}\n    {\\xdef#1{#2}}\n    {\\xdef#1{\\expandonce#1#2}}}\n\n\\newrobustcmd*{\\protected@eappto}{\\etb@protected\\eappto}\n\\newrobustcmd*{\\protected@xappto}{\\etb@protected\\xappto}\n\n% {<cstoken>}{<code>}\n\n\\newrobustcmd{\\preto}[2]{%\n  \\ifundef{#1}\n    {\\edef#1{\\unexpanded{#2}}}\n    {\\edef#1{\\unexpanded{#2}\\expandonce#1}}}\n\\newrobustcmd{\\epreto}[2]{%\n  \\ifundef{#1}\n    {\\edef#1{#2}}\n    {\\edef#1{#2\\expandonce#1}}}\n\\newrobustcmd{\\gpreto}[2]{%\n  \\ifundef{#1}\n    {\\xdef#1{\\unexpanded{#2}}}\n    {\\xdef#1{\\unexpanded{#2}\\expandonce#1}}}\n\\newrobustcmd{\\xpreto}[2]{%\n  \\ifundef{#1}\n    {\\xdef#1{#2}}\n    {\\xdef#1{#2\\expandonce#1}}}\n\n\\newrobustcmd*{\\protected@epreto}{\\etb@protected\\epreto}\n\\newrobustcmd*{\\protected@xpreto}{\\etb@protected\\xpreto}\n\n% {<csname>}{<code>}\n\n\\newrobustcmd*{\\csappto}[1]{\\expandafter\\appto\\csname#1\\endcsname}\n\\newrobustcmd*{\\cseappto}[1]{\\expandafter\\eappto\\csname#1\\endcsname}\n\\newrobustcmd*{\\csgappto}[1]{\\expandafter\\gappto\\csname#1\\endcsname}\n\\newrobustcmd*{\\csxappto}[1]{\\expandafter\\xappto\\csname#1\\endcsname}\n\\newrobustcmd*{\\protected@cseappto}{\\etb@protected\\cseappto}\n\\newrobustcmd*{\\protected@csxappto}{\\etb@protected\\csxappto}\n\n% {<csname>}{<code>}\n\n\\newrobustcmd*{\\cspreto}[1]{\\expandafter\\preto\\csname#1\\endcsname}\n\\newrobustcmd*{\\csepreto}[1]{\\expandafter\\epreto\\csname#1\\endcsname}\n\\newrobustcmd*{\\csgpreto}[1]{\\expandafter\\gpreto\\csname#1\\endcsname}\n\\newrobustcmd*{\\csxpreto}[1]{\\expandafter\\xpreto\\csname#1\\endcsname}\n\\newrobustcmd*{\\protected@csepreto}{\\etb@protected\\csepreto}\n\\newrobustcmd*{\\protected@csxpreto}{\\etb@protected\\csxpreto}\n\n% {<cstoken>}{<numexpr>}\n\n\\newrobustcmd*{\\numdef}[2]{%\n  \\ifundef#1{\\let#1\\z@}{}%\n  \\edef#1{\\the\\numexpr#2}}\n\\newrobustcmd*{\\numgdef}[2]{%\n  \\ifundef#1{\\let#1\\z@}{}%\n  \\xdef#1{\\the\\numexpr#2}}\n\n% {<csname>}{<numexpr>}\n\n\\newrobustcmd*{\\csnumdef}[1]{%\n  \\expandafter\\numdef\\csname#1\\endcsname}\n\\newrobustcmd*{\\csnumgdef}[1]{%\n  \\expandafter\\numgdef\\csname#1\\endcsname}\n\n% {<cstoken>}{<dimexpr>}\n\n\\newrobustcmd*{\\dimdef}[2]{%\n  \\ifundef#1{\\let#1\\z@}{}%\n  \\edef#1{\\the\\dimexpr#2}}\n\\newrobustcmd*{\\dimgdef}[2]{%\n  \\ifundef#1{\\let#1\\z@}{}%\n  \\xdef#1{\\the\\dimexpr#2}}\n\n% {<csname>}{<dimexpr>}\n\n\\newrobustcmd*{\\csdimdef}[1]{%\n  \\expandafter\\dimdef\\csname#1\\endcsname}\n\\newrobustcmd*{\\csdimgdef}[1]{%\n  \\expandafter\\dimgdef\\csname#1\\endcsname}\n\n% {<cstoken>}{<glueexpr>}\n\n\\newrobustcmd*{\\gluedef}[2]{%\n  \\ifundef#1{\\let#1\\z@skip}{}%\n  \\edef#1{\\the\\glueexpr#2}}\n\\newrobustcmd*{\\gluegdef}[2]{%\n  \\ifundef#1{\\let#1\\z@skip}{}%\n  \\xdef#1{\\the\\glueexpr#2}}\n\n% {<csname>}{<glueexpr>}\n\n\\newrobustcmd*{\\csgluedef}[1]{%\n  \\expandafter\\gluedef\\csname#1\\endcsname}\n\\newrobustcmd*{\\csgluegdef}[1]{%\n  \\expandafter\\gluegdef\\csname#1\\endcsname}\n\n% {<cstoken>}{<muexpr>}\n\n\\newrobustcmd*{\\mudef}[2]{%\n  \\ifundef#1{\\def#1{0mu}}{}%\n  \\edef#1{\\the\\muexpr#2}}\n\\newrobustcmd*{\\mugdef}[2]{%\n  \\ifundef#1{\\let#1\\z@}{}%\n  \\xdef#1{\\the\\muexpr#2}}\n\n% {<csname>}{<muexpr>}\n\n\\newrobustcmd*{\\csmudef}[1]{%\n  \\expandafter\\mudef\\csname#1\\endcsname}\n\\newrobustcmd*{\\csmugdef}[1]{%\n  \\expandafter\\mugdef\\csname#1\\endcsname}\n\n% {<counter>}{<numexpr>}\n\n\\newrobustcmd*{\\defcounter}[2]{%\n  \\ifcsundef{c@#1}\n    {\\etb@noglobal\\@nocounterr{#1}}%\n    {\\csname c@#1\\endcsname\\numexpr#2\\relax}}\n\n% {<length>}{<glueexpr>}\n\n\\newrobustcmd*{\\deflength}[2]{%\n  \\ifundef{#1}\n    {\\etb@noglobal\\etb@err@nolen{#1}}%\n    {#1\\glueexpr#2\\relax}}\n\n\\protected\\def\\etb@err@nolen#1{%\n  \\etb@error{Length '\\string#1' undefined}\\@eha}\n\n% {<name>}\n\n\\newrobustcmd*{\\newbool}[1]{%\n  \\expandafter\\@ifdefinable\\csname if#1\\endcsname{%\n    \\expandafter\\newif\\csname if#1\\endcsname}}\n\n% {<name>}\n\n\\newrobustcmd*{\\providebool}[1]{%\n  \\ifcsundef{if#1}\n    {\\expandafter\\newif\\csname if#1\\endcsname}\n    {\\begingroup\n     \\edef\\@tempa{\\expandafter\\meaning\\csname if#1\\endcsname}%\n     \\ifx\\@tempa\\etb@isfalse\n     \\else\n       \\ifx\\@tempa\\etb@istrue\n       \\else\n         \\etb@error{\\@backslashchar if#1 not a boolean}\\@eha\n       \\fi\n     \\fi\n     \\endgroup}}\n\n% {<name>}{<true>|<false>}\n\n\\newrobustcmd*{\\setbool}[2]{%\n  \\ifcsundef{if#1}\n    {\\etb@noglobal\\etb@err@nobool{#1}}\n    {\\ifcsundef{#1#2}\n       {\\etb@noglobal\\etb@err@boolval{#2}}\n       {\\csname#1#2\\endcsname}}}\n\n% {<name>}\n\n\\newrobustcmd*{\\booltrue}[1]{%\n  \\ifcsundef{if#1}\n    {\\etb@noglobal\\etb@err@nobool{#1}}\n    {\\csname#1true\\endcsname}}\n\n% {<name>}\n\n\\newrobustcmd*{\\boolfalse}[1]{%\n  \\ifcsundef{if#1}\n    {\\etb@noglobal\\etb@err@nobool{#1}}\n    {\\csname#1false\\endcsname}}\n\n\\edef\\etb@istrue{\\meaning\\iftrue}\n\\edef\\etb@isfalse{\\meaning\\iffalse}\n\\protected\\def\\etb@noglobal{\\let\\relax\\relax}\n\n% {<name>}{<true}{<false>}\n\n\\newcommand*{\\ifbool}[1]{%\n  \\ifcsundef{if#1}\n    {\\etb@err@nobool{#1}\\@gobbletwo}\n    {\\csname if#1\\endcsname\n       \\expandafter\\@firstoftwo\n     \\else\n       \\expandafter\\@secondoftwo\n     \\fi}}\n\n% {<name>}{<not true}{<not false>}\n\n\\newcommand*{\\notbool}[1]{%\n  \\ifcsundef{if#1}\n    {\\etb@err@nobool{#1}\\@gobbletwo}\n    {\\csname if#1\\endcsname\n       \\expandafter\\@secondoftwo\n     \\else\n       \\expandafter\\@firstoftwo\n     \\fi}}\n\n\\protected\\def\\etb@err@nobool#1{%\n  \\etb@error{Boolean '\\@backslashchar if#1' undefined}\\@eha}\n\n\\def\\etb@err@boolval#1{%\n  \\etb@error\n    {Invalid boolean value '#1'}\n    {Valid boolean values are 'true' and 'false'.}}\n\n% {<name>}\n\n\\newrobustcmd*{\\newtoggle}[1]{%\n  \\ifcsdef{etb@tgl@#1}\n    {\\etb@error{Toggle '#1' already defined}\\@eha}\n    {\\cslet{etb@tgl@#1}\\@secondoftwo}}\n\n% {<name>}\n\n\\newrobustcmd*{\\providetoggle}[1]{%\n  \\ifcsdef{etb@tgl@#1}\n    {}\n    {\\cslet{etb@tgl@#1}\\@secondoftwo}}\n\n% {<name>}{<true>|<false>}\n\n\\newrobustcmd*{\\settoggle}[2]{%\n  \\ifcsdef{etb@tgl@#1}\n    {\\ifcsdef{etb@toggle#2}\n       {\\csletcs{etb@tgl@#1}{etb@toggle#2}}\n       {\\etb@noglobal\\etb@err@boolval{#2}}}\n    {\\etb@noglobal\\etb@err@notoggle{#1}}}\n\n% {<name>}\n\n\\newrobustcmd*{\\toggletrue}[1]{%\n  \\ifcsdef{etb@tgl@#1}\n    {\\cslet{etb@tgl@#1}\\etb@toggletrue}\n    {\\etb@noglobal\\etb@err@notoggle{#1}}}\n\n% {<name>}\n\n\\newrobustcmd*{\\togglefalse}[1]{%\n  \\ifcsdef{etb@tgl@#1}\n    {\\cslet{etb@tgl@#1}\\etb@togglefalse}\n    {\\etb@noglobal\\etb@err@notoggle{#1}}}\n\n\\let\\etb@toggletrue\\@firstoftwo\n\\let\\etb@togglefalse\\@secondoftwo\n\n% {<name>}{<true}{<false>}\n\n\\newcommand*{\\iftoggle}[1]{%\n  \\ifcsdef{etb@tgl@#1}\n    {\\csname etb@tgl@#1\\endcsname}\n    {\\etb@err@notoggle{#1}\\@gobbletwo}}\n\n% {<name>}{<not true}{<not false>}\n\n\\newcommand*{\\nottoggle}[1]{%\n  \\ifcsdef{etb@tgl@#1}\n    {\\csname etb@tgl@#1\\endcsname\\@secondoftwo\\@firstoftwo}\n    {\\etb@err@notoggle{#1}\\@gobbletwo}}\n\n\\protected\\def\\etb@err@notoggle#1{%\n  \\etb@error{Toggle '#1' undefined}\\@eha}\n\n% {<cstoken>}{<true}{<false>}\n\n\\protected\\def\\etb@ifscanable#1{%\n  \\begingroup\n  \\edef\\etb@resrvda{%\n    \\def\\noexpand\\etb@resrvda####1\\detokenize{macro}:####2->####3&{%\n      ####1\\def\\string\\etb@resrvda####2{####3}}%\n    \\edef\\noexpand\\etb@resrvda{\\noexpand\\etb@resrvda\\meaning#1&}}%\n  \\etb@resrvda\n  \\makeatletter\n  \\scantokens\\expandafter{\\etb@resrvda}%\n  \\expandafter\\endgroup\\ifx#1\\etb@resrvda\n    \\expandafter\\@firstoftwo\n  \\else\n    \\expandafter\\@secondoftwo\n  \\fi}\n\n% {<cstoken>}{<search>}{<true}{<false>}\n\n\\protected\\long\\def\\etb@ifpattern#1#2{%\n  \\begingroup\n  \\edef\\etb@resrvda{%\n    \\def\\noexpand\\etb@resrvda####1\\detokenize{#2}####2&{%\n      \\endgroup\\noexpand\\noexpand\\noexpand\\ifblank{####2}}%\n    \\edef\\noexpand\\etb@resrvda{\\noexpand\\etb@resrvda\n      \\expandafter\\strip@prefix\\meaning#1\\detokenize{#2}&}%\n    \\noexpand\\etb@resrvda}\n  \\etb@resrvda\\@secondoftwo\\@firstoftwo}\n\n% {<string>}{<true}{<false>}\n\n\\protected\\long\\def\\etb@ifhashcheck#1{%\n  \\begingroup\n  \\edef\\etb@resrvda{\\detokenize{#1}}%\n  \\expandafter\\endgroup\n  \\expandafter\\etb@ifhashcheck@i\\meaning\\etb@resrvda&}\n\n\\edef\\etb@ifhashcheck@i#1&{%\n  \\noexpand\\expandafter\n  \\noexpand\\etb@ifhashcheck@ii\n  \\noexpand\\strip@prefix#1\\string#\\string#&}\n\n\\edef\\etb@ifhashcheck@ii{%\n  \\def\\noexpand\\etb@ifhashcheck@ii##1\\string#\\string###2&}\n\\etb@ifhashcheck@ii{\\ifblank{#2}}\n\n% {<cstoken>}\n\n\\newrobustcmd*{\\robustify}[1]{%\n  \\ifundef{#1}\n    {\\etb@error{\\string#1 undefined}\\@eha}\n    {\\ifdefmacro{#1}\n       {\\ifdefltxprotect{#1}\n          {\\letcs\\etb@resrvda{\\expandafter\\@gobble\\string#1 }%\n           \\@tempswatrue}\n          {\\let\\etb@resrvda#1%\n           \\@tempswafalse}%\n        \\ifdefparam\\etb@resrvda\n          {\\etb@ifscanable\\etb@resrvda\n             {\\etb@robustify\\etb@resrvda\n              \\let#1\\etb@resrvda}\n             {\\etb@error{Failed to robustify \\string#1}\n                {The command is special and cannot be\n                 handled by \\string\\robustify.}%\n              \\@tempswafalse}}\n          {\\protected\\edef#1{\\expandonce\\etb@resrvda}}\n        \\if@tempswa\n          \\ifcsdef{\\string#1 }\n            {}\n            {\\csundef{\\expandafter\\@gobble\\string#1 }}%\n        \\fi\n        \\undef\\etb@resrvda}\n       {\\etb@error{\\string#1 not a macro}\\@eha}}}\n\n\\def\\etb@robustify#1{%\n  \\begingroup\n  \\edef\\etb@resrvdb{%\n    \\def\\noexpand\\etb@resrvdb####1\\detokenize{macro}:####2->####3&{%\n      \\protected####1\\def\\string#1\\space####2{####3}}%\n    \\edef\\noexpand\\etb@resrvdb{%\n      \\noexpand\\etb@resrvdb\\meaning#1&}}%\n  \\etb@resrvdb\n  \\etb@patchcmd@scantoks\\etb@resrvdb}\n\n%  {<cstoken>}{<search>}{<true}{<false>}\n% *{<cstoken>}{<true}{<false>}\n\n\\newrobustcmd{\\ifpatchable}{%\n  \\etb@dbg@trce\\ifpatchable\n  \\begingroup\n  \\@makeother\\#%\n  \\@ifstar\\etb@ifpatchable@i\\etb@ifpatchable}\n\n\\long\\def\\etb@ifpatchable#1#2{%\n  \\endgroup\n  \\etb@dbg@init#1%\n  \\ifundef{#1}\n    {\\etb@dbg@fail{def}\\@secondoftwo}\n    {\\etb@dbg@info{def}%\n     \\ifdefmacro{#1}\n       {\\etb@dbg@info{mac}%\n        \\etb@ifscanable{#1}\n          {\\etb@ifhashcheck{#2}\n             {\\etb@dbg@info{tok}%\n              \\etb@ifpattern#1{#2}\n                 {\\etb@dbg@info{pat}%\n                  \\etb@dbg@info{pos}\\@firstoftwo}\n                 {\\etb@dbg@fail{pat}\\@secondoftwo}}\n             {\\etb@dbg@fail{hsh}\\@secondoftwo}}\n          {\\etb@dbg@fail{tok}\\@secondoftwo}}\n       {\\etb@dbg@fail{mac}\\@secondoftwo}}}\n\n\\long\\def\\etb@ifpatchable@i#1{%\n  \\endgroup\n  \\etb@dbg@init#1%\n  \\ifundef{#1}\n    {\\etb@dbg@fail{def}\\@secondoftwo}\n    {\\etb@dbg@info{def}%\n     \\ifdefmacro{#1}\n       {\\etb@dbg@info{mac}%\n        \\ifdefparam{#1}\n          {\\etb@dbg@info{prm}%\n           \\etb@ifscanable{#1}\n             {\\etb@dbg@info{tok}%\n              \\etb@dbg@info{pos}\\@firstoftwo}\n             {\\etb@dbg@fail{tok}\\@secondoftwo}}\n          {\\etb@dbg@info{prl}%\n           \\ifdefprotected{#1}\n             {\\etb@dbg@info{pro}}\n             {}%\n           \\etb@dbg@info{pos}\\@firstoftwo}}\n       {\\etb@dbg@fail{mac}\\@secondoftwo}}}\n\n% [<prefix>]{<cstoken>}{<search>}{<replace>}{<success>}{<failure>}\n\n\\newrobustcmd*{\\patchcmd}{%\n  \\etb@dbg@trce\\patchcmd\n  \\begingroup\n  \\@makeother\\#%\n  \\etb@patchcmd}\n\n\\newcommand{\\etb@patchcmd}[4][########1]{%\n  \\etb@ifpatchable#2{#3}\n    {\\etb@dbg@succ{ret}%\n     \\begingroup\n     \\edef\\etb@resrvda{%\n       \\def\\noexpand\\etb@resrvda####1\\detokenize{macro:}####2->####3&{%\n         #1\\def\\string\\etb@resrvda\\space####2{\\noexpand\\etb@resrvdb####3&}}%\n       \\def\\noexpand\\etb@resrvdb####1\\detokenize{#3}####2&{%\n         ####1\\detokenize{#4}####2}%\n       \\edef\\noexpand\\etb@resrvda{%\n         \\noexpand\\etb@resrvda\\meaning#2&}}%\n     \\etb@resrvda\n     \\etb@patchcmd@scantoks\\etb@resrvda\n     \\let#2\\etb@resrvda\n     \\undef\\etb@resrvda\n     \\@firstoftwo}\n    {\\@secondoftwo}}\n\n\\def\\etb@patchcmd@scantoks#1{%\n  \\edef\\etb@resrvda{\\endgroup\n    \\unexpanded{\\makeatletter\\scantokens}{#1}%\n    \\catcode\\number`\\@=\\the\\catcode`\\@\\relax}%\n  \\etb@resrvda}\n\n% {<cstoken>}{<code>}{<success>}{<failure>}\n\n\\newrobustcmd*{\\apptocmd}{%\n  \\etb@dbg@trce\\apptocmd\n  \\begingroup\n  \\@makeother\\#%\n  \\etb@hooktocmd\\etb@append}\n\n\\newrobustcmd*{\\pretocmd}{%\n  \\etb@dbg@trce\\pretocmd\n  \\begingroup\n  \\@makeother\\#%\n  \\etb@hooktocmd\\etb@prepend}\n\n\\long\\def\\etb@hooktocmd#1#2#3{%\n  \\endgroup\n  \\etb@dbg@init#2%\n  \\ifundef{#2}\n    {\\etb@dbg@fail{def}\\@secondoftwo}\n    {\\etb@dbg@info{def}%\n     \\ifdefmacro{#2}\n       {\\etb@dbg@info{mac}%\n        \\ifdefparam{#2}\n          {\\etb@dbg@info{prm}%\n           \\etb@ifscanable{#2}\n             {\\etb@ifhashcheck{#3}\n                {\\etb@dbg@info{tok}%\n                 \\etb@dbg@succ{ret}%\n                 \\etb@hooktocmd@i#1#2{#3}%\n                 \\@firstoftwo}\n                {\\etb@dbg@fail{hsh}\\@secondoftwo}}\n             {\\etb@dbg@fail{tok}\\@secondoftwo}}\n          {\\etb@dbg@info{prl}%\n           \\ifdefprotected{#2}\n             {\\etb@dbg@info{pro}%\n              \\etb@dbg@succ{red}%\n              \\protected}\n             {\\etb@dbg@succ{red}}%\n           \\edef#2{#1{\\expandonce#2}{\\unexpanded{#3}}}%\n           \\@firstoftwo}}\n       {\\etb@dbg@fail{mac}\\@secondoftwo}}}\n\n\\long\\def\\etb@hooktocmd@i#1#2#3{%\n  \\begingroup\n  \\edef\\etb@resrvda{%\n    \\def\\noexpand\\etb@resrvda####1\\detokenize{macro}:####2->####3&{%\n      ####1\\def\\string\\etb@resrvda\\space####2{#1{####3}{\\detokenize{#3}}}}%\n    \\edef\\noexpand\\etb@resrvda{%\n      \\noexpand\\etb@resrvda\\meaning#2&}}%\n  \\etb@resrvda\n  \\etb@patchcmd@scantoks\\etb@resrvda\n  \\let#2\\etb@resrvda\n  \\undef\\etb@resrvda}\n\n\\long\\def\\etb@append#1#2{#1#2}\n\\long\\def\\etb@prepend#1#2{#2#1}\n\n\\newrobustcmd*{\\tracingpatches}{%\n  \\etb@info{Enabling tracing}%\n  \\input{etoolbox.def}%\n  \\global\\let\\tracingpatches\\relax}\n\\@onlypreamble\\tracingpatches\n\n\\let\\etb@dbg@trce\\@gobble\n\\let\\etb@dbg@init\\@gobble\n\\let\\etb@dbg@info\\@gobble\n\\let\\etb@dbg@succ\\@gobble\n\\let\\etb@dbg@fail\\@gobble\n\n% {<numeral>}\n\n\\newcommand{\\rmntonum}[1]{%\n  \\ifblank{#1}\n    {}\n    {\\expandafter\\etb@rti@end\\number\\numexpr\n     \\expandafter\\etb@rti@prs\\detokenize{#1}&\\relax}}\n\n\\def\\etb@rti@prs#1#2{%\n  \\ifx&#1%\n    \\expandafter\\@firstoftwo\n  \\else\n    \\expandafter\\@secondoftwo\n  \\fi\n  {#1#2}\n  {\\ifx&#2%\n     \\expandafter\\@firstoftwo\n   \\else\n     \\expandafter\\@secondoftwo\n   \\fi\n   {\\etb@rti@chk#1+\\etb@rti@num#1#2}\n   {\\etb@rti@chk#1\\etb@rti@chk#2%\n    \\ifnum\\etb@rti@num#1<\\etb@rti@num#2 %\n      \\expandafter\\@firstoftwo\n    \\else\n      \\expandafter\\@secondoftwo\n    \\fi\n    {+\\etb@rti@num#2-\\etb@rti@num#1\\etb@rti@prs}\n    {+\\etb@rti@num#1\\etb@rti@prs#2}}}}\n\n\\def\\etb@rti@chk#1{%\n  \\ifcsname etb@rmn@#1\\endcsname\n  \\else\n    \\expandafter\\etb@rti@brk\n  \\fi}\n\n\\def\\etb@rti@brk#1&{+\\z@&-1}\n\\def\\etb@rti@end#1&#2\\relax{\\ifblank{#2}{#1}{#2}}\n\\def\\etb@rti@num#1{\\csname etb@rmn@#1\\endcsname}\n\n\\chardef\\etb@rmn@i=1\n\\chardef\\etb@rmn@I=1\n\\chardef\\etb@rmn@v=5\n\\chardef\\etb@rmn@V=5\n\\chardef\\etb@rmn@x=10\n\\chardef\\etb@rmn@X=10\n\\chardef\\etb@rmn@l=50\n\\chardef\\etb@rmn@L=50\n\\chardef\\etb@rmn@c=100\n\\chardef\\etb@rmn@C=100\n\\mathchardef\\etb@rmn@d=500\n\\mathchardef\\etb@rmn@D=500\n\\mathchardef\\etb@rmn@m=1000\n\\mathchardef\\etb@rmn@M=1000\n\n% {<numeral>}{<true>}{<false>}\n\n\\newcommand{\\ifrmnum}[1]{%\n  \\ifblank{#1}\n    {\\@secondoftwo}\n    {\\expandafter\\etb@ifr@prs\\detokenize{#1}\\relax}}\n\n\\def\\etb@ifr@prs#1{%\n  \\ifx\\relax#1%\n    \\expandafter\\@firstoftwo\n  \\else\n    \\ifcsname etb@rmn@#1\\endcsname\n      \\expandafter\\expandafter\n      \\expandafter\\etb@ifr@prs\n    \\else\n      \\expandafter\\expandafter\n      \\expandafter\\etb@ifr@brk\n    \\fi\n  \\fi}\n\n\\def\\etb@ifr@brk#1\\relax{\\@secondoftwo}\n\n% <*>{<command>}{<separator>}\n\n\\newrobustcmd*{\\DeclareListParser}{%\n  \\@ifstar\n    {\\etb@defparser\\etb@defparser@arg}\n    {\\etb@defparser\\etb@defparser@do}}\n\n\\def\\etb@defparser#1#2#3{%\n  \\@ifdefinable#2{#1{#2}{#3}}}\n\n\\def\\etb@defparser@do#1#2{%\n  \\begingroup\n  \\edef\\@tempa{\\endgroup\n    \\long\\def\\noexpand#1####1{%\n      \\expandafter\\noexpand\n      \\csname etb@lst@\\expandafter\\@gobble\\string#1\\endcsname\n      \\space####1\\noexpand#2&}%\n    \\long\\csdef{etb@lst@\\expandafter\\@gobble\\string#1}####1\\noexpand#2####2&{%\n      \\noexpand\\etb@listitem\\noexpand\\do{####1}%\n      \\noexpand\\ifblank{####2}\n        {\\noexpand\\listbreak}\n        {\\expandafter\\noexpand\n         \\csname etb@lst@\\expandafter\\@gobble\\string#1\\endcsname\n\t \\space####2}&}}%\n  \\@tempa}\n\n\\def\\etb@defparser@arg#1#2{%\n  \\begingroup\n  \\edef\\@tempa{\\endgroup\n    \\long\\def\\noexpand#1####1####2{%\n      \\expandafter\\noexpand\n      \\csname etb@lst@\\expandafter\\@gobble\\string#1\\endcsname\n      {####1}\\space####2\\noexpand#2&}%\n    \\long\\csdef{etb@lst@\\expandafter\\@gobble\\string#1}####1####2\\noexpand#2####3&{%\n      \\noexpand\\etb@listitem{####1}{####2}%\n      \\noexpand\\ifblank{####3}\n        {\\noexpand\\listbreak}\n        {\\expandafter\\noexpand\n         \\csname etb@lst@\\expandafter\\@gobble\\string#1\\endcsname\n\t {####1}\\space####3}&}}%\n  \\@tempa}\n\n\\long\\def\\etb@listitem#1#2{%\n  \\ifblank{#2}\n    {}\n    {\\expandafter\\etb@listitem@i\n     \\expandafter{\\@firstofone#2}{#1}}}\n\\long\\def\\etb@listitem@i#1#2{#2{#1}}\n\n\\newcommand*{\\listbreak}{}\n\\long\\def\\listbreak#1&{}\n\n% {<item1>,<item2>,...} => \\do{<item1>}\\do{<item2>}...\n\n\\DeclareListParser{\\docsvlist}{,}\n\n% {<handler>}{<item1>,<item2>,...} => <handler>{<item1>}<handler>{<item2>}...\n\n\\DeclareListParser*{\\forcsvlist}{,}\n\n% {<listmacro>}{<string>}\n\n\\newrobustcmd{\\listadd}[2]{%\n  \\ifblank{#2}{}{\\appto#1{#2|}}}\n\\newrobustcmd{\\listeadd}[2]{%\n  \\begingroup\n  \\edef\\etb@tempa{\\endgroup\\noexpand\\ifblank{#2}}%\n  \\etb@tempa{}{\\eappto#1{#2|}}}\n\\newrobustcmd{\\listgadd}[2]{%\n  \\ifblank{#2}{}{\\gappto#1{#2|}}}\n\\newrobustcmd{\\listxadd}[2]{%\n  \\begingroup\n  \\edef\\etb@tempa{\\endgroup\\noexpand\\ifblank{#2}}%\n  \\etb@tempa{}{\\xappto#1{#2|}}}\n\n% {<listcsname>}{<string>}\n\n\\newrobustcmd{\\listcsadd}[1]{%\n  \\expandafter\\listadd\\csname#1\\endcsname}\n\\newrobustcmd{\\listcseadd}[1]{%\n  \\expandafter\\listeadd\\csname#1\\endcsname}\n\\newrobustcmd{\\listcsgadd}[1]{%\n  \\expandafter\\listgadd\\csname#1\\endcsname}\n\\newrobustcmd{\\listcsxadd}[1]{%\n  \\expandafter\\listxadd\\csname#1\\endcsname}\n\n% {<string>}{<listmacro>}{<true>}{<false>}\n\n\\newrobustcmd{\\ifinlist}[2]{%\n  \\begingroup\n  \\def\\etb@tempa##1|#1|##2&{\\endgroup\n    \\ifblank{##2}\\@secondoftwo\\@firstoftwo}%\n  \\expandafter\\etb@tempa\\expandafter|#2|#1|&}\n\n\\newrobustcmd{\\xifinlist}[1]{%\n  \\begingroup\n  \\edef\\etb@tempa{\\endgroup\\ifinlist{#1}}%\n  \\etb@tempa}\n\n% {<string>}{<listcsname>}{<true>}{<false>}\n\n\\newrobustcmd{\\ifinlistcs}[2]{%\n  \\expandafter\\etb@ifinlistcs@i\\csname #2\\endcsname{#1}}\n\\long\\def\\etb@ifinlistcs@i#1#2{\\ifinlist{#2}{#1}}\n\n\\newrobustcmd{\\xifinlistcs}[1]{%\n  \\begingroup\n  \\edef\\etb@tempa{\\endgroup\\ifinlistcs{#1}}%\n  \\etb@tempa}\n\n% {<handler>}{<listmacro>} => <handler>{<item1>}<handler>{<item2>}...\n\n\\newcommand*{\\forlistloop}[2]{%\n  \\expandafter\\etb@forlistloop\\expandafter{#2}{#1}}\n\n\\long\\def\\etb@forlistloop#1#2{\\etb@forlistloop@i{#2}#1|&}\n\n\\long\\def\\etb@forlistloop@i#1#2|#3&{%\n  \\ifblank{#2}\n    {}\n    {#1{#2}}%\n  \\ifblank{#3}\n    {\\listbreak}\n    {\\etb@forlistloop@i{#1}#3}%\n  &}\n\n% {<handler>}{<listcsname>} => <handler>{<item1>}<handler>{<item2>}...\n\n\\newcommand*{\\forlistcsloop}[2]{%\n  \\expandafter\\expandafter\\expandafter\\etb@forlistloop\n  \\expandafter\\expandafter\\expandafter{\\csname#2\\endcsname}{#1}}\n\n% {<listmacro>} => \\do{<item1>}\\do{<item2>}...\n\n\\newcommand*{\\dolistloop}{\\forlistloop\\do}\n\n% {<listcsname>} => \\do{<item1>}\\do{<item2>}...\n\n\\newcommand*{\\dolistcsloop}{\\forlistcsloop\\do}\n\n% {<code>}\n\n\\newrobustcmd*{\\AtEndPreamble}{\\gappto\\@endpreamblehook}\n\\newcommand*{\\@endpreamblehook}{}\n\n\\preto\\document{%\n  \\endgroup\n  \\let\\AtEndPreamble\\@firstofone\n  \\@endpreamblehook\n  \\protected\\def\\AtEndPreamble{\\@notprerr\\@gobble}%\n  \\undef\\@endpreamblehook\n  \\begingroup}\n\n% {<code>}\n\n\\newrobustcmd*{\\AfterPreamble}{\\AtBeginDocument}\n\\AtEndPreamble{\\let\\AfterPreamble\\@firstofone}\n\n% {<code>}\n\n\\newrobustcmd*{\\AfterEndPreamble}{\\gappto\\@afterendpreamblehook}\n\\newcommand*{\\@afterendpreamblehook}{}\n\n\\appto\\document{%\n  \\let\\AfterEndPreamble\\@firstofone\n  \\@afterendpreamblehook\n  \\protected\\def\\AfterEndPreamble{\\@notprerr\\@gobble}%\n  \\undef\\@afterendpreamblehook\n  \\ignorespaces}\n\n\\AtEndDocument{\\let\\AfterEndPreamble\\@gobble}\n\n% {<code>}\n\n\\newrobustcmd*{\\AfterEndDocument}{\\gappto\\@afterenddocumenthook}\n\\newcommand*{\\@afterenddocumenthook}{}\n\n\\patchcmd\\enddocument\n  {\\deadcycles}\n  {\\let\\AfterEndDocument\\@firstofone\n   \\@afterenddocumenthook\n   \\deadcycles}\n  {}\n  {\\let\\etb@@end\\@@end\n   \\def\\@@end{%\n     \\let\\AfterEndDocument\\@firstofone\n     \\@afterenddocumenthook\n     \\etb@@end}}\n\n% {<environment>}{<code>}\n\n\\newrobustcmd{\\AtBeginEnvironment}[1]{%\n  \\csgappto{@begin@#1@hook}}\n\n\\patchcmd\\begin\n  {\\csname #1\\endcsname}\n  {\\csuse{@begin@#1@hook}%\n   \\csname #1\\endcsname}\n  {}\n  {\\etb@warning{%\n     Patching '\\string\\begin' failed!\\MessageBreak\n     '\\string\\AtBeginEnvironment' will not work\\@gobble}}\n\n% {<environment>}{<code>}\n\n\\newrobustcmd{\\AtEndEnvironment}[1]{%\n  \\csgappto{@end@#1@hook}}\n\n\\patchcmd\\end\n  {\\csname end#1\\endcsname}\n  {\\csuse{@end@#1@hook}%\n   \\csname end#1\\endcsname}\n  {}\n  {\\etb@warning{%\n     Patching '\\string\\end' failed!\\MessageBreak\n     '\\string\\AtEndEnvironment' will not work\\@gobble}}\n\n% {<environment>}{<code>}\n\n\\newrobustcmd{\\BeforeBeginEnvironment}[1]{%\n  \\csgappto{@beforebegin@#1@hook}}\n\n\\pretocmd\\begin\n  {\\csuse{@beforebegin@#1@hook}}\n  {}\n  {\\etb@warning{%\n     Patching '\\string\\begin' failed!\\MessageBreak\n     '\\string\\BeforeBeginEnvironment' will not work\\@gobble}}\n\n% {<environment>}{<code>}\n\n\\newrobustcmd{\\AfterEndEnvironment}[1]{%\n  \\csgappto{@afterend@#1@hook}}\n\n\\patchcmd\\end\n  {\\if@ignore}\n  {\\csuse{@afterend@#1@hook}%\n   \\if@ignore}\n  {}\n  {\\etb@warning{%\n     Patching '\\string\\end' failed!\\MessageBreak\n     '\\string\\AfterEndEnvironment' will not work\\@gobble}}\n\n\\endinput\n"
p0
.I0
.S'Slunits'
p0
.S'$style_file: Slunits\n%%\n%% This is file `SIunits.sty\',\n%% generated with the docstrip utility.\n%%\n%% The original source files were:\n%%\n%% SIunits.dtx  (with options: `package\')\n%% \n%% Copyright (c) 1998-2002 Marcel Heldoorn <m.heldoorn@webschool.nl>.\n%% \n%% This program may be distributed and/or modified under the conditions of the LaTeX Project\n%% Public License, either version 1.2 of this license or (at your option) any later version.\n%% The latest version of this license is in http://www.latex-project.org/lppl.txt and\n%% version 1.2 or later is part of all distributions of LaTeX version 1999/12/01 or later.\n%% \n%% For error reports in case of UNCHANGED versions see the readme.txt file.\n%% \n%% Please do not request updates from me directly. Distribution is done through the\n%% Comprehensive TeX Archive Network (CTAN).\n%% \n\\def\\SIunits@RCS$#1: #2 #3${#2}\n\\def\\filename{SIunits.dtx}%Source File Name\n\\xdef\\fileversion{\\SIunits@RCS$Revision: 1.1.1.1 $}%Revision generated by CS-RCS\n\\xdef\\filedate{\\SIunits@RCS$Date: 2003/02/26 03:15:34 $}%Date generated by CS-RCS\n\\let\\docversion=\\fileversion\n\\let\\docdate=\\filedate\n\\NeedsTeXFormat{LaTeX2e}[1997/12/01]\n\\ProvidesPackage{SIunits}\n  [\\filedate\\space v\\fileversion\\space\n     Support for the International System of units (MH)]\n \\def\\packagemessage{}\n\\typeout{\\packagemessage}\n\\newif\\if@redefsquare\\@redefsquarefalse\n\\newif\\if@defsquaren\\@defsquarenfalse\n\\newif\\if@redefGray\\@redefGrayfalse\n\\newif\\if@defGray\\@defGrayfalse\n\\newif\\if@textstyle\\@textstylefalse\n\\newif\\if@optionbinary\\@optionbinaryfalse\n\\newif\\if@optionNoAMS\\@optionNoAMSfalse\n\\newif\\if@inunitcommand\\@inunitcommandfalse\n\\newlength{\\@qskwidth}\n\\newif\\if@defitalian\\@defitalianfalse\n\\DeclareRobustCommand\\SI@fstyle[1]{\\mathrm{#1}}\n\\DeclareTextSymbolDefault{\\SImu}{TS1}\n\\DeclareTextSymbol{\\SImu}{TS1}{181} % micro sign\n\\DeclareFontEncoding{TS1}{}{}\n\\DeclareFontSubstitution{TS1}{cmr}{m}{n}\n\\DeclareFontFamily{OML}{eur}{\\skewchar\\font127} \\DeclareFontShape{OML}{eur}{m}{n}{<5> <6>\n                <7> <8> <9> gen * eurm <10><10.95><12><14.4><17.28><20.74><24.88>eurm10}{}\n\\DeclareSymbolFont{greek}{OML}{eur}{m}{n}\n\\DeclareMathSymbol{\\upmu}{\\mathord}{greek}{"16}\n\\newcommand*\\SIunits[1][thickspace,thickqspace]{\\@for\\SIunits@@:=#1%\n  \\do{\\SIunits@execopt\\SIunits@@}}\n\\newcommand*\\SIunits@execopt[1]{\\@ifundefined{SIunits@opt@#1}%\n  {\\PackageWarning{SIunits}{Requested option `#1\' not provided}}%\n  {\\@nameuse{SIunits@opt@#1}}}\n\\newcommand*\\SIunits@opt@thickspace{%\n  \\@thickspace{runtime option `thickspace\' provided!}}\n\\newcommand*\\SIunits@opt@mediumspace{%\n  \\@mediumspace{runtime option `mediumspace\' provided!}}\n\\newcommand*\\SIunits@opt@thinspace{%\n  \\@thinspace{runtime option `thinspace\' provided!}}\n\\newcommand*\\SIunits@opt@cdot{%\n  \\@cdot{runtime option `cdot\' provided!}}\n\\newcommand*\\SIunits@opt@thickqspace{%\n  \\@thickqspace{runtime option `thickqspace\' provided!}}\n\\newcommand*\\SIunits@opt@mediumqspace{%\n  \\@mediumqspace{runtime option `mediumqspace\' provided!}}\n\\newcommand*\\SIunits@opt@thinqspace{%\n  \\@thinqspace{runtime option `thinqspace\' provided!}}\n\\DeclareRobustCommand{\\@text}{%\n  \\ifmmode\\expandafter\\@text@\\else\\expandafter\\mbox\\fi}\n\\let\\nfss@text\\@text%\n\\def\\@text@#1{\\mathchoice%\n  {\\textdef@\\displaystyle\\f@size{#1}}%\n  {\\textdef@\\textstyle\\tf@size{\\firstchoice@false #1}}%\n  {\\textdef@\\textstyle\\sf@size{\\firstchoice@false #1}}%\n  {\\textdef@\\textstyle\\ssf@size{\\firstchoice@false #1}}%\n  \\check@mathfonts}%\n\\def\\textdef@#1#2#3{\\hbox{{%\n                    \\everymath{#1}%\n                    \\let\\f@size#2\\selectfont%\n                    #3}}}%\n\\newif\\iffirstchoice@%\n\\firstchoice@true%\n\\def\\stepcounter#1{%\n  \\iffirstchoice@%\n     \\addtocounter{#1}\\@ne%\n     \\begingroup \\let\\@elt\\@stpelt \\csname cl@#1\\endcsname \\endgroup\n  \\fi%\n}%\n\\DeclareRobustCommand*{\\meter}{\\metre}\n\\DeclareRobustCommand*{\\deka}{\\deca}\n\\DeclareRobustCommand*{\\dekad}{\\decad}\n\\DeclareRobustCommand*{\\NoAMS}{\\addprefix{\\micro}{\\mbox{\\SImu}}}\n\\DeclareRobustCommand{\\addunit}[2]{\\newcommand{#1}{\\ensuremath{\\SI@fstyle{#2}}}}\n\\DeclareRobustCommand{\\addprefix}[2]{\\newcommand{#1}{\\ensuremath{\\SI@fstyle{#2}}}}\n\\DeclareRobustCommand*{\\unitskip}[1]{\\renewcommand{\\usk}{\\ensuremath{#1}}}\n\\DeclareRobustCommand*{\\quantityskip}[1]{\\renewcommand{\\@qsk}{\\ensuremath{#1}}}\n\\DeclareRobustCommand*{\\per}{\\ensuremath{\\SI@fstyle{/}}}\n\\DeclareRobustCommand*{\\usk}{\\ensuremath{\\;}}\n\\DeclareRobustCommand*{\\@qsk}{\\ensuremath{\\;}}\n\\renewcommand{\\cdot}{\\,\\mbox{\\textperiodcentered}\\,}\n\\newcommand{\\@cdot}[1]{\\DeclareRobustCommand*{\\usk}{\\ensuremath{\\cdot}}\\typeout{#1}}\n\\newcommand{\\@thickspace}[1]{\\DeclareRobustCommand*{\\usk}{\\ensuremath{\\;}}\\typeout{#1}}\n\\newcommand{\\@mediumspace}[1]{\\DeclareRobustCommand*{\\usk}{\\ensuremath{\\:}}\\typeout{#1}}\n\\newcommand{\\@thinspace}[1]{\\DeclareRobustCommand*{\\usk}{\\ensuremath{\\,}}\\typeout{#1}}\n\\newcommand{\\@thickqspace}[1]{\\DeclareRobustCommand*{\\@qsk}{\\ensuremath{\\;}}\\typeout{#1}}\n\\newcommand{\\@mediumqspace}[1]{\\DeclareRobustCommand*{\\@qsk}{\\ensuremath{\\:}}\\typeout{#1}}\n\\newcommand{\\@thinqspace}[1]{\\DeclareRobustCommand*{\\@qsk}{\\ensuremath{\\,}}\\typeout{#1}}\n{\\catcode`\\.=13\\gdef.{\\usk}}\n\\newcommand{\\period@active}[1]{\\begingroup\\mathcode`\\.="8000\\ensuremath{#1}\\endgroup}\n\\DeclareRobustCommand{\\unit}[2]{\\@inunitcommandtrue%\n \\ensuremath{\\SI@fstyle{#1\\@qsk\\period@active{#2}}}%\n \\@inunitcommandfalse}\n\\DeclareRobustCommand{\\one}{\\settowidth{\\@qskwidth}{\\@qsk}\\hspace*{-\\@qskwidth}}\n\\DeclareRobustCommand{\\no@qsk}{%\n \\if@inunitcommand%\n  \\one%\n \\else%\n  \\relax%\n \\fi%\n}\n\\DeclareRobustCommand{\\power}[2]{\\ensuremath{\\SI@fstyle{#1}^{\\SI@fstyle{#2}}}}\n\\AtBeginDocument{%\n \\if@redefsquare\n  \\providecommand{\\square}[1]{\\power{#1}{2}}\n  \\renewcommand{\\square}[1]{\\power{#1}{2}}\n  \\typeout{Option `amssymb\' provided! ^^J\n  Command \\protect\\square\\space redefined by SIunits package!}\n  \\typeout{}\n \\else\n   \\if@defsquaren\n    \\providecommand{\\squaren}[1]{\\power{#1}{2}}\n    \\renewcommand{\\squaren}[1]{\\power{#1}{2}}\n    \\typeout{Option `squaren\' provided! ^^J\n    Command \\protect\\squaren\\space defined by SIunits package!}\n    \\typeout{}\n   \\else\n    \\@ifundefined{square}{%\n     \\newcommand*{\\square}[1]{\\power{#1}{2}}\n     }{%\n     \\PackageError{SIunits}{%\n     The command \\protect\\square\\space was already defined.\\MessageBreak\n     Possibly due to the amssymb package}%\n     {Hint: use option `amssymb\' or `squaren\' with SIunits package.\\MessageBreak\n     See SIunits.dvi or readme.txt section: Known problems and limitations.}\n    }  %\\ifundefined{square}\n   \\fi %\\if@defsquaren\n \\fi   %\\if@redefsquare\n \\if@defitalian\n \\PackageWarning{SIunits}{Option `italian\' provided.\\MessageBreak\n                          Command \\protect\\unit\\space defined by babel.\\MessageBreak\n                          Mind to use \\protect\\unita\\space instead.}%\n \\DeclareRobustCommand{\\unita}[2]{%\n           \\@inunitcommandtrue%\n           \\ensuremath{\\SI@fstyle{#1\\@qsk\\period@active{#2}}}%\n           \\@inunitcommandfalse%\n           }%\n \\fi%\\if@defitalian\n}     %\\AtBeginDocument\n\\DeclareRobustCommand{\\SI@square}[1]\n    {\\if@defsquaren%\n      \\squaren{#1}%\n        \\else\n      \\square{#1}%\n     \\fi %\\if@defsquaren\n    }\n\\DeclareRobustCommand*{\\squared}{\\ensuremath{^{\\mathrm{2}}}}\n\\DeclareRobustCommand*{\\cubic}[1]{\\power{#1}{3}}\n\\DeclareRobustCommand*{\\cubed}{\\ensuremath{^{\\mathrm{3}}}}\n\\DeclareRobustCommand*{\\fourth}[1]{\\power{#1}{4}}\n\\DeclareRobustCommand*{\\reciprocal}[1]{\\power{#1}{-1}}\n\\DeclareRobustCommand*{\\rp}{\\reciprocal}\n\\DeclareRobustCommand*{\\rpsquare}[1]{\\power{#1}{-2}}\n\\DeclareRobustCommand*{\\rpsquared}{\\ensuremath{^{\\mathrm{-2}}}}\n\\DeclareRobustCommand*{\\rpcubic}[1]{\\power{#1}{-3}}\n\\DeclareRobustCommand*{\\rpcubed}{\\ensuremath{^{\\mathrm{-3}}}}\n\\DeclareRobustCommand*{\\rpfourth}[1]{\\power{#1}{-4}}\n\\addprefix{\\yocto}{y}\n\\addprefix{\\zepto}{z}\n\\addprefix{\\atto}{a}\n\\addprefix{\\femto}{f}\n\\addprefix{\\pico}{p}\n\\addprefix{\\nano}{n}\n\\AtBeginDocument{%\n\\if@optionNoAMS%\n \\addprefix{\\micro}{\\mbox{\\SImu}}%\n\\else%\n  \\addprefix{\\micro}{\\upmu}%\n \\fi%\n\\if@textstyle%\n  \\DeclareRobustCommand{\\micro}{{\\ensuremath{\\@text{\\SImu}}}}%\n\\fi}\n\\addprefix{\\milli}{m}\n\\addprefix{\\centi}{c}\n\\addprefix{\\deci}{d}\n\\addprefix{\\deca}{da}\n\\addprefix{\\hecto}{h}\n\\addprefix{\\kilo}{k}\n\\addprefix{\\mega}{M}\n\\addprefix{\\giga}{G}\n\\addprefix{\\tera}{T}\n\\addprefix{\\peta}{P}\n\\addprefix{\\exa}{E}\n\\addprefix{\\zetta}{Z}\n\\addprefix{\\yotta}{Y}\n\\DeclareRobustCommand*{\\yoctod}{\\power{10}{-24}}\n\\DeclareRobustCommand*{\\zeptod}{\\power{10}{-21}}\n\\DeclareRobustCommand*{\\attod}{\\power{10}{-18}}\n\\DeclareRobustCommand*{\\femtod}{\\power{10}{-15}}\n\\DeclareRobustCommand*{\\picod}{\\power{10}{-12}}\n\\DeclareRobustCommand*{\\nanod}{\\power{10}{-9}}\n\\DeclareRobustCommand*{\\microd}{\\power{10}{-6}}\n\\DeclareRobustCommand*{\\millid}{\\power{10}{-3}}\n\\DeclareRobustCommand*{\\centid}{\\power{10}{-2}}\n\\DeclareRobustCommand*{\\decid}{\\power{10}{-1}}\n\\DeclareRobustCommand*{\\decad}{\\power{10}{1}}\n\\DeclareRobustCommand*{\\hectod}{\\power{10}{2}}\n\\DeclareRobustCommand*{\\kilod}{\\power{10}{3}}\n\\DeclareRobustCommand*{\\megad}{\\power{10}{6}}\n\\DeclareRobustCommand*{\\gigad}{\\power{10}{9}}\n\\DeclareRobustCommand*{\\terad}{\\power{10}{12}}\n\\DeclareRobustCommand*{\\petad}{\\power{10}{15}}\n\\DeclareRobustCommand*{\\exad}{\\power{10}{18}}\n\\DeclareRobustCommand*{\\zettad}{\\power{10}{21}}\n\\DeclareRobustCommand*{\\yottad}{\\power{10}{24}}\n\\addunit{\\gram}{g}\n\\addunit{\\metre}{m}\n\\addunit{\\kilogram}{\\kilo\\gram}\n\\addunit{\\second}{s}\n\\addunit{\\ampere}{A}\n\\addunit{\\kelvin}{K}\n\\addunit{\\mole}{mol}\n\\addunit{\\candela}{cd}\n\\addunit{\\radian}{rad}\n\\addunit{\\steradian}{sr}\n\\addunit{\\hertz}{Hz}\n\\addunit{\\newton}{N}\n\\addunit{\\pascal}{Pa}\n\\addunit{\\joule}{J}\n\\addunit{\\watt}{W}\n\\addunit{\\coulomb}{C}\n\\addunit{\\volt}{V}\n\\addunit{\\farad}{F}\n\\addunit{\\ohm}{\\ensuremath{\\Omega}}\n\\addunit{\\siemens}{S}\n\\addunit{\\weber}{Wb}\n\\addunit{\\tesla}{T}\n\\addunit{\\henry}{H}\n\\newcommand{\\degreecelsius}{\\protect\\@inunitcommandfalse\\ensuremath{\\SI@fstyle{\\degree\\Celsius}}}\n\\addunit{\\celsius}{\\degreecelsius}\n\\addunit{\\lumen}{lm}\n\\addunit{\\lux}{lx}\n\\addunit{\\becquerel}{Bq}\n\\AtBeginDocument{%\n\\if@redefGray\n  \\providecommand{\\gray}{\\ensuremath{\\SI@fstyle{Gy}}}\n  \\renewcommand{\\gray}{\\ensuremath{\\SI@fstyle{Gy}}}\n  \\typeout{Option `pstricks\' provided! ^^J\n           Command \\protect\\gray\\space redefined by SIunits package!}\n  \\typeout{}\n \\else\n   \\if@defGray\n    \\providecommand{\\Gray}{\\ensuremath{\\SI@fstyle{Gy}}}\n    \\renewcommand{\\Gray}{\\ensuremath{\\SI@fstyle{Gy}}}\n    \\typeout{Option `Gray\' provided! ^^J\n             Command \\protect\\Gray\\space defined by SIunits package!}\n    \\typeout{}\n   \\else\n    \\@ifundefined{gray}{%\n     \\newcommand*{\\gray}{\\ensuremath{\\SI@fstyle{Gy}}}\n     }{%\n     \\PackageWarningNoLine{SIunits}{%\n     The command \\protect\\gray\\space was already defined.\\MessageBreak\n     Possibly due to the pstricks package}\n     \\typeout{Hint: use option `pstricks\' or `Gray\' with SIunits package.}\n     \\typeout{See SIunits.dvi or readme.txt section: Known problems and limitations.}\n     \\typeout{}\n    }          %\\ifundefined{gray}\n   \\fi %\\if@defGray\n \\fi   %\\if@redefGray\n}      %\\AtBeginDocument\n\\addunit{\\sievert}{Sv}\n\\addunit{\\katal}{kat}\n\n\\newcommand*\\SIunits@opt@derivedinbase{%\n\\typeout{Option \'derivedinbase\' provided!^^J}\n\\addunit{\\radianbase}%\n        {\\metre\\usk\\reciprocal\\metre}\n\\addunit{\\steradianbase}%\n        {\\squaremetre\\usk\\rpsquare\\metre}\n\\addunit{\\hertzbase}%\n        {\\reciprocal\\second}\n\\addunit{\\newtonbase}%\n        {\\metre\\usk\\kilogram\\usk\\second\\rpsquared}\n\\addunit{\\pascalbase}%\n        {\\reciprocal\\metre\\usk\\kilogram\\usk\\second\\rpsquared}\n\\addunit{\\joulebase}%\n        {\\squaremetre\\usk\\kilogram\\usk\\second\\rpsquared}\n\\addunit{\\wattbase}%\n        {\\squaremetre\\usk\\kilogram\\usk\\rpcubic\\second}\n\\addunit{\\coulombbase}%\n        {\\ampere\\usk\\second}\n\\addunit{\\voltbase}%\n        {\\squaremetre\\usk\\kilogram\\usk\\rpcubic\\second\\usk\\reciprocal\\ampere}\n\\addunit{\\faradbase}%\n        {\\rpsquare\\metre\\usk\\reciprocal\\kilogram\\usk\\fourth\\second\\usk\\ampere\\squared}\n\\addunit{\\ohmbase}%\n        {\\squaremetre\\usk\\kilogram\\usk\\rpcubic\\second\\usk\\rpsquare\\ampere}\n\\addunit{\\siemensbase}%\n        {\\rpsquare\\metre\\usk\\reciprocal\\kilogram\\usk\\cubic\\second\\usk\\ampere\\squared}\n\\addunit{\\weberbase}%\n        {\\squaremetre\\usk\\kilogram\\usk\\second\\rpsquared\\usk\\reciprocal\\ampere}\n\\addunit{\\teslabase}%\n        {\\kilogram\\usk\\second\\rpsquared\\usk\\reciprocal\\ampere}\n\\addunit{\\henrybase}%\n        {\\squaremetre\\usk\\kilogram\\usk\\second\\rpsquared\\usk\\rpsquare\\ampere}\n\\addunit{\\celsiusbase}%\n        {\\kelvin}\n\\addunit{\\lumenbase}%\n        {\\candela\\usk\\squaremetre\\usk\\rpsquare\\metre}\n\\addunit{\\luxbase}%\n        {\\candela\\usk\\squaremetre\\usk\\rpfourth\\metre}\n\\addunit{\\becquerelbase}%\n        {\\hertzbase}\n\\addunit{\\graybase}%\n        {\\squaremetre\\usk\\second\\rpsquared}\n\\addunit{\\sievertbase}%\n        {\\graybase}\n\\addunit{\\katalbase}%\n        {\\rp\\second\\usk\\mole }\n}\n\\newcommand*\\SIunits@opt@derived{%\n\\addunit{\\derradian}%\n        {\\metre\\usk\\reciprocal\\metre}\n\\addunit{\\dersteradian}%\n        {\\squaremetre\\usk\\rpsquare\\metre}\n\\addunit{\\derhertz}%\n        {\\reciprocal\\second}\n\\addunit{\\dernewton}%\n        {\\metre\\usk\\kilogram\\usk\\second\\rpsquared}\n\\addunit{\\derpascal}%\n        {\\newton\\usk\\rpsquare\\metre}\n\\addunit{\\derjoule}%\n        {\\newton\\usk\\metre}\n\\addunit{\\derwatt}%\n        {\\joule\\usk\\reciprocal\\second}\n\\addunit{\\dercoulomb}%\n        {\\ampere\\usk\\second}\n\\addunit{\\dervolt}%\n        {\\watt\\usk\\reciprocal\\ampere}\n\\addunit{\\derfarad}%\n        {\\coulomb\\usk\\reciprocal\\volt}\n\\addunit{\\derohm}%\n        {\\volt\\usk\\reciprocal\\ampere}\n\\addunit{\\dersiemens}%\n        {\\ampere\\usk\\reciprocal\\volt}\n\\addunit{\\derweber}%\n        {\\squaremetre\\usk\\kilogram\\usk\\second\\rpsquared\\usk\\reciprocal\\ampere}\n\\addunit{\\dertesla}%\n        {\\weber\\usk\\rpsquare\\metre}\n\\addunit{\\derhenry}%\n        {\\weber\\usk\\reciprocal\\ampere}\n\\addunit{\\dercelsius}%\n        {\\kelvin}\n\\addunit{\\derlumen}%\n        {\\candela\\usk\\steradian}\n\\addunit{\\derlux}%\n        {\\lumen\\usk\\rpsquare\\metre}\n\\addunit{\\derbecquerel}%\n        {\\derhertz}\n\\addunit{\\dergray}%\n        {\\joule\\usk\\reciprocal\\kilogram}\n\\addunit{\\dersievert}%\n        {\\dergray}\n\\addunit{\\derkatal}%\n        {\\katalbase}\n     \\typeout{Option `derived\' provided!}}\n\\addunit{\\minute}{min}\n\\addunit{\\hour}{h}\n\\addunit{\\dday}{d}\n\\addunit{\\degree}{\\no@qsk\\ensuremath{^{\\circ}}}\n\\addunit{\\paminute}{\\no@qsk\\ensuremath{\'}}\n\\addunit{\\arcminute}{\\no@qsk\\ensuremath{\'}}\n\\addunit{\\pasecond}{\\no@qsk\\ensuremath{\'\'}}\n\\addunit{\\arcsecond}{\\no@qsk\\ensuremath{\'\'}}\n\\addunit{\\ton}{t}\n\\addunit{\\tonne}{t}\n\\addunit{\\liter}{L}\n\\addunit{\\litre}{l}\n\\addunit{\\neper}{Np}\n\\addunit{\\bel}{B}\n\\addunit{\\curie}{Ci}\n\\addunit{\\rad}{rad}\n\\addunit{\\arad}{rd}\n\\addunit{\\rem}{rem}\n\\addunit{\\roentgen}{R}\n\\addunit{\\electronvolt}{e\\volt}\n\\addunit{\\atomicmass}{u}\n\\addunit{\\are}{a}\n\\addunit{\\hectare}{\\hecto\\are}\n\\addunit{\\barn}{b}\n\\addunit{\\bbar}{bar}\n\\addunit{\\gal}{Gal}\n\\addunit{\\angstrom}{\\mbox{{\\AA}}}\n\\addunit{\\rperminute}{r\\per\\minute}\n\\addunit{\\rpersecond}{r\\per\\second}\n\\addunit{\\squaremetre}{\\SI@square\\metre}\n\\addunit{\\cubicmetre}{\\cubic\\metre}\n\\addunit{\\graypersecond}{\\gray\\per\\second}\n\\addunit{\\graypersecondnp}{\\gray\\usk\\reciprocal\\second}\n\\addunit{\\metrepersquaresecond}{\\metre\\per\\second\\squared}\n\\addunit{\\metrepersquaresecondnp}{\\metre\\usk\\second\\rpsquared}\n\\addunit{\\joulepermole}{\\joule\\per\\mole}\n\\addunit{\\joulepermolenp}{\\joule\\usk\\reciprocal\\mole}\n\\addunit{\\molepercubicmetre}{\\mole\\per\\cubic\\metre}\n\\addunit{\\molepercubicmetrenp}{\\mole\\usk\\rpcubic\\metre}\n\\addunit{\\radianpersquaresecond}{\\radian\\per\\second\\squared}\n\\addunit{\\radianpersquaresecondnp}{\\radian\\usk\\second\\rpsquared}\n\\addunit{\\kilogramsquaremetrepersecond}{\\kilogram\\usk\\squaremetre\\per\\second}\n\\addunit{\\kilogramsquaremetrepersecondnp}{\\kilogram\\usk\\squaremetre\\usk\\reciprocal\\second}\n\\addunit{\\radianpersecond}{\\radian\\per\\second}\n\\addunit{\\radianpersecondnp}{\\radian\\usk\\reciprocal\\second}\n\\addunit{\\squaremetrepercubicmetre}{\\squaremetre\\per\\cubic\\metre}\n\\addunit{\\squaremetrepercubicmetrenp}{\\squaremetre\\usk\\rpcubic\\metre}\n\\addunit{\\katalpercubicmetre}{\\katal\\per\\cubic\\metre}\n\\addunit{\\katalpercubicmetrenp}{\\katal\\usk\\rpcubic\\metre}\n\\addunit{\\coulombpermol}{\\coulomb\\per\\mole}\n\\addunit{\\coulombpermolnp}{\\coulomb\\usk\\reciprocal\\mole}\n\\addunit{\\amperepersquaremetre}{\\ampere\\per\\squaremetre}\n\\addunit{\\amperepersquaremetrenp}{\\ampere\\usk\\rpsquare\\metre}\n\\addunit{\\kilogrampercubicmetre}{\\kilogram\\per\\cubic\\metre}\n\\addunit{\\kilogrampercubicmetrenp}{\\kilogram\\usk\\rpcubic\\metre}\n\\addunit{\\squaremetrepernewtonsecond}{\\squaremetre\\per\\newton\\usk\\second}\n\\addunit{\\squaremetrepernewtonsecondnp}{\\squaremetre\\usk\\reciprocal\\newton\\usk\\reciprocal\\second}\n\\addunit{\\pascalsecond}{\\pascal\\usk\\second}\n\\addunit{\\coulombpercubicmetre}{\\coulomb\\per\\cubic\\metre}\n\\addunit{\\coulombpercubicmetrenp}{\\coulomb\\usk\\rpcubic\\metre}\n\\addunit{\\amperemetresecond}{\\ampere\\usk\\metre\\usk\\second}\n\\addunit{\\voltpermetre}{\\volt\\per\\metre}\n\\addunit{\\voltpermetrenp}{\\volt\\usk\\reciprocal\\metre}\n\\addunit{\\coulombpersquaremetre}{\\coulomb\\per\\squaremetre}\n\\addunit{\\coulombpersquaremetrenp}{\\coulomb\\usk\\rpsquare\\metre}\n\\addunit{\\faradpermetre}{\\farad\\per\\metre}\n\\addunit{\\faradpermetrenp}{\\farad\\usk\\reciprocal\\metre}\n\\addunit{\\ohmmetre}{\\ohm\\usk\\metre}\n\\addunit{\\kilowatthour}{\\kilo\\watt\\hour}\n\\addunit{\\wattpersquaremetre}{\\watt\\per\\squaremetre}\n\\addunit{\\wattpersquaremetrenp}{\\watt\\usk\\rpsquare\\metre}\n\\addunit{\\joulepersquaremetre}{\\joule\\per\\squaremetre}\n\\addunit{\\joulepersquaremetrenp}{\\joule\\usk\\rpsquare\\metre}\n\\addunit{\\newtonpercubicmetre}{\\newton\\per\\cubic\\metre}\n\\addunit{\\newtonpercubicmetrenp}{\\newton\\usk\\rpcubic\\metre}\n\\addunit{\\newtonperkilogram}{\\newton\\per\\kilogram}\n\\addunit{\\newtonperkilogramnp}{\\newton\\usk\\reciprocal\\kilogram}\n\\addunit{\\jouleperkelvin}{\\joule\\per\\kelvin}\n\\addunit{\\jouleperkelvinnp}{\\joule\\usk\\reciprocal\\kelvin}\n\\addunit{\\jouleperkilogram}{\\joule\\per\\kilogram}\n\\addunit{\\jouleperkilogramnp}{\\joule\\usk\\reciprocal\\kilogram}\n\\addunit{\\coulombperkilogram}{\\coulomb\\per\\kilogram}\n\\addunit{\\coulombperkilogramnp}{\\coulomb\\usk\\reciprocal\\kilogram}\n\\addunit{\\squaremetrepersecond}{\\squaremetre\\per\\second}\n\\addunit{\\squaremetrepersecondnp}{\\squaremetre\\usk\\reciprocal\\second}\n\\addunit{\\squaremetrepersquaresecond}{\\squaremetre\\per\\second\\squared}\n\\addunit{\\squaremetrepersquaresecondnp}{\\squaremetre\\usk\\second\\rpsquared}\n\\addunit{\\kilogrammetrepersecond}{\\kilogram\\usk\\metre\\per\\second}\n\\addunit{\\kilogrammetrepersecondnp}{\\kilogram\\usk\\metre\\usk\\reciprocal\\second}\n\\addunit{\\candelapersquaremetre}{\\candela\\per\\squaremetre}\n\\addunit{\\candelapersquaremetrenp}{\\candela\\usk\\rpsquare\\metre}\n\\addunit{\\amperepermetre}{\\ampere\\per\\metre}\n\\addunit{\\amperepermetrenp}{\\ampere\\usk\\reciprocal\\metre}\n\\addunit{\\joulepertesla}{\\joule\\per\\tesla}\n\\addunit{\\jouleperteslanp}{\\joule\\usk\\reciprocal\\tesla}\n\\addunit{\\henrypermetre}{\\henry\\per\\metre}\n\\addunit{\\henrypermetrenp}{\\henry\\usk\\reciprocal\\metre}\n\\addunit{\\kilogrampersecond}{\\kilogram\\per\\second}\n\\addunit{\\kilogrampersecondnp}{\\kilogram\\usk\\reciprocal\\second}\n\\addunit{\\kilogrampersquaremetresecond}{\\kilogram\\per\\squaremetre\\usk\\second}\n\\addunit{\\kilogrampersquaremetresecondnp}{\\kilogram\\usk\\rpsquare\\metre\\usk\\reciprocal\\second}\n\\addunit{\\kilogrampersquaremetre}{\\kilogram\\per\\squaremetre}\n\\addunit{\\kilogrampersquaremetrenp}{\\kilogram\\usk\\rpsquare\\metre}\n\\addunit{\\kilogrampermetre}{\\kilogram\\per\\metre}\n\\addunit{\\kilogrampermetrenp}{\\kilogram\\usk\\reciprocal\\metre}\n\\addunit{\\joulepermolekelvin}{\\joule\\per\\mole\\usk\\kelvin}\n\\addunit{\\joulepermolekelvinnp}{\\joule\\usk\\reciprocal\\mole\\usk\\reciprocal\\kelvin}\n\\addunit{\\kilogramperkilomole}{\\kilogram\\per\\kilo\\mole}\n\\addunit{\\kilogramperkilomolenp}{\\kilogram\\usk\\kilo\\reciprocal\\mole}\n\\addunit{\\kilogramsquaremetre}{\\kilogram\\usk\\squaremetre}\n\\addunit{\\kilogramsquaremetrenp}{\\kilogramsquaremetre}\n\\addunit{\\kilogrammetrepersquaresecond}{\\kilogram\\usk\\metre\\per\\second\\squared}\n\\addunit{\\kilogrammetrepersquaresecondnp}{\\kilogram\\usk\\metre\\usk\\second\\rpsquared}\n\\addunit{\\newtonpersquaremetre}{\\newton\\per\\squaremetre}\n\\addunit{\\newtonpersquaremetrenp}{\\newton\\usk\\rpsquare\\metre}\n\\addunit{\\persquaremetresecond}{1\\per\\squaremetre\\usk\\second}\n\\addunit{\\persquaremetresecondnp}{\\rpsquare\\metre\\usk\\reciprocal\\second}\n\\addunit{\\wattperkilogram}{\\watt\\per\\kilogram}\n\\addunit{\\wattperkilogramnp}{\\watt\\usk\\reciprocal\\kilogram}\n\\addunit{\\wattpercubicmetre}{\\watt\\per\\cubic\\metre}\n\\addunit{\\wattpercubicmetrenp}{\\watt\\usk\\rpcubic\\metre}\n\\addunit{\\wattpersquaremetresteradian}{\\watt\\per\\squaremetre\\usk\\steradian}\n\\addunit{\\wattpersquaremetresteradiannp}{\\watt\\usk\\rpsquare\\metre\\usk\\rp\\steradian}\n\\addunit{\\jouleperkilogramkelvin}{\\joule\\per\\kilogram\\usk\\kelvin}\n\\addunit{\\jouleperkilogramkelvinnp}{\\joule\\usk\\reciprocal\\kilogram\\usk\\reciprocal\\kelvin}\n\\addunit{\\squaremetreperkilogram}{\\squaremetre\\per\\kilogram}\n\\addunit{\\rpsquaremetreperkilogram}{\\squaremetre\\usk\\reciprocal\\kilogram}\n\\addunit{\\cubicmetreperkilogram}{\\cubic\\metre\\per\\kilogram}\n\\addunit{\\rpcubicmetreperkilogram}{\\cubic\\metre\\usk\\reciprocal\\kilogram}\n\\addunit{\\newtonpermetre}{\\newton\\per\\metre}\n\\addunit{\\newtonpermetrenp}{\\newton\\usk\\reciprocal\\metre}\n\\addunit{\\Celsius}{\\ensuremath{\\SI@fstyle{C}}}\n\\addunit{\\wattpermetrekelvin}{\\watt\\per\\metre\\usk\\kelvin}\n\\addunit{\\wattpermetrekelvinnp}{\\watt\\usk\\reciprocal\\metre\\usk\\reciprocal\\kelvin}\n\\addunit{\\newtonmetre}{\\newton\\usk\\metre} \\addunit{\\newtonmetrenp}{\\newtonmetre}\n\\addunit{\\squaremetrepercubicsecond}{\\squaremetre\\per\\cubic\\second}\n\\addunit{\\squaremetrepercubicsecondnp}{\\squaremetre\\usk\\rpcubic\\second}\n\\addunit{\\metrepersecond}{\\metre\\per\\second}\n\\addunit{\\metrepersecondnp}{\\metre\\usk\\reciprocal\\second}\n\\addunit{\\joulepercubicmetre}{\\joule\\per\\cubicmetre}\n\\addunit{\\joulepercubicmetrenp}{\\joule\\usk\\rpcubic\\metre}\n\\addunit{\\kilogrampercubicmetrecoulomb}{\\kilogram\\per\\cubic\\metre\\usk\\coulomb}\n\\addunit{\\kilogrampercubicmetrecoulombnp}{\\kilogram\\usk\\rpcubic\\metre\\usk\\reciprocal\\coulomb}\n\\addunit{\\cubicmetrepersecond}{\\cubicmetre\\per\\second}\n\\addunit{\\rpcubicmetrepersecond}{\\cubicmetre\\usk\\reciprocal\\second}\n\\addunit{\\kilogrampersecondcubicmetre}{\\kilogram\\per\\second\\usk\\cubicmetre}\n\\addunit{\\kilogrampersecondcubicmetrenp}{\\kilogram\\usk\\reciprocal\\second\\usk\\rpcubic\\metre}\n\\DeclareOption{cdot}{\\@cdot{Option `cdot\' provided!}}\n\\DeclareOption{thickspace}{\\@thickspace{Option `thickspace\' provided!}}\n\\DeclareOption{mediumspace}{\\@mediumspace{Option `mediumspace\' provided!}}\n\\DeclareOption{thinspace}{\\@thinspace{Option `thinspace\' provided!}}\n\\DeclareOption{thickqspace}{\\@thickqspace{Option `thickqspace\' provided!}}\n\\DeclareOption{mediumqspace}{\\@mediumqspace{Option `mediumqspace\' provided!}}\n\\DeclareOption{thinqspace}{\\@thinqspace{Option `thinqspace\' provided!}}\n\\DeclareOption{textstyle}{\\renewcommand\\SI@fstyle[1]{\\@text{\\protect#1}}%\n\\@textstyletrue%\n\\typeout{Option `textstyle\' provided!}}\n\\DeclareOption{amssymb}{\\@redefsquaretrue%\n\\typeout{Option `amssymb\' provided!}}\n\\DeclareOption{squaren}{\\@defsquarentrue%\n\\typeout{Option `squaren\' provided!}}\n\\DeclareOption{pstricks}{\\@redefGraytrue%\n\\typeout{Option `pstricks\' provided!}}\n\\DeclareOption{Gray}{\\@defGraytrue%\n\\typeout{Option `Gray\' provided!}}\n\\DeclareOption{italian}{\\@defitaliantrue%\n\\typeout{Option `italian\' provided!}}\n\\DeclareOption{binary}{\\@optionbinarytrue }\n\\AtEndOfPackage{\\if@optionbinary\\RequirePackage{binary}\\fi}\n\\DeclareOption{derivedinbase}{\\SIunits@opt@derivedinbase}\n\\DeclareOption{derived}{\\SIunits@opt@derived}\n\\DeclareOption{noams}{\\@optionNoAMStrue%\n\\typeout{Option `noams\' provided!}}\n\\DeclareOption*{\\PackageWarningNoLine{SIunits}{What is `\\CurrentOption\'?}}\n\\InputIfFileExists{SIunits.cfg}{}%\n{\\PackageWarningNoLine{SIunits}{You have no `SIunits.cfg\' file installed.\n\\MessageBreak I will assume you are using `thickspace\' and `thickqspace\'}\n\\ExecuteOptions{thickspace,thickqspace}}\n\\ProcessOptions\\relax\n%% \n%%  Source: $Id: SIunits.sty,v 1.1.1.1 2003/02/26 03:15:34 amb Exp $\n%%\n%% End of file `SIunits.sty\'.\n'
p0
.I0
.S'titling'
p0
.S'$style_file: titling\n%%\n%% This is file `titling.sty\',\n%% generated with the docstrip utility.\n%%\n%% The original source files were:\n%%\n%% titling.dtx  (with options: `usc\')\n%% \n%% -----------------------------------------------------------------\n%%   Author: Peter Wilson (Herries Press)\n%%   Maintainer: Will Robertson (will dot robertson at latex-project dot org)\n%%   Copyright 2000--2004 Peter R. Wilson\n%% \n%%   This work may be distributed and/or modified under the\n%%   conditions of the LaTeX Project Public License, either\n%%   version 1.3c of this license or (at your option) any\n%%   later version: <http://www.latex-project.org/lppl.txt>\n%% \n%%   This work has the LPPL maintenance status "maintained".\n%%   The Current Maintainer of this work is Will Robertson.\n%% \n%%   This work consists of the files listed in the README file.\n%% -----------------------------------------------------------------\n%% \n\\NeedsTeXFormat{LaTeX2e}\n\\ProvidesPackage{titling}[2009/09/04 v2.1d maketitle typesetting]\n\n\\newcommand{\\pretitle}[1]{\\def\\@bspretitle{#1}}\n\\newcommand{\\posttitle}[1]{\\def\\@bsposttitle{#1}}\n\\newcommand{\\preauthor}[1]{\\def\\@bspreauthor{#1}}\n\\newcommand{\\postauthor}[1]{\\def\\@bspostauthor{#1}}\n\\newcommand{\\predate}[1]{\\def\\@bspredate{#1}}\n\\newcommand{\\postdate}[1]{\\def\\@bspostdate{#1}}\n\n\\if@titlepage\n  \\pretitle{\\begin{center}\\LARGE}\n  \\posttitle{\\par\\end{center}\\vskip 2em}\n  \\preauthor{\\begin{center}\n    \\large \\lineskip .75em%\n    \\begin{tabular}[t]{c}}\n  \\postauthor{\\end{tabular}\\par\\end{center}}\n  \\predate{\\begin{center}\\large}\n  \\postdate{\\par\\end{center}}\n\\else\n  \\pretitle{\\begin{center}\\LARGE}\n  \\posttitle{\\par\\end{center}\\vskip 0.5em}\n  \\preauthor{\\begin{center}\n    \\large \\lineskip .5em%\n    \\begin{tabular}[t]{c}}\n  \\postauthor{\\end{tabular}\\par\\end{center}}\n  \\predate{\\begin{center}\\large}\n  \\postdate{\\par\\end{center}}\n\\fi\n\n\\newcommand{\\maketitlehooka}{}\n\\newcommand{\\maketitlehookb}{}\n\\newcommand{\\maketitlehookc}{}\n\\newcommand{\\maketitlehookd}{}\n\n\\newcommand{\\thanksmarkseries}[1]{%\n  \\def\\@bsmarkseries{\\renewcommand{\\thefootnote}{\\@nameuse{#1}{footnote}}}}\n\\newcommand{\\symbolthanksmark}{\\thanksmarkseries{\\fnsymbol}}\n\\newcommand{\\@bscontmark}{\\setcounter{footnote}{0}}\n\\newcommand{\\continuousmarks}{\\def\\@bscontmark{}}\n\\newcommand{\\thanksheadextra}[2]{%\n  \\def\\@bsthanksheadpre{#1}%\n  \\def\\@bsthanksheadpost{#2}}\n\\newcommand{\\thanksfootextra}[2]{%\n  \\def\\thanksfootpre{#1}%\n  \\def\\thanksfootpost{#2}}\n\n\\DeclareRobustCommand{\\thanksmark}[1]{\\footnotemark[#1]}\n\\newcommand{\\thanksgap}[1]{\\hspace{#1}}\n\\newcommand{\\tamark}{\\@thefnmark}\n\n\\newlength{\\thanksmarkwidth}\n\\newlength{\\thanksmargin}\n\\newcommand{\\thanksscript}[1]{\\textsuperscript{#1}}\n\\newcommand{\\makethanksmarkhook}{}\n\n\\newcommand{\\thanksfootmark}{%\n  \\hb@xt@\\thanksmarkwidth{\\hfil\\normalfont\\thanksscript{%\n    \\thanksfootpre \\tamark \\thanksfootpost}}}\n\n\\newcommand{\\makethanksmark}{%\n  \\leavevmode%\n  \\makethanksmarkhook\\relax\n  \\parindent 1em\\noindent\n  \\leftskip\\thanksmargin\\relax\n  \\advance\\leftskip \\thanksmarkwidth \\null\\nobreak\\hskip -\\leftskip\n  \\thanksfootmark\n}\n\n\\newcommand{\\usethanksrule}{\\let\\footnoterule\\thanksrule}\n\\newcommand{\\cancelthanksrule}{\\let\\footnoterule\\@bsfootnoterule}\n\n\\if@titlepage\n  \\thanksmarkseries{arabic}    % normal footnote numbers\n\\else\n  \\thanksmarkseries{fnsymbol}\n\\fi\n\\thanksheadextra{}{}\n\\thanksfootextra{}{}\n\\setlength{\\thanksmarkwidth}{1.8em}\n\\setlength{\\thanksmargin}{-\\thanksmarkwidth}\n\n\\AtBeginDocument{%\n  \\let\\thanksrule\\footnoterule\n  \\let\\@bsfootnoterule\\footnoterule\n}\n\n\\newlength{\\droptitle}\n\\setlength{\\droptitle}{0pt}\n\n\\providecommand{\\maketitle}{}\n\\if@titlepage\n  \\renewcommand{\\maketitle}{\\begin{titlepage}%\n    \\let\\footnotesize\\small\n    \\let\\footnoterule\\relax\n    \\let \\footnote \\thanks\n    \\@bsmarkseries\n      \\def\\@makefnmark{\\rlap{\\@textsuperscript{%\n         \\normalfont\\@bsthanksheadpre \\tamark \\@bsthanksheadpost}}}%\n      \\long\\def\\@makefntext##1{\\makethanksmark ##1}\n    \\null\\vfil\n    \\vskip 60\\p@\n    \\vspace*{\\droptitle}\n    \\maketitlehooka\n    {\\@bspretitle \\@title \\@bsposttitle}\n    \\maketitlehookb\n    {\\@bspreauthor \\@author \\@bspostauthor}\n    \\maketitlehookc\n    {\\@bspredate \\@date \\@bspostdate}\n    \\maketitlehookd\n    \\par\n    \\@thanks\n    \\vfil\\null\n    \\end{titlepage}%\n    \\@bscontmark  %  \\setcounter{footnote}{0}%\n%%%    \\@bsmtitlempty\n  } % end titlepage defs\n\\else\n  \\renewcommand{\\maketitle}{\\par\n    \\begingroup\n      \\@bsmarkseries\n      \\def\\@makefnmark{\\rlap{\\@textsuperscript{%\n         \\normalfont\\@bsthanksheadpre \\tamark \\@bsthanksheadpost}}}%\n      \\long\\def\\@makefntext##1{\\makethanksmark ##1}\n      \\if@twocolumn\n        \\ifnum \\col@number=\\@ne\n          \\@maketitle\n        \\else\n          \\twocolumn[\\@maketitle]%\n        \\fi\n      \\else\n        \\newpage\n        \\global\\@topnum\\z@\n        \\@maketitle\n      \\fi\n      \\thispagestyle{plain}\\@thanks\n    \\endgroup\n    \\@bscontmark  %  \\setcounter{footnote}{0}%\n%%%    \\@bsmtitlempty\n  } % end non-titlepage\n\n  \\def\\@maketitle{%\n    \\newpage\n    \\null\n    \\vskip 2em%\n          \\vspace*{\\droptitle}\n    \\maketitlehooka\n    {\\@bspretitle \\@title \\@bsposttitle}\n    \\maketitlehookb\n    {\\@bspreauthor \\@author \\@bspostauthor}\n    \\maketitlehookc\n    {\\@bspredate \\@date \\@bspostdate}\n    \\maketitlehookd\n    \\par\n    \\vskip 1.5em}\n\\fi\n\n\\newenvironment{titlingpage}%\n  {%\n   \\let\\footnoterule\\relax\n   \\let\\footnotesize\\small\n   \\if@twocolumn\n     \\@restonecoltrue\\onecolumn\n   \\else\n     \\@restonecolfalse\n   \\fi\n   \\thispagestyle{empty}\n   \\setcounter{page}\\@ne\n  }{%\n   \\thispagestyle{empty}\n   \\if@restonecol\\twocolumn \\else \\newpage \\fi\n   \\if@twoside\\else \\setcounter{page}\\@ne\\fi}\n\n\\newcommand{\\calccentering}[2]{\n  #1 = \\paperwidth\n  \\advance #1 by -\\textwidth\n  \\divide #1 by \\tw@\n  \\advance #1 by -#2\n  \\advance #1 by -\\hoffset\n  \\advance #1 by -1in\n}\n\n\\newcommand{\\emptythanks}{\\global\\let\\@thanks\\@empty}\n\n\\newcommand{\\@bsmtitlempty}{%\n  \\global\\let\\maketitle\\relax\n  \\global\\let\\@maketitle\\relax\n  \\global\\let\\title\\relax\n  \\global\\let\\author\\relax\n  \\global\\let\\date\\relax\n  \\global\\let\\thanksmarkseries\\relax\n  \\global\\let\\thanksheadextra\\relax\n  \\global\\let\\thanksfootextra\\relax\n  \\global\\let\\thanksmark\\relax\n  \\global\\let\\thanksgap\\relax\n}\n\n\\newcommand{\\keepthetitle}{%\n  \\@bsmtitlempty\n  \\global\\let\\thanks\\relax\n  \\global\\let\\and\\relax\n  \\global\\let\\@thanks\\@empty\n  \\global\\let\\@title\\@empty\n  \\global\\let\\@author\\@empty\n  \\global\\let\\@date\\@empty\n}\n\n\\providecommand{\\killtitle}{}\n\\renewcommand{\\killtitle}{%\n  \\keepthetitle\n  \\global\\let\\thetitle\\relax\n  \\global\\let\\theauthor\\relax\n  \\global\\let\\thedate\\relax\n}\n\n\\providecommand{\\appendiargdef}[2]{\\begingroup\n  \\toks@\\expandafter{#1{##1}#2}%\n  \\edef\\@bsx{\\endgroup \\def\\noexpand#1####1{\\the\\toks@}}%\n  \\@bsx}\n\n\\appendiargdef{\\title}{%\n  \\begingroup\n    \\renewcommand{\\thanks}[1]{}\n    \\renewcommand{\\thanksmark}[1]{}\n    \\renewcommand{\\thanksgap}[1]{}\n    \\protected@xdef\\thetitle{#1}\n  \\endgroup}\n\\appendiargdef{\\author}{%\n  \\begingroup\n    \\renewcommand{\\thanks}[1]{}\n    \\renewcommand{\\and}{\\unskip, }\n    \\renewcommand{\\thanksmark}[1]{}\n    \\renewcommand{\\thanksgap}[1]{}\n    \\protected@xdef\\theauthor{#1}\n  \\endgroup}\n\\appendiargdef{\\date}{%\n  \\begingroup\n    \\renewcommand{\\thanks}[1]{}\n    \\renewcommand{\\thanksmark}[1]{}\n    \\renewcommand{\\thanksgap}[1]{}\n    \\protected@xdef\\thedate{#1}\n  \\endgroup}\n\n\\endinput\n%%\n%% End of file `titling.sty\'.\n'
p0
.I0
.S'Classfile'
p0
.S'You can add your custom classfile here.'
p0
.I1
.S'jpaper'
p0
.S'$class: jpaper\n\\NeedsTeXFormat{LaTeX2e}\n% \\ProvidesClass{jpaper}[ASPLOS 2014 Submission template]\n\\ProvidesClass{jpaper}[2012/08/02 ISCA Submission template]\n\n% jpaper provides two modes:\n% In addition to the usual options leqno and fleqn, jpaper also provides the\n% following additional flags (each of which can be turned on by specifying the\n% flag as an option, or turned off by specifying "no"flag as an option):\n% * lineno: Enables line numbering. This may be useful while editing.\n% * pageno: Enables page numbering. This is useful for anything that is not\n% * hyperref: Enables the hyperref package. While the hyperref package is\n%   normally convenient for your readers, IEEE PDF-eXpress does not allow it.\n%\n% The default set of options is camera,nolineno,nopageno,nohyperref.\n\n\\RequirePackage{etoolbox}\n\n\\DeclareOption{leqno}{\\input{leqno.clo}}\n\\DeclareOption{fleqn}{\\input{fleqn.clo}}\n\\newtoggle{jp@lineno}\n\\newtoggle{jp@pageno}\n\\newtoggle{jp@hyperref}\n\\DeclareOption{lineno}{\\toggletrue{jp@lineno}}\n\\DeclareOption{nolineno}{\\togglefalse{jp@lineno}}\n\\DeclareOption{pageno}{\\toggletrue{jp@pageno}}\n\\DeclareOption{nopageno}{\\togglefalse{jp@pageno}}\n\\DeclareOption{hyperref}{\\toggletrue{jp@hyperref}}\n\\DeclareOption{nohyperref}{\\togglefalse{jp@hyperref}}\n\\ExecuteOptions{nolineno,pageno,hyperref}\n\\ProcessOptions\n\n% Load the underlying article class.\n\\LoadClass[letterpaper,10pt,twocolumn]{article}\n\n\n% Standard packages.\n\\RequirePackage[utf8]{inputenc}\n\\RequirePackage[T1]{fontenc}\n\\RequirePackage{verbatim}\n\\RequirePackage{fixltx2e}\n\\RequirePackage[usenames,dvipsnames,svgnames,table]{xcolor}\n\n% Basic text typesetting options.\n\\RequirePackage{mathptmx}\n\\RequirePackage[scaled=0.833]{helvet}\n\\RequirePackage[scaled=0.875]{couriers}\n\\setlength{\\parindent}{1em}\n\\RequirePackage{setspace}\n\\newcommand{\\normalspacing}{}\n\\RequirePackage{microtype}\n\n% High penalty for widows and orphans\n\\widowpenalty=300 \\clubpenalty=300\n\n% Page margins:\n% 3/4" left and right, 1" top, 1 1/8" bottom.\n\\RequirePackage{geometry}\n\\geometry{lmargin=0.7in,rmargin=0.7in,tmargin=.8in,bmargin=.8in}\n\n% 1/4" space between columns.\n\\setlength{\\columnsep}{0.25in}\n\n% Title formatting.\n\\RequirePackage{titling}\n\\setlength{\\droptitle}{-3.5em}\n\n\\pretitle{\\begin{center}\\vspace{-.5in}\nISCA Submission \\#\\iscasubmissionnumber -- Confidential Draft -- Do Not Distribute!!\\\\\n\\vspace{.35in}\n\\normalfont\\Large\\bfseries}\n\\posttitle{\\par\\end{center}}\n\\preauthor{\\begin{center}\\normalfont\\large%\n    \\begin{tabular}[t]{c}}\n\\postauthor{\\end{tabular}\\par\\end{center}}\n\\predate{}\n\\postdate{}\n\n\n% The abstract should be normally sized and italicized. Abstract leading\n% should, in general, follow the normal leading.\n\\RequirePackage{abstract}\n\\newcommand{\\abstractspacing}{\\normalspacing}\n\\renewcommand{\\abstractnamefont}{\\normalfont\\large\\bfseries}\n\\renewcommand{\\abstracttextfont}{\\normalfont\\itshape\\abstractspacing}\n\\setlength{\\absleftindent}{0in}\n\\setlength{\\absrightindent}{0in}\n\\setlength{\\abstitleskip}{-1.5em}\n\n% Compress vertical space around section and subsection headings. Make\n% subsubsection headings run-in (i.e. part of the following paragraph).\n\\RequirePackage[compact]{titlesec}\n\\titleformat{\\section}[hang]{\\normalfont\\large\\bfseries}{\\thesection. }%\n  {0pt}{}{}\n\\titleformat{\\subsection}[hang]{\\normalfont\\bfseries}{\\thesubsection. }%\n  {0pt}{}{}\n\\titleformat{\\subsubsection}[runin]{\\normalfont\\bfseries}{\\thesubsubsection. }%\n  {0pt}{}{}\n\\newlength{\\sectionspace}\n\\setlength{\\sectionspace}{1.5ex plus 0.25ex}\n\\titlespacing*{\\section}{0pt}{\\sectionspace}{\\sectionspace}\n\\titlespacing*{\\subsection}{0pt}{\\sectionspace}{\\sectionspace}\n\\titlespacing*{\\subsubsection}{0pt}{\\parskip}{0.25em plus 0.1em minus 0.05em}\n\n% Compress itemize and enumerate environments.\n\\RequirePackage{enumerate}\n\\RequirePackage{enumitem}\n\\setlist{noitemsep, leftmargin=*, topsep=0pt, partopsep=0pt}\n\n% Bibliography formatting.\n\\newcommand{\\bibspacing}{\\setstretch{0}}\n\\let\\jp@bibliography\\thebibliography\n\\renewcommand{\\thebibliography}[1]{%\n  \\jp@bibliography{#1}%\n  \\setlength{\\itemsep}{-0.25em} \\footnotesize \\bibspacing%\n  \\vspace{-0.25em}}\n% This is IEEEtran\'s bibliography formatting control macro.\n\\def\\bstctlcite{\\@ifnextchar[{\\@bstctlcite}{\\@bstctlcite[@auxout]}}\n\\def\\@bstctlcite[#1]#2{\\@bsphack\n  \\@for\\@citeb:=#2\\do{%\n    \\edef\\@citeb{\\expandafter\\@firstofone\\@citeb}%\n    \\if@filesw\\immediate\\write\\csname #1\\endcsname%\n      {\\string\\citation{\\@citeb}}\\fi}%\n  \\@esphack}\n\n% Settings for figures and tables. Figure captions are placed below the figure,\n% while table captions are placed above the table. All captions are sans-serif.\n\\RequirePackage[font={normalsize,sf,bf}]{caption}\n%\\RequirePackage[position=bottom]{subfig}\n\\captionsetup[table]{aboveskip=0.5em, belowskip=0.5em}\n\\captionsetup[figure]{aboveskip=0.5em, belowskip=0em}\n\\captionsetup[subfloat]{font={small,sf}}\n\\setcounter{topnumber}{2}\n\\setcounter{dbltopnumber}{2}\n\\setcounter{bottomnumber}{2}\n\\setcounter{totalnumber}{4}\n\\renewcommand{\\topfraction}{0.85}\n\\renewcommand{\\dbltopfraction}{0.9}\n\\renewcommand{\\bottomfraction}{0.85}\n\\renewcommand{\\textfraction}{0.07}\n\\renewcommand{\\floatpagefraction}{0.85}\n\\renewcommand{\\dblfloatpagefraction}{0.85}\n\n\\setlength{\\floatsep}{0.5em plus 0.2em minus 0.2em}\n\\setlength{\\dblfloatsep}{0.5em plus 0.2em minus 0.2em}\n\\setlength{\\textfloatsep}{0.5em plus 0.2em minus 0.2em}\n\\setlength{\\dbltextfloatsep}{0.5em plus 0.2em minus 0.2em}\n\n% Utility packages for floats and tables.\n\\RequirePackage{float}\n\\RequirePackage{graphicx}\n\\RequirePackage{booktabs}\n\\RequirePackage{multirow}\n\n% Page numbering.\n\\iftoggle{jp@pageno}{%\n  \\pagestyle{plain}\n  \\newcommand{\\jp@mt@pageno}{}}{%\n  \\pagestyle{empty}\n  \\newcommand{\\jp@mt@pageno}{\\thispagestyle{empty}}}\n\n% Line numbering.\n\\iftoggle{jp@lineno}{%\n  \\RequirePackage{lineno}\n  \\renewcommand{\\linenumberfont}{\\normalfont\\tt\\small}\n  \\newcommand{\\jp@mt@lineno}{\\linenumbers}\n}{%\n  \\newcommand{\\jp@mt@lineno}{}\n}\n\n% Replace maketitle to invoke settings for leading, page numbering, and line\n% numbering.\n\\let\\jp@maketitle\\maketitle\n\\renewcommand{\\maketitle}{%\n  \\jp@maketitle%\n  \\jp@mt@pageno%\n  \\jp@mt@lineno%\n  \\normalspacing}\n\n% Footnotes may not span pages.\n\\interfootnotelinepenalty=10000\n\n% Formatting for margin notes (which you may find useful during editing).\n\\let\\jp@marginpar\\marginpar\n\\renewcommand\\marginpar[1]{\\jp@marginpar%\n  [\\raggedleft\\singlespacing\\footnotesize\\color{red} #1]%\n  {\\raggedright\\singlespacing\\footnotesize\\color{red} #1}}\n\n\\setlength{\\marginparwidth}{0.65in}\n\n% Link and URL formatting.\n\\iftoggle{jp@hyperref}{%\n  \\RequirePackage{hyperref}\n  \\hypersetup{%\n    unicode=true,%\n    pdfstartview={FitH},%\n    colorlinks=true,%\n    citecolor=red,%\n    %filecolor=black,%\n    %linkcolor=black,%\n    %urlcolor=black\n}}{}\n\\RequirePackage{url}\n\n% Scientific units.\n\\RequirePackage[squaren]{SIunits}\n\n\\endinput\n'
p0
.I0
.S'Head'
p0
.S''
p0
.I6
.S'Doc class'
p0
.S'$head:\n\\documentclass[pageno]{jpaper}\n\n\\newcommand{\\iscasubmissionnumber}{376}\n\\date{}'
p0
.I0
.S'Prereqs'
p0
.S'$head:\n\\usepackage{epsfig}\n\\usepackage{amsmath,environ}\n\\usepackage{color}\n\\usepackage{graphicx}\n\\usepackage{listings}\n\\usepackage{pdfsync}\n\\usepackage{caption}\n\\usepackage{algorithm}\n%\\usepackage[ruled,vlined,commentsnumbered]{algorithm2e}\n%\\usepackage{algorithmic}\n\\usepackage{algpseudocode}\n\\usepackage{subcaption}\n\\usepackage{todonotes}\n\\newcommand{\\redcomment}[1]{\\todo[inline,color=red!40,size=\\small]{#1}}\n\\newcommand{\\greencomment}[1]{\\todo[inline,color=green!40,size=\\small]{#1}}\n\\newcommand{\\bluecomment}[1]{\\todo[inline,color=blue!40,size=\\small]{#1}}\n\\newcommand{\\yellowcomment}[1]{\\todo[inline,color=yellow!40,size=\\small]{#1}}\n\\lstset{language=C++, basicstyle=\\footnotesize}'
p0
.I0
.S'Recommended'
p0
.S'$head: \\usepackage{balance}\n\\usepackage{cite}'
p0
.I0
.S'Your stuff'
p0
.S'$head: \\linespread{0.98}'
p0
.I0
.S'Start doc'
p0
.S'$head: \\begin{document}\n'
p0
.I0
.S'Authors'
p0
.S'\n\\author{\n}'
p0
.I0
.S'Tail'
p0
.S''
p0
.I1
.S'Standard Tail'
p0
.S'$tail: \\bibliographystyle{unsrt}\n%\\singlespacing\n%\\scriptsize\n\\balance\n\\bibliography{bib}\n\\end{document}'
p0
.I0
.