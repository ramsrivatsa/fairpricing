S'Snap'
p0
.S'SnapCharge: A System Architecture for Fair Pricing in Infrastructure-as-a-Service Clouds\n'
p0
.I2
.S'Main Sections'
p0
.S''
p0
.I8
.S'Abstract'
p0
.S''
p0
.I2
.S'Problem'
p0
.S'$absp: Infrastructure-as-a-service (IaaS) clouds primarily use a pricing model that charges users a flat hourly fee for running their applications on shared servers. This pricing model leads to the unfortunate scenario whereby users incur higher fees when their application happens to be scheduled to co-run with an application that contends for microarchitectural resources.  However, this problem remains unsolved for IaaS cloulds due to the lack of a \\emph{scalable}, \\emph{accurate} and \\emph{lightweight} technique for live, continuous estimation of the performance degradation caused by co-running virtual machines (VMs) on cloud servers.\n\n% Moreover, the users of heavily contentious applications pay nothing for the disutility they cause to other users.'
p0
.I0
.S'Solution'
p0
.S"$absp: To address this problem, this paper introduces \\textbf{SnapCharge}, a runtime mechanism for estimating the degradation caused by co-running VMs in public clouds. SnapCharge uses a novel \\emph{snapshot} technique that uses strategic phase-triggered millisecond-scale micro-experiments to orchestrate a scalable, precise and low-overhead interference estimation engine that can be continuously deployed in IaaS cloud environments to facilitate fair pricing. Addressing this problem to enable \\emph{fair pricing} allows IaaS clouds to develop robust pricing models that charge users a fee congruent to their resource usage rather than as a function of the behavior of other users' applications. We evaluate snapshot for a wide spectrum of workload scenarios and applications, demonstrating that it seamlessly scales up to 16 VMs and can estimate performance degradation to within 4\\% of ground truth while introducing a negligible performance overhead of less than 1\\%."
p0
.I1
.S'$omit!:$gcmt:MAL - add a \\$ result to the end of abstract'
p0
.S''
p0
.I0
.S'Introduction'
p0
.S'$s:Introduction'
p0
.I8
.S'Importance of cloud'
p0
.S'$p: Cloud computing has emerged as a key technology in a number of ways over the past few years, evidenced by the fact that 93\\% of the organizations is either running applications or experimenting with Infrastructure-as-a-Service (IaaS) cloud~\\cite{forbes}. With IaaS cloud computing emerging to be the most preferred choice, it becomes increasingly important to leverage its benefits as efficiently as possible. \n\n'
p0
.I0
.S'Status of IaaS clouds'
p0
.S'$p: Infrastructure-as-a-Service (IaaS) cloud computing enables users to take advantage of the computing infrastructures under the pay-as-you-go scheme. Cloud providers rely on virtualization to provide the isolated computing resources called instances (or virtual machines) to each customer~\\cite{aws,gce}. High resource utilization is achieved by consolidating virtual machines into a single server. However, consolidation of virtual machines (VMs) belonging to different users leads to performance interference with each other. This interference leads to \\emph{unfair pricing} and, while users can opt to purchase dedicated server resources, this interference particularly problematic for the pricing schemes affecting the wide variety of users whose applications are run on shared server allocations~\\cite{Nathuji:2010:QMP:1755913.1755938,Govindan:2011:CQE:2038916.2038938,Ahn:2012:DVM:2342763.2342782,Varadarajan:2012:RAI:2382196.2382228,Vasic:2012:DAR:2248487.2151021,Novakovic:2013:DTI:2535461.2535489,Ma:2015:SDS:2694344.2694382,Liu:2014:OVM:2665671.2665720, 6522328}. On these shared servers users can specify the quantity of virtual CPUs, memory and disk, but cannot specify the requirements for shared architectural resources like last level cache, memory bandwidth and memory controller.'
p0
.I0
.S'Motivation graph'
p0
.S'$p:  Figure~\\ref{fig:comparecorun} shows performance degradation when the applications on the x-axis from SiriusSuite~\\cite{sirius}, DjiNN \\& Tonic~\\cite{djinn}, and SPEC CPU2006 co-run with \\texttt{libquantum} and \\texttt{povray}. In such a scenario, the \\texttt{Question Answer} application becomes 1.97x slower when co-running with \\texttt{libquantum} due to contention of shared architectural resources. On the other hand, when co-locating with \\texttt{povray}, the performance overhead is negligible. From the perspective of users, this slowdown in execution time is not accounted for because IaaS cloud providers calculate the price on an hourly basis based on the amount of time each application takes to execute and not the actual utilization server microarchitectural resources.  This practice has been noted to discourage users and leads to users gaming the system~\\cite{Varadarajan:2012:RAI:2382196.2382228}.\n'
p0
.I2
.S'$fig:comparecorun,1:'
p0
.S''
p0
.I0
.S'$graph:comparecorun:Slowdown in execution time of applications when running with co-runners. Users end up paying more when their applications are co-located with libquantum.\\vspace{-0.3in}:1'
p0
.S'from collections import defaultdict\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ncolocationListBaseline = [ \'colocating with perlbench\', \'colocating with astar\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with bzip2\', \'colocating with libquantum\', \'colocating with lbm\', \'colocating with sphinx3\', \'colocating with soplex\' ]\n#runningList = [ \'mcf\', \'colocating with bzip2\', \'mcf\', \'colocating with astar\', \'mcf\', \'colocating with soplex\', \'mcf\', \'colocating with lbm\', \'mcf\', \'colocating with libquantum\' ]\nrunningList1 = [ \'libquantum\', \'colocating with povray\', \'libquantum\', \'colocating with libquantum\']\nrunningList2 = [ \'lbm\', \'colocating with povray\', \'lbm\', \'colocating with libquantum\']\nrunningList3 = [  \'soplex\', \'colocating with povray\', \'soplex\', \'colocating with libquantum\']\nrunningList4 = [ \'gmm\', \'colocating with povray\', \'gmm\', \'colocating with libquantum\']\nrunningList5 = [   \'crf\', \'colocating with povray\', \'crf\', \'colocating with libquantum\']\nrunningList6 = [  \'nlp-pos\', \'colocating with povray\', \'nlp-pos\', \'colocating with libquantum\']\nbenchListExperiments = [\'lbm\', \'libquantum\', \'soplex\']\nbenchListExperiments2 = [\'gmm\', \'crf\', \'nlp-pos\']\nbenchListExperiments3 = [\'lbm\', \'libquantum\', \'soplex\', \'speech\', \'crf\', \'NLP\']\nxlabels = [\'Speech\\nRecognition\', \'Question\\nAnswer\', \'Natural\\nLanguage\\nProcessing\', \'lbm\', \'libquantum\', \'soplex\' ]\ngmm=0.74\ncrf=0.55\nnlp_pos=0.45\nlibquantum=0.59\nlbm=0.95\nsoplex=1.3\ndef autolabel(rects):\n    # attach some text labels\n    for rect in rects:\n        height = rect.get_height()\n        plt.text(rect.get_x()-rect.get_width()/2., 1.1*height, \'%.2fx\'%float(height), size=\'15\')\n\ndef autolabel2(rects):\n    # attach some text labels\n    for rect in rects:\n        height = rect.get_height()\n        plt.text(rect.get_x(), 1.05*height, \'%.2fx\'%float(height), size=\'15\')\n\nfilename = \'shutter_cpi_5\'\nfList2 = [s.strip() for s in open(\'../../papergraphs/1.1intrograph/degradation/spec.txt\').readlines()]\nfList3 = [s.strip() for s in open(\'../../papergraphs/1.1intrograph/degradation/sirius.txt\').readlines()]\n\ndictList_degradation_colocation = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_colocation_sirius = defaultdict(lambda  : defaultdict(list))\n\nlabels = [\'0x\', \'1x\', \'2x\', \'3x\', \'4x\']\n\nfor (b,a) in enumerate(fList2):\n    if a in colocationListBaseline:\n        index = a\n    else:\n        if a in benchListExperiments:\n            dictList_degradation_colocation[index][a].append(float(fList2[b+1]))\n\nfor (b,a) in enumerate(fList3):\n    if a in colocationListBaseline:\n        index = a\n    else:\n        if a in benchListExperiments2:\n            dictList_degradation_colocation_sirius[index][a].append(float(fList3[b+1]))\n\nyaxis = ()\nyaxis2 = ()\nxaxis = ()\n#xaxis = xaxis + (\'solo app\',)\n#yaxis = yaxis + (1,)\n#yaxis2= yaxis2 + (1,)\n#sorting the ground truth values\nfor a in xrange(0,len(runningList1),2):\n    j = runningList1[a+1]\n    i = runningList1[a]\n    #yaxis = yaxis + (np.mean(dictList_degradation_colocation[j][i])/np.mean(dictList_degradation_colocation[\'colocating with bzip2\'][i]), )\n    yaxis = yaxis + (np.mean(dictList_degradation_colocation[j][i])/libquantum, )\nfor a in xrange(0,len(runningList2),2):\n    j = runningList2[a+1]\n    i = runningList2[a]\n    #yaxis = yaxis + (np.mean(dictList_degradation_colocation[j][i])/np.mean(dictList_degradation_colocation[\'colocating with bzip2\'][i]), )\n    yaxis = yaxis + (np.mean(dictList_degradation_colocation[j][i])/lbm, )\nfor a in xrange(0,len(runningList3),2):\n    j = runningList3[a+1]\n    i = runningList3[a]\n    #yaxis = yaxis + (np.mean(dictList_degradation_colocation[j][i])/np.mean(dictList_degradation_colocation[\'colocating with bzip2\'][i]), )\n    yaxis = yaxis + (np.mean(dictList_degradation_colocation[j][i])/soplex, )\n\nfor a in xrange(0,len(runningList4),2):\n    j = runningList4[a+1]\n    i = runningList4[a]\n    yaxis2= yaxis2 + (np.mean(dictList_degradation_colocation_sirius[j][i])/gmm, )\n    #print j,i,dictList_degradation_colocation_sirius[j][i]\n\nfor a in xrange(0,len(runningList5),2):\n    j = runningList5[a+1]\n    i = runningList5[a]\n    yaxis2= yaxis2 + (np.mean(dictList_degradation_colocation_sirius[j][i])/crf, )\n    #print j,i,dictList_degradation_colocation_sirius[j][i]\n\nfor a in xrange(0,len(runningList6),2):\n    j = runningList6[a+1]\n    i = runningList6[a]\n    yaxis2= yaxis2 + (np.mean(dictList_degradation_colocation_sirius[j][i])/nlp_pos, )\n    #print j,i,dictList_degradation_colocation_sirius[j][i]\n#print yaxis,yaxis2\n\n\nyaxis_povray = ()\nyaxis_libquantum = ()\n\nfor (count,item) in enumerate(yaxis2):\n    if count%2 == 0:\n        yaxis_povray = yaxis_povray + (item , )\n    else:\n        yaxis_libquantum = yaxis_libquantum + (item, )\n\nfor (count,item) in enumerate(yaxis):\n    if count%2 == 0:\n        yaxis_povray = yaxis_povray + (item , )\n    else:\n        yaxis_libquantum = yaxis_libquantum + (item, )\n\n\n#print yaxis_povray, yaxis_libquantum\n\n\n\nwidth=0.25\nx = np.arange(len(yaxis))\nfig = plt.figure(figsize=(10, 5))\nax1 = fig.add_subplot(111)\nbar1 = ax1.bar( x, yaxis_povray, width, color="y", label=\'co-running with povray\')\nax2 = ax1.twinx()\nbar2 = ax2.bar( x+width, yaxis_libquantum, width, color="r", label=\'co-running with libquantum\')\nautolabel(bar1)\nax1.set_xlim(0,6)\nax1.set_ylim(0,4)\nax1.set_yticklabels((\'\', \'\', \'1x\',\'\', \'2x\', \'\', \'3x\', \'\', \'4x\', \'\') , size=\'18\')\nax2.set_ylim(0,4)\nax2.set_yticklabels((\'\', \'\', \'$1000\',\'\', \'$2000\', \'\', \'$3000\', \'\', \'$4000\', \'\') , size=\'18\')\nax1.set_xticklabels(xlabels,  ha=\'left\', rotation=\'0\', size=\'16\')\nautolabel2(bar2)\nax1.legend(prop={\'size\':17}, loc=2)\nax2.legend(prop={\'size\':17}, loc=1)\nplt.tight_layout()\nplt.grid()\n'
p0
.I0
.S'Solution for fair pricing'
p0
.S'$p: To enable \\emph{fair pricing} on public clouds, a methodology is needed to precisely measure performance degradation incurred by co-runners. This necessitates the dynamic estimation of solo performance of applications when running alone to quantify the degree of performance degradation due to co-runners. Although there have been some prior work on predicting interference~\\cite{fairpricing, 6844481, Tang:2013:RRS:2451116.2451126, bubbleflux}, several key open challenges must be addressed to realize a solution that is suitable to be deployed in IaaS clouds:\n\n\\begin{enumerate}\n\\item \\textbf{Scalable} - Since there are a number of cores in modern server platforms, a solution that is scalable to the number of instances of VMs that may be simultaneously co-running is needed. As such, this solution must estimate performance degradation that is being experienced by all cores on a typical server.\n\n\\item \\textbf{Accurate} - These solutions should be accurate in estimating performance degradation, as these performance estimations directly correlate to pricing which customers have to pay.\n\n\\item \\textbf{Lightweight} - Production environments only allow solutions to pose a small amount of overhead. Companies such as Google can tolerate not more than 1\\% to 2\\% degradation for supporting runtime profiling technique~\\cite{overheadgoogle}.\n\\end{enumerate}\n'
p0
.I0
.S'Introduction to snapshot'
p0
.S"$p:In this paper, we propose \\textit{SnapCharge}, a solution that uses a novel \\emph{snapshot} technique to estimate performance degradation during runtime with high accuracy and negligible overhead. The key insight underlying the design of the \\textit{snapshot} technique is that the fact that execution behaviors of applications do not significantly change within a single phase can be exploited to realize a measurement mechanism that is scalable to the number of hardware contexts on a single server. Snapshots remove the need to take multiple degradation measurements within a single phase and triggers an interference estimation event on phase and co-phase boundaries to provide a lightweight runtime system with low overhead. As a result, the effective time for which we try to estimate performance degradation is negligible. \n\nSnapshot works by performing dynamic measurements where a micro-pause is introduced to a VM's co-runners when the VM changes phases, allowing snapshot to measure the solo performance of the VM. Comparing this solo performance measurement to measurements made once all co-runners have resumed allows degradation to be estimated. Triggering these \\emph{interference estimation events} is a carefully designed mechanism that leverages carefully selected performance monitoring units (PMUs) measurements in concert with lightweight processing to avoid detecting \\emph{false phase boundaries} -- changes in application behavior that are the result of measurement fluctuations or changes in co-runner contentiousness -- while detecting \\emph{true phase boundaries} -- actual changes in application behavior. Thus, interference estimation events occur only when they allow snapshot to refine its estimates of performance degradation. As a result of this design, our technique is resilient to overhead issues that have proved prohibitive for a scalable and deployable design."
p0
.I0
.S'Introduction to phase detection mechanism'
p0
.S'$p:\nTo enable \\textit{snapshot}, one of the most significant challenges is to precisely, efficiently, and continuously detect not only phase, but also co-phase changes in public clouds. In this paper, we design a solution that leverages PMUs to capture both phase and co-phase changes of applications running on VMs in a highly efficient manner. Since each application has different sensitivities on architectural resources, we identify and use a mix of PMU types that can differentiate phase changes across applications. We perform cross validation on these selected PMU types on a spectrum of application workloads to demonstrate generality. Using snapshot, we are able to continuously monitor the performance implications of inter-VM interference and enable a fair pricing solution on modern commodity servers. The new contributions of this paper are as follows.'
p0
.I0
.S'Summarize of contribution'
p0
.S'$p:\n\n\\begin{itemize}\n\\item \\textbf{Snapshot Technique:} We introduce \\textit{snapshot}, a scalable, accurate and lightweight mechanism for estimating performance degradation for applications running in public clouds. \n\n\\item \\textbf{Phase Triggered Measurement:} We design a novel phase triggered mechanism based on a set of performance monitoring units for identifying execution behaviors of applications and evaluate how the selected PMUs generalize to a variety of applications.\n\n\\item \\textbf{SnapCharge - Pricing RUNtime Engine:} We describe a runtime system for fair pricing that enables customers to pay as though their application runs in isolation. Since it does not require any modifications of hypervisors or guest operating systems, our runtime system can be deployed in public clouds today.\n\n\\item \\textbf{Real-system Evaluation:} \nWe perform a thorough evaluation of our runtime system on real systems for a variety of applications including SiriusSuite~\\cite{sirius}, DjiNN\\&Tonic Suite~\\cite{djinn} and SPEC CPU2006. In addition, we perform scalability studies to evaluate the effectiveness of proposed runtime for future IaaS clouds.\n\n\\end{itemize}'
p0
.I0
.S'Results discussion'
p0
.S'$p: Using our runtime engine, we are able to precisely estimate the performance degradation in co-located environments with a mean absolute error of around 4\\% and negligible overhead of less than 1\\% for a wide spectrum of workload scenarios that are being executed in current day IaaS clouds. We have also evaluated our technique on different microarchitectural platforms to demonstrate its platform independent nature. Compared to prior interference prediction techniques~\\cite{fairpricing, 6844481}, our technique shows up to 4x more accuracy with 5x less overhead, and is deployable in current and future IaaS public clouds. '
p0
.I0
.S'Background and Related work'
p0
.S'$s:Background and Motivation'
p0
.I4
.S'IaaS Public Clouds'
p0
.S'$s: IaaS Public Clouds'
p0
.I1
.S'Note'
p0
.S'$p: Most public clouds take advantage of virtualization technology to provide an isolated computing infrastructure to each customer as well as to improve the utilization of their cloud datacenters.  Commercial cloud providers serve a variety of types of virtual machines to satisfy the diverse requirements of users. For each VM allocation, customers choose suitable resource capabilities such as the number of virtual CPUs, the amount of memory and storage size based on their demands. The price range for a given VM allocation differs based on instance types and capabilities. '
p0
.I0
.S'Pricing Schemes and Challenges'
p0
.S'$s:Pricing Schemes and Challenges'
p0
.I1
.S'Note'
p0
.S"$p: To charge fees to customers, public clouds such as Amazon EC2~\\cite{aws-pricing} and Google Compute Engine~\\cite{gce-pricing} charge an hourly rate based on execution time of the VM. Although the pay-as-you-go scheme is an attractive pricing model for its simplicity, it overlooks the fact that the computing resources can be shared between different customers. The application performance of users could be easily affected by other customers using the shared computing resources. If a virtual machine undergoes performance degradation due to resource contention, the victim ends up paying more due to their increased execution time. \n\nTo mitigate the fairness problem, we could consider having strict quality of service (QoS) agreements between service providers and customers. However, it is difficult to define QoS metrics in public clouds because the applications running inside VMs are not visible to the IaaS platform. Even with insights into the nature of broad categories of applications such as web serving or business analytics, applications within the same category often have different execution characteristics. For example, there can be two users running web servers on clouds, but each web server might be customized for their own purpose. Then, QoS metrics like request per second (RPS) would be difficult to use.\n\nThe most accurate way of eliminating biased pricing schemes is to measure performance degradation due to co-running applications during runtime. However, it is challenging in co-located environments like public clouds as architectural resources such as last level cache and memory bandwidth, which are shared among users, make it difficult to estimate performance degradation for each user's VM. \n"
p0
.I0
.S'State of-the-art solution and its limitations'
p0
.S'$s:State-of-the-Art Solution and Its Limitations'
p0
.I1
.S'Note'
p0
.S'$p: There are two classes of prior approaches for estimating the amount of performance degradation in co-located environments~\\cite{fairpricing, 6844481, bubbleflux, Tang:2013:RRS:2451116.2451126}. These techniques periodically pause all the co-running applications for a short time, allowing one application to continue running. During this pause, the running application monopolizes the computing resources on the system to determine the degree of performance degradation. Although this approach is a straightforward technique, there are three limitations: 1) not scalable, 2) low accuracy, and 3) high overhead. Due to those limitations, prior techniques are not deployable in modern IaaS clouds.'
p0
.I0
.S'Related Work'
p0
.S'$s: Related Work'
p0
.I4
.S'Table'
p0
.S'$t: \n\\begin{table}[bt!]\n\\begin{footnotesize}\n\\centering\n  \\resizebox{\\columnwidth}{!}{\n\\begin{tabular}{|l|lll|ll|}\n\\hline\n                                                                          & \\multicolumn{3}{l|}{System Approaches}                                                                                    & \\multicolumn{2}{l|}{Architectural Support}                                                                                                     \\\\ \\cline{2-6} \n                                                                          & SnapCharge & \\begin{tabular}[c]{@{}l@{}}Quality \\\\ Time\\end{tabular} & \\begin{tabular}[c]{@{}l@{}}Fair \\\\ Pricing\\end{tabular} & MISE                                                        & STFM                                                        \\\\ \\hline\n\\begin{tabular}[c]{@{}l@{}}Deployability in \\\\ public clouds\\end{tabular} & \\checkmark     & \\checkmark                                                       & \\checkmark                                                       & X                                                           & X                                                           \\\\\n\\begin{tabular}[c]{@{}l@{}}Overhead\\\\ (worst case)\\end{tabular}           & 5\\%   & 40\\%                                                    & 40\\%                                                    & \\begin{tabular}[c]{@{}l@{}}Hardware\\\\ Overhead\\end{tabular} & \\begin{tabular}[c]{@{}l@{}}Hardware\\\\ Overhead\\end{tabular} \\\\\n\\begin{tabular}[c]{@{}l@{}}Error\\\\ (worst case)\\end{tabular}              & 10\\%  & 45\\%                                                    & 45\\%                                                    & 20\\%                                                        & 83\\%                                                        \\\\\nPhase analysis                                                            & \\checkmark     & X                                                       & X                                                       & X                                                           & X                                                           \\\\ \\hline\n\\end{tabular}\n}\n\n\\caption{Comparison to prior work ( for 4 cores ) \\vspace{-0.3in}}\n\\label{table:comparison}\n\\end{footnotesize}\n\\end{table}'
p0
.I0
.S'Summary'
p0
.S'$p:There have been many prior studies to detect performance interference in a variety aspects of architectural resources. We categorize the prior work into two broad types. We look first into the system and OS level approaches and then address the architectural supports for detecting the interference. \n'
p0
.I0
.S'System and OS'
p0
.S'$p: {\\bf System/OS  approaches: } There are many efforts introducing software frameworks and proposing the new designs of operating systems~\\cite{Govindan:2011:CQE:2038916.2038938,bubbleup,Yang:2013:BPO:2485922.2485974,Tang:2013:RRS:2451116.2451126,Nathuji:2010:QMP:1755913.1755938, Park:2013:RCH:2451116.2451137, Liu:2014:GVM:2665671.2665698}. \nQ-Cloud measures the resource capacity for satisfying QoS in a dedicated server called staging server and then decides the placement which server will be profitable to minimize the interference. Nevertheless, the QoS could be violated by allowing co-location. To avoid this situation, the system provides additional resources from head-room by reserving presubscribed amount of resources. If the placement meets the target QoS, the head-room would be utilized in a best-effort manner~\\cite{Nathuji:2010:QMP:1755913.1755938}. To  precisely estimate the performance interferences without profiling on a dedicated server, Bubble-up~\\cite{bubbleup} and Cuanta~\\cite{Govindan:2011:CQE:2038916.2038938} designed the synthetic workloads to understand the degree of interference when co-locating applications. Bubble-up probes the interference by using synthetic workloads and determines whether to allow co-location or not so as to meet the QoS of latency critical applications running on datacenters. POPPA~\\cite{fairpricing} and QualityTime~\\cite{6844481} proposed similar runtime approaches to measure performance of each application in co-located environment. The most accurate way of measuring performance for an individual application is to observe its solo execution. They perceived this concept by pausing other co-runners during a small amount of time. Then, the target application can monopolize resources without any interference. Meanwhile, Soares et al. studied the concept of pollute buffer in shared last level caches to prevent filling the shared caches as non-reusable data. It focused on improving the utilization of shared caches through OS-level page allocation~\\cite{Soares:2008:RHE:1521747.1521800}. Zhuravlev et al. extended the CPU scheduler to alleviate the degree of interferences in a native system. The goal of this work is to schedule the threads by evenly distributing the load intensity to caches~\\cite{Zhuravlev:2010:ASR:1736020.1736036}. Blagodurov et al. proposed that the scheduler needs to consider the effects of NUMA~\\cite{Blagodurov:2011:CNC:2002181.2002182}. Also, there are many prior studies to solve the contention problems such as shared last level cache and NUMA by scheduling virtual machines~\\cite{Ahn:2012:DVM:2342763.2342782,6522328,Liu:2014:OVM:2665671.2665720}.'
p0
.I0
.S'Architectural supports'
p0
.S'$p: {\\bf Architectural Supports: } \nThere are various approaches mitigating performance interference and guaranteeing fairness in shared caches, memory controller and bandwidth. \nNesbit et al. employed the network fair queuing model in the memory scheduler to meet the fairness~\\cite{Nesbit:2006:FQM}. Mutlu and Moscibroda focused on DRAM specific architectures such as row buffers and multi banks~\\cite{stfm}. They pointed out that modern DRAM controllers only consider maximizing throughputs instead of fairness. To alleviate the problem, they introduced the memory scheduling technique to ensure the fairness between threads. Ebrahimi et al. extended the fairness problem in memory subsystems by including shared last level cache and memory bandwidth~\\cite{fst}. This work focused on the source incurring performance interference and proposed throttling mechanism by controlling injection rates of requests to alleviate the contention of shared resources. Subramanian et al. further investigated the shared memory subsystem in terms of fairness~\\cite{6522356}.\nSuh et al. firstly discussed the cache partitioning scheme to efficiently use the shared resources~\\cite{Suh:2002:NMM:874076.876484}. Qureshi et al. proposed utility based cache partitioning technique to achieve high performance~\\cite{Qureshi:2006:UCP:1194816.1194855}. They developed utility monitors to track the efficiency of caches for each application and then decided the degree of cache partitioning to minimize the total cache misses from all applications. Rafique et al. studied the cache and bandwidth managements by cooperating operating system and hardware~\\cite{Rafique:2006:ASO:1152154.1152160,Rafique:2007:EMD:1299042.1299052 }. To prevent the replacement from other applications, pinning the way of cache was introduced~\\cite{Srikantaiah:2008:ASP:1346281.1346299}. \nTraditionally, there are many prior studies in terms of detecting phase changes.  These works proposed architectural supports for efficiently detecting phase changes on CMP and SMT~\\cite{Dhodapkar:2003:CPP:956417.956539, Luque:2009:CAC:1591872.1591935, Luque:2009:IIC:1636712.1637756, 5989796, Luque:2013:FCT:2400682.2400709, Sherwood:2003:PTP:859618.859657, Lau:2005:TPC:1042442.1043427, Eyerman:2009:PCA:1508244.1508260}. \nRecently, to minimize the effects of cache pollutions, virtualization-aware prefetching techniques are introduced~\\cite{Daly,ReCap,Ahn:2014:MVP:2742155.2742195}. Table ~\\ref{table:comparison} provides a quantitative comparison of our proposed SnapCharge technique versus the state of the art interference prediction techniques. '
p0
.I0
.S'SnapCharge'
p0
.S'$s: SnapCharge: Pricing RUNtime Engine'
p0
.I7
.S'Overview'
p0
.S"$p:\nIn this section, we propose \\textbf{P}ricing \\textbf{R}untime \\textbf{E}ngine (SnapCharge), an online runtime engine for enabling fair pricing in public clouds. SnapCharge is based on \\textit{snapshot} technique on top of the phase triggered mechanism. \\textit{Snapshot} is an efficient and scalable technique to precisely detect, quantify, and account for performance degradation in public clouds. SnapCharge performs a snapshot of the system during whenever an application's phase changes. \n\nTo enable \\textit{snapshot}, we propose a phase triggered mechanism based on Performance Monitoring Units (PMUs). We provide a robust solution towards detecting runtime phase changes at co-located environments using PMUs. "
p0
.I0
.S'Snapshot'
p0
.S'$s: Snapshot Technique'
p0
.I4
.S'Design description'
p0
.S'$p: Our goal in the design of SnapCharge is to achieve high accuracy with low overhead in estimating unintended performance degradation on public clouds during runtime. In other words, this is the slowdown applications are subjected to, due to the presence of co-runners. To obtain that, we need to know the performance of the application during co-location $CPI_{(co-location)}$ as well as the performance of the application when it is running alone $CPI_{(solo)}$. Using these quantities, performance degradation of the applications can be easily identified using the following equation.\n\n\\begin{equation} \\label{eq:degradation_equation}\nPerformance Degradation = \\dfrac{CPI_{(co-location)}}{CPI_{(solo)}}\n\\end{equation}\n\n\n$CPI_{(co-location)}$ is the CPI of the application when the co-runners are running. $CPI_{(co-location)}$ is directly measured when the application is running along with the co-runners. A key challenge towards accomplishing this is to estimate the solo execution performance of the application $CPI_{(solo)}$ even during the presence of co-runners. To achieve this, our \\textit{snapshot} technique selectively pauses all the co-running VMs for a sufficient amount of time. During this time, we allow the un-paused VM to monopolize computing resources present in the system by taking a \\textit{snapshot} of the system. In other words, we measure the performance of the application during those pause periods. We use the aggregated value of these measurements to estimate the solo performance of that particular of the application.\n\nAn important challenge towards realizing this technique is to identify the right situations to perform snapshots. This is because excessive/unnecessary pausing of co-runners might cause drastic overhead problems. These right situations are identified as phase changes by us based on the following observations. Firstly, the execution behavior of applications does not drastically change within a single phase. It means that we need to estimate performance degradation once during every phase. On the other hand, most of the applications that we measure show that the number of phase changes is not many \\cite{Sherwood:2003:PTP:859618.859657, Dhodapkar:2003:CPP:956417.956539, DBLP:journals/jilp/HamerlyPLC05}. It gives us an opportunity to optimize our snapshot technique for common cases where applications have few phase changes. Therefore, we can estimate performance degradation with negligible overheads.'
p0
.I0
.S'$pdf_fig:snapshot_shuttering:Overview of snapshot technique\\vspace{-0.2in}:0.9'
p0
.S''
p0
.I1
.S'$fig:snapshot_shuttering,1:!'
p0
.S''
p0
.I0
.S'Figure Explanation'
p0
.S'$p: \n\nHence, in order to obtain the solo execution performance of an application $CPI_{(solo)}$, we use the CPI measurements that we had obtained during the pause periods. To be more precise, we aggregate the performance estimation of every individual phase of the VM to calculate the performance degradation for the entire execution of the application as shown by Equation \\ref{solo_equation}.\n\n\\begin{equation} \\label{solo_equation}\n\\small CPI_{(solo)} = \\dfrac{CPI_{(1)} \\times T_{(1)} + CPI_{(2)} \\times T_{(2)} + . . . . + CPI_{(n)} \\times T_{(n)}}{T_{1} + T_{2} . . . . + T_{n}}\n\\end{equation}\nwhere,\n\\begin{itemize}\n\\item $CPI_{(solo)}$ is estimated CPI of solo execution of an application.\n\\item $CPI_{(i)}$ is estimated CPI of solo execution of the application during phase $i$.\n\\item $T_{(i)}$ is time for which the application remains in phase $i$.\n\\item $n$ is total number of phases in the application.\n\\end{itemize}\n\nFigure \\ref{fig:snapshot_shuttering} shows how our \\textit{snapshot} technique estimates performance degradation. We can see from  Figure \\ref{fig:snapshot_shuttering} that whenever there is a phase change, the co-running VMs are paused by our runtime system to measure solo performance execution.\n'
p0
.I0
.S'Motivation for next section'
p0
.S'$p: To make \\textit{snapshot} technique viable, accurately triggering the snapshots during phase changes is very important. We discuss this in the next section.'
p0
.I0
.S'Phase Triggered Mechansim'
p0
.S'$s: Phase Triggered Mechanism\n'
p0
.I9
.S'$pdf_fig:type1:Exogenous phases. (a) Solo Execution of application. (b) Fluctuations in PMU type during co-location. (c) Co-phase interference during co-location\\vspace{-0.1in}:1'
p0
.S''
p0
.I1
.S'$fig:type1,1:!'
p0
.S''
p0
.I0
.S'Intro'
p0
.S"$p: The key challenge of phase triggered mechanism is to precisely identify changes. A phase is defined as an interval within a program's execution with similar behavior \\cite{DBLP:journals/jilp/HamerlyPLC05}. Changes in program behavior are referred to as endogenous phase changes which can be seen by the drastic increase or decrease in the Cycles Per Instruction (CPI) of an application. This drastic variation of CPI is clearly visible when an application is running alone making endogenous phase change detection very easy. However, public clouds which allow co-location of multiple VMs makes it difficult to identify endogenous phase changes. In the presence of co- runners, there are a number of unnecessary phase changes being detected due to fluctuations in PMU measurements or phase changes in co-running applications. These unnecessary phases referred to as exogenous phase changes do not reflect endogenous phase changes. Detecting phase changes during such situations will result in unnecessary pausing of co-runners leading to high overhead. In the next section, we try to investigate the situations during which exogenous phase changes occur so as to mitigate its counter effects.\n"
p0
.I0
.S'co-runner interference'
p0
.S'$s: Exogenous phase changes - Scenarios'
p0
.I2
.S'Note'
p0
.S"$p: \n\\begin{itemize}\n\\item \\textbf{Continious Fluctuation of PMU measurements} - \n\nStreaming PMU measurements belonging to a particular phase lie within a certain range of values. Whenever there is a phase change, incoming PMU measurements would lie within a different range of values. This is a common case during the solo execution of an application. On the other hand, in the presence of contentious co-runners, fluctuation of incoming PMU measurements makes it difficult for us to determine if they belong to the same phase or a new phase. This fluctuation is commonly observed for PMU types like Last Level Cache, CPI etc. This is because, during the presence of contentious co-runners, there is an excessive thrashing of these resources from time to time which results in such fluctuations. This phenomenon is illustrated in Figure ~\\ref{fig:type1}. Figure ~\\ref{fig:type1} (a) shows the phase of an application when it is running alone. Figure ~\\ref{fig:type1} (b) shows the PMU measurements when the application is running along with a co-runner. We can clearly see in Figure ~\\ref{fig:type1} (b) that some PMU measurements from phase 1 lie closer to the range of PMU measurements in phase 2 and vice versa. This is a common case with when the PMU measurements are of type Last Level Cache which is shared between multiple applications. \n\n\\item \\textbf{Co-phase interference} -  Co-running applications may change phases. This would interfere with the phase of the observed application resulting to a phase change due to the change in the range of incoming PMU measurements though there isn't an endogenous phase change actually. This phenomenon is called co-phase interference. In this situation, we need PMU measurements that can distinguish between endogenous phase changes and co-phase interference.  From Figure ~\\ref{fig:type1} (c), we see that the PMU measurements showing co-phase variation are equally significant compared to the endogenous phase changes. This can result in triggering unnecessary additional phase changes.\n\\end{itemize}\n\nFrom this, it is clear that detecting endogenous phase changes during co-located environments is challenging. Frequently triggering a phase change will result in increasing the overhead due to pausing of co-runners by our snapshot technique. Hence, we need to design the runtime system to accurately trigger snapshots during endogenous phase changes simultaneously minimizing triggering of unnecessary phase changes."
p0
.I0
.S'$omit!:$pdf_fig:type2:False phase due to co-phase interference:1'
p0
.S''
p0
.I1
.S'$fig:type2,1:!'
p0
.S''
p0
.I0
.S'$omit!Picking PMU types'
p0
.S'$s: Picking PMU types'
p0
.I1
.S'Note'
p0
.S'$p: \nIn order to trigger snapshots during inherent phase changes without triggering snapshots during unnecessary phase changes, we need a technique that could distinctly distinguish phase boundaries across a variety of applications. \n\nIt is evident that phase changes of applications can be clearly identified by observing architectural resource usages [cite][cite]. For example, the number of branch instructions executed by an application within a particular phase remains fairly constant. This is due to the fact that during that phase, the application would be executing the same region of the binary. Whenever the application switches to execute a different part of the binary, it is denoted by a variation in the number of branch instructions executed and is associated with a corresponding phase change. Hence we observe various architectural resource utilization at runtime to detect phase changes. We took advantage of performance monitoring units (PMUs) which helps us to observe the utilization of architectural resources at runtime. With the help of PMUs we can observe multiple architectural components to detect runtime phase changes and identify the best component which can detect phase changes across a varied class of applications. \n\n\n'
p0
.I0
.S'Finding Representative Types of PMU for Phase Detection'
p0
.S'$s:Finding Representative Types of PMU for Phase Detection'
p0
.I5
.S'$omit!:Table explanation 2'
p0
.S'$p: We first identify the best type of PMU for each application individually. This is identified based on two criteria. Firstly, the best type of PMU should detect all inherent phase changes present in solo execution of the application. Secondly, it should minimize falsely detecting phase changes due to the interference from co-runners. In other words, among the existing PMU types, which can detect all inherent phases present in solo execution of the application, the best type of PMU is the one which has the lowest number of falsely detected phase changes. The reason behind this is that minimizing the number of falsely detecting phase changes will reduce the overheads of pausing the VMs unnecessarily. Based on the best type of PMU obtained for the training applications, we can select a subset of PMU types to detect phase changes. \n\nTable \\ref{table:pmctype} shows the preferred types of PMU for eight applications ordered by the effectiveness in which they are able to detect phase changes. Due to the space limit, the table shows only three types of PMU among six types. Based on this order, we can choose a common subset of PMU types which can detect phase changes effectively across the training set of applications. Using this method, we obtain three types of PMU, \\textit{CPI, LLC store miss} and \\textit{L1-d cache load miss}, to capture phase changes for the eight training SPEC applications.'
p0
.I0
.S'Brief intro'
p0
.S'$p: In order to trigger snapshots during endogenous phase changes, we need a technique that could simultaneously distinguish phase changes across a variety of applications and discard fluctuations and co-phase interference. We investigated the runtime information provided by PMUs to achieve this goal. The key challenge here is to identify the right PMU type to perform phase detection across a wide variety of applications. This is because our experiments show that some PMU types are much more effective in discarding unnecessary phase changes at co-located environments. Hence, we investigate each and every available PMU type for gauging its effectiveness towards achieving the above-mentioned goal.\n\nTo utilize PMUs for capturing phase changes across a wide variety of applications, we initially take a training set of applications. We try to tune our parameters based on which phase changes are clearly identified for the training set. Later in section 5, we use the same parameters to cross validate our experiments on a set of different benchmarks under different co-running applications. We carefully choose our training set of applications to cover a wide range of contentiousness, sensitivity and phase changing attributes \\cite{Tang:2011:CVS:2000417.2000419}. The list of training applications is shown in Table ~\\ref{table:pmctype}. We use \\texttt{astar} as our training co-runner. \\texttt{Astar} is known to be both contentious as well as phasy. This can train our model to be resistant against both fluctuations as well as co-phase interference. \n\n\\begin{itemize}\n\\item \\textbf{1 - Solo profiling} We first profile the solo execution of the training set of applications to obtain its CPI over the number of retired instruction (time). From this, we identify the endogenous phase changes present in the application. We obtain a vector of timestamps where each entry denotes the timestamp at which a phase change occurs in an application. \n\n\\item \\textbf{2 - Colo profiling} As a first step towards identifying useful PMU types, we profile the training application to obtain PMU measurements with a training co-runner. We then observe this profile to identify if phases are being detected appropriately at the timestamps which are obtained from solo profiling. \n\n\\item \\textbf{3 - Quantifying the effectiveness of PMU type} The end goal of this process is to obtain the best PMU type to detect endogenous phase changes across a varied class of applications. To enable that we should quantify the effectiveness of individual PMU types for every single application. This is done by the PMU scoring technique as described in the Section \\ref{subsubsec:FindingRepresentativeTypesofPMUforPhaseDetection}. \n\n\\item \\textbf{4 - Ranking PMU types} Lastly, we rank the PMU types  for each application from the quantity obtained from the previous step. From observing the best PMU type for every single application, we try to obtain a single PMU type that can be utilized to detect phase changes across a varied class of application. \n\\end{itemize} \n'
p0
.I0
.S'$pdf_fig:fluctuations:Resistance to fluctuations by PMU types \\vspace{-0.2in}:1:!'
p0
.S''
p0
.I1
.S'$fig:fluctuations,1:'
p0
.S''
p0
.I0
.S'$pdf_fig:type3:Resistance to co-phase interference by PMU types \\vspace{-0.3in}:1:t!'
p0
.S''
p0
.I1
.S'$fig:type3,1:'
p0
.S''
p0
.I0
.S'PMU ordering table'
p0
.S'$t:\n\\begin{table}[bt!]\n\\begin{footnotesize}\n\\begin{tabular}{|l|lll|}\n\\hline\n\\multirow{2}{*}{{\\bf Application}} & \\multicolumn{3}{c|}{{\\bf PMU rank}}           \\\\ \\cline{2-4} \n                                   & {\\bf 1st}    & {\\bf 2nd} & {\\bf 3rd}    \\\\ \\hline\nastar                              & \\textbf{CPI}            & branch       & L1-D load miss \\\\\nbzip2                              &\\textbf{LLC store miss} & CPI          & L1-D load miss \\\\\ncactusADM                          & \\textbf{L1-D load miss} & L1-D load    & CPI            \\\\\ndealII                             & \\textbf{CPI}            & L1-D load    & branch         \\\\\nmcf                                & \\textbf{L1-D load miss} & CPI          & LLC load       \\\\\nmilc                               & \\textbf{LLC store miss} & L1-D load    & branch         \\\\\nxalancbmk                          & \\textbf{LLC store miss} & LLC load     & L1-D load      \\\\\ntonto                              & \\textbf{L1-D load miss} & branch       & CPI            \\\\ \\hline\n\\end{tabular}\n\\caption{PMU types ordered by their effectiveness \\vspace{-0.3in}}\n\\label{table:pmctype}\n\\end{footnotesize}\n\\end{table}'
p0
.I0
.S'$pdf_fig:triggerscoring:Overview of trigger scoring technique:1:!'
p0
.S''
p0
.I1
.S'$fig*:triggerscoring,2:!'
p0
.S''
p0
.I0
.S'$sub_fig*:PMUtypephase:Phase changes triggered by PMU types when running with \\texttt{astar}. Single PMU type is insufficient:mcfl1dastar,1:milcl1dastar,1:!'
p0
.S''
p0
.I4
.S'$graph_fig:mcfl1dastar:\\texttt{mcf}:1'
p0
.S'import matplotlib.pyplot as plt\nimport numpy as np\nfrom collections import defaultdict\nimport matplotlib.cm as cmx\nimport matplotlib.colors as cl\nimport matplotlib.pyplot as pl\n\n\nfilename = \'5\'\nf1 = [s.strip() for s in open(\'../../papergraphs/phases/pmutypes/single.txt\').readlines()]\nf2 = [s.strip() for s in open(\'../../papergraphs/phases/pmutypes/degradation.txt\').readlines()]\n#f3 = [s.strip() for s in open(\'../../papergraphs/phases/shutter_phase_%s.txt\' % filename).readlines()]\n\nbenchListBaseline = [ \'gcc\', \'perlbench\', \'mcf\', \'leslie3d\', \'povray\', \'libquantum\', \'astar\', \'bzip2\', \'milc\', \'namd\', \'calculix\', \'h264ref\', \'zeusmp\', \'gobmk\', \'hmmer\', \'tonto\', \'sphinx3\', \'bwaves\', \'gromacs\', \'dealII\', \'sjeng\', \'lbm\', \'xalancbmk\', \'gamess\', \'cactusADM\', \'soplex\', \'GemsFDTD\', \'omnetpp\' ]\nbenchListExperiments = [ \'gcc\', \'perlbench\', \'mcf\', \'leslie3d\', \'povray\', \'libquantum\', \'astar\', \'bzip2\', \'milc\', \'namd\', \'calculix\', \'h264ref\', \'zeusmp\', \'gobmk\', \'hmmer\', \'tonto\', \'sphinx3\', \'bwaves\', \'gromacs\', \'dealII\', \'sjeng\', \'lbm\', \'xalancbmk\', \'gamess\', \'cactusADM\', \'soplex\', \'GemsFDTD\', \'omnetpp\' ]\ncolocationListBaseline = [ \'colocating with mcf\', \'colocating with povray\', \'colocating with astar\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with bzip2\' ]\ncolocationListExperiments = [ \'colocating with mcf\', \'colocating with povray\', \'colocating with perlbench\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with bzip2\' ]\nrunningList = [ \'mcf\' ,\'colocating with astar\']\n\nphaseList_single = defaultdict(list)\nphaseList_degradation = defaultdict(lambda  : defaultdict(list))\nphaseList_shutter = defaultdict(lambda  : defaultdict(list))\nphaseList_colocation = defaultdict(lambda  : defaultdict(list))\n\n\nllc_miss_phaseList_single = defaultdict(list)\nllc_miss_phaseList_degradation = defaultdict(lambda  : defaultdict(list))\nllc_miss_phaseList_shutter = defaultdict(lambda  : defaultdict(list))\nllc_miss_phaseList_colocation = defaultdict(lambda  : defaultdict(list))\n\n\n\ndef setAxLinesBW(ax):\n    MARKERSIZE = 3\n    COLORMAP = {\n        \'g\': {\'marker\': None, \'dash\': (None,None)},\n        \'k\': {\'marker\': None, \'dash\': [5,5]},\n        \'r\': {\'marker\': None, \'dash\': [5,3,1,3]},\n        \'c\': {\'marker\': None, \'dash\': [1,3]},\n        \'m\': {\'marker\': None, \'dash\': [5,2,5,2,5,10]},\n        \'y\': {\'marker\': None, \'dash\': [5,3,1,2,1,10]},\n        \'b\': {\'marker\': \'+\', \'dash\': (None,None)} #[1,2,1,10]}\n        }\n\n    for line in ax.get_lines() + ax.get_legend().get_lines():\n        origColor = line.get_color()\n        line.set_color(\'black\')\n        line.set_dashes(COLORMAP[origColor][\'dash\'])\n        line.set_marker(COLORMAP[origColor][\'marker\'])\n        line.set_markersize(MARKERSIZE)\n\ndef setFigLinesBW(fig):\n    for ax in fig.get_axes():\n        setAxLinesBW(ax)\n\ndef color_maker(count, map=\'gnuplot2\', min=0.100, max=0.900):\n     assert(min >= 0.000 and max <= 1.000 and max > min)\n     gran=100000.0\n     maker = cmx.ScalarMappable(norm=cl.Normalize(vmin=0, vmax=int(gran)), cmap=pl.get_cmap(map))\n\n     r = [min*gran]\n     if count > 1:\n         r = [min*gran + gran*x*(max-min)/float(count-1) for x in range(0, count)]\n\n     return [maker.to_rgba(t) for t in r]\nfirstList1 = []\nsecondList1 = []\nthirdList1 = []\nfourthList1 = []\nfifthList1 = []\nsixthList1 = []\nseventhList1 = []\neighthList1 = []\n\nfor line in f1:\n    firstList1.append(line)\n\nfor line in f2:\n    secondList1.append(line)\n\n#for line in f3:\n#    thirdList1.append(line)\n\nglobal index\nglobal index2\n\nfor (j,i) in enumerate(firstList1):\n    #print i\n    if i in benchListBaseline:\n        index = i\n    else:\n        phaseList_single[index].append(i.split())\n\n\n\nfor (j,i) in enumerate(secondList1):\n    if i in colocationListExperiments:\n        index2=i\n    elif i in benchListExperiments:\n        index=i\n    else:\n        phaseList_degradation[index2][index].append(i.split())\n\n\n\nfor (j,i) in enumerate(thirdList1):\n    if i in colocationListExperiments:\n        index2=i\n    elif i in benchListExperiments:\n        index=i\n    else:\n        phaseList_shutter[index2][index].append(i.split())\n\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    print i\n    instruction_list1=[]\n    cpi_list1=[]\n    instruction_list2=[]\n    cpi_list2=[]\n    instruction_list3=[]\n    cpi_list3=[]\n    instruction_list4=[]\n    cpi_list4=[]\n    for (b,a) in enumerate(phaseList_shutter[j][i]):\n        if a[0][0] == \'-\':\n            break\n        else:\n            instruction_list1.append(float(a[1]))\n            cpi_list1.append(a[2])\n\n    for (b,a) in enumerate(phaseList_single[i]):\n        if a[0][0] == \'-\':\n            break\n        else:\n            instruction_list2.append(float(a[1]))\n            cpi_list2.append(a[2])\n\n    for (b,a) in enumerate(phaseList_degradation[j][i]):\n        if a[0][0] == \'-\':\n            break\n        else:\n            instruction_list3.append(float(a[1]))\n            cpi_list3.append(float(a[14])/10)\n\n    for (b,a) in enumerate(phaseList_degradation[j][i]):\n        if a[0][0] == \'-\':\n            break\n        else:\n            instruction_list4.append(float(a[1]))\n            cpi_list4.append(float(a[7])/1)\n    #print instruction_list\n    #print cpi_list\n\n    color_list = color_maker(3, map="afmhot")\n    f, ax1 = plt.subplots(figsize=(12,5))\n    ax1.set_xlabel(\'Executed instructions\', fontsize=23)\n    ax1.set_ylabel(\'CPI\',fontsize=23)\n    ax1.plot(instruction_list2,cpi_list2, color=\'y\', linestyle=\'-\', marker=\'d\', markevery=10, label= \'CPI solo\')\n    ax1.legend(loc=2,prop={\'size\':20})\n    ax2 = ax1.twinx()\n    ax2.plot(instruction_list3,cpi_list3, \'r--\',  label= \'LLC store misses \\nw/ %s\' %(j[16:]))\n    ax2.plot(instruction_list4,cpi_list4, color=\'b\', linestyle=\'-\', marker=\'.\',  markevery=20,  label= \'L1-d load misses \\nw/ %s\' %(j[16:]))\n    #ax2.plot(instruction_list3,cpi_list3, color=\'b\',  label= \'co-run: %s with %s\' %(i,j[16:]))\n    ax2.set_ylabel(\'PMU Measurements\',fontsize=23)\n    ax1.set_ylim(-0.5,25)\n    ax2.set_ylim(-0.5,25)\n    ax2.set_xlim(0,320000000000)\n    ax1.tick_params(axis=\'both\', labelsize=18)\n    ax2.tick_params(axis=\'both\', labelsize=18)\n    ax2.legend(loc=1,prop={\'size\':17}, ncol=2)\n    del instruction_list1\n    del cpi_list1\n\n    #setFigLinesBW(f)\n    #f.savefig(\'%s_and_libquantum2.pdf\'%(i),bbox_inches=\'tight\' ,dpi=200)'
p0
.I0
.S'$graph_fig:milcl1dastar:\\texttt{milc}:1'
p0
.S"import matplotlib.pyplot as plt\nimport numpy as np\nfrom collections import defaultdict\n\nfilename = '5'\nf1 = [s.strip() for s in open('../../papergraphs/phases/pmutypes/single.txt').readlines()]\nf2 = [s.strip() for s in open('../../papergraphs/phases/pmutypes/degradation.txt').readlines()]\n#f3 = [s.strip() for s in open('../../papergraphs/phases/shutter_phase_%s.txt' % filename).readlines()]\n\nbenchListBaseline = [ 'gcc', 'perlbench', 'mcf', 'leslie3d', 'povray', 'libquantum', 'astar', 'bzip2', 'milc', 'namd', 'calculix', 'h264ref', 'zeusmp', 'gobmk', 'hmmer', 'tonto', 'sphinx3', 'bwaves', 'gromacs', 'dealII', 'sjeng', 'lbm', 'xalancbmk', 'gamess', 'cactusADM', 'soplex', 'GemsFDTD', 'omnetpp' ]\nbenchListExperiments = [ 'gcc', 'perlbench', 'mcf', 'leslie3d', 'povray', 'libquantum', 'astar', 'bzip2', 'milc', 'namd', 'calculix', 'h264ref', 'zeusmp', 'gobmk', 'hmmer', 'tonto', 'sphinx3', 'bwaves', 'gromacs', 'dealII', 'sjeng', 'lbm', 'xalancbmk', 'gamess', 'cactusADM', 'soplex', 'GemsFDTD', 'omnetpp' ]\ncolocationListBaseline = [ 'colocating with mcf', 'colocating with povray', 'colocating with astar', 'colocating with astar', 'colocating with libquantum', 'colocating with povray', 'colocating with omnetpp', 'colocating with bzip2' ]\ncolocationListExperiments = [ 'colocating with mcf', 'colocating with povray', 'colocating with perlbench', 'colocating with astar', 'colocating with libquantum', 'colocating with povray', 'colocating with omnetpp', 'colocating with bzip2' ]\nrunningList = [ 'milc' ,'colocating with astar']\n\nphaseList_single = defaultdict(list)\nphaseList_degradation = defaultdict(lambda  : defaultdict(list))\nphaseList_shutter = defaultdict(lambda  : defaultdict(list))\nphaseList_colocation = defaultdict(lambda  : defaultdict(list))\n\n\nllc_miss_phaseList_single = defaultdict(list)\nllc_miss_phaseList_degradation = defaultdict(lambda  : defaultdict(list))\nllc_miss_phaseList_shutter = defaultdict(lambda  : defaultdict(list))\nllc_miss_phaseList_colocation = defaultdict(lambda  : defaultdict(list))\n\ndef setAxLinesBW(ax):\n    MARKERSIZE = 3\n    COLORMAP = {\n        'g': {'marker': None, 'dash': (None,None)},\n        'k': {'marker': None, 'dash': [5,5]},\n        'r': {'marker': None, 'dash': [5,3,1,3]},\n        'c': {'marker': None, 'dash': [1,3]},\n        'm': {'marker': None, 'dash': [5,2,5,2,5,10]},\n        'y': {'marker': None, 'dash': [5,3,1,2,1,10]},\n        'b': {'marker': '+', 'dash': (None,None)} #[1,2,1,10]}\n        }\n\n    for line in ax.get_lines() + ax.get_legend().get_lines():\n        origColor = line.get_color()\n        line.set_color('black')\n        line.set_dashes(COLORMAP[origColor]['dash'])\n        line.set_marker(COLORMAP[origColor]['marker'])\n        line.set_markersize(MARKERSIZE)\n\ndef setFigLinesBW(fig):\n    for ax in fig.get_axes():\n        setAxLinesBW(ax)\n\nfirstList1 = []\nsecondList1 = []\nthirdList1 = []\nfourthList1 = []\nfifthList1 = []\nsixthList1 = []\nseventhList1 = []\neighthList1 = []\n\nfor line in f1:\n    firstList1.append(line)\n\nfor line in f2:\n    secondList1.append(line)\n\n#for line in f3:\n#    thirdList1.append(line)\n\nglobal index\nglobal index2\n\nfor (j,i) in enumerate(firstList1):\n    #print i\n    if i in benchListBaseline:\n        index = i\n    else:\n        phaseList_single[index].append(i.split())\n\n\n\nfor (j,i) in enumerate(secondList1):\n    if i in colocationListExperiments:\n        index2=i\n    elif i in benchListExperiments:\n        index=i\n    else:\n        phaseList_degradation[index2][index].append(i.split())\n\n\n\nfor (j,i) in enumerate(thirdList1):\n    if i in colocationListExperiments:\n        index2=i\n    elif i in benchListExperiments:\n        index=i\n    else:\n        phaseList_shutter[index2][index].append(i.split())\n\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    print i\n    instruction_list1=[]\n    cpi_list1=[]\n    instruction_list2=[]\n    cpi_list2=[]\n    instruction_list3=[]\n    cpi_list3=[]\n    instruction_list4=[]\n    cpi_list4=[]\n    for (b,a) in enumerate(phaseList_shutter[j][i]):\n        if a[0][0] == '-':\n            break\n        else:\n            instruction_list1.append(float(a[1]))\n            cpi_list1.append(a[2])\n\n    for (b,a) in enumerate(phaseList_single[i]):\n        if a[0][0] == '-':\n            break\n        else:\n            instruction_list2.append(float(a[1]))\n            cpi_list2.append(a[2])\n\n    for (b,a) in enumerate(phaseList_degradation[j][i]):\n        if a[0][0] == '-':\n            break\n        else:\n            instruction_list3.append(float(a[1]))\n            cpi_list3.append(float(a[7])/10)\n\n    for (b,a) in enumerate(phaseList_degradation[j][i]):\n        if a[0][0] == '-':\n            break\n        else:\n            instruction_list4.append(float(a[1]))\n            cpi_list4.append(float(a[14])/100)\n\n    #print instruction_list\n    #print cpi_list\n\n    f, ax1 = plt.subplots(figsize=(12,5))\n    ax1.set_xlabel('Executed instructions', fontsize=23)\n    ax1.set_ylabel('CPI',fontsize=23)\n    ax1.plot(instruction_list2,cpi_list2, color='y', linestyle='-', marker='d', markevery=10,  label= 'CPI solo')\n    ax1.legend(loc=2,prop={'size':23})\n    ax2 = ax1.twinx()\n    ax2.plot(instruction_list3,cpi_list3, 'r--',  label= 'L1-d load misses \\nw/ %s' %(j[16:]))\n    ax2.plot(instruction_list4,cpi_list4, color='b', linestyle='-', marker='.', markevery=20,  label= 'LLC store misses \\nw/ %s' %(j[16:]))\n    #ax2.plot(instruction_list3,cpi_list3, color='b',  label= 'co-run: %s with %s' %(i,j[16:]))\n    ax2.set_ylabel('PMU Measurements',fontsize=23)\n    ax1.set_ylim(-0.5,3)\n    ax2.set_ylim(-0.5,3)\n    ax1.tick_params(axis='both', labelsize=18)\n    ax2.tick_params(axis='both', labelsize=18)\n    ax2.legend(loc=1,prop={'size':23})\n    del instruction_list1\n    del cpi_list1\n\n    #setFigLinesBW(f)\n    #f.savefig('%s_and_libquantum2.pdf'%(i),bbox_inches='tight' ,dpi=200)"
p0
.I0
.S'$graph_fig:mcfllcastar:\\texttt{mcf}:1'
p0
.S"import matplotlib.pyplot as plt\nimport numpy as np\nfrom collections import defaultdict\n\nfilename = '5'\nf1 = [s.strip() for s in open('../../papergraphs/phases/pmutypes/single.txt').readlines()]\nf2 = [s.strip() for s in open('../../papergraphs/phases/pmutypes/degradation.txt').readlines()]\n#f3 = [s.strip() for s in open('../../papergraphs/phases/shutter_phase_%s.txt' % filename).readlines()]\n\nbenchListBaseline = [ 'gcc', 'perlbench', 'mcf', 'leslie3d', 'povray', 'libquantum', 'astar', 'bzip2', 'milc', 'namd', 'calculix', 'h264ref', 'zeusmp', 'gobmk', 'hmmer', 'tonto', 'sphinx3', 'bwaves', 'gromacs', 'dealII', 'sjeng', 'lbm', 'xalancbmk', 'gamess', 'cactusADM', 'soplex', 'GemsFDTD', 'omnetpp' ]\nbenchListExperiments = [ 'gcc', 'perlbench', 'mcf', 'leslie3d', 'povray', 'libquantum', 'astar', 'bzip2', 'milc', 'namd', 'calculix', 'h264ref', 'zeusmp', 'gobmk', 'hmmer', 'tonto', 'sphinx3', 'bwaves', 'gromacs', 'dealII', 'sjeng', 'lbm', 'xalancbmk', 'gamess', 'cactusADM', 'soplex', 'GemsFDTD', 'omnetpp' ]\ncolocationListBaseline = [ 'colocating with mcf', 'colocating with povray', 'colocating with astar', 'colocating with astar', 'colocating with libquantum', 'colocating with povray', 'colocating with omnetpp', 'colocating with bzip2' ]\ncolocationListExperiments = [ 'colocating with mcf', 'colocating with povray', 'colocating with perlbench', 'colocating with astar', 'colocating with libquantum', 'colocating with povray', 'colocating with omnetpp', 'colocating with bzip2' ]\nrunningList = [ 'mcf' ,'colocating with astar']\n\nphaseList_single = defaultdict(list)\nphaseList_degradation = defaultdict(lambda  : defaultdict(list))\nphaseList_shutter = defaultdict(lambda  : defaultdict(list))\nphaseList_colocation = defaultdict(lambda  : defaultdict(list))\n\n\nllc_miss_phaseList_single = defaultdict(list)\nllc_miss_phaseList_degradation = defaultdict(lambda  : defaultdict(list))\nllc_miss_phaseList_shutter = defaultdict(lambda  : defaultdict(list))\nllc_miss_phaseList_colocation = defaultdict(lambda  : defaultdict(list))\n\ndef setAxLinesBW(ax):\n    MARKERSIZE = 3\n    COLORMAP = {\n        'g': {'marker': None, 'dash': (None,None)},\n        'k': {'marker': None, 'dash': [5,5]},\n        'r': {'marker': None, 'dash': [5,3,1,3]},\n        'c': {'marker': None, 'dash': [1,3]},\n        'm': {'marker': None, 'dash': [5,2,5,2,5,10]},\n        'y': {'marker': None, 'dash': [5,3,1,2,1,10]},\n        'b': {'marker': '+', 'dash': (None,None)} #[1,2,1,10]}\n        }\n\n    for line in ax.get_lines() + ax.get_legend().get_lines():\n        origColor = line.get_color()\n        line.set_color('black')\n        line.set_dashes(COLORMAP[origColor]['dash'])\n        line.set_marker(COLORMAP[origColor]['marker'])\n        line.set_markersize(MARKERSIZE)\n\ndef setFigLinesBW(fig):\n    for ax in fig.get_axes():\n        setAxLinesBW(ax)\n\nfirstList1 = []\nsecondList1 = []\nthirdList1 = []\nfourthList1 = []\nfifthList1 = []\nsixthList1 = []\nseventhList1 = []\neighthList1 = []\n\nfor line in f1:\n    firstList1.append(line)\n\nfor line in f2:\n    secondList1.append(line)\n\n#for line in f3:\n#    thirdList1.append(line)\n\nglobal index\nglobal index2\n\nfor (j,i) in enumerate(firstList1):\n    #print i\n    if i in benchListBaseline:\n        index = i\n    else:\n        phaseList_single[index].append(i.split())\n\n\n\nfor (j,i) in enumerate(secondList1):\n    if i in colocationListExperiments:\n        index2=i\n    elif i in benchListExperiments:\n        index=i\n    else:\n        phaseList_degradation[index2][index].append(i.split())\n\n\n\nfor (j,i) in enumerate(thirdList1):\n    if i in colocationListExperiments:\n        index2=i\n    elif i in benchListExperiments:\n        index=i\n    else:\n        phaseList_shutter[index2][index].append(i.split())\n\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    print i\n    instruction_list1=[]\n    cpi_list1=[]\n    instruction_list2=[]\n    cpi_list2=[]\n    instruction_list3=[]\n    cpi_list3=[]\n    for (b,a) in enumerate(phaseList_shutter[j][i]):\n        if a[0][0] == '-':\n            break\n        else:\n            instruction_list1.append(float(a[1]))\n            cpi_list1.append(a[2])\n\n    for (b,a) in enumerate(phaseList_single[i]):\n        if a[0][0] == '-':\n            break\n        else:\n            instruction_list2.append(float(a[1]))\n            cpi_list2.append(a[2])\n\n    for (b,a) in enumerate(phaseList_degradation[j][i]):\n        if a[0][0] == '-':\n            break\n        else:\n            instruction_list3.append(float(a[1]))\n            cpi_list3.append(float(a[14])/10)\n\n    #print instruction_list\n    #print cpi_list\n\n    f, ax1 = plt.subplots(figsize=(12,5))\n    ax1.set_xlabel('Executed instructions', fontsize=23)\n    ax1.set_ylabel('CPI',fontsize=23)\n    ax1.plot(instruction_list2,cpi_list2, 'y.-',  label= 'CPI solo')\n    ax1.legend(loc=2,prop={'size':23})\n    ax2 = ax1.twinx()\n    ax2.plot(instruction_list3,cpi_list3, 'r--',  label= 'LLC store misses \\nw/ %s' %(j[16:]))\n    #ax2.plot(instruction_list3,cpi_list3, color='b',  label= 'co-run: %s with %s' %(i,j[16:]))\n    ax2.set_ylabel('LLC store misses',fontsize=23)\n    ax1.set_ylim(-0.5,25)\n    ax2.set_ylim(-0.5,25)\n    ax2.set_xlim(0,320000000000)\n    ax1.tick_params(axis='both', labelsize=18)\n    ax2.tick_params(axis='both', labelsize=18)\n    ax2.legend(loc=1,prop={'size':23})\n    del instruction_list1\n    del cpi_list1\n\n    #setFigLinesBW(f)\n    #f.savefig('%s_and_libquantum2.pdf'%(i),bbox_inches='tight' ,dpi=200)"
p0
.I0
.S'$graph_fig:milcllcastar:\\texttt{milc}:1'
p0
.S"import matplotlib.pyplot as plt\nimport numpy as np\nfrom collections import defaultdict\n\nfilename = '5'\nf1 = [s.strip() for s in open('../../papergraphs/phases/pmutypes/single.txt').readlines()]\nf2 = [s.strip() for s in open('../../papergraphs/phases/pmutypes/degradation.txt').readlines()]\n#f3 = [s.strip() for s in open('../../papergraphs/phases/shutter_phase_%s.txt' % filename).readlines()]\n\nbenchListBaseline = [ 'gcc', 'perlbench', 'mcf', 'leslie3d', 'povray', 'libquantum', 'astar', 'bzip2', 'milc', 'namd', 'calculix', 'h264ref', 'zeusmp', 'gobmk', 'hmmer', 'tonto', 'sphinx3', 'bwaves', 'gromacs', 'dealII', 'sjeng', 'lbm', 'xalancbmk', 'gamess', 'cactusADM', 'soplex', 'GemsFDTD', 'omnetpp' ]\nbenchListExperiments = [ 'gcc', 'perlbench', 'mcf', 'leslie3d', 'povray', 'libquantum', 'astar', 'bzip2', 'milc', 'namd', 'calculix', 'h264ref', 'zeusmp', 'gobmk', 'hmmer', 'tonto', 'sphinx3', 'bwaves', 'gromacs', 'dealII', 'sjeng', 'lbm', 'xalancbmk', 'gamess', 'cactusADM', 'soplex', 'GemsFDTD', 'omnetpp' ]\ncolocationListBaseline = [ 'colocating with mcf', 'colocating with povray', 'colocating with astar', 'colocating with astar', 'colocating with libquantum', 'colocating with povray', 'colocating with omnetpp', 'colocating with bzip2' ]\ncolocationListExperiments = [ 'colocating with mcf', 'colocating with povray', 'colocating with perlbench', 'colocating with astar', 'colocating with libquantum', 'colocating with povray', 'colocating with omnetpp', 'colocating with bzip2' ]\nrunningList = [ 'milc' ,'colocating with astar']\n\nphaseList_single = defaultdict(list)\nphaseList_degradation = defaultdict(lambda  : defaultdict(list))\nphaseList_shutter = defaultdict(lambda  : defaultdict(list))\nphaseList_colocation = defaultdict(lambda  : defaultdict(list))\n\n\nllc_miss_phaseList_single = defaultdict(list)\nllc_miss_phaseList_degradation = defaultdict(lambda  : defaultdict(list))\nllc_miss_phaseList_shutter = defaultdict(lambda  : defaultdict(list))\nllc_miss_phaseList_colocation = defaultdict(lambda  : defaultdict(list))\n\ndef setAxLinesBW(ax):\n    MARKERSIZE = 3\n    COLORMAP = {\n        'g': {'marker': None, 'dash': (None,None)},\n        'k': {'marker': None, 'dash': [5,5]},\n        'r': {'marker': None, 'dash': [5,3,1,3]},\n        'c': {'marker': None, 'dash': [1,3]},\n        'm': {'marker': None, 'dash': [5,2,5,2,5,10]},\n        'y': {'marker': None, 'dash': [5,3,1,2,1,10]},\n        'b': {'marker': '+', 'dash': (None,None)} #[1,2,1,10]}\n        }\n\n    for line in ax.get_lines() + ax.get_legend().get_lines():\n        origColor = line.get_color()\n        line.set_color('black')\n        line.set_dashes(COLORMAP[origColor]['dash'])\n        line.set_marker(COLORMAP[origColor]['marker'])\n        line.set_markersize(MARKERSIZE)\n\ndef setFigLinesBW(fig):\n    for ax in fig.get_axes():\n        setAxLinesBW(ax)\n\nfirstList1 = []\nsecondList1 = []\nthirdList1 = []\nfourthList1 = []\nfifthList1 = []\nsixthList1 = []\nseventhList1 = []\neighthList1 = []\n\nfor line in f1:\n    firstList1.append(line)\n\nfor line in f2:\n    secondList1.append(line)\n\n#for line in f3:\n#    thirdList1.append(line)\n\nglobal index\nglobal index2\n\nfor (j,i) in enumerate(firstList1):\n    #print i\n    if i in benchListBaseline:\n        index = i\n    else:\n        phaseList_single[index].append(i.split())\n\n\n\nfor (j,i) in enumerate(secondList1):\n    if i in colocationListExperiments:\n        index2=i\n    elif i in benchListExperiments:\n        index=i\n    else:\n        phaseList_degradation[index2][index].append(i.split())\n\n\n\nfor (j,i) in enumerate(thirdList1):\n    if i in colocationListExperiments:\n        index2=i\n    elif i in benchListExperiments:\n        index=i\n    else:\n        phaseList_shutter[index2][index].append(i.split())\n\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    print i\n    instruction_list1=[]\n    cpi_list1=[]\n    instruction_list2=[]\n    cpi_list2=[]\n    instruction_list3=[]\n    cpi_list3=[]\n    for (b,a) in enumerate(phaseList_shutter[j][i]):\n        if a[0][0] == '-':\n            break\n        else:\n            instruction_list1.append(float(a[1]))\n            cpi_list1.append(a[2])\n\n    for (b,a) in enumerate(phaseList_single[i]):\n        if a[0][0] == '-':\n            break\n        else:\n            instruction_list2.append(float(a[1]))\n            cpi_list2.append(a[2])\n\n    for (b,a) in enumerate(phaseList_degradation[j][i]):\n        if a[0][0] == '-':\n            break\n        else:\n            instruction_list3.append(float(a[1]))\n            cpi_list3.append(float(a[14])/100)\n\n    #print instruction_list\n    #print cpi_list\n\n    f, ax1 = plt.subplots(figsize=(12,5))\n    ax1.set_xlabel('Executed instructions', fontsize=23)\n    ax1.set_ylabel('CPI',fontsize=23)\n    ax1.plot(instruction_list2,cpi_list2, 'y.-',  label= 'CPI solo')\n    ax1.legend(loc=2,prop={'size':23})\n    ax2 = ax1.twinx()\n    ax2.plot(instruction_list3,cpi_list3, 'r--',  label= 'LLC store misses \\nw/ %s' %(j[16:]))\n    #ax2.plot(instruction_list3,cpi_list3, color='b',  label= 'co-run: %s with %s' %(i,j[16:]))\n    ax2.set_ylabel('LLC store misses',fontsize=23)\n    ax1.set_ylim(-0.5,3)\n    ax2.set_ylim(-0.5,3)\n    ax2.legend(loc=1,prop={'size':23})\n    ax1.tick_params(axis='both', labelsize=18)\n    ax2.tick_params(axis='both', labelsize=18)\n    del instruction_list1\n    del cpi_list1\n\n    #setFigLinesBW(f)\n    #f.savefig('%s_and_libquantum2.pdf'%(i),bbox_inches='tight' ,dpi=200)"
p0
.I0
.S'Trigger Scoring Technique'
p0
.S'$s: PMU scoring technique '
p0
.I2
.S'Note'
p0
.S'$p: \n\nIn order to identify the best PMU types for every single application, we quantify the effectiveness of each PMU type in detecting endogenous phase changes across every single application present in the training set. \n\n\\textbf{[Input and Output]} The input to trigger scoring technique is an application and its corresponding time varying PMU measurements during co-location for a particular PMU type. The output given by the trigger scoring technique is called the threshold of separation ($\\delta$) which quantifies the effectiveness of a particular PMU type.\n\n\\textbf{[Objective function]} The objective function of the trigger scoring technique is to quantify the effectiveness of PMU measurements of a particular PMU type to detect all inherent phases present in the solo execution of the application and to minimize triggering unnecessary phases. This can be done by identifying appropriate PMU types which show resistance to fluctuations and co-phase interference. For example, from looking at Figure ~\\ref{fig:fluctuations} we are clearly able to see that compared to the PMU type shown in Figure ~\\ref{fig:fluctuations} (c) \\texttt{[PMU typeY]}, the PMU type shown in Figure ~\\ref{fig:fluctuations} (b) \\texttt{[PMU typeX]} is much more tolerant to fluctuations in PMU measurements. Similarly, from looking at Figure ~\\ref{fig:type3} we are clearly able to see that compared to the PMU type shown in Figure ~\\ref{fig:type3} (c) \\texttt{[PMU typeY]}, the PMU type shown in Figure ~\\ref{fig:type3} (b) \\texttt{[PMU typeX]} is much more tolerant to co-phase interference.  PMU scoring technique tries to quantify this observation so as to rank the effectiveness of PMU types in detecting phase changes in application. This will enable us to choose a common PMU types to detect phase changes across applications. \n\n\\textbf{[Threshold of separation ]} The PMU scoring technique quantifies the effectiveness of PMU type using a value called the threshold of separation ($\\delta$). This value is exclusive to every PMU type, application pair and is obtained for all combinations of PMU type, application pair. This value should be high enough to discard variations due to fluctuations in PMU measurements and co-phase interference but low enough to capture the magnitude of intra application phase change. \n\n\\textbf{[Method to obtain threshold of separation ($\\delta$)]} In order to obtain the effectiveness of a PMU type, we first profile the application to obtain PMU measurements during co-location. We then quantitatively measure the magnitude of variation potrayed by the PMU measurements at every single phase boundary that is obtained from the solo execution profile. This can be quantitatively measured by observing the variation of incoming PMU measurements at phase boundaries. Figure ~\\ref{fig:triggerscoring} clearly illustrates this methodology to obtain the value of threshold of separation ($\\delta$). At every phase boundary, we determine the magnitude at which streaming PMU measurements should be varied so as to identify them. From the example given at Figure ~\\ref{fig:triggerscoring} (b)  and ~\\ref{fig:triggerscoring} (c) we can see that at timestamp t1 which is a phase change, the PMU measurement change from 3.02 to 6.1. The magnitude of change at this timestamp is is $\\delta_{1}$ which is shown in Figure ~\\ref{fig:triggerscoring} (c). Similarly we obtain all the $\\delta_{i}$ values at phase change happening at every timestamp $t_{i}$. The final score of the PMU is the minimum of all the obtained $\\delta$ values. \n\n%A good PMU indicator is one which where - 1. The variation between intra-phase PMU measurements is low and the variation between inter-phase PMU measurement is high.  2. The variations between inter-phase PMU measurements is higher than the variation between co-phase interference. We use a metric called the threshold of separation($\\delta$),  to distinguish between true phase changes and false phase changes. '
p0
.I0
.S'$omit!:Note'
p0
.S'$p: \nFigure ~\\ref{fig:triggerscoring} shows the overview of PMU scoring technique. \n\\textbf{[Input]} The input to trigger scoring technique is a an application and its corresponding time varying PMU measurements during co-location for a particular PMU type. \n\n\\textbf{[Output]} The output given by the trigger scoring technique is called the threshold of separation ($\\delta$) which quantifies the effectiveness of a particular PMU type.\n\n\\textbf{[Objective function]} The objective function of the trigger scoring technique is to quantify the effectiveness of PMU measurements of a particular PMU type to detect all inherent phases present in the solo execution of application and to  minimize triggering unnecessary phases. This can be done by identifying appropriate PMU types which show resistance to fluctuations and co-phase interference. For example, from looking at Figure ~\\ref{fig:fluctuations} we are clearly able to see that compared to the PMU type shown in Figure ~\\ref{fig:fluctuations} (c) \\texttt{[PMU typeX]}, the PMU type shown in Figure ~\\ref{fig:fluctuations} (b) \\texttt{[PMU typeY]} is much more tolerant to fluctuations in PMU measurements. PMU scoring technique tries to quantify this observation so as to rank the effectiveness of PMU types in detecting phase changes in application. This will enable us to choose a common PMU types to detect phase changes across applications. \n\n\\textbf{[Threshold of separation ]} The PMU scoring technique quantifies the effectiveness of PMU type using a value called the threshold of separation ($\\delta$). This value is exclusive to every PMU type, application pair. This value should be high enough to discard variations due to fluctuations in PMU measurements and co-phase interference but low enough to capture the magnitude of intra application phase change. \n\n\\textbf{[Method to obtain threshold of separation]} Consider the following ideal case example situation where there are streaming values of incoming PMU measurements when an application is co-locating:- \n\n\\texttt{3, 3.1, 3.05, 3.02, (t1) 6.1, 6.05, 6.03, 6.02, (t2) 8.51, 8.52, 8.55, 8.5}\n\nThe phase detection technique should determine at timestamps t1 and t2 that there is a phase change as the range of incoming PMU measurements vary significantly. This variation can be quantitatively seen by comparing the streaming measurements with the value present at the most recent phase change. Timestamps t1 and t2, as we have already mentioned is obtained by profiling solo execution of application. \n\n\\texttt{3.1   /3        = 1.03}\n\n\\texttt{3.05/3      = 1.02}\n\n\\texttt{6.1   /3  =  2.03} (significant variation - phase change)\n\n\\texttt{6.05   /6.1  =  0.99} \n\n\\texttt{6.03   /6.1  =  0.99} \n\n\\texttt{6.02   /6.1  =  0.99} \n\n\\texttt{8.51   /6.1  =  1.39} (significant variation - phase change)\n\n\nFrom this example it is clearly seen that PMU measurements that are 2.3x more than the most recent phase change can detect phase change at timestamp t1 and 1.39X more than the most recent phase change can detect phase change at timestamp t2. To generalize, we can conclude that an upper bound value of 1.39 can detect phase changes at both timestamps t1 and t2 in this particular scenario. The threshold of separation ($\\delta$) for a PMU type application pair is the upper bound and lower bound values that can detect all the phase changes present in that application. \n\n\n\n\n\n%A good PMU indicator is one which where - 1. The variation between intra-phase PMU measurements is low and the variation between inter-phase PMU measurement is high.  2. The variations between inter-phase PMU measurements is higher than the variation between co-phase interference. We use a metric called the threshold of separation($\\delta$),  to distinguish between true phase changes and false phase changes. '
p0
.I0
.S'Ranking PMUs'
p0
.S'$s: Ranking PMU types'
p0
.I2
.S'Note'
p0
.S'$p: \nThe motivation behind ranking PMU types is to obtain a common set of PMU types that can detect runtime phase changes across a varied class of applications. In that context, we need to choose PMU types that depict phase changes much more significantly compared to fluctuations or co-phase interference. To fulfill that, it is clear that PMU types that possess high values of ($\\delta$) can be more effective. Hence, we rank PMU types for an application based on this metric as shown in Table ~\\ref{table:pmctype}. We have used all the PMU types that are being supported in our infrastructure. In this paper, we have shown the only the top 3 PMU types due to space constraints. \n\nA counter-intuitive observation from our experiments as depicted in Table ~\\ref{table:pmctype} shows that there is no single PMU type that can detect phase changes across all the training set of applications. In other words, there can be a situation where the same architectural resource would fail to capture the phase boundaries across a different set of applications. This is attributed by the fact that the nature of applications running in public clouds is varied extensively. \n'
p0
.I0
.S'Explain Figures'
p0
.S'$p: We use Figure ~\\ref{fig:PMUtypephase} to illustrate a scenario where a single PMU type is not able to identify phase boundaries across two different applications. Figure \\ref{fig:PMUtypephase} shows that each application requires different types of PMU to precisely detect phase changes. The x-axis indicates the cumulative number of instructions executed as time progresses. The left y-axis and yellow (diamond) line show CPI of the applications when running alone and the right y-axis and the blue (circle) / red (dashed) line show estimating phase changes by a selected performance counter for the application when running with three instances of \\texttt{astar} as co-runners. From Figure \\ref{fig:mcfl1dastar}, we find out that the performance counter, \\textit{L1-d cache load misses}, can effectively detect endogenous phase changes of \\texttt{mcf} in co-located environments whereas Figure \\ref{fig:milcl1dastar} shows that the same type of PMU is unable to detect endogenous phase changes of \\texttt{milc}. On the other hand, \\textit{LLC store misses} are able to detect endogenous phase changes for the \\texttt{milc} as shown in Figure \\ref{fig:milcl1dastar} whereas the same type of PMU is unable to detect endogenous phase changes of \\texttt{mcf} as shown in Figure \\ref{fig:mcfl1dastar}. These results motivate us to need multiple types of PMU to capture phase changes across applications. To achieve this, we undertake an approach where we observe a set of architectural resources in contrast to a single resource to identify inherent phase changes across multiple applications.\n\nOur runtime system collects three types of PMU events once every second. It tries to detect if any phase change exists. To avoid missing endogenous phase changes, we use a conservative approach to obtain a snapshot during a phase change even if one of the PMU types out of the three detects a phase change. This is because failing to detect endogenous phase changes will significantly reduce the accuracy in estimating CPI of solo execution. On the other hand, mispredicting phase changes causes only negligible overhead if the frequency of such events is low. '
p0
.I0
.S'Implementation Issues'
p0
.S'$s:Implementation Issues'
p0
.I3
.S'Implementation issues'
p0
.S'$p: In the section, we discuss some of the implementation issues that we had faced while utilizing PMUs for detecting phase changes across applications. '
p0
.I0
.S'Spike elimination'
p0
.S'$s:Eliminating Spikes '
p0
.I4
.S'$omit!:$pdf_fig:detect_phases: Process of detecting phase changes:1'
p0
.S''
p0
.I1
.S'$fig*:detect_phases,1.85:'
p0
.S''
p0
.I0
.S'What is spike'
p0
.S'$p: \nWhile observing phase changes of the training applications, we notice that there are spikes in the reported PMU measurements. These spikes occasionally occur during a short interval of time and show significant variations in the execution behavior. In such a case, our phase detection methodology should not treat spikes as phase changes. '
p0
.I0
.S'Solution - data structure'
p0
.S'$p: To distinguish between spikes and inherent phase changes, we employ a binary classification technique. We maintain a queue per each PMU type. Each queue contains $k$ latest values that have been measured by the PMU type. The value of $k$ is empirically determined by repeating experiments with different $k$ values and optimizing for value which is enough to differentiate phase changes and spikes. This parameter is also cross-validated. We know that whenever there is a phase change associated with an application, subsequent PMU measurements fall under a different range which corresponds to a completely new phase. On the other hand, whenever there is a spike, the PMU measurements show drastic changes for one or two values and the rest falling under the same range. In order to eliminate such drastic changes due to spikes, we declare a phase change only when a significant number of the values present in the queue belongs to a new range. In other words, we replace the comparison of a single value as shown in the previous section to a queue of values. In this way, we are able to eliminate incorrectly detected phase changes due to spikes. '
p0
.I0
.S'Figure Explanation'
p0
.S'$p: Figure~\\ref{fig:noise_elimination} shows an example differentiating spikes and phase changes. During $T_{1}$ in Figure~\\ref{fig:noise_elimination}, the range of a significant number of elements changes to 3.0 compared to a previous phase which is around 1.0. In such a case, we consider this as a phase change where we take a \\textit{snapshot} of the new phase by pausing all co-runners. On the other hand, during $T_{2}$, the CPI of every element in the queue is closely around 3 except for one which is around 6.5. This change is considered as a spike and is not classified as a new phase. \n%The pictorial phase diagram gives a visual difference distinguishing phase changes and spikes. '
p0
.I0
.S'Selective Pausing'
p0
.S'$s:Selective Pausing'
p0
.I1
.S'Note'
p0
.S'$p: We know that consolidation of Virtual Machines (VMs) belonging to different users is a common practice employed by cloud service providers. Since the each VM belongs to a different user, the nature of the application executed by every user in the VMs is completely non-deterministic. Therefore, there might be situations where the applications that are executing neither contend for shared cache nor for memory bandwidth. In such a situation pausing such co-runners for obtaining snapshots during phase changes is completely un-necessary. This is due to the fact that, such co-runners have negligible effects on other running applications. Hence, we employ a selective pausing technique by taking into account the nature of the co-running applications. In other words, during phase changes, we pause co-runners that significantly contend for shared architectural resources. To realize that, we identify the magnitude of contentiousness of an application and pause applications based on tolerable contentiousness characteristics as proposed by Tang et. a.l \\cite{Tang:2011:CVS:2000417.2000419}. This prevents un-necessary pausing of applications which have no effect on co-running applications. '
p0
.I0
.S'$pdf_fig:noise_elimination:Differentiating spikes and phases \\vspace{-0.3in} :1'
p0
.S''
p0
.I1
.S'$fig:noise_elimination,1:'
p0
.S''
p0
.I0
.S'Pricing for Fairness'
p0
.S'$s: Pricing for Fairness'
p0
.I5
.S'Overview'
p0
.S'$p:In this section, we describe how the proposed \\textit{snapshot} technique can be used for enabling fair pricing in public clouds. Pricing in public clouds is based on an hourly basis which could create a biased scenario in co-located environments. We need a mechanism to charge each user based on how individual applications perform when they were running alone. \n%This method would not be influenced by the nature of co-runner. '
p0
.I0
.S'Algorithm'
p0
.S''
p0
.I1
.S'Algorithm for Phase change'
p0
.S'$t:\n\\begin{algorithm}[!tb]\n\\caption{SnapCharge: Pricing RUNtime Engine }\n\\label{alg:fpalgo}\n\\begin{algorithmic}\n\\begin{small}\n\\State $perfScoreVM_{i}$ = <CPI, LLC, L1D >\\;\\Comment{A queue of performance counters per VM}\n\\State $perfDegVM_{i}$ = <$VM_{1}$, ...., $VM_{n}$> \n%\\State $ perfDeg_{List} = < VM_{1}, ..., VM_{n} > $\n\\Comment{Performance degradation for each VM}\n\\State\n\\State /* \\textbf{Step 1:} Obtaining PMU measurements for all VMs */\n\\For{each $VM_{i}$ in $1$ ... $n$ }\n\\State $perfScoreVM_{i}$[CPI] <= gather\\_CPI($VM_{i}$) \n\\State $perfScoreVM_{i}$[LLC] <= gather\\_LLC\\_store\\_miss($VM_{i}$)\n\\State $perfScoreVM_{i}$[L1D] <= gather\\_L1d\\_cache\\_miss($VM_{i}$)\n\\EndFor \n\\State\n\\State /* \\textbf{Step 2:} Triggering phase changes by PMU types */\n\\For{each $VM_{i}$ in $1$ ... $n$}\n\\For{each $PMUtype_{j}$ in $1$ ... $m$}\n\\If{check\\_phase\\_change ($VM_{i}$[j]) == true}\n\\State pausing all co-running VMs except for itself;\n\\State $perfDegVM_{i}$ <= difference(gather\\_CPI($VM_{i}$) - $perfScoreVM_{i}$[CPI])\n\\State resuming all paused VMs\n\\EndIf\n\\EndFor \n\\EndFor \n\\State\n\\State /* \\textbf{Step 3:} Calculating price based on estimated degradation */\n\\For{each $VM_{i}$ in $1$ ... $n$}\n\\If{check\\_perfDeg\\_vm($VM_{i}$) == true}\n\\State reflect the unintended performance degradation in its bill\n\\EndIf\n\\EndFor \n\\end{small}\\\n\\end{algorithmic}\n\\end{algorithm}'
p0
.I0
.S'Pricing Equation'
p0
.S'$p: With the help of \\textit{snapshot}, we are able to accurately estimate the performance degradation in co-located environments with a very low overhead. This can in turn be used to price individual users based on the amount of time by which they have been degraded. From the estimated performance degradation, the price of each user can be calculated by the following equation. \n\\begin{equation} \\label{price}\nP_{i} = BasePrice/PerfDeg_{i}\n\\end{equation}\nwhere,\n\\begin{itemize}\n\\item $P_{i}$: price paid by user $i$.\n\\item $PerfDeg_{i}$: degradation suffered by user $i$ from equation \\ref{eq:degradation_equation}.\n\\end{itemize}\n\n\nThe $BasePrice$ in this equation is the share of price which each user would pay without taking into account the performance degradation due to co-running applications. The division of the base price with $PerfDeg_{i}$ charges each user $i$ with a price proportional to the performance degradation. This is due to the amount of degradation that the application has been subjected to due to its co-runners. '
p0
.I0
.S'Algorithm Description'
p0
.S'$p: Algorithm \\ref{alg:fpalgo} summarizes each step incurred by our fair pricing runtime engine. The runtime consists of three functions. In step 1, it measures three types of PMUs every second for each VM. Step 2 of the algorithm tries to detect phase changes based on the PMU measurements. If there is a phase change, then it pauses all other co-running VMs to measure CPI of solo execution for the application. Finally, we can calculate the price by reflecting the estimated performance degradation on the equation.'
p0
.I0
.S'$sub_fig:sirius-acc-over:Accuracy and overhead of SiriusSuite and DjiNN\\&Tonic Suite\\vspace{-0.0in}:sirius-accuracy,1:nl:sirius-overhead,1:!'
p0
.S''
p0
.I2
.S'$graph_fig:sirius-accuracy:Accuracy:1'
p0
.S'from collections import defaultdict\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nbenchListBaseline = [ \'gcc\', \'perlbench\', \'leslie3d\', \'povray\', \'libquantum\', \'astar\', \'bzip2\', \'milc\', \'namd\', \'calculix\', \'h264ref\', \'sphinx3\', \'zeusmp\', \'gobmk\', \'hmmer\', \'tonto\', \'bwaves\', \'gromacs\', \'dealII\', \'sjeng\', \'lbm\', \'xalancbmk\', \'gamess\', \'cactusADM\', \'soplex\', \'GemsFDTD\', \'omnetpp\', \'mcf\' ]\nbenchListExperiments = [ \'gcc\', \'perlbench\', \'leslie3d\', \'povray\', \'libquantum\', \'astar\', \'bzip2\', \'milc\', \'namd\', \'calculix\', \'h264ref\', \'sphinx3\', \'zeusmp\', \'gobmk\', \'hmmer\', \'tonto\', \'bwaves\', \'gromacs\', \'dealII\', \'sjeng\', \'lbm\', \'xalancbmk\', \'gamess\', \'cactusADM\', \'soplex\', \'GemsFDTD\', \'omnetpp\', \'mcf\' ]\ncolocationListBaseline = [ \'colocating with lbm\', \'colocating with povray\', \'colocating with astar\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with mcf\' ]\ncolocationListExperiments = [ \'colocating with lbm\', \'colocating with povray\', \'colocating with perlbench\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with mcf\' ]\nrunningList2 = [  \'perlbench\', \'colocating with libquantum\', \'mcf\', \'colocating with libquantum\', \'leslie3d\', \'colocating with libquantum\', \'povray\', \'colocating with libquantum\', \'libquantum\', \'colocating with libquantum\', \'astar\', \'colocating with libquantum\', \'bzip2\', \'colocating with libquantum\', \'milc\', \'colocating with libquantum\', \'namd\', \'colocating with libquantum\', \'calculix\', \'colocating with libquantum\', \'h264ref\', \'colocating with libquantum\', \'gobmk\', \'colocating with libquantum\', \'hmmer\', \'colocating with libquantum\', \'tonto\', \'colocating with libquantum\', \'sphinx3\', \'colocating with libquantum\', \'zeusmp\', \'colocating with libquantum\', \'bwaves\', \'colocating with libquantum\', \'gromacs\', \'colocating with libquantum\', \'dealII\', \'colocating with libquantum\', \'sjeng\', \'colocating with libquantum\', \'lbm\', \'colocating with libquantum\', \'xalancbmk\', \'colocating with libquantum\', \'gamess\', \'colocating with libquantum\', \'cactusADM\', \'colocating with libquantum\', \'soplex\', \'colocating with libquantum\', \'GemsFDTD\', \'colocating with libquantum\', \'omnetpp\', \'colocating with libquantum\' ]\n\nsiriusbenchListBaseline = [ \'gmm\', \'dnn_asr\', \'surf-fe\', \'surf-fd\', \'stem\', \'regex\', \'crf\', \'img-imc\', \'img-dig\', \'img-face\', \'nlp-pos\', \'nlp-chk\', \'nlp-ner\']\nsiriusbenchListExperiments = [ \'gmm\', \'dnn_asr\', \'surf-fe\', \'surf-fd\', \'stem\', \'regex\', \'crf\', \'img-imc\', \'img-dig\', \'img-face\', \'nlp-pos\', \'nlp-chk\', \'nlp-ner\']\nsiriuscolocationListBaseline = [ \'colocating with lbm\', \'colocating with povray\', \'colocating with astar\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with mcf\' ]\nsiriuscolocationListExperiments = [ \'colocating with lbm\', \'colocating with povray\', \'colocating with perlbench\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with mcf\' ]\nsiriusrunningList2 = [ \'gmm\', \'colocating with libquantum\', \'dnn_asr\', \'colocating with libquantum\', \'surf-fe\', \'colocating with libquantum\', \'surf-fd\', \'colocating with libquantum\', \'stem\', \'colocating with libquantum\', \'regex\', \'colocating with libquantum\', \'crf\', \'colocating with libquantum\', \'img-imc\', \'colocating with libquantum\', \'img-dig\', \'colocating with libquantum\', \'img-face\', \'colocating with libquantum\', \'nlp-pos\', \'colocating with libquantum\', \'nlp-chk\', \'colocating with libquantum\', \'nlp-ner\' , \'colocating with libquantum\']\n\ndef autolabel(rects):\n    # attach some text labels\n    for rect in rects:\n        height = rect.get_height()\n        plt.text(rect.get_x()+rect.get_width()/2., 1.05*height, \'%.2f\'%float(height))\n\ndef autolabel2(rects):\n    # attach some text labels\n    for rect in rects:\n        height = rect.get_height()\n        plt.text(rect.get_x()+rect.get_width()/2., 1.05*height, \'%.2f\'%float(height))\n\ndef add_line(ax, xpos, ypos):\n    line = plt.Line2D([xpos, xpos], [ypos + .1, ypos - .5], transform=ax.transAxes, linewidth=2, color=\'black\')\n    line.set_clip_on(False)\n    ax.add_line(line)\n\nfilename = \'shutter_cpi_10\'\n\nfList3= [s.strip() for s in open(\'../../papergraphs/accuracy/libquantumcorunner/priorwork/shutter_cpi_5.txt\').readlines()]\n\nfList4 = [s.strip() for s in open(\'../../papergraphs/accuracy/libquantumcorunner/singlevm/shutter_cpi_1000.txt\').readlines()]\nfList5 = [s.strip() for s in open(\'../../papergraphs/accuracy/libquantumcorunner/degradation/shutter_cpi_1000.txt\').readlines()]\nfList6 = [s.strip() for s in open(\'../../papergraphs/accuracy/libquantumcorunner/snapshot2/%s.txt\' % filename).readlines()]\nfList7 = [s.strip() for s in open(\'../../papergraphs/accuracy/libquantumcorunner/degradation3/shutter_cpi_1000.txt\').readlines()]\n\nfList8= [s.strip() for s in open(\'../../papergraphs/accuracy/libquantumcorunner/siriusdjinn/priorwork/shutter_cpi_4.txt\').readlines()]\n\nfList9 = [s.strip() for s in open(\'../../papergraphs/accuracy/libquantumcorunner/siriusdjinn/singlevm/shutter_cpi_1000.txt\').readlines()]\nfList10 = [s.strip() for s in open(\'../../papergraphs/accuracy/libquantumcorunner/siriusdjinn/degradation/shutter_cpi_1000.txt\').readlines()]\nfList11 = [s.strip() for s in open(\'../../papergraphs/accuracy/libquantumcorunner/siriusdjinn/snapshot/%s.txt\' % filename).readlines()]\n\ndictList_single_vm = defaultdict(list)\ndictList_degradation_colocation = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_colocation2 = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter2 = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter3 = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter4 = defaultdict(lambda  : defaultdict(list))\nplot_degradation = defaultdict(dict)\nplot_degradation2 = defaultdict(dict)\nplot_degradation_error = defaultdict(dict)\nplot_degradation_error2 = defaultdict(dict)\nplot_degradation_abs = defaultdict(dict)\nplot_degradation_abs2 = defaultdict(dict)\n\nfor (b,a) in enumerate(fList4):\n    if a in benchListBaseline:\n        dictList_single_vm[a].append(fList4[b+1])\n\n#SORTING LIST CONTAING VALUES OF SINGLE SPEC RUNS INSIDE VMs\nfor i in benchListBaseline:\n    dictList_single_vm[i].sort()\n    #print i,dictList_single_vm[i]\n\nfor (b,a) in enumerate(fList5):\n    #print a\n    if a in colocationListBaseline:\n       #print a\n       index = a\n    else:\n        if a in benchListExperiments:\n            #print a\n            dictList_degradation_colocation[index][a].append(fList5[b+1])\n\n#sorting the ground truth values\nfor a in xrange(0,len(runningList2),2):\n    j = runningList2[a+1]\n    i = runningList2[a]\n    dictList_degradation_colocation[j][i].sort()\n    #print j,i,dictList_degradation_colocation[j][i]\n\nfor (b,a) in enumerate(fList7):\n    #print a\n    if a in colocationListBaseline:\n       #print a\n       index = a\n    else:\n        if a in benchListExperiments:\n            #print a\n            dictList_degradation_colocation2[index][a].append(fList7[b+1])\n\n#APPENDING DEGRADATION SHUTTER\nfor (b,a) in enumerate(fList6):\n    if a in colocationListExperiments:\n        index = a\n    else:\n        if a in benchListExperiments:\n            dictList_degradation_shutter[index][a].append(fList6[b+1])\n\nfor (b,a) in enumerate(fList3):\n    if a in colocationListExperiments:\n        index = a\n    else:\n        if a in benchListExperiments:\n            dictList_degradation_shutter3[index][a].append(fList3[b+1])\n\nfor a in xrange(0,len(runningList2),2):\n    j = runningList2[a+1]\n    i = runningList2[a]\n    #print i,j,dictList_degradation_shutter[j][i]\n#APPENDING DEGRADATION SHUTTER2 as shutter and colocation values are tab separated\nfor a in xrange(0,len(runningList2),2):\n    j = runningList2[a+1]\n    i = runningList2[a]\n    for elem in dictList_degradation_shutter[j][i]:\n        dictList_degradation_shutter2[j][i].extend(elem.strip().split(\'\\t\'))\n\n    for elem in dictList_degradation_shutter3[j][i]:\n        dictList_degradation_shutter4[j][i].extend(elem.strip().split(\'\\t\'))\n    #print dictList_degradation_shutter2[j][i]\n\nyaxis2 = ()\nyaxis3 = ()\nyaxis_abs2 = ()\nyaxis_abs3 = ()\nerror2 = ()\nerror3 = ()\nxaxis2 = ()\nfor a in xrange(0,len(runningList2),2):\n    j = runningList2[a+1]\n    i = runningList2[a]\n    #print i,j\n    #print dictList_single_vm[i]\n    #print dictList_degradation_colocation[j][i]\n    #print dictList_degradation_shutter2[j][i]\n    denominator1 = sum(float(n) for (m,n) in enumerate(dictList_single_vm[i]) if m!=0 and m!=len(dictList_single_vm[i])-1)/(len(dictList_single_vm[i])-2)\n    numerator1 = sum(float(n) for (m,n) in enumerate(dictList_degradation_colocation[j][i]))/(len(dictList_degradation_colocation[j][i]))\n    numerator10 = sum(float(n) for (m,n) in enumerate(dictList_degradation_colocation2[j][i]))/(len(dictList_degradation_colocation2[j][i]))\n    shutter_temp_list = []\n    shutter_temp_list2 = []\n    colo_temp_list = []\n    colo_temp_list2 = []\n    degradation_temp_list = []\n    degradation_temp_list2 = []\n    error_temp_list = []\n    error_temp_list2 = []\n    #print numerator1\n    #print denominator1\n    for (count,item) in enumerate(dictList_degradation_shutter2[j][i]):\n        if count%2==0:\n            colo_temp_list.append(item)\n        if count%2==1:\n            shutter_temp_list.append(item)\n\n    for (count,item) in enumerate(dictList_degradation_shutter4[j][i]):\n        if count%2==0:\n            colo_temp_list2.append(item)\n        if count%2==1:\n            shutter_temp_list2.append(item)\n\n    for (count,item) in enumerate(shutter_temp_list):\n        degradation_temp_list.append(abs((((float(shutter_temp_list[count])/float(colo_temp_list[count]))-(numerator1/denominator1))/(float(shutter_temp_list[count])/float(colo_temp_list[count])))*100))\n\n    shutter_temp_list.sort()\n    shutter_temp_list2.sort()\n    colo_temp_list.sort()\n    colo_temp_list2.sort()\n    #print shutter_temp_list\n    #print colo_temp_list\n    #print dictList_degradation_shutter2[j][i]\n    denominator2 = sum(float(n) for (m,n) in enumerate(shutter_temp_list) if m!=0 and m!=len(shutter_temp_list)-1 )/len(shutter_temp_list)\n    numerator2 = sum(float(n) for (m,n) in enumerate(colo_temp_list) if m!=0 and m!=len(colo_temp_list)-1  )/len(colo_temp_list)\n    for (m,n) in enumerate(shutter_temp_list):\n        ratio=float(n)/float(colo_temp_list[m])\n        error_temp_list.append(abs((((ratio)-(numerator10/denominator1))/(numerator10/denominator1))*100))\n    plot_degradation_error[j][i]=np.std(error_temp_list)\n\n    denominator3 = sum(float(n) for (m,n) in enumerate(shutter_temp_list2))/(len(shutter_temp_list2))\n    numerator3 = sum(float(n) for (m,n) in enumerate(colo_temp_list2))/(len(colo_temp_list2))\n    for (m,n) in enumerate(shutter_temp_list2):\n        ratio=float(n)/float(colo_temp_list2[m])\n        error_temp_list2.append(abs((((ratio)-(numerator3/denominator3))/(numerator1/denominator1))*100))\n    plot_degradation_error2[j][i]=np.std(error_temp_list2)\n\n    #print numerator2\n    #print denominator2\n    del shutter_temp_list\n    del colo_temp_list\n    del degradation_temp_list\n    del shutter_temp_list2\n    del colo_temp_list2\n    del degradation_temp_list2\n    plot_degradation[j][i] = (((numerator2/denominator2)-(numerator10/denominator1))/(numerator10/denominator1))*100\n    plot_degradation_abs[j][i] = abs((((numerator2/denominator2)-(numerator10/denominator1))/(numerator10/denominator1))*100)\n    plot_degradation2[j][i] = (((numerator3/denominator3)-(numerator1/denominator1))/(numerator1/denominator1))*100\n    plot_degradation_abs2[j][i] = abs((((numerator3/denominator3)-(numerator1/denominator1))/(numerator1/denominator1))*100)\n    #print j,i,plot_degradation[j][i]\n    #print plot_degradation_error[j][i]\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    xaxis2 = xaxis2 + (i,)\n    yaxis2 = yaxis2 + (plot_degradation[j][i],)\n    yaxis3 = yaxis3 + (plot_degradation2[j][i],)\n    yaxis_abs2 = yaxis_abs2 + (plot_degradation_abs[j][i],)\n    yaxis_abs3 = yaxis_abs3 + (plot_degradation_abs2[j][i],)\n    error2 = error2 + (plot_degradation_error[j][i],)\n    error3 = error3 + (plot_degradation_error2[j][i],)\n    #print numerator2,denominator2,numerator2/denominator2\n    #print denominator2/numerator2\n    #print j,i,plot_degradation[j][i]\n            #print (((numerator2/denominator2)-(numerator1/denominator1))/(numerator2/denominator2))*100\n#print np.mean(yaxis2)\n\n\n#width=0.25\n#x = np.arange(len(yaxis2))\n#fig = plt.figure(figsize=(28, 5))\n##bar1 = plt.bar( x, yaxis, width, color="r", label=\'colocating with libquatum (avg = %.2f)\' %(np.mean(yaxis_abs)))\n#bar1 = plt.bar( x, yaxis_abs3, width, color="k", yerr=error3, label=\'Shuttering (mean: %.2f)\' %(np.mean(yaxis_abs3)))\n#bar2 = plt.bar( x+width, yaxis_abs2, width, color="lightgrey", yerr=error2, label=\'Snapshot (mean: %.2f)\' %(np.mean(yaxis_abs2)))\n##bar3 = plt.bar( x+width+width, yaxis3, width, color="g", label=\'colocating with sphinx  (avg = %.2f)\' %(np.mean(yaxis_abs3)))\n##autolabel(bar1)\n##autolabel(bar2)\n#plt.ylabel( \'Estimation error (%)\' ,fontsize=\'25\')\n##plt.title(\'Error in predicting degradation when co-locating with libquantum\')\n#plt.xticks(x + width/2.0, xaxis2, rotation=\'30\', size=\'23\',  ha=\'center\', va=\'top\')\n##plt.yticks((-0.5,0,1,2,3,4),(\'\',\'0\',\'1\',\'2\',\'3\',\'4\'),size=\'23\')\n#plt.yticks((0,10,20,30,40,50),(\'0\',\'10\',\'20\',\'30\',\'40\',\' \'),size=\'25\')\n#plt.ylim(0,50)\n#plt.xlim(-1,26)\n#plt.grid()\n#plt.tight_layout()\n#plt.legend(loc=9, ncol=2, prop={\'size\':28})\n##plt.savefig(\'%s_maybefinal_error.png\' %(filename), dpi=125)\n\n\n## ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\ndel dictList_single_vm\ndel dictList_degradation_colocation\ndel dictList_degradation_shutter\ndel dictList_degradation_shutter2\ndel dictList_degradation_shutter3\ndel dictList_degradation_shutter4\ndel plot_degradation\ndel plot_degradation2\ndel plot_degradation_error\ndel plot_degradation_error2\ndel plot_degradation_abs\ndel plot_degradation_abs2\n\ndictList_single_vm = defaultdict(list)\ndictList_degradation_colocation = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter2 = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter3 = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter4 = defaultdict(lambda  : defaultdict(list))\nplot_degradation = defaultdict(dict)\nplot_degradation2 = defaultdict(dict)\nplot_degradation_error = defaultdict(dict)\nplot_degradation_error2 = defaultdict(dict)\nplot_degradation_abs = defaultdict(dict)\nplot_degradation_abs2 = defaultdict(dict)\n\nfor (b,a) in enumerate(fList9):\n    if a in siriusbenchListBaseline:\n        dictList_single_vm[a].append(fList9[b+1])\n\n#SORTING LIST CONTAING VALUES OF SINGLE SPEC RUNS INSIDE VMs\nfor i in siriusbenchListBaseline:\n    dictList_single_vm[i].sort()\n    #print i,dictList_single_vm[i]\n\nfor (b,a) in enumerate(fList10):\n    #print a\n    if a in siriuscolocationListBaseline:\n       #print a\n       index = a\n    else:\n        if a in siriusbenchListExperiments:\n            #print a\n            dictList_degradation_colocation[index][a].append(fList10[b+1])\n\n#sorting the ground truth values\nfor a in xrange(0,len(siriusrunningList2),2):\n    j = siriusrunningList2[a+1]\n    i = siriusrunningList2[a]\n    #print i,j\n    dictList_degradation_colocation[j][i].sort()\n    #print j,i,dictList_degradation_colocation[j][i]\n\n#for a in xrange(0,len(runningList),2):\n#    j = runningList[a+1]\n#    i = runningList[a]\n#    numerator1 = sum(float(n) for (m,n) in enumerate(dictList_degradation_colocation[j][i]) if m!=0 and m!=len(dictList_degradation_colocation[j][i])-1)/(len(dictList_degradation_colocation[j][i])-2)\n#    print numerator1\n#    #print dictList_degradation_colocation[runningList[a+1]][runningList[a]]\n#    #print numerator1\n\n#APPENDING DEGRADATION SHUTTER\nfor (b,a) in enumerate(fList11):\n    #print a\n    if a in siriuscolocationListExperiments:\n        index = a\n    else:\n        if a in siriusbenchListExperiments:\n            dictList_degradation_shutter[index][a].append(fList11[b+1])\n\nfor (b,a) in enumerate(fList8):\n    if a in siriuscolocationListExperiments:\n        index = a\n    else:\n        if a in siriusbenchListExperiments:\n            dictList_degradation_shutter3[index][a].append(fList8[b+1])\n\nfor a in xrange(0,len(siriusrunningList2),2):\n    j = siriusrunningList2[a+1]\n    i = siriusrunningList2[a]\n    #print i,j,dictList_degradation_shutter[j][i]\n#APPENDING DEGRADATION SHUTTER2 as shutter and colocation values are tab separated\nfor a in xrange(0,len(siriusrunningList2),2):\n    j = siriusrunningList2[a+1]\n    i = siriusrunningList2[a]\n    for elem in dictList_degradation_shutter[j][i]:\n        dictList_degradation_shutter2[j][i].extend(elem.strip().split(\'\\t\'))\n\n    for elem in dictList_degradation_shutter3[j][i]:\n        dictList_degradation_shutter4[j][i].extend(elem.strip().split(\'\\t\'))\n    #print dictList_degradation_shutter2[j][i]\n\n\nlib_xaxis2 = ()\nlib_yaxis2 = ()\nlib_yaxis3 = ()\nlib_yaxis_abs2 = ()\nlib_yaxis_abs3 = ()\nlib_error2 = ()\nlib_error3 = ()\n\nfor a in xrange(0,len(siriusrunningList2),2):\n    j = siriusrunningList2[a+1]\n    i = siriusrunningList2[a]\n    #print i,j\n    #print i\n    #print dictList_single_vm[i]\n    #print dictList_degradation_colocation[j][i]\n    #print dictList_degradation_shutter2[j][i]\n    denominator1 = sum(float(n) for (m,n) in enumerate(dictList_single_vm[i]) if m!=0 and m!=len(dictList_single_vm[i])-1)/(len(dictList_single_vm[i])-2)\n    numerator1 = sum(float(n) for (m,n) in enumerate(dictList_degradation_colocation[j][i]))/(len(dictList_degradation_colocation[j][i]))\n    shutter_temp_list = []\n    shutter_temp_list2 = []\n    colo_temp_list = []\n    colo_temp_list2 = []\n    degradation_temp_list = []\n    degradation_temp_list2 = []\n    error_temp_list = []\n    error_temp_list2 = []\n    #print numerator1\n    #print denominator1\n    for (count,item) in enumerate(dictList_degradation_shutter2[j][i]):\n        if count%2==0:\n            colo_temp_list.append(item)\n        if count%2==1:\n            shutter_temp_list.append(item)\n\n    for (count,item) in enumerate(dictList_degradation_shutter4[j][i]):\n        if count%2==0:\n            colo_temp_list2.append(item)\n        if count%2==1:\n            shutter_temp_list2.append(item)\n\n    for (count,item) in enumerate(shutter_temp_list):\n        degradation_temp_list.append(abs((((float(shutter_temp_list[count])/float(colo_temp_list[count]))-(numerator1/denominator1))/(float(shutter_temp_list[count])/float(colo_temp_list[count])))*100))\n\n    shutter_temp_list.sort()\n    shutter_temp_list2.sort()\n    colo_temp_list.sort()\n    colo_temp_list2.sort()\n    #print shutter_temp_list\n    #print colo_temp_list\n    #print dictList_degradation_shutter2[j][i]\n    denominator2 = sum(float(n) for (m,n) in enumerate(shutter_temp_list) if m!=0 and m!=len(dictList_single_vm[i])-1)/(len(dictList_single_vm[i])-2)/len(shutter_temp_list)\n    numerator2 = sum(float(n) for (m,n) in enumerate(colo_temp_list) if m!=0 and m!=len(dictList_single_vm[i])-1)/(len(dictList_single_vm[i])-2 )/len(colo_temp_list)\n    for (m,n) in enumerate(shutter_temp_list):\n        ratio=float(n)/float(colo_temp_list[m])\n        error_temp_list.append(abs((((ratio)-(numerator1/denominator1))/(numerator1/denominator1))*100))\n    plot_degradation_error[j][i]=np.std(error_temp_list)\n\n    denominator3 = sum(float(n) for (m,n) in enumerate(shutter_temp_list2))/(len(shutter_temp_list2))\n    numerator3 = sum(float(n) for (m,n) in enumerate(colo_temp_list2))/(len(colo_temp_list2))\n    for (m,n) in enumerate(shutter_temp_list2):\n        ratio=float(n)/float(colo_temp_list2[m])\n        error_temp_list2.append(abs((((ratio)-(numerator3/denominator3))/(numerator1/denominator1))*100))\n    plot_degradation_error2[j][i]=np.std(error_temp_list2)\n\n    #print numerator2\n    #print denominator2\n    del shutter_temp_list\n    del colo_temp_list\n    del degradation_temp_list\n    del shutter_temp_list2\n    del colo_temp_list2\n    del degradation_temp_list2\n    plot_degradation[j][i] = (((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100\n    plot_degradation_abs[j][i] = abs((((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100)\n    plot_degradation2[j][i] = (((numerator3/denominator3)-(numerator1/denominator1))/(numerator1/denominator1))*100\n    plot_degradation_abs2[j][i] = abs((((numerator3/denominator3)-(numerator1/denominator1))/(numerator1/denominator1))*100)\n    #print j,i,plot_degradation[j][i]\n    #print plot_degradation_error[j][i]\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    lib_xaxis2 = lib_xaxis2 + (i,)\n    lib_yaxis2 = lib_yaxis2 + (plot_degradation[j][i],)\n    lib_yaxis3 = lib_yaxis3 + (plot_degradation2[j][i],)\n    lib_yaxis_abs2 = lib_yaxis_abs2 + (plot_degradation_abs[j][i],)\n    lib_yaxis_abs3 = lib_yaxis_abs3 + (plot_degradation_abs2[j][i],)\n    lib_error2 = lib_error2 + (plot_degradation_error[j][i],)\n    lib_error3 = lib_error3 + (plot_degradation_error2[j][i],)\n    #print numerator2,denominator2,numerator2/denominator2\n    #print denominator2/numerator2\n    #print j,i,plot_degradation[j][i],plot_degradation2[j][i]\n            #print (((numerator2/denominator2)-(numerator1/denominator1))/(numerator2/denominator2))*100\n#print np.mean(yaxis2)\n\n\n############### MCF STARTING #######################\nbenchListBaseline = [ \'gcc\', \'perlbench\', \'leslie3d\', \'povray\', \'libquantum\', \'astar\', \'bzip2\', \'milc\', \'namd\', \'calculix\', \'h264ref\', \'sphinx3\', \'zeusmp\', \'gobmk\', \'hmmer\', \'tonto\', \'bwaves\', \'gromacs\', \'dealII\', \'sjeng\', \'lbm\', \'xalancbmk\', \'gamess\', \'cactusADM\', \'soplex\', \'GemsFDTD\', \'omnetpp\', \'mcf\' ]\nbenchListExperiments = [ \'gcc\', \'perlbench\', \'leslie3d\', \'povray\', \'libquantum\', \'astar\', \'bzip2\', \'milc\', \'namd\', \'calculix\', \'h264ref\', \'sphinx3\', \'zeusmp\', \'gobmk\', \'hmmer\', \'tonto\', \'bwaves\', \'gromacs\', \'dealII\', \'sjeng\', \'lbm\', \'xalancbmk\', \'gamess\', \'cactusADM\', \'soplex\', \'GemsFDTD\', \'omnetpp\', \'mcf\' ]\ncolocationListBaseline = [ \'colocating with lbm\', \'colocating with povray\', \'colocating with astar\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with mcf\' ]\ncolocationListExperiments = [ \'colocating with lbm\', \'colocating with povray\', \'colocating with perlbench\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with mcf\' ]\n\nrunningList2 = [  \'perlbench\', \'colocating with mcf\', \'mcf\', \'colocating with mcf\', \'leslie3d\', \'colocating with mcf\', \'povray\', \'colocating with mcf\', \'libquantum\', \'colocating with mcf\', \'astar\', \'colocating with mcf\', \'bzip2\', \'colocating with mcf\', \'milc\', \'colocating with mcf\', \'namd\', \'colocating with mcf\', \'calculix\', \'colocating with mcf\', \'h264ref\', \'colocating with mcf\', \'gobmk\', \'colocating with mcf\', \'hmmer\', \'colocating with mcf\', \'tonto\', \'colocating with mcf\', \'sphinx3\', \'colocating with mcf\', \'zeusmp\', \'colocating with mcf\', \'bwaves\', \'colocating with mcf\', \'gromacs\', \'colocating with mcf\', \'dealII\', \'colocating with mcf\', \'sjeng\', \'colocating with mcf\', \'lbm\', \'colocating with mcf\', \'xalancbmk\', \'colocating with mcf\', \'gamess\', \'colocating with mcf\', \'cactusADM\', \'colocating with mcf\', \'soplex\', \'colocating with mcf\', \'GemsFDTD\', \'colocating with mcf\', \'omnetpp\', \'colocating with mcf\' ]\nsiriusbenchListBaseline = [ \'gmm\', \'dnn_asr\', \'surf-fe\', \'surf-fd\', \'stem\', \'regex\', \'crf\', \'img-imc\', \'img-dig\', \'img-face\', \'nlp-pos\', \'nlp-chk\', \'nlp-ner\']\nsiriusbenchListExperiments = [ \'gmm\', \'dnn_asr\', \'surf-fe\', \'surf-fd\', \'stem\', \'regex\', \'crf\', \'img-imc\', \'img-dig\', \'img-face\', \'nlp-pos\', \'nlp-chk\', \'nlp-ner\']\nsiriuscolocationListBaseline = [ \'colocating with lbm\', \'colocating with povray\', \'colocating with astar\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with mcf\' ]\nsiriuscolocationListExperiments = [ \'colocating with lbm\', \'colocating with povray\', \'colocating with perlbench\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with mcf\' ]\nsiriusrunningList2 = [ \'gmm\', \'colocating with mcf\', \'dnn_asr\', \'colocating with mcf\', \'surf-fe\', \'colocating with mcf\', \'surf-fd\', \'colocating with mcf\', \'stem\', \'colocating with mcf\', \'regex\', \'colocating with mcf\', \'crf\', \'colocating with mcf\', \'img-imc\', \'colocating with mcf\', \'img-dig\', \'colocating with mcf\', \'img-face\', \'colocating with mcf\', \'nlp-pos\', \'colocating with mcf\', \'nlp-chk\', \'colocating with mcf\', \'nlp-ner\' , \'colocating with mcf\']\n\ndef autolabel(rects):\n    # attach some text labels\n    for rect in rects:\n        height = rect.get_height()\n        plt.text(rect.get_x()+rect.get_width()/2., 1.05*height, \'%.2f\'%float(height))\n\ndef autolabel2(rects):\n    # attach some text labels\n    for rect in rects:\n        height = rect.get_height()\n        plt.text(rect.get_x()+rect.get_width()/2., 1.05*height, \'%.2f\'%float(height))\n\ndef add_line(ax, xpos, ypos):\n    line = plt.Line2D([xpos, xpos], [ypos + .1, ypos - .5], transform=ax.transAxes, linewidth=2, color=\'black\')\n    line.set_clip_on(False)\n    ax.add_line(line)\n\n\nfilename = \'shutter_cpi_70\'\n\nfList3= [s.strip() for s in open(\'../../papergraphs/accuracy/mcfcorunner/priorwork/shutter_cpi_5.txt\').readlines()]\n\nfList4 = [s.strip() for s in open(\'../../papergraphs/accuracy/mcfcorunner/singlevm/shutter_cpi_1000.txt\').readlines()]\nfList5 = [s.strip() for s in open(\'../../papergraphs/accuracy/mcfcorunner/degradation/shutter_cpi_1000.txt\').readlines()]\nfList6 = [s.strip() for s in open(\'../../papergraphs/accuracy/mcfcorunner/snapshot/%s.txt\' % filename).readlines()]\n\n\nfList8= [s.strip() for s in open(\'../../papergraphs/accuracy/mcfcorunner/siriusdjinn/priorwork/shutter_cpi_4.txt\').readlines()]\n\nfList9 = [s.strip() for s in open(\'../../papergraphs/accuracy/mcfcorunner/siriusdjinn/singlevm/shutter_cpi_1000.txt\').readlines()]\nfList10 = [s.strip() for s in open(\'../../papergraphs/accuracy/mcfcorunner/siriusdjinn/degradation/shutter_cpi_1000.txt\').readlines()]\nfList11 = [s.strip() for s in open(\'../../papergraphs/accuracy/mcfcorunner/siriusdjinn/snapshot/shutter_cpi_75.txt\').readlines()]\n\ndictList_single_vm = defaultdict(list)\ndictList_degradation_colocation = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter2 = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter3 = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter4 = defaultdict(lambda  : defaultdict(list))\nplot_degradation = defaultdict(dict)\nplot_degradation2 = defaultdict(dict)\nplot_degradation_error = defaultdict(dict)\nplot_degradation_error2 = defaultdict(dict)\nplot_degradation_abs = defaultdict(dict)\nplot_degradation_abs2 = defaultdict(dict)\n\nfor (b,a) in enumerate(fList4):\n    if a in benchListBaseline:\n        dictList_single_vm[a].append(fList4[b+1])\n\n#SORTING LIST CONTAING VALUES OF SINGLE SPEC RUNS INSIDE VMs\nfor i in benchListBaseline:\n    dictList_single_vm[i].sort()\n    #print i,dictList_single_vm[i]\n\nfor (b,a) in enumerate(fList5):\n    #print a\n    if a in colocationListBaseline:\n       #print a\n       index = a\n    else:\n        if a in benchListExperiments:\n            #print a\n            dictList_degradation_colocation[index][a].append(fList5[b+1])\n\n#sorting the ground truth values\nfor a in xrange(0,len(runningList2),2):\n    j = runningList2[a+1]\n    i = runningList2[a]\n    dictList_degradation_colocation[j][i].sort()\n    #print j,i,dictList_degradation_colocation[j][i]\n\n\n#APPENDING DEGRADATION SHUTTER\nfor (b,a) in enumerate(fList6):\n    if a in colocationListExperiments:\n        index = a\n    else:\n        if a in benchListExperiments:\n            dictList_degradation_shutter[index][a].append(fList6[b+1])\n\nfor (b,a) in enumerate(fList3):\n    if a in colocationListExperiments:\n        index = a\n    else:\n        if a in benchListExperiments:\n            dictList_degradation_shutter3[index][a].append(fList3[b+1])\n\nfor a in xrange(0,len(runningList2),2):\n    j = runningList2[a+1]\n    i = runningList2[a]\n    #print i,j,dictList_degradation_shutter[j][i]\n#APPENDING DEGRADATION SHUTTER2 as shutter and colocation values are tab separated\nfor a in xrange(0,len(runningList2),2):\n    j = runningList2[a+1]\n    i = runningList2[a]\n    for elem in dictList_degradation_shutter[j][i]:\n        dictList_degradation_shutter2[j][i].extend(elem.strip().split(\'\\t\'))\n\n    for elem in dictList_degradation_shutter3[j][i]:\n        dictList_degradation_shutter4[j][i].extend(elem.strip().split(\'\\t\'))\n    #print dictList_degradation_shutter2[j][i]\n\nyaxis2 = ()\nyaxis3 = ()\nyaxis_abs2 = ()\nyaxis_abs3 = ()\nerror2 = ()\nerror3 = ()\nxaxis2 = ()\nfor a in xrange(0,len(runningList2),2):\n    j = runningList2[a+1]\n    i = runningList2[a]\n    #print i,j\n    #print dictList_single_vm[i]\n    #print dictList_degradation_colocation[j][i]\n    #print dictList_degradation_shutter2[j][i]\n    denominator1 = sum(float(n) for (m,n) in enumerate(dictList_single_vm[i]) if m!=0 and m!=len(dictList_single_vm[i])-1)/(len(dictList_single_vm[i])-2)\n    numerator1 = sum(float(n) for (m,n) in enumerate(dictList_degradation_colocation[j][i]))/(len(dictList_degradation_colocation[j][i]))\n    shutter_temp_list = []\n    shutter_temp_list2 = []\n    colo_temp_list = []\n    colo_temp_list2 = []\n    degradation_temp_list = []\n    degradation_temp_list2 = []\n    error_temp_list = []\n    error_temp_list2 = []\n    #print numerator1\n    #print denominator1\n    for (count,item) in enumerate(dictList_degradation_shutter2[j][i]):\n        if count%2==0:\n            colo_temp_list.append(item)\n        if count%2==1:\n            shutter_temp_list.append(item)\n\n    for (count,item) in enumerate(dictList_degradation_shutter4[j][i]):\n        if count%2==0:\n            colo_temp_list2.append(item)\n        if count%2==1:\n            shutter_temp_list2.append(item)\n\n    for (count,item) in enumerate(shutter_temp_list):\n        degradation_temp_list.append(abs((((float(shutter_temp_list[count])/float(colo_temp_list[count]))-(numerator1/denominator1))/(float(shutter_temp_list[count])/float(colo_temp_list[count])))*100))\n\n    shutter_temp_list.sort()\n    shutter_temp_list2.sort()\n    colo_temp_list.sort()\n    colo_temp_list2.sort()\n    #print shutter_temp_list\n    #print colo_temp_list\n    #print dictList_degradation_shutter2[j][i]\n    denominator2 = sum(float(n) for (m,n) in enumerate(shutter_temp_list) if m!=0 and m!=len(shutter_temp_list)-1)/(len(shutter_temp_list)-2)\n    numerator2 = sum(float(n) for (m,n) in enumerate(colo_temp_list) if m!=0 and m!=len(colo_temp_list)-1)/(len(colo_temp_list)-2)\n    #denominator2 = sum(float(n) for (m,n) in enumerate(shutter_temp_list))/len(shutter_temp_list)\n    #numerator2 = sum(float(n) for (m,n) in enumerate(colo_temp_list))/len(colo_temp_list)\n    for (m,n) in enumerate(shutter_temp_list):\n        ratio=float(n)/float(colo_temp_list[m])\n        error_temp_list.append(abs((((ratio)-(numerator1/denominator1))/(numerator1/denominator1))*100))\n    plot_degradation_error[j][i]=np.std(error_temp_list)\n\n    denominator3 = sum(float(n) for (m,n) in enumerate(shutter_temp_list2))/(len(shutter_temp_list2))\n    numerator3 = sum(float(n) for (m,n) in enumerate(colo_temp_list2))/(len(colo_temp_list2))\n    for (m,n) in enumerate(shutter_temp_list2):\n        ratio=float(n)/float(colo_temp_list2[m])\n        error_temp_list2.append(abs((((ratio)-(numerator3/denominator3))/(numerator1/denominator1))*100))\n    plot_degradation_error2[j][i]=np.std(error_temp_list2)\n\n    #print numerator2\n    #print denominator2\n    del shutter_temp_list\n    del colo_temp_list\n    del degradation_temp_list\n    del shutter_temp_list2\n    del colo_temp_list2\n    del degradation_temp_list2\n    plot_degradation[j][i] = (((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100\n    plot_degradation_abs[j][i] = abs((((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100)\n    plot_degradation2[j][i] = (((numerator3/denominator3)-(numerator1/denominator1))/(numerator1/denominator1))*100\n    plot_degradation_abs2[j][i] = abs((((numerator3/denominator3)-(numerator1/denominator1))/(numerator1/denominator1))*100)\n    #print j,i,plot_degradation[j][i]\n    #print plot_degradation_error[j][i]\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    xaxis2 = xaxis2 + (i,)\n    yaxis2 = yaxis2 + (plot_degradation[j][i],)\n    yaxis3 = yaxis3 + (plot_degradation2[j][i],)\n    yaxis_abs2 = yaxis_abs2 + (plot_degradation_abs[j][i],)\n    yaxis_abs3 = yaxis_abs3 + (plot_degradation_abs2[j][i],)\n    error2 = error2 + (plot_degradation_error[j][i],)\n    error3 = error3 + (plot_degradation_error2[j][i],)\n\n\n#width=0.25\n#x = np.arange(len(yaxis2))\n#fig = plt.figure(figsize=(28, 5))\n##bar1 = plt.bar( x, yaxis, width, color="r", label=\'colocating with libquatum (avg = %.2f)\' %(np.mean(yaxis_abs)))\n#bar1 = plt.bar( x, yaxis_abs3, width, color="k", yerr=error3, label=\'Shuttering (mean: %.2f)\' %(np.mean(yaxis_abs3)))\n#bar2 = plt.bar( x+width, yaxis_abs2, width, color="lightgrey", yerr=error2, label=\'Snapshot (mean: %.2f)\' %(np.mean(yaxis_abs2)))\n##bar3 = plt.bar( x+width+width, yaxis3, width, color="g", label=\'colocating with sphinx  (avg = %.2f)\' %(np.mean(yaxis_abs3)))\n##autolabel(bar1)\n##autolabel(bar2)\n#plt.ylabel( \'Estimation error(%)\' ,fontsize=\'25\')\n##plt.title(\'Error in predicting degradation when co-locating with mcf\')\n#plt.xticks(x + width/2.0, xaxis2, rotation=\'30\', size=\'23\',  ha=\'center\', va=\'top\')\n#plt.yticks(np.arange(0,50,10),size=\'25\')\n#plt.ylim(0,40)\n#plt.xlim(-1,27)\n#plt.grid()\n#plt.tight_layout()\n#plt.legend(loc=9, ncol=2, prop={\'size\':28})\n##plt.savefig(\'%s_maybefinal_error.png\' %(filename), dpi=125)\n\ndel dictList_single_vm\ndel dictList_degradation_colocation\ndel dictList_degradation_shutter\ndel dictList_degradation_shutter2\ndel dictList_degradation_shutter3\ndel dictList_degradation_shutter4\ndel plot_degradation\ndel plot_degradation2\ndel plot_degradation_error\ndel plot_degradation_error2\ndel plot_degradation_abs\ndel plot_degradation_abs2\n\ndictList_single_vm = defaultdict(list)\ndictList_degradation_colocation = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter2 = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter3 = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter4 = defaultdict(lambda  : defaultdict(list))\nplot_degradation = defaultdict(dict)\nplot_degradation2 = defaultdict(dict)\nplot_degradation_error = defaultdict(dict)\nplot_degradation_error2 = defaultdict(dict)\nplot_degradation_abs = defaultdict(dict)\nplot_degradation_abs2 = defaultdict(dict)\n\nfor (b,a) in enumerate(fList9):\n    if a in siriusbenchListBaseline:\n        dictList_single_vm[a].append(fList9[b+1])\n\n#SORTING LIST CONTAING VALUES OF SINGLE SPEC RUNS INSIDE VMs\nfor i in siriusbenchListBaseline:\n    dictList_single_vm[i].sort()\n    #print i,dictList_single_vm[i]\n\nfor (b,a) in enumerate(fList10):\n    #print a\n    if a in siriuscolocationListBaseline:\n       #print a\n       index = a\n    else:\n        if a in siriusbenchListExperiments:\n            #print a\n            dictList_degradation_colocation[index][a].append(fList10[b+1])\n\n#sorting the ground truth values\nfor a in xrange(0,len(siriusrunningList2),2):\n    j = siriusrunningList2[a+1]\n    i = siriusrunningList2[a]\n    #print i,j\n    dictList_degradation_colocation[j][i].sort()\n    #print j,i,dictList_degradation_colocation[j][i]\n\n#for a in xrange(0,len(runningList),2):\n#    j = runningList[a+1]\n#    i = runningList[a]\n#    numerator1 = sum(float(n) for (m,n) in enumerate(dictList_degradation_colocation[j][i]) if m!=0 and m!=len(dictList_degradation_colocation[j][i])-1)/(len(dictList_degradation_colocation[j][i])-2)\n#    print numerator1\n#    #print dictList_degradation_colocation[runningList[a+1]][runningList[a]]\n#    #print numerator1\n\n#APPENDING DEGRADATION SHUTTER\nfor (b,a) in enumerate(fList11):\n    #print a\n    if a in siriuscolocationListExperiments:\n        index = a\n    else:\n        if a in siriusbenchListExperiments:\n            dictList_degradation_shutter[index][a].append(fList11[b+1])\n\nfor (b,a) in enumerate(fList8):\n    if a in siriuscolocationListExperiments:\n        index = a\n    else:\n        if a in siriusbenchListExperiments:\n            dictList_degradation_shutter3[index][a].append(fList8[b+1])\n\nfor a in xrange(0,len(siriusrunningList2),2):\n    j = siriusrunningList2[a+1]\n    i = siriusrunningList2[a]\n    #print i,j,dictList_degradation_shutter[j][i]\n#APPENDING DEGRADATION SHUTTER2 as shutter and colocation values are tab separated\nfor a in xrange(0,len(siriusrunningList2),2):\n    j = siriusrunningList2[a+1]\n    i = siriusrunningList2[a]\n    for elem in dictList_degradation_shutter[j][i]:\n        dictList_degradation_shutter2[j][i].extend(elem.strip().split(\'\\t\'))\n\n    for elem in dictList_degradation_shutter3[j][i]:\n        dictList_degradation_shutter4[j][i].extend(elem.strip().split(\'\\t\'))\n    #print dictList_degradation_shutter2[j][i]\n\nmcf_xaxis2 = ()\nmcf_yaxis2 = ()\nmcf_yaxis3 = ()\nmcf_yaxis_abs2 = ()\nmcf_yaxis_abs3 = ()\nmcf_error2 = ()\nmcf_error3 = ()\nfor a in xrange(0,len(siriusrunningList2),2):\n    j = siriusrunningList2[a+1]\n    i = siriusrunningList2[a]\n    #print i,j\n    #print i\n    #print dictList_single_vm[i]\n    #print dictList_degradation_colocation[j][i]\n    #print dictList_degradation_shutter2[j][i]\n    denominator1 = sum(float(n) for (m,n) in enumerate(dictList_single_vm[i]) if m!=0 and m!=len(dictList_single_vm[i])-1)/(len(dictList_single_vm[i])-2)\n    numerator1 = sum(float(n) for (m,n) in enumerate(dictList_degradation_colocation[j][i]))/(len(dictList_degradation_colocation[j][i]))\n    shutter_temp_list = []\n    shutter_temp_list2 = []\n    colo_temp_list = []\n    colo_temp_list2 = []\n    degradation_temp_list = []\n    degradation_temp_list2 = []\n    error_temp_list = []\n    error_temp_list2 = []\n    #print numerator1\n    #print denominator1\n    for (count,item) in enumerate(dictList_degradation_shutter2[j][i]):\n        if count%2==0:\n            colo_temp_list.append(item)\n        if count%2==1:\n            shutter_temp_list.append(item)\n\n    for (count,item) in enumerate(dictList_degradation_shutter4[j][i]):\n        if count%2==0:\n            colo_temp_list2.append(item)\n        if count%2==1:\n            shutter_temp_list2.append(item)\n\n    for (count,item) in enumerate(shutter_temp_list):\n        degradation_temp_list.append(abs((((float(shutter_temp_list[count])/float(colo_temp_list[count]))-(numerator1/denominator1))/(float(shutter_temp_list[count])/float(colo_temp_list[count])))*100))\n\n    shutter_temp_list.sort()\n    shutter_temp_list2.sort()\n    colo_temp_list.sort()\n    colo_temp_list2.sort()\n    #print shutter_temp_list\n    #print colo_temp_list\n    #print dictList_degradation_shutter2[j][i]\n    denominator2 = sum(float(n) for (m,n) in enumerate(shutter_temp_list) if m!=0 and m!=len(dictList_single_vm[i])-1)/(len(dictList_single_vm[i])-2)/len(shutter_temp_list)\n    numerator2 = sum(float(n) for (m,n) in enumerate(colo_temp_list) if m!=0 and m!=len(dictList_single_vm[i])-1)/(len(dictList_single_vm[i])-2 )/len(colo_temp_list)\n    for (m,n) in enumerate(shutter_temp_list):\n        ratio=float(n)/float(colo_temp_list[m])\n        error_temp_list.append(abs((((ratio)-(numerator1/denominator1))/(numerator1/denominator1))*100))\n    plot_degradation_error[j][i]=np.std(error_temp_list)\n\n    denominator3 = sum(float(n) for (m,n) in enumerate(shutter_temp_list2))/(len(shutter_temp_list2))\n    numerator3 = sum(float(n) for (m,n) in enumerate(colo_temp_list2))/(len(colo_temp_list2))\n    for (m,n) in enumerate(shutter_temp_list2):\n        ratio=float(n)/float(colo_temp_list2[m])\n        error_temp_list2.append(abs((((ratio)-(numerator3/denominator3))/(numerator1/denominator1))*100))\n    plot_degradation_error2[j][i]=np.std(error_temp_list2)\n\n    #print numerator2\n    #print denominator2\n    del shutter_temp_list\n    del colo_temp_list\n    del degradation_temp_list\n    del shutter_temp_list2\n    del colo_temp_list2\n    del degradation_temp_list2\n    plot_degradation[j][i] = (((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100\n    plot_degradation_abs[j][i] = abs((((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100)\n    plot_degradation2[j][i] = (((numerator3/denominator3)-(numerator1/denominator1))/(numerator1/denominator1))*100\n    plot_degradation_abs2[j][i] = abs((((numerator3/denominator3)-(numerator1/denominator1))/(numerator1/denominator1))*100)\n    #print j,i,plot_degradation[j][i]\n    #print plot_degradation_error[j][i]\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    mcf_xaxis2 = mcf_xaxis2 + (i,)\n    mcf_yaxis2 = mcf_yaxis2 + (plot_degradation[j][i],)\n    mcf_yaxis3 = mcf_yaxis3 + (plot_degradation2[j][i],)\n    mcf_yaxis_abs2 = mcf_yaxis_abs2 + (plot_degradation_abs[j][i],)\n    mcf_yaxis_abs3 = mcf_yaxis_abs3 + (plot_degradation_abs2[j][i],)\n    mcf_error2 = mcf_error2 + (plot_degradation_error[j][i],)\n    mcf_error3 = mcf_error3 + (plot_degradation_error2[j][i],)\n    #print numerator2,denominator2,numerator2/denominator2\n    #print denominator2/numerator2\n    print j,i,plot_degradation[j][i],plot_degradation2[j][i]\n            #print (((numerator2/denominator2)-(numerator1/denominator1))/(numerator2/denominator2))*100\n#print np.mean(yaxis2)\n\nbenchListBaseline = [ \'gcc\', \'perlbench\', \'leslie3d\', \'povray\', \'libquantum\', \'astar\', \'bzip2\', \'milc\', \'namd\', \'calculix\', \'h264ref\', \'sphinx3\', \'zeusmp\', \'gobmk\', \'hmmer\', \'tonto\', \'bwaves\', \'gromacs\', \'dealII\', \'sjeng\', \'lbm\', \'xalancbmk\', \'gamess\', \'cactusADM\', \'soplex\', \'GemsFDTD\', \'omnetpp\', \'mcf\' ]\nbenchListExperiments = [ \'gcc\', \'perlbench\', \'leslie3d\', \'povray\', \'libquantum\', \'astar\', \'bzip2\', \'milc\', \'namd\', \'calculix\', \'h264ref\', \'sphinx3\', \'zeusmp\', \'gobmk\', \'hmmer\', \'tonto\', \'bwaves\', \'gromacs\', \'dealII\', \'sjeng\', \'lbm\', \'xalancbmk\', \'gamess\', \'cactusADM\', \'soplex\', \'GemsFDTD\', \'omnetpp\', \'mcf\' ]\ncolocationListBaseline = [ \'colocating with lbm\', \'colocating with povray\', \'colocating with milc\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with mcf\' ]\ncolocationListExperiments = [ \'colocating with lbm\', \'colocating with povray\', \'colocating with milc\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with mcf\' ]\n\nrunningList2 = [  \'perlbench\', \'colocating with milc\', \'mcf\', \'colocating with milc\', \'leslie3d\', \'colocating with milc\', \'povray\', \'colocating with milc\', \'libquantum\', \'colocating with milc\', \'astar\', \'colocating with milc\', \'bzip2\', \'colocating with milc\', \'milc\', \'colocating with milc\', \'namd\', \'colocating with milc\', \'calculix\', \'colocating with milc\', \'h264ref\', \'colocating with milc\', \'gobmk\', \'colocating with milc\', \'hmmer\', \'colocating with milc\', \'tonto\', \'colocating with milc\', \'sphinx3\', \'colocating with milc\', \'zeusmp\', \'colocating with milc\', \'bwaves\', \'colocating with milc\', \'gromacs\', \'colocating with milc\', \'dealII\', \'colocating with milc\', \'sjeng\', \'colocating with milc\', \'lbm\', \'colocating with milc\', \'xalancbmk\', \'colocating with milc\', \'gamess\', \'colocating with milc\', \'cactusADM\', \'colocating with milc\', \'soplex\', \'colocating with milc\', \'GemsFDTD\', \'colocating with milc\', \'omnetpp\', \'colocating with milc\' ]\n\nsiriusbenchListBaseline = [ \'gmm\', \'dnn_asr\', \'surf-fe\', \'surf-fd\', \'stem\', \'regex\', \'crf\', \'img-imc\', \'img-dig\', \'img-face\', \'nlp-pos\', \'nlp-chk\', \'nlp-ner\']\nsiriusbenchListExperiments = [ \'gmm\', \'dnn_asr\', \'surf-fe\', \'surf-fd\', \'stem\', \'regex\', \'crf\', \'img-imc\', \'img-dig\', \'img-face\', \'nlp-pos\', \'nlp-chk\', \'nlp-ner\']\nsiriuscolocationListBaseline = [ \'colocating with lbm\', \'colocating with povray\', \'colocating with astar\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with mcf\' ]\nsiriuscolocationListExperiments = [ \'colocating with lbm\', \'colocating with povray\', \'colocating with perlbench\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with mcf\' ]\nsiriusrunningList2 = [ \'gmm\', \'colocating with milc\', \'dnn_asr\', \'colocating with milc\', \'surf-fe\', \'colocating with milc\', \'surf-fd\', \'colocating with milc\', \'stem\', \'colocating with milc\', \'regex\', \'colocating with milc\', \'crf\', \'colocating with milc\', \'img-imc\', \'colocating with milc\', \'img-dig\', \'colocating with milc\', \'img-face\', \'colocating with milc\', \'nlp-pos\', \'colocating with milc\', \'nlp-chk\', \'colocating with milc\', \'nlp-ner\' , \'colocating with milc\']\n\n\ndef autolabel(rects):\n    # attach some text labels\n    for rect in rects:\n        height = rect.get_height()\n        plt.text(rect.get_x()+rect.get_width()/2., 1.05*height, \'%.2f\'%float(height))\n\ndef autolabel2(rects):\n    # attach some text labels\n    for rect in rects:\n        height = rect.get_height()\n        plt.text(rect.get_x()+rect.get_width()/2., 1.05*height, \'%.2f\'%float(height))\n\ndef add_line(ax, xpos, ypos):\n    line = plt.Line2D([xpos, xpos], [ypos + .1, ypos - .5], transform=ax.transAxes, linewidth=2, color=\'black\')\n    line.set_clip_on(False)\n    ax.add_line(line)\n\n\nfilename = \'shutter_cpi_70\'\n#fList = [s.strip() for s in open(\'../../papergraphs/2.fullspec/accuracy/libquantumcorunner/single_vm_ground_truth/shutter_cpi_1000.txt\').readlines()]\n#fList2 = [s.strip() for s in open(\'../../papergraphs/2.fullspec/accuracy/libquantumcorunner/degradation_ground_truth/shutter_cpi_1000.txt\').readlines()]\n#fList3 = [s.strip() for s in open(\'../../papergraphs/2.fullspec/accuracy/libquantumcorunner/experiment_1/%s.txt\' % filename).readlines()]\nfList3= [s.strip() for s in open(\'../../papergraphs/accuracy/milccorunner/priorwork/shutter_cpi_5.txt\').readlines()]\n\nfList4 = [s.strip() for s in open(\'../../papergraphs/accuracy/milccorunner/singlevm/shutter_cpi_1000.txt\').readlines()]\nfList5 = [s.strip() for s in open(\'../../papergraphs/accuracy/milccorunner/degradation/shutter_cpi_1000.txt\').readlines()]\nfList6 = [s.strip() for s in open(\'../../papergraphs/accuracy/milccorunner/snapshot/%s.txt\' % filename).readlines()]\n\nfList8= [s.strip() for s in open(\'../../papergraphs/accuracy/milccorunner/siriusdjinn/priorwork/shutter_cpi_4.txt\').readlines()]\n\nfList9 = [s.strip() for s in open(\'../../papergraphs/accuracy/libquantumcorunner/siriusdjinn/singlevm/shutter_cpi_1000.txt\').readlines()]\nfList10 = [s.strip() for s in open(\'../../papergraphs/accuracy/milccorunner/siriusdjinn/degradation/shutter_cpi_1000.txt\').readlines()]\nfList11 = [s.strip() for s in open(\'../../papergraphs/accuracy/milccorunner/siriusdjinn/snapshot/shutter_cpi_75.txt\').readlines()]\n\n\ndictList_single_vm = defaultdict(list)\ndictList_degradation_colocation = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter2 = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter3 = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter4 = defaultdict(lambda  : defaultdict(list))\nplot_degradation = defaultdict(dict)\nplot_degradation2 = defaultdict(dict)\nplot_degradation_error = defaultdict(dict)\nplot_degradation_error2 = defaultdict(dict)\nplot_degradation_abs = defaultdict(dict)\nplot_degradation_abs2 = defaultdict(dict)\n\nfor (b,a) in enumerate(fList4):\n    if a in benchListBaseline:\n        dictList_single_vm[a].append(fList4[b+1])\n\n#SORTING LIST CONTAING VALUES OF SINGLE SPEC RUNS INSIDE VMs\nfor i in benchListBaseline:\n    dictList_single_vm[i].sort()\n    #print i,dictList_single_vm[i]\n\nfor (b,a) in enumerate(fList5):\n    #print a\n    if a in colocationListBaseline:\n       #print a\n       index = a\n    else:\n        if a in benchListExperiments:\n            #print a\n            dictList_degradation_colocation[index][a].append(fList5[b+1])\n\n#sorting the ground truth values\nfor a in xrange(0,len(runningList2),2):\n    j = runningList2[a+1]\n    i = runningList2[a]\n    dictList_degradation_colocation[j][i].sort()\n    #print j,i,dictList_degradation_colocation[j][i]\n\n\n\n#APPENDING DEGRADATION SHUTTER\nfor (b,a) in enumerate(fList6):\n    if a in colocationListExperiments:\n        index = a\n    else:\n        if a in benchListExperiments:\n            dictList_degradation_shutter[index][a].append(fList6[b+1])\n\nfor (b,a) in enumerate(fList3):\n    if a in colocationListExperiments:\n        index = a\n    else:\n        if a in benchListExperiments:\n            dictList_degradation_shutter3[index][a].append(fList3[b+1])\n\nfor a in xrange(0,len(runningList2),2):\n    j = runningList2[a+1]\n    i = runningList2[a]\n    #print i,j,dictList_degradation_shutter[j][i]\n#APPENDING DEGRADATION SHUTTER2 as shutter and colocation values are tab separated\nfor a in xrange(0,len(runningList2),2):\n    j = runningList2[a+1]\n    i = runningList2[a]\n    for elem in dictList_degradation_shutter[j][i]:\n        dictList_degradation_shutter2[j][i].extend(elem.strip().split(\'\\t\'))\n\n    for elem in dictList_degradation_shutter3[j][i]:\n        dictList_degradation_shutter4[j][i].extend(elem.strip().split(\'\\t\'))\n    #print dictList_degradation_shutter2[j][i]\n\nyaxis2 = ()\nyaxis3 = ()\nyaxis_abs2 = ()\nyaxis_abs3 = ()\nerror2 = ()\nerror3 = ()\nxaxis2 = ()\nfor a in xrange(0,len(runningList2),2):\n    j = runningList2[a+1]\n    i = runningList2[a]\n    #print i,j\n    #print dictList_single_vm[i]\n    #print dictList_degradation_colocation[j][i]\n    #print dictList_degradation_shutter2[j][i]\n    denominator1 = sum(float(n) for (m,n) in enumerate(dictList_single_vm[i]) if m!=0 and m!=len(dictList_single_vm[i])-1)/(len(dictList_single_vm[i])-2)\n    numerator1 = sum(float(n) for (m,n) in enumerate(dictList_degradation_colocation[j][i]))/(len(dictList_degradation_colocation[j][i]))\n    shutter_temp_list = []\n    shutter_temp_list2 = []\n    colo_temp_list = []\n    colo_temp_list2 = []\n    degradation_temp_list = []\n    degradation_temp_list2 = []\n    error_temp_list = []\n    error_temp_list2 = []\n    #print numerator1\n    #print denominator1\n    for (count,item) in enumerate(dictList_degradation_shutter2[j][i]):\n        if count%2==0:\n            colo_temp_list.append(item)\n        if count%2==1:\n            shutter_temp_list.append(item)\n\n    for (count,item) in enumerate(dictList_degradation_shutter4[j][i]):\n        if count%2==0:\n            colo_temp_list2.append(item)\n        if count%2==1:\n            shutter_temp_list2.append(item)\n\n    for (count,item) in enumerate(shutter_temp_list):\n        degradation_temp_list.append(abs((((float(shutter_temp_list[count])/float(colo_temp_list[count]))-(numerator1/denominator1))/(float(shutter_temp_list[count])/float(colo_temp_list[count])))*100))\n\n    shutter_temp_list.sort()\n    shutter_temp_list2.sort()\n    colo_temp_list.sort()\n    colo_temp_list2.sort()\n    #print shutter_temp_list\n    #print colo_temp_list\n    #print dictList_degradation_shutter2[j][i]\n    denominator2 = sum(float(n) for (m,n) in enumerate(shutter_temp_list) if m!=0 and m!=len(shutter_temp_list)-1)/(len(shutter_temp_list)-2)\n    numerator2 = sum(float(n) for (m,n) in enumerate(colo_temp_list) if m!=0 and m!=len(colo_temp_list)-1)/(len(colo_temp_list)-2)\n    for (m,n) in enumerate(shutter_temp_list):\n        ratio=float(n)/float(colo_temp_list[m])\n        error_temp_list.append(abs((((ratio)-(numerator1/denominator1))/(numerator1/denominator1))*100))\n    plot_degradation_error[j][i]=np.std(error_temp_list)\n\n    denominator3 = sum(float(n) for (m,n) in enumerate(shutter_temp_list2))/(len(shutter_temp_list2))\n    numerator3 = sum(float(n) for (m,n) in enumerate(colo_temp_list2))/(len(colo_temp_list2))\n    for (m,n) in enumerate(shutter_temp_list2):\n        ratio=float(n)/float(colo_temp_list2[m])\n        error_temp_list2.append(abs((((ratio)-(numerator3/denominator3))/(numerator1/denominator1))*100))\n    plot_degradation_error2[j][i]=np.std(error_temp_list2)\n\n    #print numerator2\n    #print denominator2\n    del shutter_temp_list\n    del colo_temp_list\n    del degradation_temp_list\n    del shutter_temp_list2\n    del colo_temp_list2\n    del degradation_temp_list2\n    plot_degradation[j][i] = (((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100\n    plot_degradation_abs[j][i] = abs((((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100)\n    plot_degradation2[j][i] = (((numerator3/denominator3)-(numerator1/denominator1))/(numerator1/denominator1))*100\n    plot_degradation_abs2[j][i] = abs((((numerator3/denominator3)-(numerator1/denominator1))/(numerator1/denominator1))*100)\n    #print j,i,plot_degradation[j][i]\n    #print plot_degradation_error[j][i]\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    xaxis2 = xaxis2 + (i,)\n    yaxis2 = yaxis2 + (plot_degradation[j][i],)\n    yaxis3 = yaxis3 + (plot_degradation2[j][i],)\n    yaxis_abs2 = yaxis_abs2 + (plot_degradation_abs[j][i],)\n    yaxis_abs3 = yaxis_abs3 + (plot_degradation_abs2[j][i],)\n    error2 = error2 + (plot_degradation_error[j][i],)\n    error3 = error3 + (plot_degradation_error2[j][i],)\n\n\n#width=0.25\n#x = np.arange(len(yaxis2))\n#fig = plt.figure(figsize=(28, 5))\n##bar1 = plt.bar( x, yaxis, width, color="r", label=\'colocating with libquatum (avg = %.2f)\' %(np.mean(yaxis_abs)))\n#bar1 = plt.bar( x, yaxis_abs3, width, color="k", yerr=error3, label=\'Shuttering (mean: %.2f)\' %(np.mean(yaxis_abs3)))\n#bar2 = plt.bar( x+width, yaxis_abs2, width, color="lightgrey", yerr=error2, label=\'Snapshot (mean: %.2f)\' %(np.mean(yaxis_abs2)))\n#\n#plt.ylabel( \'Estimation error (%)\',fontsize=\'25\' )\n##plt.title(\'Error in predicting degradation when co-locating with milc\')\n#plt.xticks(x + width/2.0, xaxis2, rotation=\'30\', size=\'23\',  ha=\'center\', va=\'top\')\n#plt.yticks(np.arange(0,50,10),size=\'25\')\n#plt.ylim(0,50)\n#plt.xlim(-1,27)\n#plt.grid()\n#plt.tight_layout()\n#plt.legend(loc=9, ncol=2, prop={\'size\':28})\n##plt.savefig(\'milc_accuracy.pdf\', dpi=125)\n\ndel dictList_single_vm\ndel dictList_degradation_colocation\ndel dictList_degradation_shutter\ndel dictList_degradation_shutter2\ndel dictList_degradation_shutter3\ndel dictList_degradation_shutter4\ndel plot_degradation\ndel plot_degradation2\ndel plot_degradation_error\ndel plot_degradation_error2\ndel plot_degradation_abs\ndel plot_degradation_abs2\n\ndictList_single_vm = defaultdict(list)\ndictList_degradation_colocation = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter2 = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter3 = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter4 = defaultdict(lambda  : defaultdict(list))\nplot_degradation = defaultdict(dict)\nplot_degradation2 = defaultdict(dict)\nplot_degradation_error = defaultdict(dict)\nplot_degradation_error2 = defaultdict(dict)\nplot_degradation_abs = defaultdict(dict)\nplot_degradation_abs2 = defaultdict(dict)\n\nfor (b,a) in enumerate(fList9):\n    if a in siriusbenchListBaseline:\n        dictList_single_vm[a].append(fList9[b+1])\n\n#SORTING LIST CONTAING VALUES OF SINGLE SPEC RUNS INSIDE VMs\nfor i in siriusbenchListBaseline:\n    dictList_single_vm[i].sort()\n    #print i,dictList_single_vm[i]\n\nfor (b,a) in enumerate(fList10):\n    #print a\n    if a in siriuscolocationListBaseline:\n       #print a\n       index = a\n    else:\n        if a in siriusbenchListExperiments:\n            #print a\n            dictList_degradation_colocation[index][a].append(fList10[b+1])\n\n#sorting the ground truth values\nfor a in xrange(0,len(siriusrunningList2),2):\n    j = siriusrunningList2[a+1]\n    i = siriusrunningList2[a]\n    #print i,j\n    dictList_degradation_colocation[j][i].sort()\n    #print j,i,dictList_degradation_colocation[j][i]\n\n#for a in xrange(0,len(runningList),2):\n#    j = runningList[a+1]\n#    i = runningList[a]\n#    numerator1 = sum(float(n) for (m,n) in enumerate(dictList_degradation_colocation[j][i]) if m!=0 and m!=len(dictList_degradation_colocation[j][i])-1)/(len(dictList_degradation_colocation[j][i])-2)\n#    print numerator1\n#    #print dictList_degradation_colocation[runningList[a+1]][runningList[a]]\n#    #print numerator1\n\n#APPENDING DEGRADATION SHUTTER\nfor (b,a) in enumerate(fList11):\n    #print a\n    if a in siriuscolocationListExperiments:\n        index = a\n    else:\n        if a in siriusbenchListExperiments:\n            dictList_degradation_shutter[index][a].append(fList11[b+1])\n\nfor (b,a) in enumerate(fList8):\n    if a in siriuscolocationListExperiments:\n        index = a\n    else:\n        if a in siriusbenchListExperiments:\n            dictList_degradation_shutter3[index][a].append(fList8[b+1])\n\nfor a in xrange(0,len(siriusrunningList2),2):\n    j = siriusrunningList2[a+1]\n    i = siriusrunningList2[a]\n    #print i,j,dictList_degradation_shutter[j][i]\n#APPENDING DEGRADATION SHUTTER2 as shutter and colocation values are tab separated\nfor a in xrange(0,len(siriusrunningList2),2):\n    j = siriusrunningList2[a+1]\n    i = siriusrunningList2[a]\n    for elem in dictList_degradation_shutter[j][i]:\n        dictList_degradation_shutter2[j][i].extend(elem.strip().split(\'\\t\'))\n\n    for elem in dictList_degradation_shutter3[j][i]:\n        dictList_degradation_shutter4[j][i].extend(elem.strip().split(\'\\t\'))\n    #print dictList_degradation_shutter2[j][i]\n\nmilc_xaxis2 = ()\nmilc_yaxis2 = ()\nmilc_yaxis3 = ()\nmilc_yaxis_abs2 = ()\nmilc_yaxis_abs3 = ()\nmilc_error2 = ()\nmilc_error3 = ()\nfor a in xrange(0,len(siriusrunningList2),2):\n    j = siriusrunningList2[a+1]\n    i = siriusrunningList2[a]\n    print i,j\n    #print i\n    #print dictList_single_vm[i]\n    print dictList_degradation_colocation[j][i]\n    #print dictList_degradation_shutter2[j][i]\n    denominator1 = sum(float(n) for (m,n) in enumerate(dictList_single_vm[i]) if m!=0 and m!=len(dictList_single_vm[i])-1)/(len(dictList_single_vm[i])-2)\n    numerator1 = sum(float(n) for (m,n) in enumerate(dictList_degradation_colocation[j][i]))/(len(dictList_degradation_colocation[j][i]))\n    shutter_temp_list = []\n    shutter_temp_list2 = []\n    colo_temp_list = []\n    colo_temp_list2 = []\n    degradation_temp_list = []\n    degradation_temp_list2 = []\n    error_temp_list = []\n    error_temp_list2 = []\n    #print numerator1\n    #print denominator1\n    for (count,item) in enumerate(dictList_degradation_shutter2[j][i]):\n        if count%2==0:\n            colo_temp_list.append(item)\n        if count%2==1:\n            shutter_temp_list.append(item)\n\n    for (count,item) in enumerate(dictList_degradation_shutter4[j][i]):\n        if count%2==0:\n            colo_temp_list2.append(item)\n        if count%2==1:\n            shutter_temp_list2.append(item)\n\n    for (count,item) in enumerate(shutter_temp_list):\n        degradation_temp_list.append(abs((((float(shutter_temp_list[count])/float(colo_temp_list[count]))-(numerator1/denominator1))/(float(shutter_temp_list[count])/float(colo_temp_list[count])))*100))\n\n    shutter_temp_list.sort()\n    shutter_temp_list2.sort()\n    colo_temp_list.sort()\n    colo_temp_list2.sort()\n    #print shutter_temp_list\n    #print colo_temp_list\n    #print dictList_degradation_shutter2[j][i]\n    denominator2 = sum(float(n) for (m,n) in enumerate(shutter_temp_list) if m!=0 and m!=len(dictList_single_vm[i])-1)/(len(dictList_single_vm[i])-2)/len(shutter_temp_list)\n    numerator2 = sum(float(n) for (m,n) in enumerate(colo_temp_list) if m!=0 and m!=len(dictList_single_vm[i])-1)/(len(dictList_single_vm[i])-2 )/len(colo_temp_list)\n    for (m,n) in enumerate(shutter_temp_list):\n        ratio=float(n)/float(colo_temp_list[m])\n        error_temp_list.append(abs((((ratio)-(numerator1/denominator1))/(numerator1/denominator1))*100))\n    plot_degradation_error[j][i]=np.std(error_temp_list)\n\n    denominator3 = sum(float(n) for (m,n) in enumerate(shutter_temp_list2))/(len(shutter_temp_list2))\n    numerator3 = sum(float(n) for (m,n) in enumerate(colo_temp_list2))/(len(colo_temp_list2))\n    for (m,n) in enumerate(shutter_temp_list2):\n        ratio=float(n)/float(colo_temp_list2[m])\n        error_temp_list2.append(abs((((ratio)-(numerator3/denominator3))/(numerator1/denominator1))*100))\n    plot_degradation_error2[j][i]=np.std(error_temp_list2)\n\n    #print numerator2\n    #print denominator2\n    del shutter_temp_list\n    del colo_temp_list\n    del degradation_temp_list\n    del shutter_temp_list2\n    del colo_temp_list2\n    del degradation_temp_list2\n    plot_degradation[j][i] = (((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100\n    plot_degradation_abs[j][i] = abs((((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100)\n    plot_degradation2[j][i] = (((numerator3/denominator3)-(numerator1/denominator1))/(numerator1/denominator1))*100\n    plot_degradation_abs2[j][i] = abs((((numerator3/denominator3)-(numerator1/denominator1))/(numerator1/denominator1))*100)\n    #print j,i,plot_degradation[j][i]\n    #print plot_degradation_error[j][i]\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    milc_xaxis2 = milc_xaxis2 + (i,)\n    milc_yaxis2 = milc_yaxis2 + (plot_degradation[j][i],)\n    milc_yaxis3 = milc_yaxis3 + (plot_degradation2[j][i],)\n    milc_yaxis_abs2 = milc_yaxis_abs2 + (plot_degradation_abs[j][i],)\n    milc_yaxis_abs3 = milc_yaxis_abs3 + (plot_degradation_abs2[j][i],)\n    milc_error2 = milc_error2 + (plot_degradation_error[j][i],)\n    milc_error3 = milc_error3 + (plot_degradation_error2[j][i],)\n    #print numerator2,denominator2,numerator2/denominator2\n    #print denominator2/numerator2\n    print j,i,plot_degradation[j][i],plot_degradation2[j][i]\n            #print (((numerator2/denominator2)-(numerator1/denominator1))/(numerator2/denominator2))*100\n#print np.mean(yaxis2)\n\nbenchListBaseline = [ \'gcc\', \'perlbench\', \'leslie3d\', \'povray\', \'libquantum\', \'astar\', \'bzip2\', \'milc\', \'namd\', \'calculix\', \'h264ref\', \'sphinx3\', \'zeusmp\', \'gobmk\', \'hmmer\', \'tonto\', \'bwaves\', \'gromacs\', \'dealII\', \'sjeng\', \'lbm\', \'xalancbmk\', \'gamess\', \'cactusADM\', \'soplex\', \'GemsFDTD\', \'omnetpp\', \'mcf\' ]\nbenchListExperiments = [ \'gcc\', \'perlbench\', \'leslie3d\', \'povray\', \'libquantum\', \'astar\', \'bzip2\', \'milc\', \'namd\', \'calculix\', \'h264ref\', \'sphinx3\', \'zeusmp\', \'gobmk\', \'hmmer\', \'tonto\', \'bwaves\', \'gromacs\', \'dealII\', \'sjeng\', \'lbm\', \'xalancbmk\', \'gamess\', \'cactusADM\', \'soplex\', \'GemsFDTD\', \'omnetpp\', \'mcf\' ]\ncolocationListBaseline = [ \'colocating with lbm\', \'colocating with milc\', \'colocating with astar\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with mcf\' ]\ncolocationListExperiments = [ \'colocating with lbm\', \'colocating with milc\', \'colocating with perlbench\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with mcf\' ]\nrunningList = [  \'perlbench\', \'colocating with milc\', \'mcf\', \'colocating with milc\', \'leslie3d\', \'colocating with milc\', \'povray\', \'colocating with milc\', \'libquantum\', \'colocating with milc\', \'astar\', \'colocating with milc\', \'bzip2\', \'colocating with milc\', \'milc\', \'colocating with milc\', \'namd\', \'colocating with milc\', \'calculix\', \'colocating with milc\', \'h264ref\', \'colocating with milc\', \'gobmk\', \'colocating with milc\', \'hmmer\', \'colocating with milc\', \'tonto\', \'colocating with milc\', \'sphinx3\', \'colocating with milc\', \'zeusmp\', \'colocating with milc\', \'bwaves\', \'colocating with milc\', \'gromacs\', \'colocating with milc\', \'dealII\', \'colocating with milc\', \'sjeng\', \'colocating with milc\', \'lbm\', \'colocating with milc\', \'xalancbmk\', \'colocating with milc\', \'gamess\', \'colocating with milc\', \'cactusADM\', \'colocating with milc\', \'soplex\', \'colocating with milc\', \'GemsFDTD\', \'colocating with milc\', \'omnetpp\', \'colocating with milc\' ]\nrunningList2 = [  \'leslie3d\', \'colocating with milc\', \'zeusmp\', \'colocating with milc\', \'milc\', \'colocating with milc\', \'namd\', \'colocating with milc\', \'calculix\', \'colocating with milc\', \'gobmk\', \'colocating with milc\', \'hmmer\', \'colocating with milc\', \'tonto\', \'colocating with milc\', \'sphinx3\', \'colocating with milc\', \'bwaves\', \'colocating with milc\', \'gromacs\', \'colocating with milc\', \'dealII\', \'colocating with milc\', \'sjeng\', \'colocating with milc\', \'gamess\', \'colocating with milc\', \'cactusADM\', \'colocating with milc\', \'soplex\', \'colocating with milc\', \'GemsFDTD\', \'colocating with milc\' ]\nrunningList3 = [  \'perlbench\', \'colocating with milc\', \'mcf\', \'colocating with milc\', \'povray\', \'colocating with milc\', \'libquantum\', \'colocating with milc\', \'astar\', \'colocating with milc\', \'bzip2\', \'colocating with milc\', \'h264ref\', \'colocating with milc\',  \'lbm\', \'colocating with milc\', \'xalancbmk\', \'colocating with milc\', \'omnetpp\', \'colocating with milc\' ]\n\nsiriusbenchListBaseline = [ \'gmm\', \'dnn_asr\', \'surf-fe\', \'surf-fd\', \'stem\', \'regex\', \'crf\', \'img-imc\', \'img-dig\', \'img-face\', \'nlp-pos\', \'nlp-chk\', \'nlp-ner\']\nsiriusbenchListExperiments = [ \'gmm\', \'dnn_asr\', \'surf-fe\', \'surf-fd\', \'stem\', \'regex\', \'crf\', \'img-imc\', \'img-dig\', \'img-face\', \'nlp-pos\', \'nlp-chk\', \'nlp-ner\']\nsiriuscolocationListBaseline = [ \'colocating with lbm\', \'colocating with povray\', \'colocating with astar\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with mcf\' ]\nsiriuscolocationListExperiments = [ \'colocating with lbm\', \'colocating with povray\', \'colocating with perlbench\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with mcf\' ]\nsiriusrunningList2 = [ \'gmm\', \'colocating with libquantum\', \'dnn_asr\', \'colocating with libquantum\', \'surf-fe\', \'colocating with libquantum\', \'surf-fd\', \'colocating with libquantum\', \'stem\', \'colocating with libquantum\', \'regex\', \'colocating with libquantum\', \'crf\', \'colocating with libquantum\', \'img-imc\', \'colocating with libquantum\', \'img-dig\', \'colocating with libquantum\', \'img-face\', \'colocating with libquantum\', \'nlp-pos\', \'colocating with libquantum\', \'nlp-chk\', \'colocating with libquantum\', \'nlp-ner\' , \'colocating with libquantum\']\n\ndef autolabel(rects):\n    # attach some text labels\n    for rect in rects:\n        height = rect.get_height()\n        plt.text(rect.get_x()+rect.get_width()/2., 1.05*height, \'%.2f\'%float(height))\n\ndef autolabel2(rects):\n    # attach some text labels\n    for rect in rects:\n        height = rect.get_height()\n        plt.text(rect.get_x()+rect.get_width()/2., 1.05*height, \'%.2f\'%float(height))\n\ndef add_line(ax, xpos, ypos):\n    line = plt.Line2D([xpos, xpos], [ypos + .1, ypos - .5], transform=ax.transAxes, linewidth=2, color=\'black\')\n    line.set_clip_on(False)\n    ax.add_line(line)\n\nfilename = \'shutter_cpi_10\'\n\nfList3= [s.strip() for s in open(\'../../papergraphs/mixcorunner/priorwork/shutter_cpi_4.txt\').readlines()]\n\nfList4 = [s.strip() for s in open(\'../../papergraphs/mixcorunner/singlevm/shutter_cpi_1000.txt\').readlines()]\nfList5 = [s.strip() for s in open(\'../../papergraphs/mixcorunner/degradation/shutter_cpi_1000.txt\').readlines()]\nfList6 = [s.strip() for s in open(\'../../papergraphs/mixcorunner/snapshot/%s.txt\' % filename).readlines()]\nfList7 = [s.strip() for s in open(\'../../papergraphs/mixcorunner/degradation/shutter_cpi_100.txt\').readlines()]\n\nfList8= [s.strip() for s in open(\'../../papergraphs/mixcorunner/siriusdjinn/priorwork/shutter_cpi_4.txt\').readlines()]\n\nfList9 = [s.strip() for s in open(\'../../papergraphs/accuracy/libquantumcorunner/siriusdjinn/singlevm/shutter_cpi_1000.txt\').readlines()]\nfList10 = [s.strip() for s in open(\'../../papergraphs/mixcorunner/siriusdjinn/degradation/shutter_cpi_1000.txt\').readlines()]\nfList11 = [s.strip() for s in open(\'../../papergraphs/mixcorunner/siriusdjinn/snapshot/shutter_cpi_75.txt\').readlines()]\n\ndictList_single_vm = defaultdict(list)\ndictList_degradation_colocation = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter2 = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter3 = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter4 = defaultdict(lambda  : defaultdict(list))\nplot_degradation = defaultdict(dict)\nplot_degradation2 = defaultdict(dict)\nplot_degradation_error = defaultdict(dict)\nplot_degradation_error2 = defaultdict(dict)\nplot_degradation_abs = defaultdict(dict)\nplot_degradation_abs2 = defaultdict(dict)\n\nfor (b,a) in enumerate(fList4):\n    if a in benchListBaseline:\n        dictList_single_vm[a].append(fList4[b+1])\n\n#SORTING LIST CONTAING VALUES OF SINGLE SPEC RUNS INSIDE VMs\nfor i in benchListBaseline:\n    dictList_single_vm[i].sort()\n    #print i,dictList_single_vm[i]\n\nfor (b,a) in enumerate(fList5):\n    #print a\n    if a in colocationListBaseline:\n       #print a\n       index = a\n    else:\n        if a in benchListExperiments:\n            #print a\n            dictList_degradation_colocation[index][a].append(fList5[b+1])\n\n#sorting the ground truth values\nfor a in xrange(0,len(runningList2),2):\n    j = runningList2[a+1]\n    i = runningList2[a]\n    dictList_degradation_colocation[j][i].sort()\n    #print j,i,dictList_degradation_colocation[j][i]\n\n\n#APPENDING DEGRADATION SHUTTER\nfor (b,a) in enumerate(fList6):\n    if a in colocationListExperiments:\n        index = a\n    else:\n        if a in benchListExperiments:\n            dictList_degradation_shutter[index][a].append(fList6[b+1])\n\nfor (b,a) in enumerate(fList3):\n    if a in colocationListExperiments:\n        index = a\n    else:\n        if a in benchListExperiments:\n            dictList_degradation_shutter3[index][a].append(fList3[b+1])\n\nfor a in xrange(0,len(runningList2),2):\n    j = runningList2[a+1]\n    i = runningList2[a]\n    #print i,j,dictList_degradation_shutter[j][i]\n#APPENDING DEGRADATION SHUTTER2 as shutter and colocation values are tab separated\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    for elem in dictList_degradation_shutter[j][i]:\n        dictList_degradation_shutter2[j][i].extend(elem.strip().split(\'\\t\'))\n\n    for elem in dictList_degradation_shutter3[j][i]:\n        dictList_degradation_shutter4[j][i].extend(elem.strip().split(\'\\t\'))\n    #print dictList_degradation_shutter2[j][i]\n\nyaxis2 = ()\nyaxis3 = ()\nyaxis_abs2 = ()\nyaxis_abs3 = ()\nerror2 = ()\nerror3 = ()\nxaxis2 = ()\nfor a in xrange(0,len(runningList2),2):\n    j = runningList2[a+1]\n    i = runningList2[a]\n    #print i,j\n    #print dictList_single_vm[i]\n    #print dictList_degradation_colocation[j][i]\n    #print dictList_degradation_shutter2[j][i]\n    denominator1 = sum(float(n) for (m,n) in enumerate(dictList_single_vm[i]) if m!=0 and m!=len(dictList_single_vm[i])-1)/(len(dictList_single_vm[i])-2)\n    numerator1 = sum(float(n) for (m,n) in enumerate(dictList_degradation_colocation[j][i]))/(len(dictList_degradation_colocation[j][i]))\n    shutter_temp_list = []\n    shutter_temp_list2 = []\n    colo_temp_list = []\n    colo_temp_list2 = []\n    degradation_temp_list = []\n    degradation_temp_list2 = []\n    error_temp_list = []\n    error_temp_list2 = []\n    #print numerator1\n    #print denominator1\n    for (count,item) in enumerate(dictList_degradation_shutter2[j][i]):\n        if count%2==0:\n            colo_temp_list.append(item)\n        if count%2==1:\n            shutter_temp_list.append(item)\n\n    for (count,item) in enumerate(dictList_degradation_shutter4[j][i]):\n        if count%2==0:\n            colo_temp_list2.append(item)\n        if count%2==1:\n            shutter_temp_list2.append(item)\n\n    for (count,item) in enumerate(shutter_temp_list):\n        degradation_temp_list.append(abs((((float(shutter_temp_list[count])/float(colo_temp_list[count]))-(numerator1/denominator1))/(float(shutter_temp_list[count])/float(colo_temp_list[count])))*100))\n\n    shutter_temp_list.sort()\n    shutter_temp_list2.sort()\n    colo_temp_list.sort()\n    colo_temp_list2.sort()\n    #print shutter_temp_list\n    #print colo_temp_list\n    #print dictList_degradation_shutter2[j][i]\n    denominator2 = sum(float(n) for (m,n) in enumerate(shutter_temp_list))/len(shutter_temp_list)\n    numerator2 = sum(float(n) for (m,n) in enumerate(colo_temp_list))/len(colo_temp_list)\n    for (m,n) in enumerate(shutter_temp_list):\n        ratio=float(n)/float(colo_temp_list[m])\n        error_temp_list.append(abs((((ratio)-(numerator1/denominator1))/(numerator1/denominator1))*100))\n    plot_degradation_error[j][i]=np.std(error_temp_list)\n\n    denominator3 = sum(float(n) for (m,n) in enumerate(shutter_temp_list2))/(len(shutter_temp_list2))\n    numerator3 = sum(float(n) for (m,n) in enumerate(colo_temp_list2))/(len(colo_temp_list2))\n    for (m,n) in enumerate(shutter_temp_list2):\n        ratio=float(n)/float(colo_temp_list2[m])\n        error_temp_list2.append(abs((((ratio)-(numerator3/denominator3))/(numerator1/denominator1))*100))\n    plot_degradation_error2[j][i]=np.std(error_temp_list2)\n\n    #print numerator2\n    #print denominator2\n    del shutter_temp_list\n    del colo_temp_list\n    del degradation_temp_list\n    del shutter_temp_list2\n    del colo_temp_list2\n    del degradation_temp_list2\n    plot_degradation[j][i] = (((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100\n    plot_degradation_abs[j][i] = abs((((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100)\n    plot_degradation2[j][i] = (((numerator3/denominator3)-(numerator1/denominator1))/(numerator1/denominator1))*100\n    plot_degradation_abs2[j][i] = abs((((numerator3/denominator3)-(numerator1/denominator1))/(numerator1/denominator1))*100)\n    #print j,i,plot_degradation[j][i]\n    #print plot_degradation_error[j][i]\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    #xaxis2 = xaxis2 + (i,)\n    #yaxis2 = yaxis2 + (plot_degradation[j][i],)\n    #yaxis3 = yaxis3 + (plot_degradation2[j][i],)\n    #yaxis_abs2 = yaxis_abs2 + (plot_degradation_abs[j][i],)\n    #yaxis_abs3 = yaxis_abs3 + (plot_degradation_abs2[j][i],)\n    #error2 = error2 + (plot_degradation_error[j][i],)\n    #error3 = error3 + (plot_degradation_error2[j][i],)\n    #print numerator2,denominator2,numerator2/denominator2\n    #print denominator2/numerator2\n    #print j,i,plot_degradation[j][i]\n            #print (((numerator2/denominator2)-(numerator1/denominator1))/(numerator2/denominator2))*100\n#print np.mean(yaxis2)\n\n\ndel dictList_degradation_colocation\ndictList_degradation_colocation = defaultdict(lambda  : defaultdict(list))\n\nfor (b,a) in enumerate(fList5):\n    #print a\n    if a in colocationListBaseline:\n       #print a\n       index = a\n    else:\n        if a in benchListExperiments:\n            #print index,a\n            dictList_degradation_colocation[index][a].append(fList5[b+1])\n            #print dictList_degradation_colocation[index][a]\n\n#sorting the ground truth values\nfor a in xrange(0,len(runningList3),2):\n    j = runningList3[a+1]\n    i = runningList3[a]\n    dictList_degradation_colocation[j][i].sort()\n    #print j,i,dictList_degradation_colocation[j][i]\n\n\nfor a in xrange(0,len(runningList3),2):\n    j = runningList3[a+1]\n    i = runningList3[a]\n    #print i,j\n    #print dictList_single_vm[i]\n    #print dictList_degradation_colocation[j][i]\n    #print dictList_degradation_shutter2[j][i]\n    denominator1 = sum(float(n) for (m,n) in enumerate(dictList_single_vm[i]) if m!=0 and m!=len(dictList_single_vm[i])-1)/(len(dictList_single_vm[i])-2)\n    numerator1 = sum(float(n) for (m,n) in enumerate(dictList_degradation_colocation[j][i]))/(len(dictList_degradation_colocation[j][i]))\n    shutter_temp_list = []\n    shutter_temp_list2 = []\n    colo_temp_list = []\n    colo_temp_list2 = []\n    degradation_temp_list = []\n    degradation_temp_list2 = []\n    error_temp_list = []\n    error_temp_list2 = []\n    #print numerator1\n    #print denominator1\n    #for (count,item) in enumerate(dictList_degradation_shutter2[j][i]):\n    #    if count%2==0:\n    #        colo_temp_list.append(item)\n    #    if count%2==1:\n    #        shutter_temp_list.append(item)\n\n    for (count,item) in enumerate(dictList_degradation_shutter4[j][i]):\n        if count%2==0:\n            colo_temp_list2.append(item)\n        if count%2==1:\n            shutter_temp_list2.append(item)\n\n    #for (count,item) in enumerate(shutter_temp_list):\n    #    degradation_temp_list.append(abs((((float(shutter_temp_list[count])/float(colo_temp_list[count]))-(numerator1/denominator1))/(float(shutter_temp_list[count])/float(colo_temp_list[count])))*100))\n\n    #shutter_temp_list.sort()\n    shutter_temp_list2.sort()\n    #colo_temp_list.sort()\n    colo_temp_list2.sort()\n\n    denominator3 = sum(float(n) for (m,n) in enumerate(shutter_temp_list2))/(len(shutter_temp_list2))\n    numerator3 = sum(float(n) for (m,n) in enumerate(colo_temp_list2))/(len(colo_temp_list2))\n    for (m,n) in enumerate(shutter_temp_list2):\n        ratio=float(n)/float(colo_temp_list2[m])\n        error_temp_list2.append(abs((((ratio)-(numerator3/denominator3))/(numerator1/denominator1))*100))\n    plot_degradation_error2[j][i]=np.std(error_temp_list2)\n\n    #print numerator2\n    #print denominator2\n    #del shutter_temp_list\n    #del colo_temp_list\n    #del degradation_temp_list\n    del shutter_temp_list2\n    del colo_temp_list2\n    del degradation_temp_list2\n    #plot_degradation[j][i] = (((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100\n    #plot_degradation_abs[j][i] = abs((((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100)\n    plot_degradation2[j][i] = (((numerator3/denominator3)-(numerator1/denominator1))/(numerator1/denominator1))*100\n    plot_degradation_abs2[j][i] = abs((((numerator3/denominator3)-(numerator1/denominator1))/(numerator1/denominator1))*100)\n    #print j,i,plot_degradation[j][i]\n    #print plot_degradation_error[j][i]\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    #xaxis2 = xaxis2 + (i,)\n    #yaxis2 = yaxis2 + (plot_degradation[j][i],)\n    #yaxis3 = yaxis3 + (plot_degradation2[j][i],)\n    #yaxis_abs2 = yaxis_abs2 + (plot_degradation_abs[j][i],)\n    #yaxis_abs3 = yaxis_abs3 + (plot_degradation_abs2[j][i],)\n    #error2 = error2 + (plot_degradation_error[j][i],)\n    #error3 = error3 + (plot_degradation_error2[j][i],)\n    #print numerator2,denominator2,numerator2/denominator2\n    #print denominator2/numerator2\n    #print j,i,plot_degradation[j][i]\n            #print (((numerator2/denominator2)-(numerator1/denominator1))/(numerator2/denominator2))*100\n\ndel dictList_degradation_colocation\ndictList_degradation_colocation = defaultdict(lambda  : defaultdict(list))\n\nfor (b,a) in enumerate(fList7):\n    #print a\n    if a in colocationListBaseline:\n       #print a\n       index = a\n    else:\n        if a in benchListExperiments:\n            #print index,a\n            dictList_degradation_colocation[index][a].append(fList7[b+1])\n            #print dictList_degradation_colocation[index][a]\n\n#sorting the ground truth values\nfor a in xrange(0,len(runningList3),2):\n    j = runningList3[a+1]\n    i = runningList3[a]\n    dictList_degradation_colocation[j][i].sort()\n    #print j,i,dictList_degradation_colocation[j][i]\n\n\nfor a in xrange(0,len(runningList3),2):\n    j = runningList3[a+1]\n    i = runningList3[a]\n    print i,j\n    #print dictList_single_vm[i]\n    #print dictList_degradation_colocation[j][i]\n    #print dictList_degradation_shutter2[j][i]\n    denominator1 = sum(float(n) for (m,n) in enumerate(dictList_single_vm[i]) if m!=0 and m!=len(dictList_single_vm[i])-1)/(len(dictList_single_vm[i])-2)\n    numerator1 = sum(float(n) for (m,n) in enumerate(dictList_degradation_colocation[j][i]))/(len(dictList_degradation_colocation[j][i]))\n    shutter_temp_list = []\n    shutter_temp_list2 = []\n    colo_temp_list = []\n    colo_temp_list2 = []\n    degradation_temp_list = []\n    degradation_temp_list2 = []\n    error_temp_list = []\n    error_temp_list2 = []\n    #print numerator1\n    #print denominator1\n    for (count,item) in enumerate(dictList_degradation_shutter2[j][i]):\n        if count%2==0:\n            colo_temp_list.append(item)\n        if count%2==1:\n            shutter_temp_list.append(item)\n\n    #for (count,item) in enumerate(dictList_degradation_shutter4[j][i]):\n    #    if count%2==0:\n    #        colo_temp_list2.append(item)\n    #    if count%2==1:\n    #        shutter_temp_list2.append(item)\n\n    #for (count,item) in enumerate(shutter_temp_list):\n    #    degradation_temp_list.append(abs((((float(shutter_temp_list[count])/float(colo_temp_list[count]))-(numerator1/denominator1))/(float(shutter_temp_list[count])/float(colo_temp_list[count])))*100))\n\n    shutter_temp_list.sort()\n    #shutter_temp_list2.sort()\n    colo_temp_list.sort()\n    #colo_temp_list2.sort()\n    #print shutter_temp_list\n    #print colo_temp_list\n    #print dictList_degradation_shutter2[j][i]\n    denominator2 = sum(float(n) for (m,n) in enumerate(shutter_temp_list))/len(shutter_temp_list)\n    numerator2 = sum(float(n) for (m,n) in enumerate(colo_temp_list))/len(colo_temp_list)\n    for (m,n) in enumerate(shutter_temp_list):\n        ratio=float(n)/float(colo_temp_list[m])\n        error_temp_list.append(abs((((ratio)-(numerator1/denominator1))/(numerator1/denominator1))*100))\n    plot_degradation_error[j][i]=np.std(error_temp_list)\n\n    #denominator3 = sum(float(n) for (m,n) in enumerate(shutter_temp_list2))/(len(shutter_temp_list2))\n    #numerator3 = sum(float(n) for (m,n) in enumerate(colo_temp_list2))/(len(colo_temp_list2))\n    #for (m,n) in enumerate(shutter_temp_list2):\n    #    ratio=float(n)/float(colo_temp_list2[m])\n    #    error_temp_list2.append(abs((((ratio)-(numerator3/denominator3))/(numerator1/denominator1))*100))\n    #plot_degradation_error2[j][i]=np.std(error_temp_list2)\n\n    #print numerator2\n    #print denominator2\n    del shutter_temp_list\n    del colo_temp_list\n    del degradation_temp_list\n    #del shutter_temp_list2\n    #del colo_temp_list2\n    #del degradation_temp_list2\n    plot_degradation[j][i] = (((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100\n    plot_degradation_abs[j][i] = abs((((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100)\n    #plot_degradation2[j][i] = (((numerator3/denominator3)-(numerator1/denominator1))/(numerator1/denominator1))*100\n    #plot_degradation_abs2[j][i] = abs((((numerator3/denominator3)-(numerator1/denominator1))/(numerator1/denominator1))*100)\n    #print j,i,plot_degradation[j][i]\n    #print plot_degradation_error[j][i]\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    #xaxis2 = xaxis2 + (i,)\n    #yaxis2 = yaxis2 + (plot_degradation[j][i],)\n    #yaxis3 = yaxis3 + (plot_degradation2[j][i],)\n    #yaxis_abs2 = yaxis_abs2 + (plot_degradation_abs[j][i],)\n    #yaxis_abs3 = yaxis_abs3 + (plot_degradation_abs2[j][i],)\n    #error2 = error2 + (plot_degradation_error[j][i],)\n    #error3 = error3 + (plot_degradation_error2[j][i],)\n    #print numerator2,denominator2,numerator2/denominator2\n    #print denominator2/numerator2\n    #print j,i,plot_degradation[j][i]\n            #print (((numerator2/denominator2)-(numerator1/denominator1))/(numerator2/denominator2))*100\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    xaxis2 = xaxis2 + (i,)\n    yaxis2 = yaxis2 + (plot_degradation[j][i],)\n    yaxis3 = yaxis3 + (plot_degradation2[j][i],)\n    yaxis_abs2 = yaxis_abs2 + (plot_degradation_abs[j][i],)\n    yaxis_abs3 = yaxis_abs3 + (plot_degradation_abs2[j][i],)\n    error2 = error2 + (plot_degradation_error[j][i],)\n    error3 = error3 + (plot_degradation_error2[j][i],)\n\n\n#width=0.25\n#x = np.arange(len(yaxis2))\n#fig = plt.figure(figsize=(28, 5))\n##bar1 = plt.bar( x, yaxis, width, color="r", label=\'colocating with libquatum (avg = %.2f)\' %(np.mean(yaxis_abs)))\n#bar1 = plt.bar( x, yaxis_abs3, width, color="k", yerr=error3, label=\'Shuttering (mean: %.2f)\' %(np.mean(yaxis_abs3)))\n#bar2 = plt.bar( x+width, yaxis_abs2, width, color="lightgrey", yerr=error2, label=\'Snapshot (mean: %.2f)\' %(np.mean(yaxis_abs2)))\n##bar3 = plt.bar( x+width+width, yaxis3, width, color="g", label=\'colocating with sphinx  (avg = %.2f)\' %(np.mean(yaxis_abs3)))\n##autolabel(bar1)\n##autolabel(bar2)\n#plt.ylabel( \'Estimation error (%)\' ,fontsize=\'25\')\n##plt.title(\'Error in predicting degradation when co-locating with libquantum\')\n#plt.xticks(x + width/2.0, xaxis2, rotation=\'30\', size=\'23\',  ha=\'center\', va=\'top\')\n##plt.yticks((-0.5,0,1,2,3,4),(\'\',\'0\',\'1\',\'2\',\'3\',\'4\'),size=\'23\')\n#plt.yticks(np.arange(0,50,10),size=\'25\')\n#plt.ylim(0,40)\n#plt.xlim(-1,26)\n#plt.grid()\n#plt.tight_layout()\n#plt.legend(loc=9, ncol=2, prop={\'size\':28})\n##plt.savefig(\'mix_error.pdf\', dpi=125)\n\n\ndel dictList_single_vm\ndel dictList_degradation_colocation\ndel dictList_degradation_shutter\ndel dictList_degradation_shutter2\ndel dictList_degradation_shutter3\ndel dictList_degradation_shutter4\ndel plot_degradation\ndel plot_degradation2\ndel plot_degradation_error\ndel plot_degradation_error2\ndel plot_degradation_abs\ndel plot_degradation_abs2\n\ndictList_single_vm = defaultdict(list)\ndictList_degradation_colocation = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter2 = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter3 = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter4 = defaultdict(lambda  : defaultdict(list))\nplot_degradation = defaultdict(dict)\nplot_degradation2 = defaultdict(dict)\nplot_degradation_error = defaultdict(dict)\nplot_degradation_error2 = defaultdict(dict)\nplot_degradation_abs = defaultdict(dict)\nplot_degradation_abs2 = defaultdict(dict)\n\nfor (b,a) in enumerate(fList9):\n    if a in siriusbenchListBaseline:\n        dictList_single_vm[a].append(fList9[b+1])\n\n#SORTING LIST CONTAING VALUES OF SINGLE SPEC RUNS INSIDE VMs\nfor i in siriusbenchListBaseline:\n    dictList_single_vm[i].sort()\n    #print i,dictList_single_vm[i]\n\nfor (b,a) in enumerate(fList10):\n    #print a\n    if a in siriuscolocationListBaseline:\n       #print a\n       index = a\n    else:\n        if a in siriusbenchListExperiments:\n            #print a\n            dictList_degradation_colocation[index][a].append(fList10[b+1])\n\n#sorting the ground truth values\nfor a in xrange(0,len(siriusrunningList2),2):\n    j = siriusrunningList2[a+1]\n    i = siriusrunningList2[a]\n    #print i,j\n    dictList_degradation_colocation[j][i].sort()\n    #print j,i,dictList_degradation_colocation[j][i]\n\n#for a in xrange(0,len(runningList),2):\n#    j = runningList[a+1]\n#    i = runningList[a]\n#    numerator1 = sum(float(n) for (m,n) in enumerate(dictList_degradation_colocation[j][i]) if m!=0 and m!=len(dictList_degradation_colocation[j][i])-1)/(len(dictList_degradation_colocation[j][i])-2)\n#    print numerator1\n#    #print dictList_degradation_colocation[runningList[a+1]][runningList[a]]\n#    #print numerator1\n\n#APPENDING DEGRADATION SHUTTER\nfor (b,a) in enumerate(fList11):\n    #print a\n    if a in siriuscolocationListExperiments:\n        index = a\n    else:\n        if a in siriusbenchListExperiments:\n            dictList_degradation_shutter[index][a].append(fList11[b+1])\n\nfor (b,a) in enumerate(fList8):\n    if a in siriuscolocationListExperiments:\n        index = a\n    else:\n        if a in siriusbenchListExperiments:\n            dictList_degradation_shutter3[index][a].append(fList8[b+1])\n\nfor a in xrange(0,len(siriusrunningList2),2):\n    j = siriusrunningList2[a+1]\n    i = siriusrunningList2[a]\n    #print i,j,dictList_degradation_shutter[j][i]\n    #print i,j\n#APPENDING DEGRADATION SHUTTER2 as shutter and colocation values are tab separated\nfor a in xrange(0,len(siriusrunningList2),2):\n    j = siriusrunningList2[a+1]\n    i = siriusrunningList2[a]\n    #print i,j\n    for elem in dictList_degradation_shutter[j][i]:\n        dictList_degradation_shutter2[j][i].extend(elem.strip().split(\'\\t\'))\n        #print dictList_degradation_shutter2[j][i]\n\n    for elem in dictList_degradation_shutter3[j][i]:\n        dictList_degradation_shutter4[j][i].extend(elem.strip().split(\'\\t\'))\n    #print dictList_degradation_shutter2[j][i]\n\nmix_xaxis2 = ()\nmix_yaxis2 = ()\nmix_yaxis3 = ()\nmix_yaxis_abs2 = ()\nmix_yaxis_abs3 = ()\nmix_error2 = ()\nmix_error3 = ()\nfor a in xrange(0,len(siriusrunningList2),2):\n    j = siriusrunningList2[a+1]\n    i = siriusrunningList2[a]\n    #print i,j\n    #print i\n    #print dictList_single_vm[i]\n    #print dictList_degradation_colocation[j][i]\n    #print dictList_degradation_shutter2[j][i]\n    denominator1 = sum(float(n) for (m,n) in enumerate(dictList_single_vm[i]) if m!=0 and m!=len(dictList_single_vm[i])-1)/(len(dictList_single_vm[i])-2)\n    numerator1 = sum(float(n) for (m,n) in enumerate(dictList_degradation_colocation[j][i]))/(len(dictList_degradation_colocation[j][i]))\n    shutter_temp_list = []\n    shutter_temp_list2 = []\n    colo_temp_list = []\n    colo_temp_list2 = []\n    degradation_temp_list = []\n    degradation_temp_list2 = []\n    error_temp_list = []\n    error_temp_list2 = []\n    #print numerator1\n    #print denominator1\n    for (count,item) in enumerate(dictList_degradation_shutter2[j][i]):\n        if count%2==0:\n            colo_temp_list.append(item)\n        if count%2==1:\n            shutter_temp_list.append(item)\n\n    for (count,item) in enumerate(dictList_degradation_shutter4[j][i]):\n        if count%2==0:\n            colo_temp_list2.append(item)\n        if count%2==1:\n            shutter_temp_list2.append(item)\n\n    #print \'1 %s\' %shutter_temp_list\n    #print colo_temp_list\n    for (count,item) in enumerate(shutter_temp_list):\n        degradation_temp_list.append(abs((((float(shutter_temp_list[count])/float(colo_temp_list[count]))-(numerator1/denominator1))/(float(shutter_temp_list[count])/float(colo_temp_list[count])))*100))\n\n    shutter_temp_list.sort()\n    shutter_temp_list2.sort()\n    colo_temp_list.sort()\n    colo_temp_list2.sort()\n    #print shutter_temp_list\n    #print colo_temp_list\n    #print dictList_degradation_shutter2[j][i]\n    denominator2 = sum(float(n) for (m,n) in enumerate(shutter_temp_list))/len(shutter_temp_list)\n    numerator2 = sum(float(n) for (m,n) in enumerate(colo_temp_list))/len(colo_temp_list)\n    for (m,n) in enumerate(shutter_temp_list):\n        ratio=float(n)/float(colo_temp_list[m])\n        error_temp_list.append(abs((((ratio)-(numerator1/denominator1))/(numerator1/denominator1))*100))\n    plot_degradation_error[j][i]=np.std(error_temp_list)\n\n    denominator3 = sum(float(n) for (m,n) in enumerate(shutter_temp_list2))/(len(shutter_temp_list2))\n    numerator3 = sum(float(n) for (m,n) in enumerate(colo_temp_list2))/(len(colo_temp_list2))\n    for (m,n) in enumerate(shutter_temp_list2):\n        ratio=float(n)/float(colo_temp_list2[m])\n        error_temp_list2.append(abs((((ratio)-(numerator3/denominator3))/(numerator1/denominator1))*100))\n    plot_degradation_error2[j][i]=np.std(error_temp_list2)\n\n    #print numerator2\n    #print denominator2\n    del shutter_temp_list\n    del colo_temp_list\n    del degradation_temp_list\n    del shutter_temp_list2\n    del colo_temp_list2\n    del degradation_temp_list2\n    plot_degradation[j][i] = (((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100\n    plot_degradation_abs[j][i] = abs((((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100)\n    plot_degradation2[j][i] = (((numerator3/denominator3)-(numerator1/denominator1))/(numerator1/denominator1))*100\n    plot_degradation_abs2[j][i] = abs((((numerator3/denominator3)-(numerator1/denominator1))/(numerator1/denominator1))*100)\n    #print j,i,plot_degradation[j][i]\n    #print plot_degradation_error[j][i]\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    mix_xaxis2 = mix_xaxis2 + (i,)\n    mix_yaxis2 = mix_yaxis2 + (plot_degradation[j][i],)\n    mix_yaxis3 = mix_yaxis3 + (plot_degradation2[j][i],)\n    mix_yaxis_abs2 = mix_yaxis_abs2 + (plot_degradation_abs[j][i],)\n    mix_yaxis_abs3 = mix_yaxis_abs3 + (plot_degradation_abs2[j][i],)\n    mix_error2 = mix_error2 + (plot_degradation_error[j][i],)\n    mix_error3 = mix_error3 + (plot_degradation_error2[j][i],)\n    #print numerator2,denominator2,numerator2/denominator2\n    #print denominator2/numerator2\n    print j,i,plot_degradation[j][i],plot_degradation2[j][i]\n            #print (((numerator2/denominator2)-(numerator1/denominator1))/(numerator2/denominator2))*100\n#print np.mean(yaxis2)\n\n\n\n\nwidth=0.15\nx = np.arange(len(lib_yaxis2))\nfig = plt.figure(figsize=(15, 5))\nfig.subplots_adjust(bottom=0.5)\nax = fig.add_subplot(1,1,1)\n#bar1 = plt.bar( x, yaxis, width, color="r", label=\'colocating with libquatum (avg = %.2f)\' %(np.mean(yaxis_abs)))\n#bar1 = plt.bar( x, lib_yaxis_abs3, width, color="r", yerr=lib_error3, label=\'Shuttering (avg = %.2f)\' %(np.mean(lib_yaxis_abs3)))\nbar2 = plt.bar( x, lib_yaxis_abs2, width, color="y", yerr=lib_error2, label=\'libquantum (avg = %.2f)\' %(np.mean(lib_yaxis_abs2)))\nbar3 = plt.bar( x+width, mcf_yaxis_abs2, width, color="r", yerr=mcf_error2, label=\'mcf (avg = %.2f)\' %(np.mean(mcf_yaxis_abs2)))\nbar4 = plt.bar( x+width+width, milc_yaxis_abs2, width, color="b", yerr=milc_error2, label=\'milc (avg = %.2f)\' %(np.mean(milc_yaxis_abs2)))\nbar5 = plt.bar( x+width+width+width, mix_yaxis_abs2, width, color="g", yerr=milc_error2, label=\'mix (avg = %.2f)\' %(np.mean(mix_yaxis_abs2)))\nly = len(lib_yaxis_abs3)\nadd_line(ax, 0 * 1.0, -.1)\nadd_line(ax, 1 * 1.0, -.1)\nadd_line(ax, 1 * 0.53, -.1)\n#add_line(ax, 1 * 0.845, -.1)\n#scale = 40./ly\n#scale = 27./ly\n#for pos in xrange(ly + 1):\n#    print pos\n#    print scale\n#    add_line(ax, pos * scale, -.1)\n#scale = 34./ly\n#for pos in xrange(ly + 1):\n#    add_line(ax, pos * scale, -.1)\n#bar3 = plt.bar( x+width+width, yaxis3, width, color="g", label=\'colocating with sphinx  (avg = %.2f)\' %(np.mean(yaxis_abs3)))\n#autolabel(bar1)\n#autolabel(bar2)\nplt.ylabel( \'Estimation \\n error (%)\', fontsize=\'22\' )\n#plt.title(\'Error in predicting degradation when co-locating with libquantum\')\nplt.xticks(x + width/2.0, lib_xaxis2, rotation=\'90\', size=\'20\',  ha=\'center\', va=\'top\')\nplt.yticks(np.arange(0,50,10),size=\'20\')\nplt.ylim(0,40)\nplt.xlim(-0.2,13)\nplt.grid()\nplt.tight_layout()\nplt.legend(loc=1, ncol=4, prop={\'size\':17})\n#plt.savefig(\'accuracylibquantum.pdf\', dpi=125)\n#ax.text(5, -23, r\'SPEC 2006\', fontsize=20)\nax.text(4, -18, r\'Sirius Suite\', fontsize=20)\nax.text(10, -18, r\'DjiNN & Tonic\', fontsize=20)\n'
p0
.I0
.S'$graph_fig:sirius-overhead:Overhead:1'
p0
.S'from collections import defaultdict\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.cm as cmx\nimport matplotlib.colors as cl\n\n\n\nbenchList = [ \'gcc\', \'perlbench\', \'leslie3d\', \'povray\', \'libquantum\', \'astar\', \'bzip2\', \'milc\', \'namd\', \'calculix\', \'h264ref\', \'sphinx3\', \'zeusmp\', \'gobmk\', \'hmmer\', \'tonto\', \'bwaves\', \'gromacs\', \'dealII\', \'sjeng\', \'lbm\', \'xalancbmk\', \'gamess\', \'soplex\', \'GemsFDTD\', \'omnetpp\', \'mcf\', \'cactusADM\' ]\n\ncolocationList = [ \'colocating with libquantum\', \'colocating with mcf\',  \'colocating with sphinx3\']\ncolocationListBaseline = [ \'colocating with libquantum\', \'colocating with mcf\', \'colocating with sphinx3\' ]\n\n\nrunningList = [  \'perlbench\', \'colocating with libquantum\', \'mcf\', \'colocating with libquantum\', \'leslie3d\', \'colocating with libquantum\', \'povray\', \'colocating with libquantum\', \'libquantum\', \'colocating with libquantum\', \'astar\', \'colocating with libquantum\', \'bzip2\', \'colocating with libquantum\', \'milc\', \'colocating with libquantum\', \'namd\', \'colocating with libquantum\', \'calculix\', \'colocating with libquantum\', \'h264ref\', \'colocating with libquantum\', \'gobmk\', \'colocating with libquantum\', \'hmmer\', \'colocating with libquantum\', \'tonto\', \'colocating with libquantum\', \'sphinx3\', \'colocating with libquantum\', \'zeusmp\', \'colocating with libquantum\', \'bwaves\', \'colocating with libquantum\', \'gromacs\', \'colocating with libquantum\', \'dealII\', \'colocating with libquantum\', \'sjeng\', \'colocating with libquantum\', \'lbm\', \'colocating with libquantum\', \'xalancbmk\', \'colocating with libquantum\', \'gamess\', \'colocating with libquantum\', \'soplex\', \'colocating with libquantum\', \'cactusADM\', \'colocating with libquantum\', \'GemsFDTD\', \'colocating with libquantum\', \'omnetpp\', \'colocating with libquantum\' ]\n\n\nsiriusbenchList = [ \'gmm\', \'dnn_asr\', \'surf-fe\', \'surf-fd\', \'stem\', \'regex\', \'crf\', \'img-imc\', \'img-dig\', \'img-face\', \'nlp-pos\', \'nlp-chk\', \'nlp-ner\']\nsiriuscolocationList = [ \'colocating with lbm\', \'colocating with povray\', \'colocating with astar\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with mcf\' ]\nsiriusrunningList = [ \'gmm\', \'colocating with libquantum\', \'dnn_asr\', \'colocating with libquantum\', \'surf-fe\', \'colocating with libquantum\', \'surf-fd\', \'colocating with libquantum\', \'stem\', \'colocating with libquantum\', \'regex\', \'colocating with libquantum\', \'crf\', \'colocating with libquantum\', \'img-imc\', \'colocating with libquantum\', \'img-dig\', \'colocating with libquantum\', \'img-face\', \'colocating with libquantum\', \'nlp-pos\', \'colocating with libquantum\', \'nlp-chk\', \'colocating with libquantum\', \'nlp-ner\' , \'colocating with libquantum\']\n\ndef autolabel(rects):\n    # attach some text labels\n    for rect in rects:\n        height = rect.get_height()\n        plt.text(rect.get_x()+rect.get_width()/2., 1.05*height, \'%.2f\'%float(height), fontsize=8 )\n\ndef autolabel2(rects):\n    # attach some text labels\n    for rect in rects:\n        height = rect.get_height()\n        plt.text(rect.get_x()+rect.get_width()/2., -1.25*height, \'%.2f\'%float(height),\n                ha=\'center\', va=\'top\', fontsize=8)\n        #plt.text(rect.get_x()+rect.get_width()/2., 1.05*height, \'%.2f\'%float(height))\n\n\ndef color_maker(count, map=\'gnuplot2\', min=0.100, max=0.900):\n   assert(min >= 0.000 and max <= 1.000 and max > min)\n   gran = 100000.0\n   maker = cmx.ScalarMappable(norm=cl.Normalize(vmin=0, vmax=int(gran)),\n                              cmap=plt.get_cmap(map))\n   r = [min * gran]\n   if count > 1:\n       r = [min * gran + gran * x * (max - min) / float(count - 1) for x in range(0, count)]\n       return [maker.to_rgba(t) for t in r]\n\n\ndef add_line(ax, xpos, ypos):\n    line = plt.Line2D([xpos, xpos], [ypos + .1, ypos - .5], transform=ax.transAxes, linewidth=2, color=\'black\')\n    line.set_clip_on(False)\n    ax.add_line(line)\n\nfilename = \'execution_time_1000\'\nfList1 = [s.strip() for s in open(\'../../papergraphs/accuracy/libquantumcorunner/degradation2/%s.txt\' % filename).readlines()]  #degradation\nfList2 = [s.strip() for s in open(\'../../papergraphs/accuracy/libquantumcorunner/snapshot/phase_change_5.txt\').readlines()]\nfList3 = [s.strip() for s in open(\'../../papergraphs/accuracy/libquantumcorunner/priorwork/execution_time_5.txt\').readlines()] #prior work\n\n\nfList4 = [s.strip() for s in open(\'../../papergraphs/accuracy/libquantumcorunner/siriusdjinn/degradation/newval/%s.txt\' % filename).readlines()]  #degradation\nfList5 = [s.strip() for s in open(\'../../papergraphs/accuracy/libquantumcorunner/siriusdjinn/snapshot/phase_change_10.txt\').readlines()]\nfList6 = [s.strip() for s in open(\'../../papergraphs/accuracy/libquantumcorunner/siriusdjinn/priorwork/execution_time_4.txt\').readlines()] #prior work\n\nexecution_time_shutter = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter = defaultdict(lambda  : defaultdict(list))\navg_execution_time_shutter = defaultdict(dict)\nexecution_time_shutter2 = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter2 = defaultdict(lambda  : defaultdict(list))\navg_execution_time_shutter2 = defaultdict(dict)\ndictList_phase_change = defaultdict(lambda  : defaultdict(list))\ndictList_phase_change2 = defaultdict(lambda  : defaultdict(list))\n\nstd_execution_time = defaultdict(dict)\n\ndef print_elapsed_time_shutter(time_shutter):\n    for j in colocationList:\n        for i in benchList:\n            print \'%s ||||  %s\'%(j,i)\n            print time_shutter[j][i]\n\n\nsep = \'u\'\nfor (b,a) in enumerate(fList1):\n    #print a\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            execution_time_shutter[index][a].append((fList1[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_shutter[\'colocating with mcf\'][\'perlbench\']\n#print((s.split(start))[1].split(end)[0])\n\nfor j in colocationList:\n    for i in benchList:\n        for k in execution_time_shutter[j][i]:\n            m,s = [float (var) for var in k.split(\':\')]\n            temp = m*60 + s\n            execution_time_sec_shutter[j][i].append(temp)\n\nfor (b,a) in enumerate(fList3):\n    #print a\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            #print index\n            #print a\n            execution_time_shutter2[index][a].append((fList3[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_shutter[\'colocating with mcf\'][\'perlbench\']\n#print((s.split(start))[1].split(end)[0])\n\nfor j in colocationList:\n    for i in benchList:\n        for k in execution_time_shutter2[j][i]:\n            #print k\n            m,s = [float (var) for var in k.split(\':\')]\n            temp = m*60 + s\n            execution_time_sec_shutter2[j][i].append(temp)\n\nfor (b,a) in enumerate(fList2):\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            dictList_phase_change[index][a].append(fList2[b+1])\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    #print j,i\n    for elem in dictList_phase_change[j][i]:\n        dictList_phase_change2[j][i].extend(elem.strip().split(\'\\t\'))\n    #print dictList_phase_change2[j][i]\n\nyaxis = ()\nyaxis2= ()\nyaxis_abs = ()\nerror = ()\nxaxis = ()\n#print dictList_phase_change2[\'colocating with mcf\'][\'perlbench\']\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    print j,i\n    print dictList_phase_change2[j][i]\n    #print i,j\n    shutter_temp_list = []\n    colo_temp_list = []\n    for (count,item) in enumerate(dictList_phase_change2[j][i]):\n        if count%2==1:\n            colo_temp_list.append(float(item))\n        if count%2==0:\n            shutter_temp_list.append(float(item))\n    #print shutter_temp_list\n    shutter_avg = sum(shutter_temp_list)/len(shutter_temp_list)\n    colocation_avg = sum(colo_temp_list)/len(colo_temp_list)\n    del shutter_temp_list\n    del colo_temp_list\n\n    pause_period = ((colocation_avg ) + ((shutter_avg + (colocation_avg * 2)/3) * 3))/4\n    xaxis = xaxis + (i,)\n    #print (pause_period/np.mean(execution_time_sec_shutter[j][i]))*10\n    yaxis = yaxis + ( (pause_period/np.mean(execution_time_sec_shutter[j][i]))*7.5  ,)\n    yaxis2 = yaxis2 + ( (((np.mean(execution_time_sec_shutter2[j][i])/np.mean(execution_time_sec_shutter[j][i])) - 1)*100), )\n    print np.mean(execution_time_sec_shutter2[j][i])\n    print np.mean(execution_time_sec_shutter[j][i])\n    #print \'---------------------\'\n\nprint yaxis2\n#print np.mean(yaxis)\n\n\nwidth = 0.25\nx = np.arange(len(yaxis))\nfig = plt.figure(figsize=(28, 5))\nbar2 = plt.bar( x, yaxis2, width, color="k", label=\'Shuttering  (mean: %.2f)\' %(np.mean(yaxis2)))\nbar1 = plt.bar( x+width, yaxis, width, color="lightgrey", label=\'Snapshot (mean: %.2f)\' %(np.mean(yaxis) ))\n\n\nplt.ylabel( \'Execution time \\n overhead (%)\',fontsize=\'23\' )\n#plt.title(\'Overhead due to Prediction of degradation while co-running with LIBQUANTUM\')\nplt.xticks(x + width/2.0, xaxis, rotation=\'30\', size=\'23\', ha=\'center\')\n#plt.yticks((-5,0,10,20,30,40,50,60),(\'\',\'0\',\'10\',\'20\',\'30\',\'40\',\'50\',\'60\'),size=\'25\')\nplt.yticks((0,5,10,15),(\'0\',\'5\',\'10\',\'15\'),size=\'25\')\n#plt.yticks(np.arange(-10, 60, 10),size=\'25\')\nplt.xlim(-1,26)\nplt.grid()\nplt.legend(loc=9, ncol=2, prop={\'size\':28})\n#leg.get_frame().set_alpha(0.1)\nplt.tight_layout()\n#plt.savefig(\'phase_chagnge_overheadmaybe.png\', dpi=125)\n\n#### ----------------------------------------------------------------------------------------------------------------------------------\n\n\n#fList3 = [s.strip() for s in open(\'experiment_libquantum/phase_changes_5.txt\').readlines()]\n##fList3 = [s.strip() for s in open(\'../../papergraphs/2.fullspec/overhead/experiment_mcf/%s.txt\' % filename).readlines()]\n##fList4 = [s.strip() for s in open(\'../../papergraphs/2.fullspec/overhead/experiment_mcf/phase_changes_5.txt\').readlines()]\n##fList5 = [s.strip() for s in open(\'../../papergraphs/2.fullspec/overhead/experiment_sphinx3/%s.txt\' % filename).readlines()]\n##fList6 = [s.strip() for s in open(\'../../papergraphs/2.fullspec/overhead/experiment_sphinx3/phase_changes_5.txt\').readlines()]\n#print fList1\n\ndel execution_time_shutter\ndel execution_time_sec_shutter\ndel avg_execution_time_shutter\ndel execution_time_shutter2\ndel execution_time_sec_shutter2\ndel avg_execution_time_shutter2\ndel dictList_phase_change\ndel dictList_phase_change2\n\nexecution_time_shutter = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter = defaultdict(lambda  : defaultdict(list))\navg_execution_time_shutter = defaultdict(dict)\nexecution_time_shutter2 = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter2 = defaultdict(lambda  : defaultdict(list))\navg_execution_time_shutter2 = defaultdict(dict)\ndictList_phase_change = defaultdict(lambda  : defaultdict(list))\ndictList_phase_change2 = defaultdict(lambda  : defaultdict(list))\n\nstd_execution_time = defaultdict(dict)\n\ndef print_elapsed_time_shutter(time_shutter):\n    for j in siriuscolocationList:\n        for i in siriusbenchList:\n            print \'%s ||||  %s\'%(j,i)\n            print time_shutter[j][i]\n\n\nsep = \'u\'\nfor (b,a) in enumerate(fList4):\n    print a\n    if a in siriuscolocationList:\n        index = a\n    else:\n        if a in siriusbenchList:\n            execution_time_shutter[index][a].append((fList4[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_shutter[\'colocating with mcf\'][\'perlbench\']\n#print((s.split(start))[1].split(end)[0])\n\nfor j in siriuscolocationList:\n    for i in siriusbenchList:\n        #print i\n        for k in execution_time_shutter[j][i]:\n            try:\n                m,s = [float (var) for var in k.split(\':\')]\n                temp = m*60 + s\n            except:\n                h,m,s = [float (var) for var in k.split(\':\')]\n                temp = h*3600 + m*60 + s\n\n            execution_time_sec_shutter[j][i].append(temp)\n\nfor (b,a) in enumerate(fList6):\n    print a\n    if a in siriuscolocationList:\n        index = a\n    else:\n        if a in siriusbenchList:\n            #print index\n            #print a\n            execution_time_shutter2[index][a].append((fList6[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_shutter[\'colocating with mcf\'][\'perlbench\']\n#print((s.split(start))[1].split(end)[0])\n\nfor j in siriuscolocationList:\n    for i in siriusbenchList:\n        for k in execution_time_shutter2[j][i]:\n            #print k\n            m,s = [float (var) for var in k.split(\':\')]\n            temp = m*60 + s\n            execution_time_sec_shutter2[j][i].append(temp)\n\nfor (b,a) in enumerate(fList5):\n    if a in siriuscolocationList:\n        index = a\n    else:\n        if a in siriusbenchList:\n            dictList_phase_change[index][a].append(fList5[b+1])\n\nfor a in xrange(0,len(siriusrunningList),2):\n    j = siriusrunningList[a+1]\n    i = siriusrunningList[a]\n    #print j,i\n    for elem in dictList_phase_change[j][i]:\n        dictList_phase_change2[j][i].extend(elem.strip().split(\'\\t\'))\n    #print dictList_phase_change2[j][i]\n\nlibsiri_yaxis = ()\nlibsiri_yaxis2= ()\nlibsiri_yaxis_abs = ()\nlibsiri_error = ()\nlibsiri_xaxis = ()\n#print dictList_phase_change2[\'colocating with mcf\'][\'perlbench\']\nfor a in xrange(0,len(siriusrunningList),2):\n    j = siriusrunningList[a+1]\n    i = siriusrunningList[a]\n    #print j,i\n    #print dictList_phase_change2[j][i]\n    #print i,j\n    shutter_temp_list = []\n    colo_temp_list = []\n    for (count,item) in enumerate(dictList_phase_change2[j][i]):\n        if count%2==1:\n            colo_temp_list.append(float(item))\n        if count%2==0:\n            shutter_temp_list.append(float(item))\n    #print shutter_temp_list\n    shutter_avg = sum(shutter_temp_list)/len(shutter_temp_list)\n    colocation_avg = sum(colo_temp_list)/len(colo_temp_list)\n    del shutter_temp_list\n    del colo_temp_list\n\n    pause_period = ((colocation_avg ) + ((shutter_avg + (colocation_avg * 2)/3) * 3))/4\n    libsiri_xaxis = libsiri_xaxis + (i,)\n    #print (pause_period/np.mean(execution_time_sec_shutter[j][i]))*10\n    libsiri_yaxis = libsiri_yaxis + ( (pause_period/np.mean(execution_time_sec_shutter[j][i]))*10  ,)\n    libsiri_yaxis2 = libsiri_yaxis2 + ( abs(((np.mean(execution_time_sec_shutter2[j][i])/np.mean(execution_time_sec_shutter[j][i])) - 1)*100), )\n    #print np.mean(execution_time_sec_shutter2[j][i])\n    #print np.mean(execution_time_sec_shutter[j][i])\n    #print \'---------------------\'\n\n#print xaxis\n#print yaxis\n#print yaxis2\n#print np.mean(yaxis)\n\nbenchList = [ \'gcc\', \'perlbench\', \'leslie3d\', \'povray\', \'libquantum\', \'astar\', \'bzip2\', \'milc\', \'namd\', \'calculix\', \'h264ref\', \'sphinx3\', \'zeusmp\', \'gobmk\', \'hmmer\', \'tonto\', \'bwaves\', \'gromacs\', \'dealII\', \'sjeng\', \'lbm\', \'xalancbmk\', \'gamess\', \'soplex\', \'GemsFDTD\', \'omnetpp\', \'mcf\', \'cactusADM\' ]\n\ncolocationList = [ \'colocating with libquantum\', \'colocating with mcf\',  \'colocating with sphinx3\']\ncolocationListBaseline = [ \'colocating with libquantum\', \'colocating with mcf\', \'colocating with sphinx3\' ]\n\n\nrunningList = [  \'perlbench\', \'colocating with mcf\', \'mcf\', \'colocating with mcf\', \'leslie3d\', \'colocating with mcf\', \'povray\', \'colocating with mcf\', \'libquantum\', \'colocating with mcf\', \'astar\', \'colocating with mcf\', \'bzip2\', \'colocating with mcf\', \'milc\', \'colocating with mcf\', \'namd\', \'colocating with mcf\', \'calculix\', \'colocating with mcf\', \'h264ref\', \'colocating with mcf\', \'gobmk\', \'colocating with mcf\', \'hmmer\', \'colocating with mcf\', \'tonto\', \'colocating with mcf\', \'sphinx3\', \'colocating with mcf\', \'zeusmp\', \'colocating with mcf\', \'bwaves\', \'colocating with mcf\', \'gromacs\', \'colocating with mcf\', \'dealII\', \'colocating with mcf\', \'sjeng\', \'colocating with mcf\', \'lbm\', \'colocating with mcf\', \'xalancbmk\', \'colocating with mcf\', \'gamess\', \'colocating with mcf\', \'cactusADM\', \'colocating with mcf\', \'soplex\', \'colocating with mcf\', \'GemsFDTD\', \'colocating with mcf\', \'omnetpp\', \'colocating with mcf\' ]\n\nsiriusbenchList = [ \'gmm\', \'dnn_asr\', \'surf-fe\', \'surf-fd\', \'stem\', \'regex\', \'crf\', \'img-imc\', \'img-dig\', \'img-face\', \'nlp-pos\', \'nlp-chk\', \'nlp-ner\']\nsiriuscolocationList = [ \'colocating with lbm\', \'colocating with povray\', \'colocating with astar\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with mcf\' ]\nsiriusrunningList = [ \'gmm\', \'colocating with mcf\', \'dnn_asr\', \'colocating with mcf\', \'surf-fe\', \'colocating with mcf\', \'surf-fd\', \'colocating with mcf\', \'stem\', \'colocating with mcf\', \'regex\', \'colocating with mcf\', \'crf\', \'colocating with mcf\', \'img-imc\', \'colocating with mcf\', \'img-dig\', \'colocating with mcf\', \'img-face\', \'colocating with mcf\', \'nlp-pos\', \'colocating with mcf\', \'nlp-chk\', \'colocating with mcf\', \'nlp-ner\' , \'colocating with mcf\']\n\ndef autolabel(rects):\n    # attach some text labels\n    for rect in rects:\n        height = rect.get_height()\n        plt.text(rect.get_x()+rect.get_width()/2., 1.05*height, \'%.2f\'%float(height), fontsize=8 )\n\ndef autolabel2(rects):\n    # attach some text labels\n    for rect in rects:\n        height = rect.get_height()\n        plt.text(rect.get_x()+rect.get_width()/2., -1.25*height, \'%.2f\'%float(height),\n                ha=\'center\', va=\'top\', fontsize=8)\n        #plt.text(rect.get_x()+rect.get_width()/2., 1.05*height, \'%.2f\'%float(height))\n\ndef add_line(ax, xpos, ypos):\n    line = plt.Line2D([xpos, xpos], [ypos + .1, ypos - .5], transform=ax.transAxes, linewidth=2, color=\'black\')\n    line.set_clip_on(False)\n    ax.add_line(line)\n\n\nfilename = \'execution_time_1000\'\nfList1 = [s.strip() for s in open(\'../../papergraphs/accuracy/mcfcorunner/degradation/%s.txt\' % filename).readlines()]  #degradation\nfList2 = [s.strip() for s in open(\'../../papergraphs/accuracy/mcfcorunner/snapshot/phase_change_70.txt\').readlines()]\nfList3 = [s.strip() for s in open(\'../../papergraphs/accuracy/mcfcorunner/priorwork/execution_time_5.txt\').readlines()] #prior work\n\nfList4 = [s.strip() for s in open(\'../../papergraphs/accuracy/mcfcorunner/siriusdjinn/degradation/%s.txt\' % filename).readlines()]  #degradation\nfList5 = [s.strip() for s in open(\'../../papergraphs/accuracy/mcfcorunner/siriusdjinn/snapshot/phase_change_75.txt\').readlines()]\nfList6 = [s.strip() for s in open(\'../../papergraphs/accuracy/mcfcorunner/siriusdjinn/priorwork/execution_time_4.txt\').readlines()] #prior work\n\n\nexecution_time_shutter = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter = defaultdict(lambda  : defaultdict(list))\navg_execution_time_shutter = defaultdict(dict)\nexecution_time_shutter2 = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter2 = defaultdict(lambda  : defaultdict(list))\navg_execution_time_shutter2 = defaultdict(dict)\ndictList_phase_change = defaultdict(lambda  : defaultdict(list))\ndictList_phase_change2 = defaultdict(lambda  : defaultdict(list))\n\nstd_execution_time = defaultdict(dict)\n\ndef print_elapsed_time_shutter(time_shutter):\n    for j in colocationList:\n        for i in benchList:\n            print \'%s ||||  %s\'%(j,i)\n            print time_shutter[j][i]\n\n\nsep = \'u\'\nfor (b,a) in enumerate(fList1):\n    #print a\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            execution_time_shutter[index][a].append((fList1[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_shutter[\'colocating with mcf\'][\'perlbench\']\n#print((s.split(start))[1].split(end)[0])\n\nfor j in colocationList:\n    for i in benchList:\n        for k in execution_time_shutter[j][i]:\n            m,s = [float (var) for var in k.split(\':\')]\n            temp = m*60 + s\n            execution_time_sec_shutter[j][i].append(temp)\n\nfor (b,a) in enumerate(fList3):\n    #print a\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            #print index\n            #print a\n            execution_time_shutter2[index][a].append((fList3[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_shutter[\'colocating with mcf\'][\'perlbench\']\n#print((s.split(start))[1].split(end)[0])\n\nfor j in colocationList:\n    for i in benchList:\n        for k in execution_time_shutter2[j][i]:\n            #print k\n            m,s = [float (var) for var in k.split(\':\')]\n            temp = m*60 + s\n            execution_time_sec_shutter2[j][i].append(temp)\n\nfor (b,a) in enumerate(fList2):\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            dictList_phase_change[index][a].append(fList2[b+1])\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    #print j,i\n    for elem in dictList_phase_change[j][i]:\n        dictList_phase_change2[j][i].extend(elem.strip().split(\'\\t\'))\n    #print dictList_phase_change2[j][i]\n\nyaxis = ()\nyaxis2= ()\nyaxis_abs = ()\nerror = ()\nxaxis = ()\n#print dictList_phase_change2[\'colocating with mcf\'][\'perlbench\']\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    #print j,i\n    #print dictList_phase_change2[j][i]\n    #print i,j\n    shutter_temp_list = []\n    colo_temp_list = []\n    for (count,item) in enumerate(dictList_phase_change2[j][i]):\n        if count%2==1:\n            colo_temp_list.append(float(item))\n        if count%2==0:\n            shutter_temp_list.append(float(item))\n    #print shutter_temp_list\n    shutter_avg = sum(shutter_temp_list)/len(shutter_temp_list)\n    colocation_avg = sum(colo_temp_list)/len(colo_temp_list)\n    del shutter_temp_list\n    del colo_temp_list\n\n    pause_period = ((colocation_avg ) + ((shutter_avg + (colocation_avg * 2)/3) * 3))/4\n    xaxis = xaxis + (i,)\n    #print (pause_period/np.mean(execution_time_sec_shutter[j][i]))*10\n    yaxis = yaxis + ( (pause_period/np.mean(execution_time_sec_shutter[j][i]))*7.5  ,)\n    yaxis2 = yaxis2 + ( abs(((np.mean(execution_time_sec_shutter2[j][i])/np.mean(execution_time_sec_shutter[j][i])) - 1)*100), )\n    #print \'---------------------\'\n\n#print yaxis2\n#print np.mean(yaxis)\n\n\nwidth = 0.25\nx = np.arange(len(yaxis))\nfig = plt.figure(figsize=(28, 5))\nbar2 = plt.bar( x, yaxis2, width, color="k", label=\'Shuttering  (mean: %.2f)\' %(np.mean(yaxis2)))\nbar1 = plt.bar( x+width, yaxis, width, color="lightgrey", label=\'Snapshot (mean: %.2f)\' %(np.mean(yaxis) ))\n\n#plt.ylabel( \'Execution time \\n overhead(%)\',fontsize=23)\n##plt.title(\'Overhead due to Prediction of degradation while co-running with MCF\')\n#plt.xticks(x + width/2.0, xaxis, rotation=\'30\', size=\'23\', ha=\'center\')\n##plt.yticks((-5,0,10,20,30,40,50,60),(\'\',\'0\',\'10\',\'20\',\'30\',\'40\',\'50\',\'60\'),size=\'25\')\n#plt.yticks((0,5,10,15),(\'0\',\'5\',\'10\',\'15\'),size=\'25\')\n#plt.xlim(-1,27)\n#plt.grid()\n#plt.legend(loc=9, ncol=2, prop={\'size\':28})\n#plt.tight_layout()\n##plt.savefig(\'phase_chagnge_overheadmaybe.png\', dpi=125)\n\ndel execution_time_shutter\ndel execution_time_sec_shutter\ndel avg_execution_time_shutter\ndel execution_time_shutter2\ndel execution_time_sec_shutter2\ndel avg_execution_time_shutter2\ndel dictList_phase_change\ndel dictList_phase_change2\n\nexecution_time_shutter = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter = defaultdict(lambda  : defaultdict(list))\navg_execution_time_shutter = defaultdict(dict)\nexecution_time_shutter2 = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter2 = defaultdict(lambda  : defaultdict(list))\navg_execution_time_shutter2 = defaultdict(dict)\ndictList_phase_change = defaultdict(lambda  : defaultdict(list))\ndictList_phase_change2 = defaultdict(lambda  : defaultdict(list))\n\nstd_execution_time = defaultdict(dict)\n\ndef print_elapsed_time_shutter(time_shutter):\n    for j in siriuscolocationList:\n        for i in siriusbenchList:\n            print \'%s ||||  %s\'%(j,i)\n            print time_shutter[j][i]\n\n\nsep = \'u\'\nfor (b,a) in enumerate(fList4):\n    #print a\n    if a in siriuscolocationList:\n        index = a\n    else:\n        if a in siriusbenchList:\n            execution_time_shutter[index][a].append((fList4[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_shutter[\'colocating with mcf\'][\'perlbench\']\n#print((s.split(start))[1].split(end)[0])\n\nfor j in siriuscolocationList:\n    for i in siriusbenchList:\n        #print i\n        for k in execution_time_shutter[j][i]:\n            try:\n                m,s = [float (var) for var in k.split(\':\')]\n                temp = m*60 + s\n            except:\n                h,m,s = [float (var) for var in k.split(\':\')]\n                temp = h*3600 + m*60 + s\n\n            execution_time_sec_shutter[j][i].append(temp)\n\n#print fList6\nfor (b,a) in enumerate(fList6):\n    #print a\n    if a in siriuscolocationList:\n        index = a\n    else:\n        if a in siriusbenchList:\n            #print index\n            #print a\n            #print fList6[b+4]\n            execution_time_shutter2[index][a].append((fList6[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_shutter[\'colocating with mcf\'][\'perlbench\']\n#print((s.split(start))[1].split(end)[0])\n\nfor j in siriuscolocationList:\n    for i in siriusbenchList:\n        for k in execution_time_shutter2[j][i]:\n            #print k\n            m,s = [float (var) for var in k.split(\':\')]\n            temp = m*60 + s\n            execution_time_sec_shutter2[j][i].append(temp)\n\nfor (b,a) in enumerate(fList5):\n    if a in siriuscolocationList:\n        index = a\n    else:\n        if a in siriusbenchList:\n            dictList_phase_change[index][a].append(fList5[b+1])\n\nfor a in xrange(0,len(siriusrunningList),2):\n    j = siriusrunningList[a+1]\n    i = siriusrunningList[a]\n    #print j,i\n    for elem in dictList_phase_change[j][i]:\n        dictList_phase_change2[j][i].extend(elem.strip().split(\'\\t\'))\n    #print dictList_phase_change2[j][i]\n\nmcfsiri_yaxis = ()\nmcfsiri_yaxis2= ()\nmcfsiri_yaxis_abs = ()\nmcfsiri_error = ()\nmcfsiri_xaxis = ()\n#print dictList_phase_change2[\'colocating with mcf\'][\'perlbench\']\nfor a in xrange(0,len(siriusrunningList),2):\n    j = siriusrunningList[a+1]\n    i = siriusrunningList[a]\n    print j,i\n    #print dictList_phase_change2[j][i]\n    #print i,j\n    shutter_temp_list = []\n    colo_temp_list = []\n    for (count,item) in enumerate(dictList_phase_change2[j][i]):\n        if count%2==1:\n            colo_temp_list.append(float(item))\n        if count%2==0:\n            shutter_temp_list.append(float(item))\n    #print shutter_temp_list\n    shutter_avg = sum(shutter_temp_list)/len(shutter_temp_list)\n    colocation_avg = sum(colo_temp_list)/len(colo_temp_list)\n    del shutter_temp_list\n    del colo_temp_list\n\n    pause_period = ((colocation_avg ) + ((shutter_avg + (colocation_avg * 2)/3) * 3))/4\n    mcfsiri_xaxis = mcfsiri_xaxis + (i,)\n    #print (pause_period/np.mean(execution_time_sec_shutter[j][i]))*10\n    mcfsiri_yaxis = mcfsiri_yaxis + ( (pause_period/np.mean(execution_time_sec_shutter[j][i]))*10  ,)\n    mcfsiri_yaxis2 = mcfsiri_yaxis2 + ( abs(((np.mean(execution_time_sec_shutter2[j][i])/np.mean(execution_time_sec_shutter[j][i])) - 1)*100), )\n    print execution_time_sec_shutter2[j][i]\n    print execution_time_sec_shutter[j][i]\n    #print np.mean(execution_time_sec_shutter2[j][i])\n    #print np.mean(execution_time_sec_shutter[j][i])\n    #print \'---------------------\'\n\n#print xaxis\n#print yaxis\n#print yaxis2\n#print np.mean(yaxis)\n\nbenchList = [ \'gcc\', \'perlbench\', \'leslie3d\', \'povray\', \'libquantum\', \'astar\', \'bzip2\', \'milc\', \'namd\', \'calculix\', \'h264ref\', \'sphinx3\', \'zeusmp\', \'gobmk\', \'hmmer\', \'tonto\', \'bwaves\', \'gromacs\', \'dealII\', \'sjeng\', \'lbm\', \'xalancbmk\', \'gamess\', \'soplex\', \'GemsFDTD\', \'omnetpp\', \'mcf\', \'cactusADM\' ]\ncolocationList = [ \'colocating with libquantum\', \'colocating with mcf\',  \'colocating with milc\']\ncolocationListBaseline = [ \'colocating with libquantum\', \'colocating with mcf\', \'colocating with milc\' ]\n\nrunningList = [  \'perlbench\', \'colocating with milc\', \'mcf\', \'colocating with milc\', \'leslie3d\', \'colocating with milc\', \'povray\', \'colocating with milc\', \'libquantum\', \'colocating with milc\', \'astar\', \'colocating with milc\', \'bzip2\', \'colocating with milc\', \'milc\', \'colocating with milc\', \'namd\', \'colocating with milc\', \'calculix\', \'colocating with milc\', \'h264ref\', \'colocating with milc\', \'gobmk\', \'colocating with milc\', \'hmmer\', \'colocating with milc\', \'tonto\', \'colocating with milc\', \'sphinx3\', \'colocating with milc\', \'zeusmp\', \'colocating with milc\', \'bwaves\', \'colocating with milc\', \'gromacs\', \'colocating with milc\', \'dealII\', \'colocating with milc\', \'sjeng\', \'colocating with milc\', \'lbm\', \'colocating with milc\', \'xalancbmk\', \'colocating with milc\', \'gamess\', \'colocating with milc\', \'cactusADM\', \'colocating with milc\', \'soplex\', \'colocating with milc\', \'GemsFDTD\', \'colocating with milc\', \'omnetpp\', \'colocating with milc\' ]\n\nsiriusbenchList = [ \'gmm\', \'dnn_asr\', \'surf-fe\', \'surf-fd\', \'stem\', \'regex\', \'crf\', \'img-imc\', \'img-dig\', \'img-face\', \'nlp-pos\', \'nlp-chk\', \'nlp-ner\']\nsiriuscolocationList = [ \'colocating with milc\', \'colocating with povray\', \'colocating with astar\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with mcf\' ]\nsiriusrunningList = [ \'gmm\', \'colocating with milc\', \'dnn_asr\', \'colocating with milc\', \'surf-fe\', \'colocating with milc\', \'surf-fd\', \'colocating with milc\', \'stem\', \'colocating with milc\', \'regex\', \'colocating with milc\', \'crf\', \'colocating with milc\', \'img-imc\', \'colocating with milc\', \'img-dig\', \'colocating with milc\', \'img-face\', \'colocating with milc\', \'nlp-pos\', \'colocating with milc\', \'nlp-chk\', \'colocating with milc\', \'nlp-ner\' , \'colocating with milc\']\n#colocationListBaseline = [ \'colocating with gcc\', \'colocating with mcf\', \'colocating with perlbench\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with lbm\' ]\ndef autolabel(rects):\n    # attach some text labels\n    for rect in rects:\n        height = rect.get_height()\n        plt.text(rect.get_x()+rect.get_width()/2., 1.05*height, \'%.2f\'%float(height), fontsize=8 )\n\ndef autolabel2(rects):\n    # attach some text labels\n    for rect in rects:\n        height = rect.get_height()\n        plt.text(rect.get_x()+rect.get_width()/2., -1.25*height, \'%.2f\'%float(height),\n                ha=\'center\', va=\'top\', fontsize=8)\n        #plt.text(rect.get_x()+rect.get_width()/2., 1.05*height, \'%.2f\'%float(height))\n\ndef add_line(ax, xpos, ypos):\n    line = plt.Line2D([xpos, xpos], [ypos + .1, ypos - .5], transform=ax.transAxes, linewidth=2, color=\'black\')\n    line.set_clip_on(False)\n    ax.add_line(line)\n\nfilename = \'execution_time_1000\'\nfList1 = [s.strip() for s in open(\'../../papergraphs/accuracy/milccorunner/degradation/%s.txt\' % filename).readlines()]  #degradation\nfList2 = [s.strip() for s in open(\'../../papergraphs/accuracy/milccorunner/snapshot/phase_change_70.txt\').readlines()]\nfList3 = [s.strip() for s in open(\'../../papergraphs/accuracy/milccorunner/priorwork/execution_time_5.txt\').readlines()] #prior work\n\nfList4 = [s.strip() for s in open(\'../../papergraphs/accuracy/milccorunner/siriusdjinn/degradation/%s.txt\' % filename).readlines()]  #degradation\nfList5 = [s.strip() for s in open(\'../../papergraphs/accuracy/milccorunner/siriusdjinn/snapshot/phase_change_75.txt\').readlines()]\nfList6 = [s.strip() for s in open(\'../../papergraphs/accuracy/milccorunner/siriusdjinn/priorwork/execution_time_4.txt\').readlines()] #prior work\n\nexecution_time_shutter = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter = defaultdict(lambda  : defaultdict(list))\navg_execution_time_shutter = defaultdict(dict)\nexecution_time_shutter2 = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter2 = defaultdict(lambda  : defaultdict(list))\navg_execution_time_shutter2 = defaultdict(dict)\ndictList_phase_change = defaultdict(lambda  : defaultdict(list))\ndictList_phase_change2 = defaultdict(lambda  : defaultdict(list))\n\nstd_execution_time = defaultdict(dict)\n\ndef print_elapsed_time_shutter(time_shutter):\n    for j in colocationList:\n        for i in benchList:\n            print \'%s ||||  %s\'%(j,i)\n            print time_shutter[j][i]\n\n\nsep = \'u\'\nfor (b,a) in enumerate(fList1):\n    #print a\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            execution_time_shutter[index][a].append((fList1[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_shutter[\'colocating with mcf\'][\'perlbench\']\n#print((s.split(start))[1].split(end)[0])\n\nfor j in colocationList:\n    for i in benchList:\n        for k in execution_time_shutter[j][i]:\n            m,s = [float (var) for var in k.split(\':\')]\n            temp = m*60 + s\n            execution_time_sec_shutter[j][i].append(temp)\n\nfor (b,a) in enumerate(fList3):\n    #print a\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            #print index\n            #print a\n            execution_time_shutter2[index][a].append((fList3[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_shutter[\'colocating with mcf\'][\'perlbench\']\n#print((s.split(start))[1].split(end)[0])\n\nfor j in colocationList:\n    for i in benchList:\n        for k in execution_time_shutter2[j][i]:\n            #print k\n            m,s = [float (var) for var in k.split(\':\')]\n            temp = m*60 + s\n            execution_time_sec_shutter2[j][i].append(temp)\n\nfor (b,a) in enumerate(fList2):\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            dictList_phase_change[index][a].append(fList2[b+1])\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    #print j,i\n    for elem in dictList_phase_change[j][i]:\n        dictList_phase_change2[j][i].extend(elem.strip().split(\'\\t\'))\n    #print dictList_phase_change2[j][i]\n\nyaxis = ()\nyaxis2= ()\nyaxis_abs = ()\nerror = ()\nxaxis = ()\n#print dictList_phase_change2[\'colocating with mcf\'][\'perlbench\']\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    #print j,i\n    #print dictList_phase_change2[j][i]\n    #print i,j\n    shutter_temp_list = []\n    colo_temp_list = []\n    for (count,item) in enumerate(dictList_phase_change2[j][i]):\n        if count%2==1:\n            colo_temp_list.append(float(item))\n        if count%2==0:\n            shutter_temp_list.append(float(item))\n    #print shutter_temp_list\n    shutter_avg = sum(shutter_temp_list)/len(shutter_temp_list)\n    colocation_avg = sum(colo_temp_list)/len(colo_temp_list)\n    del shutter_temp_list\n    del colo_temp_list\n\n    pause_period = ((colocation_avg ) + ((shutter_avg + (colocation_avg * 2)/3) * 3))/4\n    xaxis = xaxis + (i,)\n    #print (pause_period/np.mean(execution_time_sec_shutter[j][i]))*10\n    yaxis = yaxis + ( (pause_period/np.mean(execution_time_sec_shutter[j][i]))*7.5  ,)\n    yaxis2 = yaxis2 + ( abs(((np.mean(execution_time_sec_shutter2[j][i])/np.mean(execution_time_sec_shutter[j][i])) - 1)*100), )\n    #print \'---------------------\'\n\n#print yaxis2\n#print np.mean(yaxis)\n\n\n#width = 0.25\n#x = np.arange(len(yaxis))\n#fig = plt.figure(figsize=(28, 5))\n#bar2 = plt.bar( x, yaxis2, width, color="k", label=\'Shuttering  (mean: %.2f)\' %(np.mean(yaxis2)))\n#bar1 = plt.bar( x+width, yaxis, width, color="lightgrey", label=\'Snapshot (mean: %.2f)\' %(np.mean(yaxis) ))\n##bar3 = plt.bar( x+width+width, yaxis3, width, color="g", label=\' colocating with sphinx3 (avg = %.1f)\' %(np.mean(yaxis3)))\n###bar3 = plt.bar( x+width+width, yaxis3, width, color="g", label=\'4 corunners (avg is %.1f)\' %(np.mean(yaxis3) ))\n###autolabel2(bar1)\n###autolabel(bar2)\n###autolabel2(bar3)\n#plt.ylabel( \'Execution time \\n overhead(%)\',fontsize=23)\n##plt.title(\'Overhead due to Prediction of degradation while co-running with milc\')\n#plt.xticks(x + width/2.0, xaxis, rotation=\'30\', size=\'23\', ha=\'center\')\n##plt.yticks((-5,0,10,20,30,40,50,60),(\'\',\'0\',\'10\',\'20\',\'30\',\'40\',\'50\',\'60\'),size=\'25\')\n#plt.yticks((0,5,10,15),(\'0\',\'5\',\'10\',\'15\'),size=\'25\')\n#plt.xlim(-1,27)\n#plt.grid()\n#plt.legend(loc=9, ncol=2, prop={\'size\':28})\n#plt.tight_layout()\n##plt.savefig(\'phase_chagnge_overheadmaybe.png\', dpi=125)\n\ndel execution_time_shutter\ndel execution_time_sec_shutter\ndel avg_execution_time_shutter\ndel execution_time_shutter2\ndel execution_time_sec_shutter2\ndel avg_execution_time_shutter2\ndel dictList_phase_change\ndel dictList_phase_change2\n\nexecution_time_shutter = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter = defaultdict(lambda  : defaultdict(list))\navg_execution_time_shutter = defaultdict(dict)\nexecution_time_shutter2 = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter2 = defaultdict(lambda  : defaultdict(list))\navg_execution_time_shutter2 = defaultdict(dict)\ndictList_phase_change = defaultdict(lambda  : defaultdict(list))\ndictList_phase_change2 = defaultdict(lambda  : defaultdict(list))\n\nstd_execution_time = defaultdict(dict)\n\ndef print_elapsed_time_shutter(time_shutter):\n    for j in siriuscolocationList:\n        for i in siriusbenchList:\n            print \'%s ||||  %s\'%(j,i)\n            print time_shutter[j][i]\n\n\nsep = \'u\'\nfor (b,a) in enumerate(fList4):\n    #print a\n    if a in siriuscolocationList:\n        index = a\n    else:\n        if a in siriusbenchList:\n            execution_time_shutter[index][a].append((fList4[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_shutter[\'colocating with mcf\'][\'perlbench\']\n#print((s.split(start))[1].split(end)[0])\n\nfor j in siriuscolocationList:\n    for i in siriusbenchList:\n        #print i\n        for k in execution_time_shutter[j][i]:\n            try:\n                m,s = [float (var) for var in k.split(\':\')]\n                temp = m*60 + s\n            except:\n                h,m,s = [float (var) for var in k.split(\':\')]\n                temp = h*3600 + m*60 + s\n\n            execution_time_sec_shutter[j][i].append(temp)\n\n#print fList6\nfor (b,a) in enumerate(fList6):\n    #print a\n    if a in siriuscolocationList:\n        index = a\n    else:\n        if a in siriusbenchList:\n            print index\n            print a\n            print fList6[b+4]\n            execution_time_shutter2[index][a].append((fList6[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_shutter[\'colocating with mcf\'][\'perlbench\']\n#print((s.split(start))[1].split(end)[0])\n\nfor j in siriuscolocationList:\n    for i in siriusbenchList:\n        for k in execution_time_shutter2[j][i]:\n            #print k\n            m,s = [float (var) for var in k.split(\':\')]\n            temp = m*60 + s\n            execution_time_sec_shutter2[j][i].append(temp)\n\nfor (b,a) in enumerate(fList5):\n    if a in siriuscolocationList:\n        index = a\n    else:\n        if a in siriusbenchList:\n            dictList_phase_change[index][a].append(fList5[b+1])\n\nfor a in xrange(0,len(siriusrunningList),2):\n    j = siriusrunningList[a+1]\n    i = siriusrunningList[a]\n    #print j,i\n    for elem in dictList_phase_change[j][i]:\n        dictList_phase_change2[j][i].extend(elem.strip().split(\'\\t\'))\n    #print dictList_phase_change2[j][i]\n\nmilcsiri_yaxis = ()\nmilcsiri_yaxis2= ()\nmilcsiri_yaxis_abs = ()\nmilcsiri_error = ()\nmilcsiri_xaxis = ()\n#print dictList_phase_change2[\'colocating with mcf\'][\'perlbench\']\nfor a in xrange(0,len(siriusrunningList),2):\n    j = siriusrunningList[a+1]\n    i = siriusrunningList[a]\n    print j,i\n    #print dictList_phase_change2[j][i]\n    shutter_temp_list = []\n    colo_temp_list = []\n    for (count,item) in enumerate(dictList_phase_change2[j][i]):\n        if count%2==1:\n            colo_temp_list.append(float(item))\n        if count%2==0:\n            shutter_temp_list.append(float(item))\n    #print shutter_temp_list\n    #print colo_temp_list\n    shutter_avg = sum(shutter_temp_list)/len(shutter_temp_list)\n    colocation_avg = sum(colo_temp_list)/len(colo_temp_list)\n    del shutter_temp_list\n    del colo_temp_list\n\n    pause_period = ((colocation_avg ) + ((shutter_avg + (colocation_avg * 2)/3) * 3))/4\n    milcsiri_xaxis = milcsiri_xaxis + (i,)\n    #print (pause_period/np.mean(execution_time_sec_shutter[j][i]))*10\n    milcsiri_yaxis = milcsiri_yaxis + ( (pause_period/np.mean(execution_time_sec_shutter[j][i]))*10  ,)\n    milcsiri_yaxis2 = milcsiri_yaxis2 + ( abs(((np.mean(execution_time_sec_shutter2[j][i])/np.mean(execution_time_sec_shutter[j][i])) - 1)*100), )\n    print execution_time_sec_shutter2[j][i]\n    print execution_time_sec_shutter[j][i]\n    #print np.mean(execution_time_sec_shutter2[j][i])\n    #print np.mean(execution_time_sec_shutter[j][i])\n    #print \'---------------------\'\n\n#print xaxis\n#print yaxis\n#print yaxis2\n#print np.mean(yaxis)\n\nbenchList = [ \'gcc\', \'perlbench\', \'leslie3d\', \'povray\', \'libquantum\', \'astar\', \'bzip2\', \'milc\', \'namd\', \'calculix\', \'h264ref\', \'sphinx3\', \'zeusmp\', \'gobmk\', \'hmmer\', \'tonto\', \'bwaves\', \'gromacs\', \'dealII\', \'sjeng\', \'lbm\', \'xalancbmk\', \'gamess\', \'soplex\', \'GemsFDTD\', \'omnetpp\', \'mcf\', \'cactusADM\' ]\n\ncolocationList = [ \'colocating with libquantum\', \'colocating with mcf\',  \'colocating with milc\']\ncolocationListBaseline = [ \'colocating with libquantum\', \'colocating with mcf\', \'colocating with milc\' ]\n\nrunningList = [  \'perlbench\', \'colocating with milc\', \'mcf\', \'colocating with milc\', \'leslie3d\', \'colocating with milc\', \'povray\', \'colocating with milc\', \'libquantum\', \'colocating with milc\', \'astar\', \'colocating with milc\', \'bzip2\', \'colocating with milc\', \'milc\', \'colocating with milc\', \'namd\', \'colocating with milc\', \'calculix\', \'colocating with milc\', \'h264ref\', \'colocating with milc\', \'gobmk\', \'colocating with milc\', \'hmmer\', \'colocating with milc\', \'tonto\', \'colocating with milc\', \'sphinx3\', \'colocating with milc\', \'zeusmp\', \'colocating with milc\',    \'bwaves\', \'colocating with milc\', \'gromacs\', \'colocating with milc\', \'dealII\', \'colocating with milc\', \'sjeng\', \'colocating with milc\', \'lbm\', \'colocating with milc\', \'xalancbmk\', \'colocating with milc\', \'gamess\', \'colocating with milc\', \'cactusADM\', \'colocating with milc\', \'soplex\', \'colocating with milc\', \'GemsFDTD\', \'colocating with milc\', \'omnetpp\', \'colocating with milc\' ]\nrunningList2 = [  \'leslie3d\', \'colocating with milc\', \'milc\', \'colocating with milc\', \'namd\', \'colocating with milc\', \'calculix\', \'colocating with milc\', \'gobmk\', \'colocating with milc\', \'hmmer\', \'colocating with milc\', \'tonto\', \'colocating with milc\', \'sphinx3\', \'colocating with milc\', \'zeusmp\', \'colocating with milc\', \'bwaves\', \'colocating with milc\', \'gromacs\', \'colocating with milc\', \'dealII\', \'colocating with milc\', \'sjeng\', \'colocating with milc\', \'gamess\', \'colocating with milc\', \'cactusADM\', \'colocating with milc\', \'soplex\', \'colocating with milc\', \'GemsFDTD\', \'colocating with milc\' ]\nrunningList3 = [  \'perlbench\', \'colocating with milc\', \'mcf\', \'colocating with milc\', \'povray\', \'colocating with milc\', \'libquantum\', \'colocating with milc\', \'astar\', \'colocating with milc\', \'bzip2\', \'colocating with milc\', \'h264ref\', \'colocating with milc\',  \'lbm\', \'colocating with milc\', \'xalancbmk\', \'colocating with milc\', \'omnetpp\', \'colocating with milc\' ]\n\nsiriusbenchList = [ \'gmm\', \'dnn_asr\', \'surf-fe\', \'surf-fd\', \'stem\', \'regex\', \'crf\', \'img-imc\', \'img-dig\', \'img-face\', \'nlp-pos\', \'nlp-chk\', \'nlp-ner\']\nsiriuscolocationList = [ \'colocating with lbm\', \'colocating with povray\', \'colocating with astar\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with mcf\' ]\nsiriusrunningList = [ \'gmm\', \'colocating with libquantum\', \'dnn_asr\', \'colocating with libquantum\', \'surf-fe\', \'colocating with libquantum\', \'surf-fd\', \'colocating with libquantum\', \'stem\', \'colocating with libquantum\', \'regex\', \'colocating with libquantum\', \'crf\', \'colocating with libquantum\', \'img-imc\', \'colocating with libquantum\', \'img-dig\', \'colocating with libquantum\', \'img-face\', \'colocating with libquantum\', \'nlp-pos\', \'colocating with libquantum\', \'nlp-chk\', \'colocating with libquantum\', \'nlp-ner\' , \'colocating with libquantum\']\n\ndef autolabel(rects):\n    # attach some text labels\n    for rect in rects:\n        height = rect.get_height()\n        plt.text(rect.get_x()+rect.get_width()/2., 1.05*height, \'%.2f\'%float(height), fontsize=8 )\n\ndef autolabel2(rects):\n    # attach some text labels\n    for rect in rects:\n        height = rect.get_height()\n        plt.text(rect.get_x()+rect.get_width()/2., -1.25*height, \'%.2f\'%float(height),\n                ha=\'center\', va=\'top\', fontsize=8)\n        #plt.text(rect.get_x()+rect.get_width()/2., 1.05*height, \'%.2f\'%float(height))\n\ndef add_line(ax, xpos, ypos):\n    line = plt.Line2D([xpos, xpos], [ypos + .1, ypos - .5], transform=ax.transAxes, linewidth=2, color=\'black\')\n    line.set_clip_on(False)\n    ax.add_line(line)\n\n\nfilename = \'execution_time_1000\'\nfList1 = [s.strip() for s in open(\'../../papergraphs/mixcorunner/degradation/%s.txt\' % filename).readlines()]  #degradation\nfList2 = [s.strip() for s in open(\'../../papergraphs/mixcorunner/snapshot/phase_change_10.txt\').readlines()]\nfList3 = [s.strip() for s in open(\'../../papergraphs/mixcorunner/priorwork/execution_time_4.txt\').readlines()] #prior work\nfList4 = [s.strip() for s in open(\'../../papergraphs/mixcorunner/degradation/execution_time_100.txt\').readlines()]  #degradation\n\nfList7 = [s.strip() for s in open(\'../../papergraphs/mixcorunner/siriusdjinn/degradation/%s.txt\' % filename).readlines()]  #degradation\nfList5 = [s.strip() for s in open(\'../../papergraphs/mixcorunner/siriusdjinn/snapshot/phase_change_75.txt\').readlines()]\nfList6 = [s.strip() for s in open(\'../../papergraphs/mixcorunner/siriusdjinn/priorwork/execution_time_4.txt\').readlines()] #prior work\n\nexecution_time_shutter = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter = defaultdict(lambda  : defaultdict(list))\navg_execution_time_shutter = defaultdict(dict)\nexecution_time_shutter2 = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter2 = defaultdict(lambda  : defaultdict(list))\navg_execution_time_shutter2 = defaultdict(dict)\ndictList_phase_change = defaultdict(lambda  : defaultdict(list))\ndictList_phase_change2 = defaultdict(lambda  : defaultdict(list))\noverhead_snapshot = defaultdict(lambda  : defaultdict(list))\noverhead_shutter = defaultdict(lambda  : defaultdict(list))\n\nstd_execution_time = defaultdict(dict)\n\ndef print_elapsed_time_shutter(time_shutter):\n    for j in colocationList:\n        for i in benchList:\n            print \'%s ||||  %s\'%(j,i)\n            print time_shutter[j][i]\n\n\nsep = \'u\'\nfor (b,a) in enumerate(fList1):\n    #print a\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            execution_time_shutter[index][a].append((fList1[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_shutter[\'colocating with mcf\'][\'perlbench\']\n#print((s.split(start))[1].split(end)[0])\n\nfor j in colocationList:\n    for i in benchList:\n        #print i\n        for k in execution_time_shutter[j][i]:\n            try:\n                #print k\n                m,s = [float (var) for var in k.split(\':\')]\n                temp = m*60 + s\n            except:\n                h,m,s = [float (var) for var in k.split(\':\')]\n                temp = h*3600 + m*60 + s\n            execution_time_sec_shutter[j][i].append(temp)\n\nfor (b,a) in enumerate(fList3):\n    #print a\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            #print index\n            #print a\n            execution_time_shutter2[index][a].append((fList3[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_shutter[\'colocating with mcf\'][\'perlbench\']\n#print((s.split(start))[1].split(end)[0])\n\nfor j in colocationList:\n    for i in benchList:\n        for k in execution_time_shutter2[j][i]:\n            #print k\n            try:\n                m,s = [float (var) for var in k.split(\':\')]\n                temp = m*60 + s\n            except:\n                h,m,s = [float (var) for var in k.split(\':\')]\n                temp = h*3600 + m*60 + s\n            execution_time_sec_shutter2[j][i].append(temp)\n\nfor (b,a) in enumerate(fList2):\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            dictList_phase_change[index][a].append(fList2[b+1])\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    #print j,i\n    for elem in dictList_phase_change[j][i]:\n        dictList_phase_change2[j][i].extend(elem.strip().split(\'\\t\'))\n    #print dictList_phase_change2[j][i]\n\nyaxis = ()\nyaxis2= ()\nyaxis_abs = ()\nerror = ()\nxaxis = ()\n#print dictList_phase_change2[\'colocating with mcf\'][\'perlbench\']\nfor a in xrange(0,len(runningList2),2):\n    j = runningList2[a+1]\n    i = runningList2[a]\n    #print j,i\n    #print dictList_phase_change2[j][i]\n    #print i,j\n    shutter_temp_list = []\n    colo_temp_list = []\n    for (count,item) in enumerate(dictList_phase_change2[j][i]):\n        if count%2==1:\n            colo_temp_list.append(float(item))\n        if count%2==0:\n            shutter_temp_list.append(float(item))\n    #print shutter_temp_list\n    shutter_avg = sum(shutter_temp_list)/len(shutter_temp_list)\n    colocation_avg = sum(colo_temp_list)/len(colo_temp_list)\n    del shutter_temp_list\n    del colo_temp_list\n\n    pause_period = ((colocation_avg ) + ((shutter_avg + (colocation_avg * 2)/3) * 3))/4\n    #xaxis = xaxis + (i,)\n    #print (pause_period/np.mean(execution_time_sec_shutter[j][i]))*10\n    overhead_snapshot[j][i] = (pause_period/np.mean(execution_time_sec_shutter[j][i]))*7.5\n    overhead_shutter[j][i] = abs(((np.mean(execution_time_sec_shutter2[j][i])/np.mean(execution_time_sec_shutter[j][i])) - 1)*100)\n    #yaxis = yaxis + ( (pause_period/np.mean(execution_time_sec_shutter[j][i]))*7.5  ,)\n    #yaxis2 = yaxis2 + ( abs(((np.mean(execution_time_sec_shutter2[j][i])/np.mean(execution_time_sec_shutter[j][i])) - 1)*100), )\n    #print \'---------------------\'\n\n\nfor a in xrange(0,len(runningList3),2):\n    j = runningList3[a+1]\n    i = runningList3[a]\n    #print j,i,execution_time_sec_shutter2[j][i],execution_time_sec_shutter[j][i]\n\n    #pause_period = ((colocation_avg ) + ((shutter_avg + (colocation_avg * 2)/3) * 3))/4\n    #xaxis = xaxis + (i,)\n    #print (pause_period/np.mean(execution_time_sec_shutter[j][i]))*10\n    #yaxis = yaxis + ( (pause_period/np.mean(execution_time_sec_shutter[j][i]))*7.5  ,)\n    overhead_shutter[j][i] = abs(((np.mean(execution_time_sec_shutter2[j][i])/np.mean(execution_time_sec_shutter[j][i])) - 1)*100)\n    #yaxis2 = yaxis2 + ( abs(((np.mean(execution_time_sec_shutter2[j][i])/np.mean(execution_time_sec_shutter[j][i])) - 1)*100), )\n#print np.mean(yaxis)\n\ndel execution_time_shutter\ndel execution_time_sec_shutter\n\nexecution_time_shutter = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter = defaultdict(lambda  : defaultdict(list))\n\n\nsep = \'u\'\nfor (b,a) in enumerate(fList4):\n    #print a\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            execution_time_shutter[index][a].append((fList4[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_shutter[\'colocating with mcf\'][\'perlbench\']\n#print((s.split(start))[1].split(end)[0])\n\nfor j in colocationList:\n    for i in benchList:\n        #print i\n        for k in execution_time_shutter[j][i]:\n            try:\n                #print k\n                m,s = [float (var) for var in k.split(\':\')]\n                temp = m*60 + s\n            except:\n                h,m,s = [float (var) for var in k.split(\':\')]\n                temp = h*3600 + m*60 + s\n            execution_time_sec_shutter[j][i].append(temp)\n\nfor a in xrange(0,len(runningList3),2):\n    j = runningList3[a+1]\n    i = runningList3[a]\n    #print j,i\n    #print dictList_phase_change2[j][i]\n    #print i,j\n    shutter_temp_list = []\n    colo_temp_list = []\n    for (count,item) in enumerate(dictList_phase_change2[j][i]):\n        if count%2==1:\n            colo_temp_list.append(float(item))\n        if count%2==0:\n            shutter_temp_list.append(float(item))\n    #print shutter_temp_list\n    shutter_avg = sum(shutter_temp_list)/len(shutter_temp_list)\n    colocation_avg = sum(colo_temp_list)/len(colo_temp_list)\n    del shutter_temp_list\n    del colo_temp_list\n\n    pause_period = ((colocation_avg ) + ((shutter_avg + (colocation_avg * 2)/3) * 3))/4\n    #xaxis = xaxis + (i,)\n    #print (pause_period/np.mean(execution_time_sec_shutter[j][i]))*10\n    #yaxis = yaxis + ( (pause_period/np.mean(execution_time_sec_shutter[j][i]))*7.5  ,)\n    overhead_snapshot[j][i] = (pause_period/np.mean(execution_time_sec_shutter[j][i]))*7.5\n    #yaxis2 = yaxis2 + ( abs(((np.mean(execution_time_sec_shutter2[j][i])/np.mean(execution_time_sec_shutter[j][i])) - 1)*100), )\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    xaxis = xaxis + (i,)\n    yaxis = yaxis + ( overhead_snapshot[j][i]  ,)\n    yaxis2 = yaxis2 + ( overhead_shutter[j][i], )\n\n#print yaxis\n#print yaxis2\n\n\n#width = 0.25\n#x = np.arange(len(yaxis))\n#fig = plt.figure(figsize=(28, 5))\n#bar2 = plt.bar( x, yaxis2, width, color="k", label=\'Shuttering  (mean: %.2f)\' %(np.mean(yaxis2)))\n#bar1 = plt.bar( x+width, yaxis, width, color="lightgrey", label=\'Snapshot (mean: %.2f)\' %(np.mean(yaxis) ))\n##bar3 = plt.bar( x+width+width, yaxis3, width, color="g", label=\' colocating with sphinx3 (avg = %.1f)\' %(np.mean(yaxis3)))\n###bar3 = plt.bar( x+width+width, yaxis3, width, color="g", label=\'4 corunners (avg is %.1f)\' %(np.mean(yaxis3) ))\n###autolabel2(bar1)\n###autolabel(bar2)\n###autolabel2(bar3)\n#plt.ylabel( \'Execution time \\n overhead(%)\',fontsize=23)\n##plt.title(\'Overhead due to Prediction of degradation while co-running with milc\')\n#plt.xticks(x + width/2.0, xaxis, rotation=\'30\', size=\'23\', ha=\'center\')\n##plt.yticks((-5,0,10,20,30,40,50,60),(\'\',\'0\',\'10\',\'20\',\'30\',\'40\',\'50\',\'60\'),size=\'25\')\n#plt.yticks((0,5,10,15),(\'0\',\'5\',\'10\',\'15\'),size=\'25\')\n#plt.xlim(-1,27)\n#plt.grid()\n#plt.legend(loc=9, ncol=2, prop={\'size\':28})\n#plt.tight_layout()\n##plt.savefig(\'milc_overhead.pdf\', dpi=125)\n\ndel execution_time_shutter\ndel execution_time_sec_shutter\ndel avg_execution_time_shutter\ndel execution_time_shutter2\ndel execution_time_sec_shutter2\ndel avg_execution_time_shutter2\ndel dictList_phase_change\ndel dictList_phase_change2\n\nexecution_time_shutter = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter = defaultdict(lambda  : defaultdict(list))\navg_execution_time_shutter = defaultdict(dict)\nexecution_time_shutter2 = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter2 = defaultdict(lambda  : defaultdict(list))\navg_execution_time_shutter2 = defaultdict(dict)\ndictList_phase_change = defaultdict(lambda  : defaultdict(list))\ndictList_phase_change2 = defaultdict(lambda  : defaultdict(list))\n\nstd_execution_time = defaultdict(dict)\n\ndef print_elapsed_time_shutter(time_shutter):\n    for j in siriuscolocationList:\n        for i in siriusbenchList:\n            print \'%s ||||  %s\'%(j,i)\n            print time_shutter[j][i]\n\n\nsep = \'u\'\nfor (b,a) in enumerate(fList7):\n    #print a\n    if a in siriuscolocationList:\n        index = a\n    else:\n        if a in siriusbenchList:\n            #print a\n            #print fList7[b+4]\n            execution_time_shutter[index][a].append((fList7[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_shutter[\'colocating with mcf\'][\'perlbench\']\n#print((s.split(start))[1].split(end)[0])\n\nfor j in siriuscolocationList:\n    for i in siriusbenchList:\n        #print i\n        for k in execution_time_shutter[j][i]:\n            try:\n                m,s = [float (var) for var in k.split(\':\')]\n                temp = m*60 + s\n            except:\n                h,m,s = [float (var) for var in k.split(\':\')]\n                temp = h*3600 + m*60 + s\n\n            execution_time_sec_shutter[j][i].append(temp)\n\nfor (b,a) in enumerate(fList6):\n    #print a\n    if a in siriuscolocationList:\n        index = a\n    else:\n        if a in siriusbenchList:\n            #print index\n            #print a\n            execution_time_shutter2[index][a].append((fList6[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_shutter[\'colocating with mcf\'][\'perlbench\']\n#print((s.split(start))[1].split(end)[0])\n\nfor j in siriuscolocationList:\n    for i in siriusbenchList:\n        for k in execution_time_shutter2[j][i]:\n            #print k\n            m,s = [float (var) for var in k.split(\':\')]\n            temp = m*60 + s\n            execution_time_sec_shutter2[j][i].append(temp)\n\nfor (b,a) in enumerate(fList5):\n    if a in siriuscolocationList:\n        index = a\n    else:\n        if a in siriusbenchList:\n            dictList_phase_change[index][a].append(fList5[b+1])\n\nmixsiri_yaxis = ()\nmixsiri_yaxis2= ()\nmixsiri_yaxis_abs = ()\nmixsiri_error = ()\nmixsiri_xaxis = ()\nfor a in xrange(0,len(siriusrunningList),2):\n    j = siriusrunningList[a+1]\n    i = siriusrunningList[a]\n    #print j,i\n    for elem in dictList_phase_change[j][i]:\n        dictList_phase_change2[j][i].extend(elem.strip().split(\'\\t\'))\n    #print dictList_phase_change2[j][i]\n\n#print dictList_phase_change2[\'colocating with mcf\'][\'perlbench\']\nfor a in xrange(0,len(siriusrunningList),2):\n    j = siriusrunningList[a+1]\n    i = siriusrunningList[a]\n    print j,i\n    #print dictList_phase_change2[j][i]\n    #print i,j\n    shutter_temp_list = []\n    colo_temp_list = []\n    for (count,item) in enumerate(dictList_phase_change2[j][i]):\n        if count%2==1:\n            colo_temp_list.append(float(item))\n        if count%2==0:\n            shutter_temp_list.append(float(item))\n    print shutter_temp_list\n    print colo_temp_list\n    shutter_avg = sum(shutter_temp_list)/len(shutter_temp_list)\n    colocation_avg = sum(colo_temp_list)/len(colo_temp_list)\n    del shutter_temp_list\n    del colo_temp_list\n\n    pause_period = ((colocation_avg ) + ((shutter_avg + (colocation_avg * 2)/3) * 3))/4\n    mixsiri_xaxis = mixsiri_xaxis + (i,)\n    #print (pause_period/np.mean(execution_time_sec_shutter[j][i]))*10\n    mixsiri_yaxis = mixsiri_yaxis + ( (pause_period/np.mean(execution_time_sec_shutter[j][i]))*10  ,)\n    mixsiri_yaxis2 = mixsiri_yaxis2 + ( abs(((np.mean(execution_time_sec_shutter2[j][i])/np.mean(execution_time_sec_shutter[j][i])) - 1)*100), )\n    #print np.mean(execution_time_sec_shutter2[j][i])\n    #print np.mean(execution_time_sec_shutter[j][i])\n    #print \'---------------------\'\n\n#print xaxis\n#print yaxis\n#print yaxis2\n#print np.mean(yaxis)\n\ncolors = color_maker(len(libsiri_yaxis), map=\'afmhot\')\n\nwidth = 0.15\nx = np.arange(len(libsiri_yaxis))\nfig = plt.figure(figsize=(15, 5))\nax = fig.add_subplot(1,1,1)\n#bar2 = plt.bar( x, libsiri_yaxis2, width, color="r", label=\'libquantum (avg = %.2f)\' %(np.mean(libsiri_yaxis2)))\nbar1 = plt.bar( x, libsiri_yaxis, width, color=\'y\', label=\'libquantum (avg = %.2f)\' %(np.mean(libsiri_yaxis) ))\nbar2 = plt.bar( x+width, mcfsiri_yaxis, width, color=\'r\', label=\'mcf (avg = %.2f)\' %(np.mean(mcfsiri_yaxis) ))\nbar4 = plt.bar( x+width+width, milcsiri_yaxis, width, color=\'b\', label=\'milc (avg = %.2f)\' %(np.mean(milcsiri_yaxis) ))\nbar4 = plt.bar( x+width+width+width, mixsiri_yaxis, width, color=\'g\', label=\'mix (avg = %.2f)\' %(np.mean(mixsiri_yaxis) ))\nly = len(yaxis2)\nadd_line(ax, 0 * 1, -.1)\nadd_line(ax, 1 * 1.0, -.1)\nadd_line(ax, 1 * 0.53, -.1)\n#add_line(ax, 1 * 0.845, -.1)\n#bar3 = plt.bar( x+width+width, yaxis3, width, color="g", label=\' colocating with sphinx3 (avg = %.1f)\' %(np.mean(yaxis3)))\n##bar3 = plt.bar( x+width+width, yaxis3, width, color="g", label=\'4 corunners (avg is %.1f)\' %(np.mean(yaxis3) ))\n##autolabel2(bar1)\n##autolabel(bar2)\n##autolabel2(bar3)\nplt.ylabel( \'Execution time \\n overhead(%)\', fontsize=\'22\' )\n#plt.title(\'Overhead due to Prediction of degradation while co-running with LIBQUANTUM\')\nplt.xticks(x + width/2.0, libsiri_xaxis, rotation=\'90\', size=\'23\', ha=\'center\')\nplt.ylim(0,20)\nplt.xlim(-0.2,13)\nplt.yticks(np.arange(0,30,10),size=\'20\')\nplt.grid()\nplt.legend(loc=1, ncol=4, prop={\'size\':17})\nplt.tight_layout()\n#plt.savefig(\'overheadlibquantum.pdf\', dpi=125)\n\n#ax.text(10, -10, r\'SPEC 2006\', fontsize=20)\nax.text(3, -11, r\'Sirius Suite\', fontsize=20)\nax.text(8, -11, r\'DjiNN & Tonic\', fontsize=20)\n'
p0
.I0
.S'$omit!:Putting All Together'
p0
.S'$s: Putting All Together'
p0
.I2
.S'Motivation'
p0
.S'$p: In the previous sections, we discussed how to select three types of event to trigger phase changes and how to eliminate spikes while triggering phase changes. In this section, we introduce how we can incorporate these two techniques to identify unintended performance degradation in public clouds.'
p0
.I0
.S'Figure explanation'
p0
.S'$p:Figure \\ref{fig:detect_phases} describes the process of the phase triggered taking place in our pricing runtime engine. Our runtime system collects three types of events every second as shown in Figure \\ref{fig:detect_phases}(a). It inspects whether there is a significant change in the range of the measured events by comparing it to the corresponding PMU measurements at the most recent phase change. In this process, it also discards spikes associated with PMU measurements as shown in Figure \\ref{fig:detect_phases}(b). To avoid missing true phase changes, we use a conservative approach to call for a phase change even if one of the PMU types out of the three detects a phase change. If we do not detect true phase changes, it will significantly reduce the accuracy in estimating CPI of solo execution. \n\nOn the other hand, mispredicting phase changes causes only negligible overhead if the frequency of such events is low. Once a new phase is detected, the runtime engine then pauses co-running VMs so as to estimate solo performance of the applications. In the example as shown in Figure \\ref{fig:detect_phases}(c), CPI:co-run, L1D:co-run and LLC:co-run indicate the PMU measurements for CPI, L1 d-cache load misses and LLC-store misses, respectively. From this figure, we are able to see that \\texttt{LLC store misses} is able to detect the phase changes present in the application whereas CPI and L1 d-cache are unable to detect phase changes in runtime.  '
p0
.I0
.S'Experimental Environments'
p0
.S'$s: Experimental Environments'
p0
.I3
.S'Overview'
p0
.S'$p: In this section, we present the experimental platform in which we evaluate our \\textit{snapshot} technique. We also enumerate the benchmarks that used in this paper. \n'
p0
.I0
.S'Experimental setup'
p0
.S'$s:Experimental Setup'
p0
.I3
.S'$sub_fig*:spec-acc-over:Accuracy and overhead of SPEC CPU 2006:spec-accuracy,2:nl:spec-overhead,2:!'
p0
.S''
p0
.I2
.S'$graph_fig:spec-accuracy:Accuracy:0.9'
p0
.S'from collections import defaultdict\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nbenchListBaseline = [ \'gcc\', \'perlbench\', \'leslie3d\', \'povray\', \'libquantum\', \'astar\', \'bzip2\', \'milc\', \'namd\', \'calculix\', \'h264ref\', \'sphinx3\', \'zeusmp\', \'gobmk\', \'hmmer\', \'tonto\', \'bwaves\', \'gromacs\', \'dealII\', \'sjeng\', \'lbm\', \'xalancbmk\', \'gamess\', \'cactusADM\', \'soplex\', \'GemsFDTD\', \'omnetpp\', \'mcf\' ]\nbenchListExperiments = [ \'gcc\', \'perlbench\', \'leslie3d\', \'povray\', \'libquantum\', \'astar\', \'bzip2\', \'milc\', \'namd\', \'calculix\', \'h264ref\', \'sphinx3\', \'zeusmp\', \'gobmk\', \'hmmer\', \'tonto\', \'bwaves\', \'gromacs\', \'dealII\', \'sjeng\', \'lbm\', \'xalancbmk\', \'gamess\', \'cactusADM\', \'soplex\', \'GemsFDTD\', \'omnetpp\', \'mcf\' ]\ncolocationListBaseline = [ \'colocating with lbm\', \'colocating with povray\', \'colocating with astar\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with mcf\' ]\ncolocationListExperiments = [ \'colocating with lbm\', \'colocating with povray\', \'colocating with perlbench\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with mcf\' ]\nrunningList2 = [  \'perlbench\', \'colocating with libquantum\', \'mcf\', \'colocating with libquantum\', \'leslie3d\', \'colocating with libquantum\', \'povray\', \'colocating with libquantum\', \'libquantum\', \'colocating with libquantum\', \'astar\', \'colocating with libquantum\', \'bzip2\', \'colocating with libquantum\', \'milc\', \'colocating with libquantum\', \'namd\', \'colocating with libquantum\', \'calculix\', \'colocating with libquantum\', \'h264ref\', \'colocating with libquantum\', \'gobmk\', \'colocating with libquantum\', \'hmmer\', \'colocating with libquantum\', \'tonto\', \'colocating with libquantum\', \'sphinx3\', \'colocating with libquantum\', \'zeusmp\', \'colocating with libquantum\', \'bwaves\', \'colocating with libquantum\', \'gromacs\', \'colocating with libquantum\', \'dealII\', \'colocating with libquantum\', \'sjeng\', \'colocating with libquantum\', \'lbm\', \'colocating with libquantum\', \'xalancbmk\', \'colocating with libquantum\', \'gamess\', \'colocating with libquantum\', \'cactusADM\', \'colocating with libquantum\', \'soplex\', \'colocating with libquantum\', \'GemsFDTD\', \'colocating with libquantum\', \'omnetpp\', \'colocating with libquantum\' ]\n\nsiriusbenchListBaseline = [ \'gmm\', \'dnn_asr\', \'surf-fe\', \'surf-fd\', \'stem\', \'regex\', \'crf\', \'img-imc\', \'img-dig\', \'img-face\', \'nlp-pos\', \'nlp-chk\', \'nlp-ner\']\nsiriusbenchListExperiments = [ \'gmm\', \'dnn_asr\', \'surf-fe\', \'surf-fd\', \'stem\', \'regex\', \'crf\', \'img-imc\', \'img-dig\', \'img-face\', \'nlp-pos\', \'nlp-chk\', \'nlp-ner\']\nsiriuscolocationListBaseline = [ \'colocating with lbm\', \'colocating with povray\', \'colocating with astar\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with mcf\' ]\nsiriuscolocationListExperiments = [ \'colocating with lbm\', \'colocating with povray\', \'colocating with perlbench\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with mcf\' ]\nsiriusrunningList2 = [ \'gmm\', \'colocating with libquantum\', \'dnn_asr\', \'colocating with libquantum\', \'surf-fe\', \'colocating with libquantum\', \'surf-fd\', \'colocating with libquantum\', \'stem\', \'colocating with libquantum\', \'regex\', \'colocating with libquantum\', \'crf\', \'colocating with libquantum\', \'img-imc\', \'colocating with libquantum\', \'img-dig\', \'colocating with libquantum\', \'img-face\', \'colocating with libquantum\', \'nlp-pos\', \'colocating with libquantum\', \'nlp-chk\', \'colocating with libquantum\', \'nlp-ner\' , \'colocating with libquantum\']\n\ndef autolabel(rects):\n    # attach some text labels\n    for rect in rects:\n        height = rect.get_height()\n        plt.text(rect.get_x()+rect.get_width()/2., 1.05*height, \'%.2f\'%float(height))\n\ndef autolabel2(rects):\n    # attach some text labels\n    for rect in rects:\n        height = rect.get_height()\n        plt.text(rect.get_x()+rect.get_width()/2., 1.05*height, \'%.2f\'%float(height))\n\ndef add_line(ax, xpos, ypos):\n    line = plt.Line2D([xpos, xpos], [ypos + .1, ypos - .5], transform=ax.transAxes, linewidth=2, color=\'black\')\n    line.set_clip_on(False)\n    ax.add_line(line)\n\nfilename = \'shutter_cpi_10\'\n\nfList3= [s.strip() for s in open(\'../../papergraphs/accuracy/libquantumcorunner/priorwork/shutter_cpi_5.txt\').readlines()]\n\nfList4 = [s.strip() for s in open(\'../../papergraphs/accuracy/libquantumcorunner/singlevm/shutter_cpi_1000.txt\').readlines()]\nfList5 = [s.strip() for s in open(\'../../papergraphs/accuracy/libquantumcorunner/degradation/shutter_cpi_1000.txt\').readlines()]\nfList6 = [s.strip() for s in open(\'../../papergraphs/accuracy/libquantumcorunner/snapshot2/%s.txt\' % filename).readlines()]\nfList7 = [s.strip() for s in open(\'../../papergraphs/accuracy/libquantumcorunner/degradation3/shutter_cpi_1000.txt\').readlines()]\n\nfList8= [s.strip() for s in open(\'../../papergraphs/accuracy/libquantumcorunner/siriusdjinn/priorwork/shutter_cpi_4.txt\').readlines()]\n\nfList9 = [s.strip() for s in open(\'../../papergraphs/accuracy/libquantumcorunner/siriusdjinn/singlevm/shutter_cpi_1000.txt\').readlines()]\nfList10 = [s.strip() for s in open(\'../../papergraphs/accuracy/libquantumcorunner/siriusdjinn/degradation/shutter_cpi_1000.txt\').readlines()]\nfList11 = [s.strip() for s in open(\'../../papergraphs/accuracy/libquantumcorunner/siriusdjinn/snapshot/%s.txt\' % filename).readlines()]\n\ndictList_single_vm = defaultdict(list)\ndictList_degradation_colocation = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_colocation2 = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter2 = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter3 = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter4 = defaultdict(lambda  : defaultdict(list))\nplot_degradation = defaultdict(dict)\nplot_degradation2 = defaultdict(dict)\nplot_degradation_error = defaultdict(dict)\nplot_degradation_error2 = defaultdict(dict)\nplot_degradation_abs = defaultdict(dict)\nplot_degradation_abs2 = defaultdict(dict)\n\nfor (b,a) in enumerate(fList4):\n    if a in benchListBaseline:\n        dictList_single_vm[a].append(fList4[b+1])\n\n#SORTING LIST CONTAING VALUES OF SINGLE SPEC RUNS INSIDE VMs\nfor i in benchListBaseline:\n    dictList_single_vm[i].sort()\n    #print i,dictList_single_vm[i]\n\nfor (b,a) in enumerate(fList5):\n    #print a\n    if a in colocationListBaseline:\n       #print a\n       index = a\n    else:\n        if a in benchListExperiments:\n            #print a\n            dictList_degradation_colocation[index][a].append(fList5[b+1])\n\n#sorting the ground truth values\nfor a in xrange(0,len(runningList2),2):\n    j = runningList2[a+1]\n    i = runningList2[a]\n    dictList_degradation_colocation[j][i].sort()\n    #print j,i,dictList_degradation_colocation[j][i]\n\nfor (b,a) in enumerate(fList7):\n    #print a\n    if a in colocationListBaseline:\n       #print a\n       index = a\n    else:\n        if a in benchListExperiments:\n            #print a\n            dictList_degradation_colocation2[index][a].append(fList7[b+1])\n\n#APPENDING DEGRADATION SHUTTER\nfor (b,a) in enumerate(fList6):\n    if a in colocationListExperiments:\n        index = a\n    else:\n        if a in benchListExperiments:\n            dictList_degradation_shutter[index][a].append(fList6[b+1])\n\nfor (b,a) in enumerate(fList3):\n    if a in colocationListExperiments:\n        index = a\n    else:\n        if a in benchListExperiments:\n            dictList_degradation_shutter3[index][a].append(fList3[b+1])\n\nfor a in xrange(0,len(runningList2),2):\n    j = runningList2[a+1]\n    i = runningList2[a]\n    #print i,j,dictList_degradation_shutter[j][i]\n#APPENDING DEGRADATION SHUTTER2 as shutter and colocation values are tab separated\nfor a in xrange(0,len(runningList2),2):\n    j = runningList2[a+1]\n    i = runningList2[a]\n    for elem in dictList_degradation_shutter[j][i]:\n        dictList_degradation_shutter2[j][i].extend(elem.strip().split(\'\\t\'))\n\n    for elem in dictList_degradation_shutter3[j][i]:\n        dictList_degradation_shutter4[j][i].extend(elem.strip().split(\'\\t\'))\n    #print dictList_degradation_shutter2[j][i]\n\nspeclib_yaxis2 = ()\nspeclib_yaxis3 = ()\nspeclib_yaxis_abs2 = ()\nspeclib_yaxis_abs3 = ()\nspeclib_error2 = ()\nspeclib_error3 = ()\nspeclib_xaxis2 = ()\nfor a in xrange(0,len(runningList2),2):\n    j = runningList2[a+1]\n    i = runningList2[a]\n    #print i,j\n    #print dictList_single_vm[i]\n    #print dictList_degradation_colocation[j][i]\n    #print dictList_degradation_shutter2[j][i]\n    denominator1 = sum(float(n) for (m,n) in enumerate(dictList_single_vm[i]) if m!=0 and m!=len(dictList_single_vm[i])-1)/(len(dictList_single_vm[i])-2)\n    numerator1 = sum(float(n) for (m,n) in enumerate(dictList_degradation_colocation[j][i]))/(len(dictList_degradation_colocation[j][i]))\n    numerator10 = sum(float(n) for (m,n) in enumerate(dictList_degradation_colocation2[j][i]))/(len(dictList_degradation_colocation2[j][i]))\n    shutter_temp_list = []\n    shutter_temp_list2 = []\n    colo_temp_list = []\n    colo_temp_list2 = []\n    degradation_temp_list = []\n    degradation_temp_list2 = []\n    error_temp_list = []\n    error_temp_list2 = []\n    #print numerator1\n    #print denominator1\n    for (count,item) in enumerate(dictList_degradation_shutter2[j][i]):\n        if count%2==0:\n            colo_temp_list.append(item)\n        if count%2==1:\n            shutter_temp_list.append(item)\n\n    for (count,item) in enumerate(dictList_degradation_shutter4[j][i]):\n        if count%2==0:\n            colo_temp_list2.append(item)\n        if count%2==1:\n            shutter_temp_list2.append(item)\n\n    for (count,item) in enumerate(shutter_temp_list):\n        degradation_temp_list.append(abs((((float(shutter_temp_list[count])/float(colo_temp_list[count]))-(numerator1/denominator1))/(float(shutter_temp_list[count])/float(colo_temp_list[count])))*100))\n\n    shutter_temp_list.sort()\n    shutter_temp_list2.sort()\n    colo_temp_list.sort()\n    colo_temp_list2.sort()\n    #print shutter_temp_list\n    #print colo_temp_list\n    #print dictList_degradation_shutter2[j][i]\n    denominator2 = sum(float(n) for (m,n) in enumerate(shutter_temp_list) if m!=0 and m!=len(shutter_temp_list)-1 )/len(shutter_temp_list)\n    numerator2 = sum(float(n) for (m,n) in enumerate(colo_temp_list) if m!=0 and m!=len(colo_temp_list)-1  )/len(colo_temp_list)\n    for (m,n) in enumerate(shutter_temp_list):\n        ratio=float(n)/float(colo_temp_list[m])\n        error_temp_list.append(abs((((ratio)-(numerator10/denominator1))/(numerator10/denominator1))*100))\n    plot_degradation_error[j][i]=np.std(error_temp_list)\n\n    denominator3 = sum(float(n) for (m,n) in enumerate(shutter_temp_list2))/(len(shutter_temp_list2))\n    numerator3 = sum(float(n) for (m,n) in enumerate(colo_temp_list2))/(len(colo_temp_list2))\n    for (m,n) in enumerate(shutter_temp_list2):\n        ratio=float(n)/float(colo_temp_list2[m])\n        error_temp_list2.append(abs((((ratio)-(numerator3/denominator3))/(numerator1/denominator1))*100))\n    plot_degradation_error2[j][i]=np.std(error_temp_list2)\n\n    #print numerator2\n    #print denominator2\n    del shutter_temp_list\n    del colo_temp_list\n    del degradation_temp_list\n    del shutter_temp_list2\n    del colo_temp_list2\n    del degradation_temp_list2\n    plot_degradation[j][i] = (((numerator2/denominator2)-(numerator10/denominator1))/(numerator10/denominator1))*100\n    plot_degradation_abs[j][i] = abs((((numerator2/denominator2)-(numerator10/denominator1))/(numerator10/denominator1))*100)\n    plot_degradation2[j][i] = (((numerator3/denominator3)-(numerator1/denominator1))/(numerator1/denominator1))*100\n    plot_degradation_abs2[j][i] = abs((((numerator3/denominator3)-(numerator1/denominator1))/(numerator1/denominator1))*100)\n    #print j,i,plot_degradation[j][i]\n    #print plot_degradation_error[j][i]\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    speclib_xaxis2 = speclib_xaxis2 + (i,)\n    speclib_yaxis2 = speclib_yaxis2 + (plot_degradation[j][i],)\n    speclib_yaxis3 = speclib_yaxis3 + (plot_degradation2[j][i],)\n    speclib_yaxis_abs2 = speclib_yaxis_abs2 + (plot_degradation_abs[j][i],)\n    speclib_yaxis_abs3 = speclib_yaxis_abs3 + (plot_degradation_abs2[j][i],)\n    speclib_error2 = speclib_error2 + (plot_degradation_error[j][i],)\n    speclib_error3 = speclib_error3 + (plot_degradation_error2[j][i],)\n    #print numerator2,denominator2,numerator2/denominator2\n    #print denominator2/numerator2\n    #print j,i,plot_degradation[j][i]\n            #print (((numerator2/denominator2)-(numerator1/denominator1))/(numerator2/denominator2))*100\n#print np.mean(yaxis2)\n\n\n#width=0.25\n#x = np.arange(len(yaxis2))\n#fig = plt.figure(figsize=(28, 5))\n##bar1 = plt.bar( x, yaxis, width, color="r", label=\'colocating with libquatum (avg = %.2f)\' %(np.mean(yaxis_abs)))\n#bar1 = plt.bar( x, yaxis_abs3, width, color="k", yerr=error3, label=\'Shuttering (mean: %.2f)\' %(np.mean(yaxis_abs3)))\n#bar2 = plt.bar( x+width, yaxis_abs2, width, color="lightgrey", yerr=error2, label=\'Snapshot (mean: %.2f)\' %(np.mean(yaxis_abs2)))\n##bar3 = plt.bar( x+width+width, yaxis3, width, color="g", label=\'colocating with sphinx  (avg = %.2f)\' %(np.mean(yaxis_abs3)))\n##autolabel(bar1)\n##autolabel(bar2)\n#plt.ylabel( \'Estimation error (%)\' ,fontsize=\'25\')\n##plt.title(\'Error in predicting degradation when co-locating with libquantum\')\n#plt.xticks(x + width/2.0, xaxis2, rotation=\'30\', size=\'23\',  ha=\'center\', va=\'top\')\n##plt.yticks((-0.5,0,1,2,3,4),(\'\',\'0\',\'1\',\'2\',\'3\',\'4\'),size=\'23\')\n#plt.yticks((0,10,20,30,40,50),(\'0\',\'10\',\'20\',\'30\',\'40\',\' \'),size=\'25\')\n#plt.ylim(0,50)\n#plt.xlim(-1,26)\n#plt.grid()\n#plt.tight_layout()\n#plt.legend(loc=9, ncol=2, prop={\'size\':28})\n##plt.savefig(\'%s_maybefinal_error.png\' %(filename), dpi=125)\n\n\n## ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\ndel dictList_single_vm\ndel dictList_degradation_colocation\ndel dictList_degradation_shutter\ndel dictList_degradation_shutter2\ndel dictList_degradation_shutter3\ndel dictList_degradation_shutter4\ndel plot_degradation\ndel plot_degradation2\ndel plot_degradation_error\ndel plot_degradation_error2\ndel plot_degradation_abs\ndel plot_degradation_abs2\n\ndictList_single_vm = defaultdict(list)\ndictList_degradation_colocation = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter2 = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter3 = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter4 = defaultdict(lambda  : defaultdict(list))\nplot_degradation = defaultdict(dict)\nplot_degradation2 = defaultdict(dict)\nplot_degradation_error = defaultdict(dict)\nplot_degradation_error2 = defaultdict(dict)\nplot_degradation_abs = defaultdict(dict)\nplot_degradation_abs2 = defaultdict(dict)\n\nfor (b,a) in enumerate(fList9):\n    if a in siriusbenchListBaseline:\n        dictList_single_vm[a].append(fList9[b+1])\n\n#SORTING LIST CONTAING VALUES OF SINGLE SPEC RUNS INSIDE VMs\nfor i in siriusbenchListBaseline:\n    dictList_single_vm[i].sort()\n    #print i,dictList_single_vm[i]\n\nfor (b,a) in enumerate(fList10):\n    #print a\n    if a in siriuscolocationListBaseline:\n       #print a\n       index = a\n    else:\n        if a in siriusbenchListExperiments:\n            #print a\n            dictList_degradation_colocation[index][a].append(fList10[b+1])\n\n#sorting the ground truth values\nfor a in xrange(0,len(siriusrunningList2),2):\n    j = siriusrunningList2[a+1]\n    i = siriusrunningList2[a]\n    #print i,j\n    dictList_degradation_colocation[j][i].sort()\n    #print j,i,dictList_degradation_colocation[j][i]\n\n#for a in xrange(0,len(runningList),2):\n#    j = runningList[a+1]\n#    i = runningList[a]\n#    numerator1 = sum(float(n) for (m,n) in enumerate(dictList_degradation_colocation[j][i]) if m!=0 and m!=len(dictList_degradation_colocation[j][i])-1)/(len(dictList_degradation_colocation[j][i])-2)\n#    print numerator1\n#    #print dictList_degradation_colocation[runningList[a+1]][runningList[a]]\n#    #print numerator1\n\n#APPENDING DEGRADATION SHUTTER\nfor (b,a) in enumerate(fList11):\n    #print a\n    if a in siriuscolocationListExperiments:\n        index = a\n    else:\n        if a in siriusbenchListExperiments:\n            dictList_degradation_shutter[index][a].append(fList11[b+1])\n\nfor (b,a) in enumerate(fList8):\n    if a in siriuscolocationListExperiments:\n        index = a\n    else:\n        if a in siriusbenchListExperiments:\n            dictList_degradation_shutter3[index][a].append(fList8[b+1])\n\nfor a in xrange(0,len(siriusrunningList2),2):\n    j = siriusrunningList2[a+1]\n    i = siriusrunningList2[a]\n    #print i,j,dictList_degradation_shutter[j][i]\n#APPENDING DEGRADATION SHUTTER2 as shutter and colocation values are tab separated\nfor a in xrange(0,len(siriusrunningList2),2):\n    j = siriusrunningList2[a+1]\n    i = siriusrunningList2[a]\n    for elem in dictList_degradation_shutter[j][i]:\n        dictList_degradation_shutter2[j][i].extend(elem.strip().split(\'\\t\'))\n\n    for elem in dictList_degradation_shutter3[j][i]:\n        dictList_degradation_shutter4[j][i].extend(elem.strip().split(\'\\t\'))\n    #print dictList_degradation_shutter2[j][i]\n\n\nlib_xaxis2 = ()\nlib_yaxis2 = ()\nlib_yaxis3 = ()\nlib_yaxis_abs2 = ()\nlib_yaxis_abs3 = ()\nlib_error2 = ()\nlib_error3 = ()\n\nfor a in xrange(0,len(siriusrunningList2),2):\n    j = siriusrunningList2[a+1]\n    i = siriusrunningList2[a]\n    #print i,j\n    #print i\n    #print dictList_single_vm[i]\n    #print dictList_degradation_colocation[j][i]\n    #print dictList_degradation_shutter2[j][i]\n    denominator1 = sum(float(n) for (m,n) in enumerate(dictList_single_vm[i]) if m!=0 and m!=len(dictList_single_vm[i])-1)/(len(dictList_single_vm[i])-2)\n    numerator1 = sum(float(n) for (m,n) in enumerate(dictList_degradation_colocation[j][i]))/(len(dictList_degradation_colocation[j][i]))\n    shutter_temp_list = []\n    shutter_temp_list2 = []\n    colo_temp_list = []\n    colo_temp_list2 = []\n    degradation_temp_list = []\n    degradation_temp_list2 = []\n    error_temp_list = []\n    error_temp_list2 = []\n    #print numerator1\n    #print denominator1\n    for (count,item) in enumerate(dictList_degradation_shutter2[j][i]):\n        if count%2==0:\n            colo_temp_list.append(item)\n        if count%2==1:\n            shutter_temp_list.append(item)\n\n    for (count,item) in enumerate(dictList_degradation_shutter4[j][i]):\n        if count%2==0:\n            colo_temp_list2.append(item)\n        if count%2==1:\n            shutter_temp_list2.append(item)\n\n    for (count,item) in enumerate(shutter_temp_list):\n        degradation_temp_list.append(abs((((float(shutter_temp_list[count])/float(colo_temp_list[count]))-(numerator1/denominator1))/(float(shutter_temp_list[count])/float(colo_temp_list[count])))*100))\n\n    shutter_temp_list.sort()\n    shutter_temp_list2.sort()\n    colo_temp_list.sort()\n    colo_temp_list2.sort()\n    #print shutter_temp_list\n    #print colo_temp_list\n    #print dictList_degradation_shutter2[j][i]\n    denominator2 = sum(float(n) for (m,n) in enumerate(shutter_temp_list) if m!=0 and m!=len(dictList_single_vm[i])-1)/(len(dictList_single_vm[i])-2)/len(shutter_temp_list)\n    numerator2 = sum(float(n) for (m,n) in enumerate(colo_temp_list) if m!=0 and m!=len(dictList_single_vm[i])-1)/(len(dictList_single_vm[i])-2 )/len(colo_temp_list)\n    for (m,n) in enumerate(shutter_temp_list):\n        ratio=float(n)/float(colo_temp_list[m])\n        error_temp_list.append(abs((((ratio)-(numerator1/denominator1))/(numerator1/denominator1))*100))\n    plot_degradation_error[j][i]=np.std(error_temp_list)\n\n    denominator3 = sum(float(n) for (m,n) in enumerate(shutter_temp_list2))/(len(shutter_temp_list2))\n    numerator3 = sum(float(n) for (m,n) in enumerate(colo_temp_list2))/(len(colo_temp_list2))\n    for (m,n) in enumerate(shutter_temp_list2):\n        ratio=float(n)/float(colo_temp_list2[m])\n        error_temp_list2.append(abs((((ratio)-(numerator3/denominator3))/(numerator1/denominator1))*100))\n    plot_degradation_error2[j][i]=np.std(error_temp_list2)\n\n    #print numerator2\n    #print denominator2\n    del shutter_temp_list\n    del colo_temp_list\n    del degradation_temp_list\n    del shutter_temp_list2\n    del colo_temp_list2\n    del degradation_temp_list2\n    plot_degradation[j][i] = (((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100\n    plot_degradation_abs[j][i] = abs((((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100)\n    plot_degradation2[j][i] = (((numerator3/denominator3)-(numerator1/denominator1))/(numerator1/denominator1))*100\n    plot_degradation_abs2[j][i] = abs((((numerator3/denominator3)-(numerator1/denominator1))/(numerator1/denominator1))*100)\n    #print j,i,plot_degradation[j][i]\n    #print plot_degradation_error[j][i]\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    lib_xaxis2 = lib_xaxis2 + (i,)\n    lib_yaxis2 = lib_yaxis2 + (plot_degradation[j][i],)\n    lib_yaxis3 = lib_yaxis3 + (plot_degradation2[j][i],)\n    lib_yaxis_abs2 = lib_yaxis_abs2 + (plot_degradation_abs[j][i],)\n    lib_yaxis_abs3 = lib_yaxis_abs3 + (plot_degradation_abs2[j][i],)\n    lib_error2 = lib_error2 + (plot_degradation_error[j][i],)\n    lib_error3 = lib_error3 + (plot_degradation_error2[j][i],)\n    #print numerator2,denominator2,numerator2/denominator2\n    #print denominator2/numerator2\n    #print j,i,plot_degradation[j][i],plot_degradation2[j][i]\n            #print (((numerator2/denominator2)-(numerator1/denominator1))/(numerator2/denominator2))*100\n#print np.mean(yaxis2)\n\n\n############### MCF STARTING #######################\nbenchListBaseline = [ \'gcc\', \'perlbench\', \'leslie3d\', \'povray\', \'libquantum\', \'astar\', \'bzip2\', \'milc\', \'namd\', \'calculix\', \'h264ref\', \'sphinx3\', \'zeusmp\', \'gobmk\', \'hmmer\', \'tonto\', \'bwaves\', \'gromacs\', \'dealII\', \'sjeng\', \'lbm\', \'xalancbmk\', \'gamess\', \'cactusADM\', \'soplex\', \'GemsFDTD\', \'omnetpp\', \'mcf\' ]\nbenchListExperiments = [ \'gcc\', \'perlbench\', \'leslie3d\', \'povray\', \'libquantum\', \'astar\', \'bzip2\', \'milc\', \'namd\', \'calculix\', \'h264ref\', \'sphinx3\', \'zeusmp\', \'gobmk\', \'hmmer\', \'tonto\', \'bwaves\', \'gromacs\', \'dealII\', \'sjeng\', \'lbm\', \'xalancbmk\', \'gamess\', \'cactusADM\', \'soplex\', \'GemsFDTD\', \'omnetpp\', \'mcf\' ]\ncolocationListBaseline = [ \'colocating with lbm\', \'colocating with povray\', \'colocating with astar\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with mcf\' ]\ncolocationListExperiments = [ \'colocating with lbm\', \'colocating with povray\', \'colocating with perlbench\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with mcf\' ]\n\nrunningList2 = [  \'perlbench\', \'colocating with mcf\', \'mcf\', \'colocating with mcf\', \'leslie3d\', \'colocating with mcf\', \'povray\', \'colocating with mcf\', \'libquantum\', \'colocating with mcf\', \'astar\', \'colocating with mcf\', \'bzip2\', \'colocating with mcf\', \'milc\', \'colocating with mcf\', \'namd\', \'colocating with mcf\', \'calculix\', \'colocating with mcf\', \'h264ref\', \'colocating with mcf\', \'gobmk\', \'colocating with mcf\', \'hmmer\', \'colocating with mcf\', \'tonto\', \'colocating with mcf\', \'sphinx3\', \'colocating with mcf\', \'zeusmp\', \'colocating with mcf\', \'bwaves\', \'colocating with mcf\', \'gromacs\', \'colocating with mcf\', \'dealII\', \'colocating with mcf\', \'sjeng\', \'colocating with mcf\', \'lbm\', \'colocating with mcf\', \'xalancbmk\', \'colocating with mcf\', \'gamess\', \'colocating with mcf\', \'cactusADM\', \'colocating with mcf\', \'soplex\', \'colocating with mcf\', \'GemsFDTD\', \'colocating with mcf\', \'omnetpp\', \'colocating with mcf\' ]\nsiriusbenchListBaseline = [ \'gmm\', \'dnn_asr\', \'surf-fe\', \'surf-fd\', \'stem\', \'regex\', \'crf\', \'img-imc\', \'img-dig\', \'img-face\', \'nlp-pos\', \'nlp-chk\', \'nlp-ner\']\nsiriusbenchListExperiments = [ \'gmm\', \'dnn_asr\', \'surf-fe\', \'surf-fd\', \'stem\', \'regex\', \'crf\', \'img-imc\', \'img-dig\', \'img-face\', \'nlp-pos\', \'nlp-chk\', \'nlp-ner\']\nsiriuscolocationListBaseline = [ \'colocating with lbm\', \'colocating with povray\', \'colocating with astar\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with mcf\' ]\nsiriuscolocationListExperiments = [ \'colocating with lbm\', \'colocating with povray\', \'colocating with perlbench\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with mcf\' ]\nsiriusrunningList2 = [ \'gmm\', \'colocating with mcf\', \'dnn_asr\', \'colocating with mcf\', \'surf-fe\', \'colocating with mcf\', \'surf-fd\', \'colocating with mcf\', \'stem\', \'colocating with mcf\', \'regex\', \'colocating with mcf\', \'crf\', \'colocating with mcf\', \'img-imc\', \'colocating with mcf\', \'img-dig\', \'colocating with mcf\', \'img-face\', \'colocating with mcf\', \'nlp-pos\', \'colocating with mcf\', \'nlp-chk\', \'colocating with mcf\', \'nlp-ner\' , \'colocating with mcf\']\n\ndef autolabel(rects):\n    # attach some text labels\n    for rect in rects:\n        height = rect.get_height()\n        plt.text(rect.get_x()+rect.get_width()/2., 1.05*height, \'%.2f\'%float(height))\n\ndef autolabel2(rects):\n    # attach some text labels\n    for rect in rects:\n        height = rect.get_height()\n        plt.text(rect.get_x()+rect.get_width()/2., 1.05*height, \'%.2f\'%float(height))\n\ndef add_line(ax, xpos, ypos):\n    line = plt.Line2D([xpos, xpos], [ypos + .1, ypos - .5], transform=ax.transAxes, linewidth=2, color=\'black\')\n    line.set_clip_on(False)\n    ax.add_line(line)\n\n\nfilename = \'shutter_cpi_70\'\n\nfList3= [s.strip() for s in open(\'../../papergraphs/accuracy/mcfcorunner/priorwork/shutter_cpi_5.txt\').readlines()]\n\nfList4 = [s.strip() for s in open(\'../../papergraphs/accuracy/mcfcorunner/singlevm/shutter_cpi_1000.txt\').readlines()]\nfList5 = [s.strip() for s in open(\'../../papergraphs/accuracy/mcfcorunner/degradation/shutter_cpi_1000.txt\').readlines()]\nfList6 = [s.strip() for s in open(\'../../papergraphs/accuracy/mcfcorunner/snapshot/%s.txt\' % filename).readlines()]\n\n\nfList8= [s.strip() for s in open(\'../../papergraphs/accuracy/mcfcorunner/siriusdjinn/priorwork/shutter_cpi_4.txt\').readlines()]\n\nfList9 = [s.strip() for s in open(\'../../papergraphs/accuracy/mcfcorunner/siriusdjinn/singlevm/shutter_cpi_1000.txt\').readlines()]\nfList10 = [s.strip() for s in open(\'../../papergraphs/accuracy/mcfcorunner/siriusdjinn/degradation/shutter_cpi_1000.txt\').readlines()]\nfList11 = [s.strip() for s in open(\'../../papergraphs/accuracy/mcfcorunner/siriusdjinn/snapshot/shutter_cpi_75.txt\').readlines()]\n\ndictList_single_vm = defaultdict(list)\ndictList_degradation_colocation = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter2 = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter3 = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter4 = defaultdict(lambda  : defaultdict(list))\nplot_degradation = defaultdict(dict)\nplot_degradation2 = defaultdict(dict)\nplot_degradation_error = defaultdict(dict)\nplot_degradation_error2 = defaultdict(dict)\nplot_degradation_abs = defaultdict(dict)\nplot_degradation_abs2 = defaultdict(dict)\n\nfor (b,a) in enumerate(fList4):\n    if a in benchListBaseline:\n        dictList_single_vm[a].append(fList4[b+1])\n\n#SORTING LIST CONTAING VALUES OF SINGLE SPEC RUNS INSIDE VMs\nfor i in benchListBaseline:\n    dictList_single_vm[i].sort()\n    #print i,dictList_single_vm[i]\n\nfor (b,a) in enumerate(fList5):\n    #print a\n    if a in colocationListBaseline:\n       #print a\n       index = a\n    else:\n        if a in benchListExperiments:\n            #print a\n            dictList_degradation_colocation[index][a].append(fList5[b+1])\n\n#sorting the ground truth values\nfor a in xrange(0,len(runningList2),2):\n    j = runningList2[a+1]\n    i = runningList2[a]\n    dictList_degradation_colocation[j][i].sort()\n    #print j,i,dictList_degradation_colocation[j][i]\n\n\n#APPENDING DEGRADATION SHUTTER\nfor (b,a) in enumerate(fList6):\n    if a in colocationListExperiments:\n        index = a\n    else:\n        if a in benchListExperiments:\n            dictList_degradation_shutter[index][a].append(fList6[b+1])\n\nfor (b,a) in enumerate(fList3):\n    if a in colocationListExperiments:\n        index = a\n    else:\n        if a in benchListExperiments:\n            dictList_degradation_shutter3[index][a].append(fList3[b+1])\n\nfor a in xrange(0,len(runningList2),2):\n    j = runningList2[a+1]\n    i = runningList2[a]\n    #print i,j,dictList_degradation_shutter[j][i]\n#APPENDING DEGRADATION SHUTTER2 as shutter and colocation values are tab separated\nfor a in xrange(0,len(runningList2),2):\n    j = runningList2[a+1]\n    i = runningList2[a]\n    for elem in dictList_degradation_shutter[j][i]:\n        dictList_degradation_shutter2[j][i].extend(elem.strip().split(\'\\t\'))\n\n    for elem in dictList_degradation_shutter3[j][i]:\n        dictList_degradation_shutter4[j][i].extend(elem.strip().split(\'\\t\'))\n    #print dictList_degradation_shutter2[j][i]\n\nspecmcf_yaxis2 = ()\nspecmcf_yaxis3 = ()\nspecmcf_yaxis_abs2 = ()\nspecmcf_yaxis_abs3 = ()\nspecmcf_error2 = ()\nspecmcf_error3 = ()\nspecmcf_xaxis2 = ()\nfor a in xrange(0,len(runningList2),2):\n    j = runningList2[a+1]\n    i = runningList2[a]\n    #print i,j\n    #print dictList_single_vm[i]\n    #print dictList_degradation_colocation[j][i]\n    #print dictList_degradation_shutter2[j][i]\n    denominator1 = sum(float(n) for (m,n) in enumerate(dictList_single_vm[i]) if m!=0 and m!=len(dictList_single_vm[i])-1)/(len(dictList_single_vm[i])-2)\n    numerator1 = sum(float(n) for (m,n) in enumerate(dictList_degradation_colocation[j][i]))/(len(dictList_degradation_colocation[j][i]))\n    shutter_temp_list = []\n    shutter_temp_list2 = []\n    colo_temp_list = []\n    colo_temp_list2 = []\n    degradation_temp_list = []\n    degradation_temp_list2 = []\n    error_temp_list = []\n    error_temp_list2 = []\n    #print numerator1\n    #print denominator1\n    for (count,item) in enumerate(dictList_degradation_shutter2[j][i]):\n        if count%2==0:\n            colo_temp_list.append(item)\n        if count%2==1:\n            shutter_temp_list.append(item)\n\n    for (count,item) in enumerate(dictList_degradation_shutter4[j][i]):\n        if count%2==0:\n            colo_temp_list2.append(item)\n        if count%2==1:\n            shutter_temp_list2.append(item)\n\n    for (count,item) in enumerate(shutter_temp_list):\n        degradation_temp_list.append(abs((((float(shutter_temp_list[count])/float(colo_temp_list[count]))-(numerator1/denominator1))/(float(shutter_temp_list[count])/float(colo_temp_list[count])))*100))\n\n    shutter_temp_list.sort()\n    shutter_temp_list2.sort()\n    colo_temp_list.sort()\n    colo_temp_list2.sort()\n    #print shutter_temp_list\n    #print colo_temp_list\n    #print dictList_degradation_shutter2[j][i]\n    denominator2 = sum(float(n) for (m,n) in enumerate(shutter_temp_list) if m!=0 and m!=len(shutter_temp_list)-1)/(len(shutter_temp_list)-2)\n    numerator2 = sum(float(n) for (m,n) in enumerate(colo_temp_list) if m!=0 and m!=len(colo_temp_list)-1)/(len(colo_temp_list)-2)\n    #denominator2 = sum(float(n) for (m,n) in enumerate(shutter_temp_list))/len(shutter_temp_list)\n    #numerator2 = sum(float(n) for (m,n) in enumerate(colo_temp_list))/len(colo_temp_list)\n    for (m,n) in enumerate(shutter_temp_list):\n        ratio=float(n)/float(colo_temp_list[m])\n        error_temp_list.append(abs((((ratio)-(numerator1/denominator1))/(numerator1/denominator1))*100))\n    plot_degradation_error[j][i]=np.std(error_temp_list)\n\n    denominator3 = sum(float(n) for (m,n) in enumerate(shutter_temp_list2))/(len(shutter_temp_list2))\n    numerator3 = sum(float(n) for (m,n) in enumerate(colo_temp_list2))/(len(colo_temp_list2))\n    for (m,n) in enumerate(shutter_temp_list2):\n        ratio=float(n)/float(colo_temp_list2[m])\n        error_temp_list2.append(abs((((ratio)-(numerator3/denominator3))/(numerator1/denominator1))*100))\n    plot_degradation_error2[j][i]=np.std(error_temp_list2)\n\n    #print numerator2\n    #print denominator2\n    del shutter_temp_list\n    del colo_temp_list\n    del degradation_temp_list\n    del shutter_temp_list2\n    del colo_temp_list2\n    del degradation_temp_list2\n    plot_degradation[j][i] = (((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100\n    plot_degradation_abs[j][i] = abs((((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100)\n    plot_degradation2[j][i] = (((numerator3/denominator3)-(numerator1/denominator1))/(numerator1/denominator1))*100\n    plot_degradation_abs2[j][i] = abs((((numerator3/denominator3)-(numerator1/denominator1))/(numerator1/denominator1))*100)\n    #print j,i,plot_degradation[j][i]\n    #print plot_degradation_error[j][i]\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    specmcf_xaxis2 = specmcf_xaxis2 + (i,)\n    specmcf_yaxis2 = specmcf_yaxis2 + (plot_degradation[j][i],)\n    specmcf_yaxis3 = specmcf_yaxis3 + (plot_degradation2[j][i],)\n    specmcf_yaxis_abs2 = specmcf_yaxis_abs2 + (plot_degradation_abs[j][i],)\n    specmcf_yaxis_abs3 = specmcf_yaxis_abs3 + (plot_degradation_abs2[j][i],)\n    specmcf_error2 = specmcf_error2 + (plot_degradation_error[j][i],)\n    specmcf_error3 = specmcf_error3 + (plot_degradation_error2[j][i],)\n\n\n#width=0.25\n#x = np.arange(len(yaxis2))\n#fig = plt.figure(figsize=(28, 5))\n##bar1 = plt.bar( x, yaxis, width, color="r", label=\'colocating with libquatum (avg = %.2f)\' %(np.mean(yaxis_abs)))\n#bar1 = plt.bar( x, yaxis_abs3, width, color="k", yerr=error3, label=\'Shuttering (mean: %.2f)\' %(np.mean(yaxis_abs3)))\n#bar2 = plt.bar( x+width, yaxis_abs2, width, color="lightgrey", yerr=error2, label=\'Snapshot (mean: %.2f)\' %(np.mean(yaxis_abs2)))\n##bar3 = plt.bar( x+width+width, yaxis3, width, color="g", label=\'colocating with sphinx  (avg = %.2f)\' %(np.mean(yaxis_abs3)))\n##autolabel(bar1)\n##autolabel(bar2)\n#plt.ylabel( \'Estimation error(%)\' ,fontsize=\'25\')\n##plt.title(\'Error in predicting degradation when co-locating with mcf\')\n#plt.xticks(x + width/2.0, xaxis2, rotation=\'30\', size=\'23\',  ha=\'center\', va=\'top\')\n#plt.yticks(np.arange(0,50,10),size=\'25\')\n#plt.ylim(0,40)\n#plt.xlim(-1,27)\n#plt.grid()\n#plt.tight_layout()\n#plt.legend(loc=9, ncol=2, prop={\'size\':28})\n##plt.savefig(\'%s_maybefinal_error.png\' %(filename), dpi=125)\n\ndel dictList_single_vm\ndel dictList_degradation_colocation\ndel dictList_degradation_shutter\ndel dictList_degradation_shutter2\ndel dictList_degradation_shutter3\ndel dictList_degradation_shutter4\ndel plot_degradation\ndel plot_degradation2\ndel plot_degradation_error\ndel plot_degradation_error2\ndel plot_degradation_abs\ndel plot_degradation_abs2\n\ndictList_single_vm = defaultdict(list)\ndictList_degradation_colocation = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter2 = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter3 = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter4 = defaultdict(lambda  : defaultdict(list))\nplot_degradation = defaultdict(dict)\nplot_degradation2 = defaultdict(dict)\nplot_degradation_error = defaultdict(dict)\nplot_degradation_error2 = defaultdict(dict)\nplot_degradation_abs = defaultdict(dict)\nplot_degradation_abs2 = defaultdict(dict)\n\nfor (b,a) in enumerate(fList9):\n    if a in siriusbenchListBaseline:\n        dictList_single_vm[a].append(fList9[b+1])\n\n#SORTING LIST CONTAING VALUES OF SINGLE SPEC RUNS INSIDE VMs\nfor i in siriusbenchListBaseline:\n    dictList_single_vm[i].sort()\n    #print i,dictList_single_vm[i]\n\nfor (b,a) in enumerate(fList10):\n    #print a\n    if a in siriuscolocationListBaseline:\n       #print a\n       index = a\n    else:\n        if a in siriusbenchListExperiments:\n            #print a\n            dictList_degradation_colocation[index][a].append(fList10[b+1])\n\n#sorting the ground truth values\nfor a in xrange(0,len(siriusrunningList2),2):\n    j = siriusrunningList2[a+1]\n    i = siriusrunningList2[a]\n    #print i,j\n    dictList_degradation_colocation[j][i].sort()\n    #print j,i,dictList_degradation_colocation[j][i]\n\n#for a in xrange(0,len(runningList),2):\n#    j = runningList[a+1]\n#    i = runningList[a]\n#    numerator1 = sum(float(n) for (m,n) in enumerate(dictList_degradation_colocation[j][i]) if m!=0 and m!=len(dictList_degradation_colocation[j][i])-1)/(len(dictList_degradation_colocation[j][i])-2)\n#    print numerator1\n#    #print dictList_degradation_colocation[runningList[a+1]][runningList[a]]\n#    #print numerator1\n\n#APPENDING DEGRADATION SHUTTER\nfor (b,a) in enumerate(fList11):\n    #print a\n    if a in siriuscolocationListExperiments:\n        index = a\n    else:\n        if a in siriusbenchListExperiments:\n            dictList_degradation_shutter[index][a].append(fList11[b+1])\n\nfor (b,a) in enumerate(fList8):\n    if a in siriuscolocationListExperiments:\n        index = a\n    else:\n        if a in siriusbenchListExperiments:\n            dictList_degradation_shutter3[index][a].append(fList8[b+1])\n\nfor a in xrange(0,len(siriusrunningList2),2):\n    j = siriusrunningList2[a+1]\n    i = siriusrunningList2[a]\n    #print i,j,dictList_degradation_shutter[j][i]\n#APPENDING DEGRADATION SHUTTER2 as shutter and colocation values are tab separated\nfor a in xrange(0,len(siriusrunningList2),2):\n    j = siriusrunningList2[a+1]\n    i = siriusrunningList2[a]\n    for elem in dictList_degradation_shutter[j][i]:\n        dictList_degradation_shutter2[j][i].extend(elem.strip().split(\'\\t\'))\n\n    for elem in dictList_degradation_shutter3[j][i]:\n        dictList_degradation_shutter4[j][i].extend(elem.strip().split(\'\\t\'))\n    #print dictList_degradation_shutter2[j][i]\n\nmcf_xaxis2 = ()\nmcf_yaxis2 = ()\nmcf_yaxis3 = ()\nmcf_yaxis_abs2 = ()\nmcf_yaxis_abs3 = ()\nmcf_error2 = ()\nmcf_error3 = ()\nfor a in xrange(0,len(siriusrunningList2),2):\n    j = siriusrunningList2[a+1]\n    i = siriusrunningList2[a]\n    #print i,j\n    #print i\n    #print dictList_single_vm[i]\n    #print dictList_degradation_colocation[j][i]\n    #print dictList_degradation_shutter2[j][i]\n    denominator1 = sum(float(n) for (m,n) in enumerate(dictList_single_vm[i]) if m!=0 and m!=len(dictList_single_vm[i])-1)/(len(dictList_single_vm[i])-2)\n    numerator1 = sum(float(n) for (m,n) in enumerate(dictList_degradation_colocation[j][i]))/(len(dictList_degradation_colocation[j][i]))\n    shutter_temp_list = []\n    shutter_temp_list2 = []\n    colo_temp_list = []\n    colo_temp_list2 = []\n    degradation_temp_list = []\n    degradation_temp_list2 = []\n    error_temp_list = []\n    error_temp_list2 = []\n    #print numerator1\n    #print denominator1\n    for (count,item) in enumerate(dictList_degradation_shutter2[j][i]):\n        if count%2==0:\n            colo_temp_list.append(item)\n        if count%2==1:\n            shutter_temp_list.append(item)\n\n    for (count,item) in enumerate(dictList_degradation_shutter4[j][i]):\n        if count%2==0:\n            colo_temp_list2.append(item)\n        if count%2==1:\n            shutter_temp_list2.append(item)\n\n    for (count,item) in enumerate(shutter_temp_list):\n        degradation_temp_list.append(abs((((float(shutter_temp_list[count])/float(colo_temp_list[count]))-(numerator1/denominator1))/(float(shutter_temp_list[count])/float(colo_temp_list[count])))*100))\n\n    shutter_temp_list.sort()\n    shutter_temp_list2.sort()\n    colo_temp_list.sort()\n    colo_temp_list2.sort()\n    #print shutter_temp_list\n    #print colo_temp_list\n    #print dictList_degradation_shutter2[j][i]\n    denominator2 = sum(float(n) for (m,n) in enumerate(shutter_temp_list) if m!=0 and m!=len(dictList_single_vm[i])-1)/(len(dictList_single_vm[i])-2)/len(shutter_temp_list)\n    numerator2 = sum(float(n) for (m,n) in enumerate(colo_temp_list) if m!=0 and m!=len(dictList_single_vm[i])-1)/(len(dictList_single_vm[i])-2 )/len(colo_temp_list)\n    for (m,n) in enumerate(shutter_temp_list):\n        ratio=float(n)/float(colo_temp_list[m])\n        error_temp_list.append(abs((((ratio)-(numerator1/denominator1))/(numerator1/denominator1))*100))\n    plot_degradation_error[j][i]=np.std(error_temp_list)\n\n    denominator3 = sum(float(n) for (m,n) in enumerate(shutter_temp_list2))/(len(shutter_temp_list2))\n    numerator3 = sum(float(n) for (m,n) in enumerate(colo_temp_list2))/(len(colo_temp_list2))\n    for (m,n) in enumerate(shutter_temp_list2):\n        ratio=float(n)/float(colo_temp_list2[m])\n        error_temp_list2.append(abs((((ratio)-(numerator3/denominator3))/(numerator1/denominator1))*100))\n    plot_degradation_error2[j][i]=np.std(error_temp_list2)\n\n    #print numerator2\n    #print denominator2\n    del shutter_temp_list\n    del colo_temp_list\n    del degradation_temp_list\n    del shutter_temp_list2\n    del colo_temp_list2\n    del degradation_temp_list2\n    plot_degradation[j][i] = (((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100\n    plot_degradation_abs[j][i] = abs((((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100)\n    plot_degradation2[j][i] = (((numerator3/denominator3)-(numerator1/denominator1))/(numerator1/denominator1))*100\n    plot_degradation_abs2[j][i] = abs((((numerator3/denominator3)-(numerator1/denominator1))/(numerator1/denominator1))*100)\n    #print j,i,plot_degradation[j][i]\n    #print plot_degradation_error[j][i]\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    mcf_xaxis2 = mcf_xaxis2 + (i,)\n    mcf_yaxis2 = mcf_yaxis2 + (plot_degradation[j][i],)\n    mcf_yaxis3 = mcf_yaxis3 + (plot_degradation2[j][i],)\n    mcf_yaxis_abs2 = mcf_yaxis_abs2 + (plot_degradation_abs[j][i],)\n    mcf_yaxis_abs3 = mcf_yaxis_abs3 + (plot_degradation_abs2[j][i],)\n    mcf_error2 = mcf_error2 + (plot_degradation_error[j][i],)\n    mcf_error3 = mcf_error3 + (plot_degradation_error2[j][i],)\n    #print numerator2,denominator2,numerator2/denominator2\n    #print denominator2/numerator2\n    print j,i,plot_degradation[j][i],plot_degradation2[j][i]\n            #print (((numerator2/denominator2)-(numerator1/denominator1))/(numerator2/denominator2))*100\n#print np.mean(yaxis2)\n\nbenchListBaseline = [ \'gcc\', \'perlbench\', \'leslie3d\', \'povray\', \'libquantum\', \'astar\', \'bzip2\', \'milc\', \'namd\', \'calculix\', \'h264ref\', \'sphinx3\', \'zeusmp\', \'gobmk\', \'hmmer\', \'tonto\', \'bwaves\', \'gromacs\', \'dealII\', \'sjeng\', \'lbm\', \'xalancbmk\', \'gamess\', \'cactusADM\', \'soplex\', \'GemsFDTD\', \'omnetpp\', \'mcf\' ]\nbenchListExperiments = [ \'gcc\', \'perlbench\', \'leslie3d\', \'povray\', \'libquantum\', \'astar\', \'bzip2\', \'milc\', \'namd\', \'calculix\', \'h264ref\', \'sphinx3\', \'zeusmp\', \'gobmk\', \'hmmer\', \'tonto\', \'bwaves\', \'gromacs\', \'dealII\', \'sjeng\', \'lbm\', \'xalancbmk\', \'gamess\', \'cactusADM\', \'soplex\', \'GemsFDTD\', \'omnetpp\', \'mcf\' ]\ncolocationListBaseline = [ \'colocating with lbm\', \'colocating with povray\', \'colocating with milc\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with mcf\' ]\ncolocationListExperiments = [ \'colocating with lbm\', \'colocating with povray\', \'colocating with milc\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with mcf\' ]\n\nrunningList2 = [  \'perlbench\', \'colocating with milc\', \'mcf\', \'colocating with milc\', \'leslie3d\', \'colocating with milc\', \'povray\', \'colocating with milc\', \'libquantum\', \'colocating with milc\', \'astar\', \'colocating with milc\', \'bzip2\', \'colocating with milc\', \'milc\', \'colocating with milc\', \'namd\', \'colocating with milc\', \'calculix\', \'colocating with milc\', \'h264ref\', \'colocating with milc\', \'gobmk\', \'colocating with milc\', \'hmmer\', \'colocating with milc\', \'tonto\', \'colocating with milc\', \'sphinx3\', \'colocating with milc\', \'zeusmp\', \'colocating with milc\', \'bwaves\', \'colocating with milc\', \'gromacs\', \'colocating with milc\', \'dealII\', \'colocating with milc\', \'sjeng\', \'colocating with milc\', \'lbm\', \'colocating with milc\', \'xalancbmk\', \'colocating with milc\', \'gamess\', \'colocating with milc\', \'cactusADM\', \'colocating with milc\', \'soplex\', \'colocating with milc\', \'GemsFDTD\', \'colocating with milc\', \'omnetpp\', \'colocating with milc\' ]\n\nsiriusbenchListBaseline = [ \'gmm\', \'dnn_asr\', \'surf-fe\', \'surf-fd\', \'stem\', \'regex\', \'crf\', \'img-imc\', \'img-dig\', \'img-face\', \'nlp-pos\', \'nlp-chk\', \'nlp-ner\']\nsiriusbenchListExperiments = [ \'gmm\', \'dnn_asr\', \'surf-fe\', \'surf-fd\', \'stem\', \'regex\', \'crf\', \'img-imc\', \'img-dig\', \'img-face\', \'nlp-pos\', \'nlp-chk\', \'nlp-ner\']\nsiriuscolocationListBaseline = [ \'colocating with lbm\', \'colocating with povray\', \'colocating with astar\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with mcf\' ]\nsiriuscolocationListExperiments = [ \'colocating with lbm\', \'colocating with povray\', \'colocating with perlbench\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with mcf\' ]\nsiriusrunningList2 = [ \'gmm\', \'colocating with milc\', \'dnn_asr\', \'colocating with milc\', \'surf-fe\', \'colocating with milc\', \'surf-fd\', \'colocating with milc\', \'stem\', \'colocating with milc\', \'regex\', \'colocating with milc\', \'crf\', \'colocating with milc\', \'img-imc\', \'colocating with milc\', \'img-dig\', \'colocating with milc\', \'img-face\', \'colocating with milc\', \'nlp-pos\', \'colocating with milc\', \'nlp-chk\', \'colocating with milc\', \'nlp-ner\' , \'colocating with milc\']\n\n\ndef autolabel(rects):\n    # attach some text labels\n    for rect in rects:\n        height = rect.get_height()\n        plt.text(rect.get_x()+rect.get_width()/2., 1.05*height, \'%.2f\'%float(height))\n\ndef autolabel2(rects):\n    # attach some text labels\n    for rect in rects:\n        height = rect.get_height()\n        plt.text(rect.get_x()+rect.get_width()/2., 1.05*height, \'%.2f\'%float(height))\n\ndef add_line(ax, xpos, ypos):\n    line = plt.Line2D([xpos, xpos], [ypos + .1, ypos - .5], transform=ax.transAxes, linewidth=2, color=\'black\')\n    line.set_clip_on(False)\n    ax.add_line(line)\n\n\nfilename = \'shutter_cpi_70\'\n#fList = [s.strip() for s in open(\'../../papergraphs/2.fullspec/accuracy/libquantumcorunner/single_vm_ground_truth/shutter_cpi_1000.txt\').readlines()]\n#fList2 = [s.strip() for s in open(\'../../papergraphs/2.fullspec/accuracy/libquantumcorunner/degradation_ground_truth/shutter_cpi_1000.txt\').readlines()]\n#fList3 = [s.strip() for s in open(\'../../papergraphs/2.fullspec/accuracy/libquantumcorunner/experiment_1/%s.txt\' % filename).readlines()]\nfList3= [s.strip() for s in open(\'../../papergraphs/accuracy/milccorunner/priorwork/shutter_cpi_5.txt\').readlines()]\n\nfList4 = [s.strip() for s in open(\'../../papergraphs/accuracy/milccorunner/singlevm/shutter_cpi_1000.txt\').readlines()]\nfList5 = [s.strip() for s in open(\'../../papergraphs/accuracy/milccorunner/degradation/shutter_cpi_1000.txt\').readlines()]\nfList6 = [s.strip() for s in open(\'../../papergraphs/accuracy/milccorunner/snapshot/%s.txt\' % filename).readlines()]\n\nfList8= [s.strip() for s in open(\'../../papergraphs/accuracy/milccorunner/siriusdjinn/priorwork/shutter_cpi_4.txt\').readlines()]\n\nfList9 = [s.strip() for s in open(\'../../papergraphs/accuracy/libquantumcorunner/siriusdjinn/singlevm/shutter_cpi_1000.txt\').readlines()]\nfList10 = [s.strip() for s in open(\'../../papergraphs/accuracy/milccorunner/siriusdjinn/degradation/shutter_cpi_1000.txt\').readlines()]\nfList11 = [s.strip() for s in open(\'../../papergraphs/accuracy/milccorunner/siriusdjinn/snapshot/shutter_cpi_75.txt\').readlines()]\n\n\ndictList_single_vm = defaultdict(list)\ndictList_degradation_colocation = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter2 = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter3 = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter4 = defaultdict(lambda  : defaultdict(list))\nplot_degradation = defaultdict(dict)\nplot_degradation2 = defaultdict(dict)\nplot_degradation_error = defaultdict(dict)\nplot_degradation_error2 = defaultdict(dict)\nplot_degradation_abs = defaultdict(dict)\nplot_degradation_abs2 = defaultdict(dict)\n\nfor (b,a) in enumerate(fList4):\n    if a in benchListBaseline:\n        dictList_single_vm[a].append(fList4[b+1])\n\n#SORTING LIST CONTAING VALUES OF SINGLE SPEC RUNS INSIDE VMs\nfor i in benchListBaseline:\n    dictList_single_vm[i].sort()\n    #print i,dictList_single_vm[i]\n\nfor (b,a) in enumerate(fList5):\n    #print a\n    if a in colocationListBaseline:\n       #print a\n       index = a\n    else:\n        if a in benchListExperiments:\n            #print a\n            dictList_degradation_colocation[index][a].append(fList5[b+1])\n\n#sorting the ground truth values\nfor a in xrange(0,len(runningList2),2):\n    j = runningList2[a+1]\n    i = runningList2[a]\n    dictList_degradation_colocation[j][i].sort()\n    #print j,i,dictList_degradation_colocation[j][i]\n\n\n\n#APPENDING DEGRADATION SHUTTER\nfor (b,a) in enumerate(fList6):\n    if a in colocationListExperiments:\n        index = a\n    else:\n        if a in benchListExperiments:\n            dictList_degradation_shutter[index][a].append(fList6[b+1])\n\nfor (b,a) in enumerate(fList3):\n    if a in colocationListExperiments:\n        index = a\n    else:\n        if a in benchListExperiments:\n            dictList_degradation_shutter3[index][a].append(fList3[b+1])\n\nfor a in xrange(0,len(runningList2),2):\n    j = runningList2[a+1]\n    i = runningList2[a]\n    #print i,j,dictList_degradation_shutter[j][i]\n#APPENDING DEGRADATION SHUTTER2 as shutter and colocation values are tab separated\nfor a in xrange(0,len(runningList2),2):\n    j = runningList2[a+1]\n    i = runningList2[a]\n    for elem in dictList_degradation_shutter[j][i]:\n        dictList_degradation_shutter2[j][i].extend(elem.strip().split(\'\\t\'))\n\n    for elem in dictList_degradation_shutter3[j][i]:\n        dictList_degradation_shutter4[j][i].extend(elem.strip().split(\'\\t\'))\n    #print dictList_degradation_shutter2[j][i]\n\nspecmilc_yaxis2 = ()\nspecmilc_yaxis3 = ()\nspecmilc_yaxis_abs2 = ()\nspecmilc_yaxis_abs3 = ()\nspecmilc_error2 = ()\nspecmilc_error3 = ()\nspecmilc_xaxis2 = ()\nfor a in xrange(0,len(runningList2),2):\n    j = runningList2[a+1]\n    i = runningList2[a]\n    #print i,j\n    #print dictList_single_vm[i]\n    #print dictList_degradation_colocation[j][i]\n    #print dictList_degradation_shutter2[j][i]\n    denominator1 = sum(float(n) for (m,n) in enumerate(dictList_single_vm[i]) if m!=0 and m!=len(dictList_single_vm[i])-1)/(len(dictList_single_vm[i])-2)\n    numerator1 = sum(float(n) for (m,n) in enumerate(dictList_degradation_colocation[j][i]))/(len(dictList_degradation_colocation[j][i]))\n    shutter_temp_list = []\n    shutter_temp_list2 = []\n    colo_temp_list = []\n    colo_temp_list2 = []\n    degradation_temp_list = []\n    degradation_temp_list2 = []\n    error_temp_list = []\n    error_temp_list2 = []\n    #print numerator1\n    #print denominator1\n    for (count,item) in enumerate(dictList_degradation_shutter2[j][i]):\n        if count%2==0:\n            colo_temp_list.append(item)\n        if count%2==1:\n            shutter_temp_list.append(item)\n\n    for (count,item) in enumerate(dictList_degradation_shutter4[j][i]):\n        if count%2==0:\n            colo_temp_list2.append(item)\n        if count%2==1:\n            shutter_temp_list2.append(item)\n\n    for (count,item) in enumerate(shutter_temp_list):\n        degradation_temp_list.append(abs((((float(shutter_temp_list[count])/float(colo_temp_list[count]))-(numerator1/denominator1))/(float(shutter_temp_list[count])/float(colo_temp_list[count])))*100))\n\n    shutter_temp_list.sort()\n    shutter_temp_list2.sort()\n    colo_temp_list.sort()\n    colo_temp_list2.sort()\n    #print shutter_temp_list\n    #print colo_temp_list\n    #print dictList_degradation_shutter2[j][i]\n    denominator2 = sum(float(n) for (m,n) in enumerate(shutter_temp_list) if m!=0 and m!=len(shutter_temp_list)-1)/(len(shutter_temp_list)-2)\n    numerator2 = sum(float(n) for (m,n) in enumerate(colo_temp_list) if m!=0 and m!=len(colo_temp_list)-1)/(len(colo_temp_list)-2)\n    for (m,n) in enumerate(shutter_temp_list):\n        ratio=float(n)/float(colo_temp_list[m])\n        error_temp_list.append(abs((((ratio)-(numerator1/denominator1))/(numerator1/denominator1))*100))\n    plot_degradation_error[j][i]=np.std(error_temp_list)\n\n    denominator3 = sum(float(n) for (m,n) in enumerate(shutter_temp_list2))/(len(shutter_temp_list2))\n    numerator3 = sum(float(n) for (m,n) in enumerate(colo_temp_list2))/(len(colo_temp_list2))\n    for (m,n) in enumerate(shutter_temp_list2):\n        ratio=float(n)/float(colo_temp_list2[m])\n        error_temp_list2.append(abs((((ratio)-(numerator3/denominator3))/(numerator1/denominator1))*100))\n    plot_degradation_error2[j][i]=np.std(error_temp_list2)\n\n    #print numerator2\n    #print denominator2\n    del shutter_temp_list\n    del colo_temp_list\n    del degradation_temp_list\n    del shutter_temp_list2\n    del colo_temp_list2\n    del degradation_temp_list2\n    plot_degradation[j][i] = (((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100\n    plot_degradation_abs[j][i] = abs((((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100)\n    plot_degradation2[j][i] = (((numerator3/denominator3)-(numerator1/denominator1))/(numerator1/denominator1))*100\n    plot_degradation_abs2[j][i] = abs((((numerator3/denominator3)-(numerator1/denominator1))/(numerator1/denominator1))*100)\n    #print j,i,plot_degradation[j][i]\n    #print plot_degradation_error[j][i]\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    specmilc_xaxis2 = specmilc_xaxis2 + (i,)\n    specmilc_yaxis2 = specmilc_yaxis2 + (plot_degradation[j][i],)\n    specmilc_yaxis3 = specmilc_yaxis3 + (plot_degradation2[j][i],)\n    specmilc_yaxis_abs2 = specmilc_yaxis_abs2 + (plot_degradation_abs[j][i],)\n    specmilc_yaxis_abs3 = specmilc_yaxis_abs3 + (plot_degradation_abs2[j][i],)\n    specmilc_error2 = specmilc_error2 + (plot_degradation_error[j][i],)\n    specmilc_error3 = specmilc_error3 + (plot_degradation_error2[j][i],)\n\n\n#width=0.25\n#x = np.arange(len(yaxis2))\n#fig = plt.figure(figsize=(28, 5))\n##bar1 = plt.bar( x, yaxis, width, color="r", label=\'colocating with libquatum (avg = %.2f)\' %(np.mean(yaxis_abs)))\n#bar1 = plt.bar( x, yaxis_abs3, width, color="k", yerr=error3, label=\'Shuttering (mean: %.2f)\' %(np.mean(yaxis_abs3)))\n#bar2 = plt.bar( x+width, yaxis_abs2, width, color="lightgrey", yerr=error2, label=\'Snapshot (mean: %.2f)\' %(np.mean(yaxis_abs2)))\n#\n#plt.ylabel( \'Estimation error (%)\',fontsize=\'25\' )\n##plt.title(\'Error in predicting degradation when co-locating with milc\')\n#plt.xticks(x + width/2.0, xaxis2, rotation=\'30\', size=\'23\',  ha=\'center\', va=\'top\')\n#plt.yticks(np.arange(0,50,10),size=\'25\')\n#plt.ylim(0,50)\n#plt.xlim(-1,27)\n#plt.grid()\n#plt.tight_layout()\n#plt.legend(loc=9, ncol=2, prop={\'size\':28})\n##plt.savefig(\'milc_accuracy.pdf\', dpi=125)\n\ndel dictList_single_vm\ndel dictList_degradation_colocation\ndel dictList_degradation_shutter\ndel dictList_degradation_shutter2\ndel dictList_degradation_shutter3\ndel dictList_degradation_shutter4\ndel plot_degradation\ndel plot_degradation2\ndel plot_degradation_error\ndel plot_degradation_error2\ndel plot_degradation_abs\ndel plot_degradation_abs2\n\ndictList_single_vm = defaultdict(list)\ndictList_degradation_colocation = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter2 = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter3 = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter4 = defaultdict(lambda  : defaultdict(list))\nplot_degradation = defaultdict(dict)\nplot_degradation2 = defaultdict(dict)\nplot_degradation_error = defaultdict(dict)\nplot_degradation_error2 = defaultdict(dict)\nplot_degradation_abs = defaultdict(dict)\nplot_degradation_abs2 = defaultdict(dict)\n\nfor (b,a) in enumerate(fList9):\n    if a in siriusbenchListBaseline:\n        dictList_single_vm[a].append(fList9[b+1])\n\n#SORTING LIST CONTAING VALUES OF SINGLE SPEC RUNS INSIDE VMs\nfor i in siriusbenchListBaseline:\n    dictList_single_vm[i].sort()\n    #print i,dictList_single_vm[i]\n\nfor (b,a) in enumerate(fList10):\n    #print a\n    if a in siriuscolocationListBaseline:\n       #print a\n       index = a\n    else:\n        if a in siriusbenchListExperiments:\n            #print a\n            dictList_degradation_colocation[index][a].append(fList10[b+1])\n\n#sorting the ground truth values\nfor a in xrange(0,len(siriusrunningList2),2):\n    j = siriusrunningList2[a+1]\n    i = siriusrunningList2[a]\n    #print i,j\n    dictList_degradation_colocation[j][i].sort()\n    #print j,i,dictList_degradation_colocation[j][i]\n\n#for a in xrange(0,len(runningList),2):\n#    j = runningList[a+1]\n#    i = runningList[a]\n#    numerator1 = sum(float(n) for (m,n) in enumerate(dictList_degradation_colocation[j][i]) if m!=0 and m!=len(dictList_degradation_colocation[j][i])-1)/(len(dictList_degradation_colocation[j][i])-2)\n#    print numerator1\n#    #print dictList_degradation_colocation[runningList[a+1]][runningList[a]]\n#    #print numerator1\n\n#APPENDING DEGRADATION SHUTTER\nfor (b,a) in enumerate(fList11):\n    #print a\n    if a in siriuscolocationListExperiments:\n        index = a\n    else:\n        if a in siriusbenchListExperiments:\n            dictList_degradation_shutter[index][a].append(fList11[b+1])\n\nfor (b,a) in enumerate(fList8):\n    if a in siriuscolocationListExperiments:\n        index = a\n    else:\n        if a in siriusbenchListExperiments:\n            dictList_degradation_shutter3[index][a].append(fList8[b+1])\n\nfor a in xrange(0,len(siriusrunningList2),2):\n    j = siriusrunningList2[a+1]\n    i = siriusrunningList2[a]\n    #print i,j,dictList_degradation_shutter[j][i]\n#APPENDING DEGRADATION SHUTTER2 as shutter and colocation values are tab separated\nfor a in xrange(0,len(siriusrunningList2),2):\n    j = siriusrunningList2[a+1]\n    i = siriusrunningList2[a]\n    for elem in dictList_degradation_shutter[j][i]:\n        dictList_degradation_shutter2[j][i].extend(elem.strip().split(\'\\t\'))\n\n    for elem in dictList_degradation_shutter3[j][i]:\n        dictList_degradation_shutter4[j][i].extend(elem.strip().split(\'\\t\'))\n    #print dictList_degradation_shutter2[j][i]\n\nmilc_xaxis2 = ()\nmilc_yaxis2 = ()\nmilc_yaxis3 = ()\nmilc_yaxis_abs2 = ()\nmilc_yaxis_abs3 = ()\nmilc_error2 = ()\nmilc_error3 = ()\nfor a in xrange(0,len(siriusrunningList2),2):\n    j = siriusrunningList2[a+1]\n    i = siriusrunningList2[a]\n    print i,j\n    #print i\n    #print dictList_single_vm[i]\n    print dictList_degradation_colocation[j][i]\n    #print dictList_degradation_shutter2[j][i]\n    denominator1 = sum(float(n) for (m,n) in enumerate(dictList_single_vm[i]) if m!=0 and m!=len(dictList_single_vm[i])-1)/(len(dictList_single_vm[i])-2)\n    numerator1 = sum(float(n) for (m,n) in enumerate(dictList_degradation_colocation[j][i]))/(len(dictList_degradation_colocation[j][i]))\n    shutter_temp_list = []\n    shutter_temp_list2 = []\n    colo_temp_list = []\n    colo_temp_list2 = []\n    degradation_temp_list = []\n    degradation_temp_list2 = []\n    error_temp_list = []\n    error_temp_list2 = []\n    #print numerator1\n    #print denominator1\n    for (count,item) in enumerate(dictList_degradation_shutter2[j][i]):\n        if count%2==0:\n            colo_temp_list.append(item)\n        if count%2==1:\n            shutter_temp_list.append(item)\n\n    for (count,item) in enumerate(dictList_degradation_shutter4[j][i]):\n        if count%2==0:\n            colo_temp_list2.append(item)\n        if count%2==1:\n            shutter_temp_list2.append(item)\n\n    for (count,item) in enumerate(shutter_temp_list):\n        degradation_temp_list.append(abs((((float(shutter_temp_list[count])/float(colo_temp_list[count]))-(numerator1/denominator1))/(float(shutter_temp_list[count])/float(colo_temp_list[count])))*100))\n\n    shutter_temp_list.sort()\n    shutter_temp_list2.sort()\n    colo_temp_list.sort()\n    colo_temp_list2.sort()\n    #print shutter_temp_list\n    #print colo_temp_list\n    #print dictList_degradation_shutter2[j][i]\n    denominator2 = sum(float(n) for (m,n) in enumerate(shutter_temp_list) if m!=0 and m!=len(dictList_single_vm[i])-1)/(len(dictList_single_vm[i])-2)/len(shutter_temp_list)\n    numerator2 = sum(float(n) for (m,n) in enumerate(colo_temp_list) if m!=0 and m!=len(dictList_single_vm[i])-1)/(len(dictList_single_vm[i])-2 )/len(colo_temp_list)\n    for (m,n) in enumerate(shutter_temp_list):\n        ratio=float(n)/float(colo_temp_list[m])\n        error_temp_list.append(abs((((ratio)-(numerator1/denominator1))/(numerator1/denominator1))*100))\n    plot_degradation_error[j][i]=np.std(error_temp_list)\n\n    denominator3 = sum(float(n) for (m,n) in enumerate(shutter_temp_list2))/(len(shutter_temp_list2))\n    numerator3 = sum(float(n) for (m,n) in enumerate(colo_temp_list2))/(len(colo_temp_list2))\n    for (m,n) in enumerate(shutter_temp_list2):\n        ratio=float(n)/float(colo_temp_list2[m])\n        error_temp_list2.append(abs((((ratio)-(numerator3/denominator3))/(numerator1/denominator1))*100))\n    plot_degradation_error2[j][i]=np.std(error_temp_list2)\n\n    #print numerator2\n    #print denominator2\n    del shutter_temp_list\n    del colo_temp_list\n    del degradation_temp_list\n    del shutter_temp_list2\n    del colo_temp_list2\n    del degradation_temp_list2\n    plot_degradation[j][i] = (((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100\n    plot_degradation_abs[j][i] = abs((((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100)\n    plot_degradation2[j][i] = (((numerator3/denominator3)-(numerator1/denominator1))/(numerator1/denominator1))*100\n    plot_degradation_abs2[j][i] = abs((((numerator3/denominator3)-(numerator1/denominator1))/(numerator1/denominator1))*100)\n    #print j,i,plot_degradation[j][i]\n    #print plot_degradation_error[j][i]\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    milc_xaxis2 = milc_xaxis2 + (i,)\n    milc_yaxis2 = milc_yaxis2 + (plot_degradation[j][i],)\n    milc_yaxis3 = milc_yaxis3 + (plot_degradation2[j][i],)\n    milc_yaxis_abs2 = milc_yaxis_abs2 + (plot_degradation_abs[j][i],)\n    milc_yaxis_abs3 = milc_yaxis_abs3 + (plot_degradation_abs2[j][i],)\n    milc_error2 = milc_error2 + (plot_degradation_error[j][i],)\n    milc_error3 = milc_error3 + (plot_degradation_error2[j][i],)\n    #print numerator2,denominator2,numerator2/denominator2\n    #print denominator2/numerator2\n    print j,i,plot_degradation[j][i],plot_degradation2[j][i]\n            #print (((numerator2/denominator2)-(numerator1/denominator1))/(numerator2/denominator2))*100\n#print np.mean(yaxis2)\n\nbenchListBaseline = [ \'gcc\', \'perlbench\', \'leslie3d\', \'povray\', \'libquantum\', \'astar\', \'bzip2\', \'milc\', \'namd\', \'calculix\', \'h264ref\', \'sphinx3\', \'zeusmp\', \'gobmk\', \'hmmer\', \'tonto\', \'bwaves\', \'gromacs\', \'dealII\', \'sjeng\', \'lbm\', \'xalancbmk\', \'gamess\', \'cactusADM\', \'soplex\', \'GemsFDTD\', \'omnetpp\', \'mcf\' ]\nbenchListExperiments = [ \'gcc\', \'perlbench\', \'leslie3d\', \'povray\', \'libquantum\', \'astar\', \'bzip2\', \'milc\', \'namd\', \'calculix\', \'h264ref\', \'sphinx3\', \'zeusmp\', \'gobmk\', \'hmmer\', \'tonto\', \'bwaves\', \'gromacs\', \'dealII\', \'sjeng\', \'lbm\', \'xalancbmk\', \'gamess\', \'cactusADM\', \'soplex\', \'GemsFDTD\', \'omnetpp\', \'mcf\' ]\ncolocationListBaseline = [ \'colocating with lbm\', \'colocating with milc\', \'colocating with astar\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with mcf\' ]\ncolocationListExperiments = [ \'colocating with lbm\', \'colocating with milc\', \'colocating with perlbench\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with mcf\' ]\nrunningList = [  \'perlbench\', \'colocating with milc\', \'mcf\', \'colocating with milc\', \'leslie3d\', \'colocating with milc\', \'povray\', \'colocating with milc\', \'libquantum\', \'colocating with milc\', \'astar\', \'colocating with milc\', \'bzip2\', \'colocating with milc\', \'milc\', \'colocating with milc\', \'namd\', \'colocating with milc\', \'calculix\', \'colocating with milc\', \'h264ref\', \'colocating with milc\', \'gobmk\', \'colocating with milc\', \'hmmer\', \'colocating with milc\', \'tonto\', \'colocating with milc\', \'sphinx3\', \'colocating with milc\', \'zeusmp\', \'colocating with milc\', \'bwaves\', \'colocating with milc\', \'gromacs\', \'colocating with milc\', \'dealII\', \'colocating with milc\', \'sjeng\', \'colocating with milc\', \'lbm\', \'colocating with milc\', \'xalancbmk\', \'colocating with milc\', \'gamess\', \'colocating with milc\', \'cactusADM\', \'colocating with milc\', \'soplex\', \'colocating with milc\', \'GemsFDTD\', \'colocating with milc\', \'omnetpp\', \'colocating with milc\' ]\nrunningList2 = [  \'leslie3d\', \'colocating with milc\', \'zeusmp\', \'colocating with milc\', \'milc\', \'colocating with milc\', \'namd\', \'colocating with milc\', \'calculix\', \'colocating with milc\', \'gobmk\', \'colocating with milc\', \'hmmer\', \'colocating with milc\', \'tonto\', \'colocating with milc\', \'sphinx3\', \'colocating with milc\', \'bwaves\', \'colocating with milc\', \'gromacs\', \'colocating with milc\', \'dealII\', \'colocating with milc\', \'sjeng\', \'colocating with milc\', \'gamess\', \'colocating with milc\', \'cactusADM\', \'colocating with milc\', \'soplex\', \'colocating with milc\', \'GemsFDTD\', \'colocating with milc\' ]\nrunningList3 = [  \'perlbench\', \'colocating with milc\', \'mcf\', \'colocating with milc\', \'povray\', \'colocating with milc\', \'libquantum\', \'colocating with milc\', \'astar\', \'colocating with milc\', \'bzip2\', \'colocating with milc\', \'h264ref\', \'colocating with milc\',  \'lbm\', \'colocating with milc\', \'xalancbmk\', \'colocating with milc\', \'omnetpp\', \'colocating with milc\' ]\n\nsiriusbenchListBaseline = [ \'gmm\', \'dnn_asr\', \'surf-fe\', \'surf-fd\', \'stem\', \'regex\', \'crf\', \'img-imc\', \'img-dig\', \'img-face\', \'nlp-pos\', \'nlp-chk\', \'nlp-ner\']\nsiriusbenchListExperiments = [ \'gmm\', \'dnn_asr\', \'surf-fe\', \'surf-fd\', \'stem\', \'regex\', \'crf\', \'img-imc\', \'img-dig\', \'img-face\', \'nlp-pos\', \'nlp-chk\', \'nlp-ner\']\nsiriuscolocationListBaseline = [ \'colocating with lbm\', \'colocating with povray\', \'colocating with astar\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with mcf\' ]\nsiriuscolocationListExperiments = [ \'colocating with lbm\', \'colocating with povray\', \'colocating with perlbench\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with mcf\' ]\nsiriusrunningList2 = [ \'gmm\', \'colocating with libquantum\', \'dnn_asr\', \'colocating with libquantum\', \'surf-fe\', \'colocating with libquantum\', \'surf-fd\', \'colocating with libquantum\', \'stem\', \'colocating with libquantum\', \'regex\', \'colocating with libquantum\', \'crf\', \'colocating with libquantum\', \'img-imc\', \'colocating with libquantum\', \'img-dig\', \'colocating with libquantum\', \'img-face\', \'colocating with libquantum\', \'nlp-pos\', \'colocating with libquantum\', \'nlp-chk\', \'colocating with libquantum\', \'nlp-ner\' , \'colocating with libquantum\']\n\ndef autolabel(rects):\n    # attach some text labels\n    for rect in rects:\n        height = rect.get_height()\n        plt.text(rect.get_x()+rect.get_width()/2., 1.05*height, \'%.2f\'%float(height))\n\ndef autolabel2(rects):\n    # attach some text labels\n    for rect in rects:\n        height = rect.get_height()\n        plt.text(rect.get_x()+rect.get_width()/2., 1.05*height, \'%.2f\'%float(height))\n\ndef add_line(ax, xpos, ypos):\n    line = plt.Line2D([xpos, xpos], [ypos + .1, ypos - .5], transform=ax.transAxes, linewidth=2, color=\'black\')\n    line.set_clip_on(False)\n    ax.add_line(line)\n\nfilename = \'shutter_cpi_10\'\n\nfList3= [s.strip() for s in open(\'../../papergraphs/mixcorunner/priorwork/shutter_cpi_4.txt\').readlines()]\n\nfList4 = [s.strip() for s in open(\'../../papergraphs/mixcorunner/singlevm/shutter_cpi_1000.txt\').readlines()]\nfList5 = [s.strip() for s in open(\'../../papergraphs/mixcorunner/degradation/shutter_cpi_1000.txt\').readlines()]\nfList6 = [s.strip() for s in open(\'../../papergraphs/mixcorunner/snapshot/%s.txt\' % filename).readlines()]\nfList7 = [s.strip() for s in open(\'../../papergraphs/mixcorunner/degradation/shutter_cpi_100.txt\').readlines()]\n\nfList8= [s.strip() for s in open(\'../../papergraphs/mixcorunner/siriusdjinn/priorwork/shutter_cpi_4.txt\').readlines()]\n\nfList9 = [s.strip() for s in open(\'../../papergraphs/accuracy/libquantumcorunner/siriusdjinn/singlevm/shutter_cpi_1000.txt\').readlines()]\nfList10 = [s.strip() for s in open(\'../../papergraphs/mixcorunner/siriusdjinn/degradation/shutter_cpi_1000.txt\').readlines()]\nfList11 = [s.strip() for s in open(\'../../papergraphs/mixcorunner/siriusdjinn/snapshot/shutter_cpi_75.txt\').readlines()]\n\ndictList_single_vm = defaultdict(list)\ndictList_degradation_colocation = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter2 = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter3 = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter4 = defaultdict(lambda  : defaultdict(list))\nplot_degradation = defaultdict(dict)\nplot_degradation2 = defaultdict(dict)\nplot_degradation_error = defaultdict(dict)\nplot_degradation_error2 = defaultdict(dict)\nplot_degradation_abs = defaultdict(dict)\nplot_degradation_abs2 = defaultdict(dict)\n\nfor (b,a) in enumerate(fList4):\n    if a in benchListBaseline:\n        dictList_single_vm[a].append(fList4[b+1])\n\n#SORTING LIST CONTAING VALUES OF SINGLE SPEC RUNS INSIDE VMs\nfor i in benchListBaseline:\n    dictList_single_vm[i].sort()\n    #print i,dictList_single_vm[i]\n\nfor (b,a) in enumerate(fList5):\n    #print a\n    if a in colocationListBaseline:\n       #print a\n       index = a\n    else:\n        if a in benchListExperiments:\n            #print a\n            dictList_degradation_colocation[index][a].append(fList5[b+1])\n\n#sorting the ground truth values\nfor a in xrange(0,len(runningList2),2):\n    j = runningList2[a+1]\n    i = runningList2[a]\n    dictList_degradation_colocation[j][i].sort()\n    #print j,i,dictList_degradation_colocation[j][i]\n\n\n#APPENDING DEGRADATION SHUTTER\nfor (b,a) in enumerate(fList6):\n    if a in colocationListExperiments:\n        index = a\n    else:\n        if a in benchListExperiments:\n            dictList_degradation_shutter[index][a].append(fList6[b+1])\n\nfor (b,a) in enumerate(fList3):\n    if a in colocationListExperiments:\n        index = a\n    else:\n        if a in benchListExperiments:\n            dictList_degradation_shutter3[index][a].append(fList3[b+1])\n\nfor a in xrange(0,len(runningList2),2):\n    j = runningList2[a+1]\n    i = runningList2[a]\n    #print i,j,dictList_degradation_shutter[j][i]\n#APPENDING DEGRADATION SHUTTER2 as shutter and colocation values are tab separated\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    for elem in dictList_degradation_shutter[j][i]:\n        dictList_degradation_shutter2[j][i].extend(elem.strip().split(\'\\t\'))\n\n    for elem in dictList_degradation_shutter3[j][i]:\n        dictList_degradation_shutter4[j][i].extend(elem.strip().split(\'\\t\'))\n    #print dictList_degradation_shutter2[j][i]\n\nspecmix_yaxis2 = ()\nspecmix_yaxis3 = ()\nspecmix_yaxis_abs2 = ()\nspecmix_yaxis_abs3 = ()\nspecmix_error2 = ()\nspecmix_error3 = ()\nspecmix_xaxis2 = ()\nfor a in xrange(0,len(runningList2),2):\n    j = runningList2[a+1]\n    i = runningList2[a]\n    #print i,j\n    #print dictList_single_vm[i]\n    #print dictList_degradation_colocation[j][i]\n    #print dictList_degradation_shutter2[j][i]\n    denominator1 = sum(float(n) for (m,n) in enumerate(dictList_single_vm[i]) if m!=0 and m!=len(dictList_single_vm[i])-1)/(len(dictList_single_vm[i])-2)\n    numerator1 = sum(float(n) for (m,n) in enumerate(dictList_degradation_colocation[j][i]))/(len(dictList_degradation_colocation[j][i]))\n    shutter_temp_list = []\n    shutter_temp_list2 = []\n    colo_temp_list = []\n    colo_temp_list2 = []\n    degradation_temp_list = []\n    degradation_temp_list2 = []\n    error_temp_list = []\n    error_temp_list2 = []\n    #print numerator1\n    #print denominator1\n    for (count,item) in enumerate(dictList_degradation_shutter2[j][i]):\n        if count%2==0:\n            colo_temp_list.append(item)\n        if count%2==1:\n            shutter_temp_list.append(item)\n\n    for (count,item) in enumerate(dictList_degradation_shutter4[j][i]):\n        if count%2==0:\n            colo_temp_list2.append(item)\n        if count%2==1:\n            shutter_temp_list2.append(item)\n\n    for (count,item) in enumerate(shutter_temp_list):\n        degradation_temp_list.append(abs((((float(shutter_temp_list[count])/float(colo_temp_list[count]))-(numerator1/denominator1))/(float(shutter_temp_list[count])/float(colo_temp_list[count])))*100))\n\n    shutter_temp_list.sort()\n    shutter_temp_list2.sort()\n    colo_temp_list.sort()\n    colo_temp_list2.sort()\n    #print shutter_temp_list\n    #print colo_temp_list\n    #print dictList_degradation_shutter2[j][i]\n    denominator2 = sum(float(n) for (m,n) in enumerate(shutter_temp_list))/len(shutter_temp_list)\n    numerator2 = sum(float(n) for (m,n) in enumerate(colo_temp_list))/len(colo_temp_list)\n    for (m,n) in enumerate(shutter_temp_list):\n        ratio=float(n)/float(colo_temp_list[m])\n        error_temp_list.append(abs((((ratio)-(numerator1/denominator1))/(numerator1/denominator1))*100))\n    plot_degradation_error[j][i]=np.std(error_temp_list)\n\n    denominator3 = sum(float(n) for (m,n) in enumerate(shutter_temp_list2))/(len(shutter_temp_list2))\n    numerator3 = sum(float(n) for (m,n) in enumerate(colo_temp_list2))/(len(colo_temp_list2))\n    for (m,n) in enumerate(shutter_temp_list2):\n        ratio=float(n)/float(colo_temp_list2[m])\n        error_temp_list2.append(abs((((ratio)-(numerator3/denominator3))/(numerator1/denominator1))*100))\n    plot_degradation_error2[j][i]=np.std(error_temp_list2)\n\n    #print numerator2\n    #print denominator2\n    del shutter_temp_list\n    del colo_temp_list\n    del degradation_temp_list\n    del shutter_temp_list2\n    del colo_temp_list2\n    del degradation_temp_list2\n    plot_degradation[j][i] = (((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100\n    plot_degradation_abs[j][i] = abs((((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100)\n    plot_degradation2[j][i] = (((numerator3/denominator3)-(numerator1/denominator1))/(numerator1/denominator1))*100\n    plot_degradation_abs2[j][i] = abs((((numerator3/denominator3)-(numerator1/denominator1))/(numerator1/denominator1))*100)\n    #print j,i,plot_degradation[j][i]\n    #print plot_degradation_error[j][i]\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    #xaxis2 = xaxis2 + (i,)\n    #yaxis2 = yaxis2 + (plot_degradation[j][i],)\n    #yaxis3 = yaxis3 + (plot_degradation2[j][i],)\n    #yaxis_abs2 = yaxis_abs2 + (plot_degradation_abs[j][i],)\n    #yaxis_abs3 = yaxis_abs3 + (plot_degradation_abs2[j][i],)\n    #error2 = error2 + (plot_degradation_error[j][i],)\n    #error3 = error3 + (plot_degradation_error2[j][i],)\n    #print numerator2,denominator2,numerator2/denominator2\n    #print denominator2/numerator2\n    #print j,i,plot_degradation[j][i]\n            #print (((numerator2/denominator2)-(numerator1/denominator1))/(numerator2/denominator2))*100\n#print np.mean(yaxis2)\n\n\ndel dictList_degradation_colocation\ndictList_degradation_colocation = defaultdict(lambda  : defaultdict(list))\n\nfor (b,a) in enumerate(fList5):\n    #print a\n    if a in colocationListBaseline:\n       #print a\n       index = a\n    else:\n        if a in benchListExperiments:\n            #print index,a\n            dictList_degradation_colocation[index][a].append(fList5[b+1])\n            #print dictList_degradation_colocation[index][a]\n\n#sorting the ground truth values\nfor a in xrange(0,len(runningList3),2):\n    j = runningList3[a+1]\n    i = runningList3[a]\n    dictList_degradation_colocation[j][i].sort()\n    #print j,i,dictList_degradation_colocation[j][i]\n\n\nfor a in xrange(0,len(runningList3),2):\n    j = runningList3[a+1]\n    i = runningList3[a]\n    #print i,j\n    #print dictList_single_vm[i]\n    #print dictList_degradation_colocation[j][i]\n    #print dictList_degradation_shutter2[j][i]\n    denominator1 = sum(float(n) for (m,n) in enumerate(dictList_single_vm[i]) if m!=0 and m!=len(dictList_single_vm[i])-1)/(len(dictList_single_vm[i])-2)\n    numerator1 = sum(float(n) for (m,n) in enumerate(dictList_degradation_colocation[j][i]))/(len(dictList_degradation_colocation[j][i]))\n    shutter_temp_list = []\n    shutter_temp_list2 = []\n    colo_temp_list = []\n    colo_temp_list2 = []\n    degradation_temp_list = []\n    degradation_temp_list2 = []\n    error_temp_list = []\n    error_temp_list2 = []\n    #print numerator1\n    #print denominator1\n    #for (count,item) in enumerate(dictList_degradation_shutter2[j][i]):\n    #    if count%2==0:\n    #        colo_temp_list.append(item)\n    #    if count%2==1:\n    #        shutter_temp_list.append(item)\n\n    for (count,item) in enumerate(dictList_degradation_shutter4[j][i]):\n        if count%2==0:\n            colo_temp_list2.append(item)\n        if count%2==1:\n            shutter_temp_list2.append(item)\n\n    #for (count,item) in enumerate(shutter_temp_list):\n    #    degradation_temp_list.append(abs((((float(shutter_temp_list[count])/float(colo_temp_list[count]))-(numerator1/denominator1))/(float(shutter_temp_list[count])/float(colo_temp_list[count])))*100))\n\n    #shutter_temp_list.sort()\n    shutter_temp_list2.sort()\n    #colo_temp_list.sort()\n    colo_temp_list2.sort()\n\n    denominator3 = sum(float(n) for (m,n) in enumerate(shutter_temp_list2))/(len(shutter_temp_list2))\n    numerator3 = sum(float(n) for (m,n) in enumerate(colo_temp_list2))/(len(colo_temp_list2))\n    for (m,n) in enumerate(shutter_temp_list2):\n        ratio=float(n)/float(colo_temp_list2[m])\n        error_temp_list2.append(abs((((ratio)-(numerator3/denominator3))/(numerator1/denominator1))*100))\n    plot_degradation_error2[j][i]=np.std(error_temp_list2)\n\n    #print numerator2\n    #print denominator2\n    #del shutter_temp_list\n    #del colo_temp_list\n    #del degradation_temp_list\n    del shutter_temp_list2\n    del colo_temp_list2\n    del degradation_temp_list2\n    #plot_degradation[j][i] = (((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100\n    #plot_degradation_abs[j][i] = abs((((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100)\n    plot_degradation2[j][i] = (((numerator3/denominator3)-(numerator1/denominator1))/(numerator1/denominator1))*100\n    plot_degradation_abs2[j][i] = abs((((numerator3/denominator3)-(numerator1/denominator1))/(numerator1/denominator1))*100)\n    #print j,i,plot_degradation[j][i]\n    #print plot_degradation_error[j][i]\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    #xaxis2 = xaxis2 + (i,)\n    #yaxis2 = yaxis2 + (plot_degradation[j][i],)\n    #yaxis3 = yaxis3 + (plot_degradation2[j][i],)\n    #yaxis_abs2 = yaxis_abs2 + (plot_degradation_abs[j][i],)\n    #yaxis_abs3 = yaxis_abs3 + (plot_degradation_abs2[j][i],)\n    #error2 = error2 + (plot_degradation_error[j][i],)\n    #error3 = error3 + (plot_degradation_error2[j][i],)\n    #print numerator2,denominator2,numerator2/denominator2\n    #print denominator2/numerator2\n    #print j,i,plot_degradation[j][i]\n            #print (((numerator2/denominator2)-(numerator1/denominator1))/(numerator2/denominator2))*100\n\ndel dictList_degradation_colocation\ndictList_degradation_colocation = defaultdict(lambda  : defaultdict(list))\n\nfor (b,a) in enumerate(fList7):\n    #print a\n    if a in colocationListBaseline:\n       #print a\n       index = a\n    else:\n        if a in benchListExperiments:\n            #print index,a\n            dictList_degradation_colocation[index][a].append(fList7[b+1])\n            #print dictList_degradation_colocation[index][a]\n\n#sorting the ground truth values\nfor a in xrange(0,len(runningList3),2):\n    j = runningList3[a+1]\n    i = runningList3[a]\n    dictList_degradation_colocation[j][i].sort()\n    #print j,i,dictList_degradation_colocation[j][i]\n\n\nfor a in xrange(0,len(runningList3),2):\n    j = runningList3[a+1]\n    i = runningList3[a]\n    print i,j\n    #print dictList_single_vm[i]\n    #print dictList_degradation_colocation[j][i]\n    #print dictList_degradation_shutter2[j][i]\n    denominator1 = sum(float(n) for (m,n) in enumerate(dictList_single_vm[i]) if m!=0 and m!=len(dictList_single_vm[i])-1)/(len(dictList_single_vm[i])-2)\n    numerator1 = sum(float(n) for (m,n) in enumerate(dictList_degradation_colocation[j][i]))/(len(dictList_degradation_colocation[j][i]))\n    shutter_temp_list = []\n    shutter_temp_list2 = []\n    colo_temp_list = []\n    colo_temp_list2 = []\n    degradation_temp_list = []\n    degradation_temp_list2 = []\n    error_temp_list = []\n    error_temp_list2 = []\n    #print numerator1\n    #print denominator1\n    for (count,item) in enumerate(dictList_degradation_shutter2[j][i]):\n        if count%2==0:\n            colo_temp_list.append(item)\n        if count%2==1:\n            shutter_temp_list.append(item)\n\n    #for (count,item) in enumerate(dictList_degradation_shutter4[j][i]):\n    #    if count%2==0:\n    #        colo_temp_list2.append(item)\n    #    if count%2==1:\n    #        shutter_temp_list2.append(item)\n\n    #for (count,item) in enumerate(shutter_temp_list):\n    #    degradation_temp_list.append(abs((((float(shutter_temp_list[count])/float(colo_temp_list[count]))-(numerator1/denominator1))/(float(shutter_temp_list[count])/float(colo_temp_list[count])))*100))\n\n    shutter_temp_list.sort()\n    #shutter_temp_list2.sort()\n    colo_temp_list.sort()\n    #colo_temp_list2.sort()\n    #print shutter_temp_list\n    #print colo_temp_list\n    #print dictList_degradation_shutter2[j][i]\n    denominator2 = sum(float(n) for (m,n) in enumerate(shutter_temp_list))/len(shutter_temp_list)\n    numerator2 = sum(float(n) for (m,n) in enumerate(colo_temp_list))/len(colo_temp_list)\n    for (m,n) in enumerate(shutter_temp_list):\n        ratio=float(n)/float(colo_temp_list[m])\n        error_temp_list.append(abs((((ratio)-(numerator1/denominator1))/(numerator1/denominator1))*100))\n    plot_degradation_error[j][i]=np.std(error_temp_list)\n\n    #denominator3 = sum(float(n) for (m,n) in enumerate(shutter_temp_list2))/(len(shutter_temp_list2))\n    #numerator3 = sum(float(n) for (m,n) in enumerate(colo_temp_list2))/(len(colo_temp_list2))\n    #for (m,n) in enumerate(shutter_temp_list2):\n    #    ratio=float(n)/float(colo_temp_list2[m])\n    #    error_temp_list2.append(abs((((ratio)-(numerator3/denominator3))/(numerator1/denominator1))*100))\n    #plot_degradation_error2[j][i]=np.std(error_temp_list2)\n\n    #print numerator2\n    #print denominator2\n    del shutter_temp_list\n    del colo_temp_list\n    del degradation_temp_list\n    #del shutter_temp_list2\n    #del colo_temp_list2\n    #del degradation_temp_list2\n    plot_degradation[j][i] = (((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100\n    plot_degradation_abs[j][i] = abs((((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100)\n    #plot_degradation2[j][i] = (((numerator3/denominator3)-(numerator1/denominator1))/(numerator1/denominator1))*100\n    #plot_degradation_abs2[j][i] = abs((((numerator3/denominator3)-(numerator1/denominator1))/(numerator1/denominator1))*100)\n    #print j,i,plot_degradation[j][i]\n    #print plot_degradation_error[j][i]\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    #xaxis2 = xaxis2 + (i,)\n    #yaxis2 = yaxis2 + (plot_degradation[j][i],)\n    #yaxis3 = yaxis3 + (plot_degradation2[j][i],)\n    #yaxis_abs2 = yaxis_abs2 + (plot_degradation_abs[j][i],)\n    #yaxis_abs3 = yaxis_abs3 + (plot_degradation_abs2[j][i],)\n    #error2 = error2 + (plot_degradation_error[j][i],)\n    #error3 = error3 + (plot_degradation_error2[j][i],)\n    #print numerator2,denominator2,numerator2/denominator2\n    #print denominator2/numerator2\n    #print j,i,plot_degradation[j][i]\n            #print (((numerator2/denominator2)-(numerator1/denominator1))/(numerator2/denominator2))*100\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    specmix_xaxis2 = specmix_xaxis2 + (i,)\n    specmix_yaxis2 = specmix_yaxis2 + (plot_degradation[j][i],)\n    specmix_yaxis3 = specmix_yaxis3 + (plot_degradation2[j][i],)\n    specmix_yaxis_abs2 = specmix_yaxis_abs2 + (plot_degradation_abs[j][i],)\n    specmix_yaxis_abs3 = specmix_yaxis_abs3 + (plot_degradation_abs2[j][i],)\n    specmix_error2 = specmix_error2 + (plot_degradation_error[j][i],)\n    specmix_error3 = specmix_error3 + (plot_degradation_error2[j][i],)\n\n\n#width=0.25\n#x = np.arange(len(yaxis2))\n#fig = plt.figure(figsize=(28, 5))\n##bar1 = plt.bar( x, yaxis, width, color="r", label=\'colocating with libquatum (avg = %.2f)\' %(np.mean(yaxis_abs)))\n#bar1 = plt.bar( x, yaxis_abs3, width, color="k", yerr=error3, label=\'Shuttering (mean: %.2f)\' %(np.mean(yaxis_abs3)))\n#bar2 = plt.bar( x+width, yaxis_abs2, width, color="lightgrey", yerr=error2, label=\'Snapshot (mean: %.2f)\' %(np.mean(yaxis_abs2)))\n##bar3 = plt.bar( x+width+width, yaxis3, width, color="g", label=\'colocating with sphinx  (avg = %.2f)\' %(np.mean(yaxis_abs3)))\n##autolabel(bar1)\n##autolabel(bar2)\n#plt.ylabel( \'Estimation error (%)\' ,fontsize=\'25\')\n##plt.title(\'Error in predicting degradation when co-locating with libquantum\')\n#plt.xticks(x + width/2.0, xaxis2, rotation=\'30\', size=\'23\',  ha=\'center\', va=\'top\')\n##plt.yticks((-0.5,0,1,2,3,4),(\'\',\'0\',\'1\',\'2\',\'3\',\'4\'),size=\'23\')\n#plt.yticks(np.arange(0,50,10),size=\'25\')\n#plt.ylim(0,40)\n#plt.xlim(-1,26)\n#plt.grid()\n#plt.tight_layout()\n#plt.legend(loc=9, ncol=2, prop={\'size\':28})\n##plt.savefig(\'mix_error.pdf\', dpi=125)\n\n\ndel dictList_single_vm\ndel dictList_degradation_colocation\ndel dictList_degradation_shutter\ndel dictList_degradation_shutter2\ndel dictList_degradation_shutter3\ndel dictList_degradation_shutter4\ndel plot_degradation\ndel plot_degradation2\ndel plot_degradation_error\ndel plot_degradation_error2\ndel plot_degradation_abs\ndel plot_degradation_abs2\n\ndictList_single_vm = defaultdict(list)\ndictList_degradation_colocation = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter2 = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter3 = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter4 = defaultdict(lambda  : defaultdict(list))\nplot_degradation = defaultdict(dict)\nplot_degradation2 = defaultdict(dict)\nplot_degradation_error = defaultdict(dict)\nplot_degradation_error2 = defaultdict(dict)\nplot_degradation_abs = defaultdict(dict)\nplot_degradation_abs2 = defaultdict(dict)\n\nfor (b,a) in enumerate(fList9):\n    if a in siriusbenchListBaseline:\n        dictList_single_vm[a].append(fList9[b+1])\n\n#SORTING LIST CONTAING VALUES OF SINGLE SPEC RUNS INSIDE VMs\nfor i in siriusbenchListBaseline:\n    dictList_single_vm[i].sort()\n    #print i,dictList_single_vm[i]\n\nfor (b,a) in enumerate(fList10):\n    #print a\n    if a in siriuscolocationListBaseline:\n       #print a\n       index = a\n    else:\n        if a in siriusbenchListExperiments:\n            #print a\n            dictList_degradation_colocation[index][a].append(fList10[b+1])\n\n#sorting the ground truth values\nfor a in xrange(0,len(siriusrunningList2),2):\n    j = siriusrunningList2[a+1]\n    i = siriusrunningList2[a]\n    #print i,j\n    dictList_degradation_colocation[j][i].sort()\n    #print j,i,dictList_degradation_colocation[j][i]\n\n#for a in xrange(0,len(runningList),2):\n#    j = runningList[a+1]\n#    i = runningList[a]\n#    numerator1 = sum(float(n) for (m,n) in enumerate(dictList_degradation_colocation[j][i]) if m!=0 and m!=len(dictList_degradation_colocation[j][i])-1)/(len(dictList_degradation_colocation[j][i])-2)\n#    print numerator1\n#    #print dictList_degradation_colocation[runningList[a+1]][runningList[a]]\n#    #print numerator1\n\n#APPENDING DEGRADATION SHUTTER\nfor (b,a) in enumerate(fList11):\n    #print a\n    if a in siriuscolocationListExperiments:\n        index = a\n    else:\n        if a in siriusbenchListExperiments:\n            dictList_degradation_shutter[index][a].append(fList11[b+1])\n\nfor (b,a) in enumerate(fList8):\n    if a in siriuscolocationListExperiments:\n        index = a\n    else:\n        if a in siriusbenchListExperiments:\n            dictList_degradation_shutter3[index][a].append(fList8[b+1])\n\nfor a in xrange(0,len(siriusrunningList2),2):\n    j = siriusrunningList2[a+1]\n    i = siriusrunningList2[a]\n    #print i,j,dictList_degradation_shutter[j][i]\n    #print i,j\n#APPENDING DEGRADATION SHUTTER2 as shutter and colocation values are tab separated\nfor a in xrange(0,len(siriusrunningList2),2):\n    j = siriusrunningList2[a+1]\n    i = siriusrunningList2[a]\n    #print i,j\n    for elem in dictList_degradation_shutter[j][i]:\n        dictList_degradation_shutter2[j][i].extend(elem.strip().split(\'\\t\'))\n        #print dictList_degradation_shutter2[j][i]\n\n    for elem in dictList_degradation_shutter3[j][i]:\n        dictList_degradation_shutter4[j][i].extend(elem.strip().split(\'\\t\'))\n    #print dictList_degradation_shutter2[j][i]\n\nmix_xaxis2 = ()\nmix_yaxis2 = ()\nmix_yaxis3 = ()\nmix_yaxis_abs2 = ()\nmix_yaxis_abs3 = ()\nmix_error2 = ()\nmix_error3 = ()\nfor a in xrange(0,len(siriusrunningList2),2):\n    j = siriusrunningList2[a+1]\n    i = siriusrunningList2[a]\n    #print i,j\n    #print i\n    #print dictList_single_vm[i]\n    #print dictList_degradation_colocation[j][i]\n    #print dictList_degradation_shutter2[j][i]\n    denominator1 = sum(float(n) for (m,n) in enumerate(dictList_single_vm[i]) if m!=0 and m!=len(dictList_single_vm[i])-1)/(len(dictList_single_vm[i])-2)\n    numerator1 = sum(float(n) for (m,n) in enumerate(dictList_degradation_colocation[j][i]))/(len(dictList_degradation_colocation[j][i]))\n    shutter_temp_list = []\n    shutter_temp_list2 = []\n    colo_temp_list = []\n    colo_temp_list2 = []\n    degradation_temp_list = []\n    degradation_temp_list2 = []\n    error_temp_list = []\n    error_temp_list2 = []\n    #print numerator1\n    #print denominator1\n    for (count,item) in enumerate(dictList_degradation_shutter2[j][i]):\n        if count%2==0:\n            colo_temp_list.append(item)\n        if count%2==1:\n            shutter_temp_list.append(item)\n\n    for (count,item) in enumerate(dictList_degradation_shutter4[j][i]):\n        if count%2==0:\n            colo_temp_list2.append(item)\n        if count%2==1:\n            shutter_temp_list2.append(item)\n\n    #print \'1 %s\' %shutter_temp_list\n    #print colo_temp_list\n    for (count,item) in enumerate(shutter_temp_list):\n        degradation_temp_list.append(abs((((float(shutter_temp_list[count])/float(colo_temp_list[count]))-(numerator1/denominator1))/(float(shutter_temp_list[count])/float(colo_temp_list[count])))*100))\n\n    shutter_temp_list.sort()\n    shutter_temp_list2.sort()\n    colo_temp_list.sort()\n    colo_temp_list2.sort()\n    #print shutter_temp_list\n    #print colo_temp_list\n    #print dictList_degradation_shutter2[j][i]\n    denominator2 = sum(float(n) for (m,n) in enumerate(shutter_temp_list))/len(shutter_temp_list)\n    numerator2 = sum(float(n) for (m,n) in enumerate(colo_temp_list))/len(colo_temp_list)\n    for (m,n) in enumerate(shutter_temp_list):\n        ratio=float(n)/float(colo_temp_list[m])\n        error_temp_list.append(abs((((ratio)-(numerator1/denominator1))/(numerator1/denominator1))*100))\n    plot_degradation_error[j][i]=np.std(error_temp_list)\n\n    denominator3 = sum(float(n) for (m,n) in enumerate(shutter_temp_list2))/(len(shutter_temp_list2))\n    numerator3 = sum(float(n) for (m,n) in enumerate(colo_temp_list2))/(len(colo_temp_list2))\n    for (m,n) in enumerate(shutter_temp_list2):\n        ratio=float(n)/float(colo_temp_list2[m])\n        error_temp_list2.append(abs((((ratio)-(numerator3/denominator3))/(numerator1/denominator1))*100))\n    plot_degradation_error2[j][i]=np.std(error_temp_list2)\n\n    #print numerator2\n    #print denominator2\n    del shutter_temp_list\n    del colo_temp_list\n    del degradation_temp_list\n    del shutter_temp_list2\n    del colo_temp_list2\n    del degradation_temp_list2\n    plot_degradation[j][i] = (((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100\n    plot_degradation_abs[j][i] = abs((((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100)\n    plot_degradation2[j][i] = (((numerator3/denominator3)-(numerator1/denominator1))/(numerator1/denominator1))*100\n    plot_degradation_abs2[j][i] = abs((((numerator3/denominator3)-(numerator1/denominator1))/(numerator1/denominator1))*100)\n    #print j,i,plot_degradation[j][i]\n    #print plot_degradation_error[j][i]\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    mix_xaxis2 = mix_xaxis2 + (i,)\n    mix_yaxis2 = mix_yaxis2 + (plot_degradation[j][i],)\n    mix_yaxis3 = mix_yaxis3 + (plot_degradation2[j][i],)\n    mix_yaxis_abs2 = mix_yaxis_abs2 + (plot_degradation_abs[j][i],)\n    mix_yaxis_abs3 = mix_yaxis_abs3 + (plot_degradation_abs2[j][i],)\n    mix_error2 = mix_error2 + (plot_degradation_error[j][i],)\n    mix_error3 = mix_error3 + (plot_degradation_error2[j][i],)\n    #print numerator2,denominator2,numerator2/denominator2\n    #print denominator2/numerator2\n    print j,i,plot_degradation[j][i],plot_degradation2[j][i]\n            #print (((numerator2/denominator2)-(numerator1/denominator1))/(numerator2/denominator2))*100\n#print np.mean(yaxis2)\n\n\n\n\nwidth=0.15\nx = np.arange(len(speclib_yaxis2))\nfig = plt.figure(figsize=(23, 5))\nfig.subplots_adjust(bottom=0.5)\nax = fig.add_subplot(1,1,1)\n#bar1 = plt.bar( x, yaxis, width, color="r", label=\'colocating with libquatum (avg = %.2f)\' %(np.mean(yaxis_abs)))\n#bar1 = plt.bar( x, lib_yaxis_abs3, width, color="r", yerr=lib_error3, label=\'Shuttering (avg = %.2f)\' %(np.mean(lib_yaxis_abs3)))\nbar2 = plt.bar( x, speclib_yaxis_abs2, width, color="y", yerr=speclib_error2, label=\'libquantum (avg = %.2f)\' %(np.mean(speclib_yaxis_abs2)))\nbar3 = plt.bar( x+width, specmcf_yaxis_abs2, width, color="r", yerr=specmcf_error2, label=\'mcf (avg = %.2f)\' %(np.mean(specmcf_yaxis_abs2)))\nbar4 = plt.bar( x+width+width, specmilc_yaxis_abs2, width, color="b", yerr=specmilc_error2, label=\'milc (avg = %.2f)\' %(np.mean(specmilc_yaxis_abs2)))\nbar5 = plt.bar( x+width+width+width, specmix_yaxis_abs2, width, color="g", yerr=specmilc_error2, label=\'mix (avg = %.2f)\' %(np.mean(specmix_yaxis_abs2)))\n#ly = len(lib_yaxis_abs3)\n#add_line(ax, 0 * 1.0, -.1)\n#add_line(ax, 1 * 1.0, -.1)\n#add_line(ax, 1 * 0.675, -.1)\n#add_line(ax, 1 * 0.845, -.1)\n#scale = 40./ly\n#scale = 27./ly\n#for pos in xrange(ly + 1):\n#    print pos\n#    print scale\n#    add_line(ax, pos * scale, -.1)\n#scale = 34./ly\n#for pos in xrange(ly + 1):\n#    add_line(ax, pos * scale, -.1)\n#bar3 = plt.bar( x+width+width, yaxis3, width, color="g", label=\'colocating with sphinx  (avg = %.2f)\' %(np.mean(yaxis_abs3)))\n#autolabel(bar1)\n#autolabel(bar2)\nplt.ylabel( \'Estimation error (%)\', fontsize=\'19\' )\n#plt.title(\'Error in predicting degradation when co-locating with libquantum\')\nplt.xticks(x + width/2.0, speclib_xaxis2, rotation=\'90\', size=\'18\',  ha=\'center\', va=\'top\')\nplt.yticks(np.arange(0,50,10),size=\'20\')\nplt.ylim(0,50)\nplt.xlim(-0.2,26)\nplt.grid()\nplt.tight_layout()\nplt.legend(loc=1, ncol=4, prop={\'size\':18})\n#plt.savefig(\'accuracylibquantum.pdf\', dpi=125)\n#ax.text(5, -23, r\'SPEC 2006\', fontsize=20)\n#ax.text(4, -23, r\'Sirius Suite\', fontsize=20)\n#ax.text(10, -23, r\'DjiNN & Tonic\', fontsize=20)\n'
p0
.I0
.S'$graph_fig:spec-overhead:Overhead:0.9'
p0
.S'from collections import defaultdict\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\n\nbenchList = [ \'gcc\', \'perlbench\', \'leslie3d\', \'povray\', \'libquantum\', \'astar\', \'bzip2\', \'milc\', \'namd\', \'calculix\', \'h264ref\', \'sphinx3\', \'zeusmp\', \'gobmk\', \'hmmer\', \'tonto\', \'bwaves\', \'gromacs\', \'dealII\', \'sjeng\', \'lbm\', \'xalancbmk\', \'gamess\', \'soplex\', \'GemsFDTD\', \'omnetpp\', \'mcf\', \'cactusADM\' ]\n\ncolocationList = [ \'colocating with libquantum\', \'colocating with mcf\',  \'colocating with sphinx3\']\ncolocationListBaseline = [ \'colocating with libquantum\', \'colocating with mcf\', \'colocating with sphinx3\' ]\n\n\nrunningList = [  \'perlbench\', \'colocating with libquantum\', \'mcf\', \'colocating with libquantum\', \'leslie3d\', \'colocating with libquantum\', \'povray\', \'colocating with libquantum\', \'libquantum\', \'colocating with libquantum\', \'astar\', \'colocating with libquantum\', \'bzip2\', \'colocating with libquantum\', \'milc\', \'colocating with libquantum\', \'namd\', \'colocating with libquantum\', \'calculix\', \'colocating with libquantum\', \'h264ref\', \'colocating with libquantum\', \'gobmk\', \'colocating with libquantum\', \'hmmer\', \'colocating with libquantum\', \'tonto\', \'colocating with libquantum\', \'sphinx3\', \'colocating with libquantum\', \'zeusmp\', \'colocating with libquantum\', \'bwaves\', \'colocating with libquantum\', \'gromacs\', \'colocating with libquantum\', \'dealII\', \'colocating with libquantum\', \'sjeng\', \'colocating with libquantum\', \'lbm\', \'colocating with libquantum\', \'xalancbmk\', \'colocating with libquantum\', \'gamess\', \'colocating with libquantum\', \'soplex\', \'colocating with libquantum\', \'cactusADM\', \'colocating with libquantum\', \'GemsFDTD\', \'colocating with libquantum\', \'omnetpp\', \'colocating with libquantum\' ]\n\n\nsiriusbenchList = [ \'gmm\', \'dnn_asr\', \'surf-fe\', \'surf-fd\', \'stem\', \'regex\', \'crf\', \'img-imc\', \'img-dig\', \'img-face\', \'nlp-pos\', \'nlp-chk\', \'nlp-ner\']\nsiriuscolocationList = [ \'colocating with lbm\', \'colocating with povray\', \'colocating with astar\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with mcf\' ]\nsiriusrunningList = [ \'gmm\', \'colocating with libquantum\', \'dnn_asr\', \'colocating with libquantum\', \'surf-fe\', \'colocating with libquantum\', \'surf-fd\', \'colocating with libquantum\', \'stem\', \'colocating with libquantum\', \'regex\', \'colocating with libquantum\', \'crf\', \'colocating with libquantum\', \'img-imc\', \'colocating with libquantum\', \'img-dig\', \'colocating with libquantum\', \'img-face\', \'colocating with libquantum\', \'nlp-pos\', \'colocating with libquantum\', \'nlp-chk\', \'colocating with libquantum\', \'nlp-ner\' , \'colocating with libquantum\']\n\ndef autolabel(rects):\n    # attach some text labels\n    for rect in rects:\n        height = rect.get_height()\n        plt.text(rect.get_x()+rect.get_width()/2., 1.05*height, \'%.2f\'%float(height), fontsize=8 )\n\ndef autolabel2(rects):\n    # attach some text labels\n    for rect in rects:\n        height = rect.get_height()\n        plt.text(rect.get_x()+rect.get_width()/2., -1.25*height, \'%.2f\'%float(height),\n                ha=\'center\', va=\'top\', fontsize=8)\n        #plt.text(rect.get_x()+rect.get_width()/2., 1.05*height, \'%.2f\'%float(height))\n\n\ndef add_line(ax, xpos, ypos):\n    line = plt.Line2D([xpos, xpos], [ypos + .1, ypos - .5], transform=ax.transAxes, linewidth=2, color=\'black\')\n    line.set_clip_on(False)\n    ax.add_line(line)\n\nfilename = \'execution_time_1000\'\nfList1 = [s.strip() for s in open(\'../../papergraphs/accuracy/libquantumcorunner/degradation2/%s.txt\' % filename).readlines()]  #degradation\nfList2 = [s.strip() for s in open(\'../../papergraphs/accuracy/libquantumcorunner/snapshot/phase_change_5.txt\').readlines()]\nfList3 = [s.strip() for s in open(\'../../papergraphs/accuracy/libquantumcorunner/priorwork/execution_time_5.txt\').readlines()] #prior work\n\n\nfList4 = [s.strip() for s in open(\'../../papergraphs/accuracy/libquantumcorunner/siriusdjinn/degradation/newval/%s.txt\' % filename).readlines()]  #degradation\nfList5 = [s.strip() for s in open(\'../../papergraphs/accuracy/libquantumcorunner/siriusdjinn/snapshot/phase_change_10.txt\').readlines()]\nfList6 = [s.strip() for s in open(\'../../papergraphs/accuracy/libquantumcorunner/siriusdjinn/priorwork/execution_time_4.txt\').readlines()] #prior work\n\nexecution_time_shutter = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter = defaultdict(lambda  : defaultdict(list))\navg_execution_time_shutter = defaultdict(dict)\nexecution_time_shutter2 = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter2 = defaultdict(lambda  : defaultdict(list))\navg_execution_time_shutter2 = defaultdict(dict)\ndictList_phase_change = defaultdict(lambda  : defaultdict(list))\ndictList_phase_change2 = defaultdict(lambda  : defaultdict(list))\n\nstd_execution_time = defaultdict(dict)\n\ndef print_elapsed_time_shutter(time_shutter):\n    for j in colocationList:\n        for i in benchList:\n            print \'%s ||||  %s\'%(j,i)\n            print time_shutter[j][i]\n\n\nsep = \'u\'\nfor (b,a) in enumerate(fList1):\n    #print a\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            execution_time_shutter[index][a].append((fList1[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_shutter[\'colocating with mcf\'][\'perlbench\']\n#print((s.split(start))[1].split(end)[0])\n\nfor j in colocationList:\n    for i in benchList:\n        for k in execution_time_shutter[j][i]:\n            m,s = [float (var) for var in k.split(\':\')]\n            temp = m*60 + s\n            execution_time_sec_shutter[j][i].append(temp)\n\nfor (b,a) in enumerate(fList3):\n    #print a\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            #print index\n            #print a\n            execution_time_shutter2[index][a].append((fList3[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_shutter[\'colocating with mcf\'][\'perlbench\']\n#print((s.split(start))[1].split(end)[0])\n\nfor j in colocationList:\n    for i in benchList:\n        for k in execution_time_shutter2[j][i]:\n            #print k\n            m,s = [float (var) for var in k.split(\':\')]\n            temp = m*60 + s\n            execution_time_sec_shutter2[j][i].append(temp)\n\nfor (b,a) in enumerate(fList2):\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            dictList_phase_change[index][a].append(fList2[b+1])\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    #print j,i\n    for elem in dictList_phase_change[j][i]:\n        dictList_phase_change2[j][i].extend(elem.strip().split(\'\\t\'))\n    #print dictList_phase_change2[j][i]\n\nlibyaxis = ()\nlibyaxis2= ()\nlibyaxis_abs = ()\nliberror = ()\nlibxaxis = ()\n#print dictList_phase_change2[\'colocating with mcf\'][\'perlbench\']\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    print j,i\n    print dictList_phase_change2[j][i]\n    #print i,j\n    shutter_temp_list = []\n    colo_temp_list = []\n    for (count,item) in enumerate(dictList_phase_change2[j][i]):\n        if count%2==1:\n            colo_temp_list.append(float(item))\n        if count%2==0:\n            shutter_temp_list.append(float(item))\n    #print shutter_temp_list\n    shutter_avg = sum(shutter_temp_list)/len(shutter_temp_list)\n    colocation_avg = sum(colo_temp_list)/len(colo_temp_list)\n    del shutter_temp_list\n    del colo_temp_list\n\n    pause_period = ((colocation_avg ) + ((shutter_avg + (colocation_avg * 2)/3) * 3))/4\n    libxaxis = libxaxis + (i,)\n    #print (pause_period/np.mean(execution_time_sec_shutter[j][i]))*10\n    libyaxis = libyaxis + ( (pause_period/np.mean(execution_time_sec_shutter[j][i]))*7.5  ,)\n    libyaxis2 = libyaxis2 + ( (((np.mean(execution_time_sec_shutter2[j][i])/np.mean(execution_time_sec_shutter[j][i])) - 1)*100), )\n    print np.mean(execution_time_sec_shutter2[j][i])\n    print np.mean(execution_time_sec_shutter[j][i])\n    #print \'---------------------\'\n\n#print yaxis2\n#print np.mean(yaxis)\n\n\n#width = 0.25\n#x = np.arange(len(yaxis))\n#fig = plt.figure(figsize=(28, 5))\n#bar2 = plt.bar( x, yaxis2, width, color="k", label=\'Shuttering  (mean: %.2f)\' %(np.mean(yaxis2)))\n#bar1 = plt.bar( x+width, yaxis, width, color="lightgrey", label=\'Snapshot (mean: %.2f)\' %(np.mean(yaxis) ))\n#\n#\n#plt.ylabel( \'Execution time \\n overhead (%)\',fontsize=\'23\' )\n##plt.title(\'Overhead due to Prediction of degradation while co-running with LIBQUANTUM\')\n#plt.xticks(x + width/2.0, xaxis, rotation=\'30\', size=\'23\', ha=\'center\')\n##plt.yticks((-5,0,10,20,30,40,50,60),(\'\',\'0\',\'10\',\'20\',\'30\',\'40\',\'50\',\'60\'),size=\'25\')\n#plt.yticks((0,5,10,15),(\'0\',\'5\',\'10\',\'15\'),size=\'25\')\n##plt.yticks(np.arange(-10, 60, 10),size=\'25\')\n#plt.xlim(-1,26)\n#plt.grid()\n#plt.legend(loc=9, ncol=2, prop={\'size\':28})\n##leg.get_frame().set_alpha(0.1)\n#plt.tight_layout()\n#plt.savefig(\'phase_chagnge_overheadmaybe.png\', dpi=125)\n\n#### ----------------------------------------------------------------------------------------------------------------------------------\n\n\n#fList3 = [s.strip() for s in open(\'experiment_libquantum/phase_changes_5.txt\').readlines()]\n##fList3 = [s.strip() for s in open(\'../../papergraphs/2.fullspec/overhead/experiment_mcf/%s.txt\' % filename).readlines()]\n##fList4 = [s.strip() for s in open(\'../../papergraphs/2.fullspec/overhead/experiment_mcf/phase_changes_5.txt\').readlines()]\n##fList5 = [s.strip() for s in open(\'../../papergraphs/2.fullspec/overhead/experiment_sphinx3/%s.txt\' % filename).readlines()]\n##fList6 = [s.strip() for s in open(\'../../papergraphs/2.fullspec/overhead/experiment_sphinx3/phase_changes_5.txt\').readlines()]\n#print fList1\n\ndel execution_time_shutter\ndel execution_time_sec_shutter\ndel avg_execution_time_shutter\ndel execution_time_shutter2\ndel execution_time_sec_shutter2\ndel avg_execution_time_shutter2\ndel dictList_phase_change\ndel dictList_phase_change2\n\nexecution_time_shutter = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter = defaultdict(lambda  : defaultdict(list))\navg_execution_time_shutter = defaultdict(dict)\nexecution_time_shutter2 = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter2 = defaultdict(lambda  : defaultdict(list))\navg_execution_time_shutter2 = defaultdict(dict)\ndictList_phase_change = defaultdict(lambda  : defaultdict(list))\ndictList_phase_change2 = defaultdict(lambda  : defaultdict(list))\n\nstd_execution_time = defaultdict(dict)\n\ndef print_elapsed_time_shutter(time_shutter):\n    for j in siriuscolocationList:\n        for i in siriusbenchList:\n            print \'%s ||||  %s\'%(j,i)\n            print time_shutter[j][i]\n\n\nsep = \'u\'\nfor (b,a) in enumerate(fList4):\n    print a\n    if a in siriuscolocationList:\n        index = a\n    else:\n        if a in siriusbenchList:\n            execution_time_shutter[index][a].append((fList4[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_shutter[\'colocating with mcf\'][\'perlbench\']\n#print((s.split(start))[1].split(end)[0])\n\nfor j in siriuscolocationList:\n    for i in siriusbenchList:\n        #print i\n        for k in execution_time_shutter[j][i]:\n            try:\n                m,s = [float (var) for var in k.split(\':\')]\n                temp = m*60 + s\n            except:\n                h,m,s = [float (var) for var in k.split(\':\')]\n                temp = h*3600 + m*60 + s\n\n            execution_time_sec_shutter[j][i].append(temp)\n\nfor (b,a) in enumerate(fList6):\n    print a\n    if a in siriuscolocationList:\n        index = a\n    else:\n        if a in siriusbenchList:\n            #print index\n            #print a\n            execution_time_shutter2[index][a].append((fList6[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_shutter[\'colocating with mcf\'][\'perlbench\']\n#print((s.split(start))[1].split(end)[0])\n\nfor j in siriuscolocationList:\n    for i in siriusbenchList:\n        for k in execution_time_shutter2[j][i]:\n            #print k\n            m,s = [float (var) for var in k.split(\':\')]\n            temp = m*60 + s\n            execution_time_sec_shutter2[j][i].append(temp)\n\nfor (b,a) in enumerate(fList5):\n    if a in siriuscolocationList:\n        index = a\n    else:\n        if a in siriusbenchList:\n            dictList_phase_change[index][a].append(fList5[b+1])\n\nfor a in xrange(0,len(siriusrunningList),2):\n    j = siriusrunningList[a+1]\n    i = siriusrunningList[a]\n    #print j,i\n    for elem in dictList_phase_change[j][i]:\n        dictList_phase_change2[j][i].extend(elem.strip().split(\'\\t\'))\n    #print dictList_phase_change2[j][i]\n\nlibsiri_yaxis = ()\nlibsiri_yaxis2= ()\nlibsiri_yaxis_abs = ()\nlibsiri_error = ()\nlibsiri_xaxis = ()\n#print dictList_phase_change2[\'colocating with mcf\'][\'perlbench\']\nfor a in xrange(0,len(siriusrunningList),2):\n    j = siriusrunningList[a+1]\n    i = siriusrunningList[a]\n    #print j,i\n    #print dictList_phase_change2[j][i]\n    #print i,j\n    shutter_temp_list = []\n    colo_temp_list = []\n    for (count,item) in enumerate(dictList_phase_change2[j][i]):\n        if count%2==1:\n            colo_temp_list.append(float(item))\n        if count%2==0:\n            shutter_temp_list.append(float(item))\n    #print shutter_temp_list\n    shutter_avg = sum(shutter_temp_list)/len(shutter_temp_list)\n    colocation_avg = sum(colo_temp_list)/len(colo_temp_list)\n    del shutter_temp_list\n    del colo_temp_list\n\n    pause_period = ((colocation_avg ) + ((shutter_avg + (colocation_avg * 2)/3) * 3))/4\n    libsiri_xaxis = libsiri_xaxis + (i,)\n    #print (pause_period/np.mean(execution_time_sec_shutter[j][i]))*10\n    libsiri_yaxis = libsiri_yaxis + ( (pause_period/np.mean(execution_time_sec_shutter[j][i]))*10  ,)\n    libsiri_yaxis2 = libsiri_yaxis2 + ( abs(((np.mean(execution_time_sec_shutter2[j][i])/np.mean(execution_time_sec_shutter[j][i])) - 1)*100), )\n    #print np.mean(execution_time_sec_shutter2[j][i])\n    #print np.mean(execution_time_sec_shutter[j][i])\n    #print \'---------------------\'\n\n#print xaxis\n#print yaxis\n#print yaxis2\n#print np.mean(yaxis)\n\nbenchList = [ \'gcc\', \'perlbench\', \'leslie3d\', \'povray\', \'libquantum\', \'astar\', \'bzip2\', \'milc\', \'namd\', \'calculix\', \'h264ref\', \'sphinx3\', \'zeusmp\', \'gobmk\', \'hmmer\', \'tonto\', \'bwaves\', \'gromacs\', \'dealII\', \'sjeng\', \'lbm\', \'xalancbmk\', \'gamess\', \'soplex\', \'GemsFDTD\', \'omnetpp\', \'mcf\', \'cactusADM\' ]\n\ncolocationList = [ \'colocating with libquantum\', \'colocating with mcf\',  \'colocating with sphinx3\']\ncolocationListBaseline = [ \'colocating with libquantum\', \'colocating with mcf\', \'colocating with sphinx3\' ]\n\n\nrunningList = [  \'perlbench\', \'colocating with mcf\', \'mcf\', \'colocating with mcf\', \'leslie3d\', \'colocating with mcf\', \'povray\', \'colocating with mcf\', \'libquantum\', \'colocating with mcf\', \'astar\', \'colocating with mcf\', \'bzip2\', \'colocating with mcf\', \'milc\', \'colocating with mcf\', \'namd\', \'colocating with mcf\', \'calculix\', \'colocating with mcf\', \'h264ref\', \'colocating with mcf\', \'gobmk\', \'colocating with mcf\', \'hmmer\', \'colocating with mcf\', \'tonto\', \'colocating with mcf\', \'sphinx3\', \'colocating with mcf\', \'zeusmp\', \'colocating with mcf\', \'bwaves\', \'colocating with mcf\', \'gromacs\', \'colocating with mcf\', \'dealII\', \'colocating with mcf\', \'sjeng\', \'colocating with mcf\', \'lbm\', \'colocating with mcf\', \'xalancbmk\', \'colocating with mcf\', \'gamess\', \'colocating with mcf\', \'cactusADM\', \'colocating with mcf\', \'soplex\', \'colocating with mcf\', \'GemsFDTD\', \'colocating with mcf\', \'omnetpp\', \'colocating with mcf\' ]\n\nsiriusbenchList = [ \'gmm\', \'dnn_asr\', \'surf-fe\', \'surf-fd\', \'stem\', \'regex\', \'crf\', \'img-imc\', \'img-dig\', \'img-face\', \'nlp-pos\', \'nlp-chk\', \'nlp-ner\']\nsiriuscolocationList = [ \'colocating with lbm\', \'colocating with povray\', \'colocating with astar\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with mcf\' ]\nsiriusrunningList = [ \'gmm\', \'colocating with mcf\', \'dnn_asr\', \'colocating with mcf\', \'surf-fe\', \'colocating with mcf\', \'surf-fd\', \'colocating with mcf\', \'stem\', \'colocating with mcf\', \'regex\', \'colocating with mcf\', \'crf\', \'colocating with mcf\', \'img-imc\', \'colocating with mcf\', \'img-dig\', \'colocating with mcf\', \'img-face\', \'colocating with mcf\', \'nlp-pos\', \'colocating with mcf\', \'nlp-chk\', \'colocating with mcf\', \'nlp-ner\' , \'colocating with mcf\']\n\ndef autolabel(rects):\n    # attach some text labels\n    for rect in rects:\n        height = rect.get_height()\n        plt.text(rect.get_x()+rect.get_width()/2., 1.05*height, \'%.2f\'%float(height), fontsize=8 )\n\ndef autolabel2(rects):\n    # attach some text labels\n    for rect in rects:\n        height = rect.get_height()\n        plt.text(rect.get_x()+rect.get_width()/2., -1.25*height, \'%.2f\'%float(height),\n                ha=\'center\', va=\'top\', fontsize=8)\n        #plt.text(rect.get_x()+rect.get_width()/2., 1.05*height, \'%.2f\'%float(height))\n\ndef add_line(ax, xpos, ypos):\n    line = plt.Line2D([xpos, xpos], [ypos + .1, ypos - .5], transform=ax.transAxes, linewidth=2, color=\'black\')\n    line.set_clip_on(False)\n    ax.add_line(line)\n\n\nfilename = \'execution_time_1000\'\nfList1 = [s.strip() for s in open(\'../../papergraphs/accuracy/mcfcorunner/degradation/%s.txt\' % filename).readlines()]  #degradation\nfList2 = [s.strip() for s in open(\'../../papergraphs/accuracy/mcfcorunner/snapshot/phase_change_70.txt\').readlines()]\nfList3 = [s.strip() for s in open(\'../../papergraphs/accuracy/mcfcorunner/priorwork/execution_time_5.txt\').readlines()] #prior work\n\nfList4 = [s.strip() for s in open(\'../../papergraphs/accuracy/mcfcorunner/siriusdjinn/degradation/%s.txt\' % filename).readlines()]  #degradation\nfList5 = [s.strip() for s in open(\'../../papergraphs/accuracy/mcfcorunner/siriusdjinn/snapshot/phase_change_75.txt\').readlines()]\nfList6 = [s.strip() for s in open(\'../../papergraphs/accuracy/mcfcorunner/siriusdjinn/priorwork/execution_time_4.txt\').readlines()] #prior work\n\n\nexecution_time_shutter = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter = defaultdict(lambda  : defaultdict(list))\navg_execution_time_shutter = defaultdict(dict)\nexecution_time_shutter2 = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter2 = defaultdict(lambda  : defaultdict(list))\navg_execution_time_shutter2 = defaultdict(dict)\ndictList_phase_change = defaultdict(lambda  : defaultdict(list))\ndictList_phase_change2 = defaultdict(lambda  : defaultdict(list))\n\nstd_execution_time = defaultdict(dict)\n\ndef print_elapsed_time_shutter(time_shutter):\n    for j in colocationList:\n        for i in benchList:\n            print \'%s ||||  %s\'%(j,i)\n            print time_shutter[j][i]\n\n\nsep = \'u\'\nfor (b,a) in enumerate(fList1):\n    #print a\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            execution_time_shutter[index][a].append((fList1[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_shutter[\'colocating with mcf\'][\'perlbench\']\n#print((s.split(start))[1].split(end)[0])\n\nfor j in colocationList:\n    for i in benchList:\n        for k in execution_time_shutter[j][i]:\n            m,s = [float (var) for var in k.split(\':\')]\n            temp = m*60 + s\n            execution_time_sec_shutter[j][i].append(temp)\n\nfor (b,a) in enumerate(fList3):\n    #print a\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            #print index\n            #print a\n            execution_time_shutter2[index][a].append((fList3[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_shutter[\'colocating with mcf\'][\'perlbench\']\n#print((s.split(start))[1].split(end)[0])\n\nfor j in colocationList:\n    for i in benchList:\n        for k in execution_time_shutter2[j][i]:\n            #print k\n            m,s = [float (var) for var in k.split(\':\')]\n            temp = m*60 + s\n            execution_time_sec_shutter2[j][i].append(temp)\n\nfor (b,a) in enumerate(fList2):\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            dictList_phase_change[index][a].append(fList2[b+1])\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    #print j,i\n    for elem in dictList_phase_change[j][i]:\n        dictList_phase_change2[j][i].extend(elem.strip().split(\'\\t\'))\n    #print dictList_phase_change2[j][i]\n\nmcfyaxis = ()\nmcfyaxis2= ()\nmcfyaxis_abs = ()\nmcferror = ()\nmcfxaxis = ()\n#print dictList_phase_change2[\'colocating with mcf\'][\'perlbench\']\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    #print j,i\n    #print dictList_phase_change2[j][i]\n    #print i,j\n    shutter_temp_list = []\n    colo_temp_list = []\n    for (count,item) in enumerate(dictList_phase_change2[j][i]):\n        if count%2==1:\n            colo_temp_list.append(float(item))\n        if count%2==0:\n            shutter_temp_list.append(float(item))\n    #print shutter_temp_list\n    shutter_avg = sum(shutter_temp_list)/len(shutter_temp_list)\n    colocation_avg = sum(colo_temp_list)/len(colo_temp_list)\n    del shutter_temp_list\n    del colo_temp_list\n\n    pause_period = ((colocation_avg ) + ((shutter_avg + (colocation_avg * 2)/3) * 3))/4\n    mcfxaxis = mcfxaxis + (i,)\n    #print (pause_period/np.mean(execution_time_sec_shutter[j][i]))*10\n    mcfyaxis = mcfyaxis + ( (pause_period/np.mean(execution_time_sec_shutter[j][i]))*7.5  ,)\n    mcfyaxis2 = mcfyaxis2 + ( abs(((np.mean(execution_time_sec_shutter2[j][i])/np.mean(execution_time_sec_shutter[j][i])) - 1)*100), )\n    #print \'---------------------\'\n\n#print yaxis2\n#print np.mean(yaxis)\n\n\n#width = 0.25\n#x = np.arange(len(yaxis))\n#fig = plt.figure(figsize=(28, 5))\n#bar2 = plt.bar( x, yaxis2, width, color="k", label=\'Shuttering  (mean: %.2f)\' %(np.mean(yaxis2)))\n#bar1 = plt.bar( x+width, yaxis, width, color="lightgrey", label=\'Snapshot (mean: %.2f)\' %(np.mean(yaxis) ))\n\n#plt.ylabel( \'Execution time \\n overhead(%)\',fontsize=23)\n##plt.title(\'Overhead due to Prediction of degradation while co-running with MCF\')\n#plt.xticks(x + width/2.0, xaxis, rotation=\'30\', size=\'23\', ha=\'center\')\n##plt.yticks((-5,0,10,20,30,40,50,60),(\'\',\'0\',\'10\',\'20\',\'30\',\'40\',\'50\',\'60\'),size=\'25\')\n#plt.yticks((0,5,10,15),(\'0\',\'5\',\'10\',\'15\'),size=\'25\')\n#plt.xlim(-1,27)\n#plt.grid()\n#plt.legend(loc=9, ncol=2, prop={\'size\':28})\n#plt.tight_layout()\n##plt.savefig(\'phase_chagnge_overheadmaybe.png\', dpi=125)\n\ndel execution_time_shutter\ndel execution_time_sec_shutter\ndel avg_execution_time_shutter\ndel execution_time_shutter2\ndel execution_time_sec_shutter2\ndel avg_execution_time_shutter2\ndel dictList_phase_change\ndel dictList_phase_change2\n\nexecution_time_shutter = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter = defaultdict(lambda  : defaultdict(list))\navg_execution_time_shutter = defaultdict(dict)\nexecution_time_shutter2 = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter2 = defaultdict(lambda  : defaultdict(list))\navg_execution_time_shutter2 = defaultdict(dict)\ndictList_phase_change = defaultdict(lambda  : defaultdict(list))\ndictList_phase_change2 = defaultdict(lambda  : defaultdict(list))\n\nstd_execution_time = defaultdict(dict)\n\ndef print_elapsed_time_shutter(time_shutter):\n    for j in siriuscolocationList:\n        for i in siriusbenchList:\n            print \'%s ||||  %s\'%(j,i)\n            print time_shutter[j][i]\n\n\nsep = \'u\'\nfor (b,a) in enumerate(fList4):\n    #print a\n    if a in siriuscolocationList:\n        index = a\n    else:\n        if a in siriusbenchList:\n            execution_time_shutter[index][a].append((fList4[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_shutter[\'colocating with mcf\'][\'perlbench\']\n#print((s.split(start))[1].split(end)[0])\n\nfor j in siriuscolocationList:\n    for i in siriusbenchList:\n        #print i\n        for k in execution_time_shutter[j][i]:\n            try:\n                m,s = [float (var) for var in k.split(\':\')]\n                temp = m*60 + s\n            except:\n                h,m,s = [float (var) for var in k.split(\':\')]\n                temp = h*3600 + m*60 + s\n\n            execution_time_sec_shutter[j][i].append(temp)\n\n#print fList6\nfor (b,a) in enumerate(fList6):\n    #print a\n    if a in siriuscolocationList:\n        index = a\n    else:\n        if a in siriusbenchList:\n            #print index\n            #print a\n            #print fList6[b+4]\n            execution_time_shutter2[index][a].append((fList6[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_shutter[\'colocating with mcf\'][\'perlbench\']\n#print((s.split(start))[1].split(end)[0])\n\nfor j in siriuscolocationList:\n    for i in siriusbenchList:\n        for k in execution_time_shutter2[j][i]:\n            #print k\n            m,s = [float (var) for var in k.split(\':\')]\n            temp = m*60 + s\n            execution_time_sec_shutter2[j][i].append(temp)\n\nfor (b,a) in enumerate(fList5):\n    if a in siriuscolocationList:\n        index = a\n    else:\n        if a in siriusbenchList:\n            dictList_phase_change[index][a].append(fList5[b+1])\n\nfor a in xrange(0,len(siriusrunningList),2):\n    j = siriusrunningList[a+1]\n    i = siriusrunningList[a]\n    #print j,i\n    for elem in dictList_phase_change[j][i]:\n        dictList_phase_change2[j][i].extend(elem.strip().split(\'\\t\'))\n    #print dictList_phase_change2[j][i]\n\nmcfsiri_yaxis = ()\nmcfsiri_yaxis2= ()\nmcfsiri_yaxis_abs = ()\nmcfsiri_error = ()\nmcfsiri_xaxis = ()\n#print dictList_phase_change2[\'colocating with mcf\'][\'perlbench\']\nfor a in xrange(0,len(siriusrunningList),2):\n    j = siriusrunningList[a+1]\n    i = siriusrunningList[a]\n    print j,i\n    #print dictList_phase_change2[j][i]\n    #print i,j\n    shutter_temp_list = []\n    colo_temp_list = []\n    for (count,item) in enumerate(dictList_phase_change2[j][i]):\n        if count%2==1:\n            colo_temp_list.append(float(item))\n        if count%2==0:\n            shutter_temp_list.append(float(item))\n    #print shutter_temp_list\n    shutter_avg = sum(shutter_temp_list)/len(shutter_temp_list)\n    colocation_avg = sum(colo_temp_list)/len(colo_temp_list)\n    del shutter_temp_list\n    del colo_temp_list\n\n    pause_period = ((colocation_avg ) + ((shutter_avg + (colocation_avg * 2)/3) * 3))/4\n    mcfsiri_xaxis = mcfsiri_xaxis + (i,)\n    #print (pause_period/np.mean(execution_time_sec_shutter[j][i]))*10\n    mcfsiri_yaxis = mcfsiri_yaxis + ( (pause_period/np.mean(execution_time_sec_shutter[j][i]))*10  ,)\n    mcfsiri_yaxis2 = mcfsiri_yaxis2 + ( abs(((np.mean(execution_time_sec_shutter2[j][i])/np.mean(execution_time_sec_shutter[j][i])) - 1)*100), )\n    print execution_time_sec_shutter2[j][i]\n    print execution_time_sec_shutter[j][i]\n    #print np.mean(execution_time_sec_shutter2[j][i])\n    #print np.mean(execution_time_sec_shutter[j][i])\n    #print \'---------------------\'\n\n#print xaxis\n#print yaxis\n#print yaxis2\n#print np.mean(yaxis)\n\nbenchList = [ \'gcc\', \'perlbench\', \'leslie3d\', \'povray\', \'libquantum\', \'astar\', \'bzip2\', \'milc\', \'namd\', \'calculix\', \'h264ref\', \'sphinx3\', \'zeusmp\', \'gobmk\', \'hmmer\', \'tonto\', \'bwaves\', \'gromacs\', \'dealII\', \'sjeng\', \'lbm\', \'xalancbmk\', \'gamess\', \'soplex\', \'GemsFDTD\', \'omnetpp\', \'mcf\', \'cactusADM\' ]\ncolocationList = [ \'colocating with libquantum\', \'colocating with mcf\',  \'colocating with milc\']\ncolocationListBaseline = [ \'colocating with libquantum\', \'colocating with mcf\', \'colocating with milc\' ]\n\nrunningList = [  \'perlbench\', \'colocating with milc\', \'mcf\', \'colocating with milc\', \'leslie3d\', \'colocating with milc\', \'povray\', \'colocating with milc\', \'libquantum\', \'colocating with milc\', \'astar\', \'colocating with milc\', \'bzip2\', \'colocating with milc\', \'milc\', \'colocating with milc\', \'namd\', \'colocating with milc\', \'calculix\', \'colocating with milc\', \'h264ref\', \'colocating with milc\', \'gobmk\', \'colocating with milc\', \'hmmer\', \'colocating with milc\', \'tonto\', \'colocating with milc\', \'sphinx3\', \'colocating with milc\', \'zeusmp\', \'colocating with milc\', \'bwaves\', \'colocating with milc\', \'gromacs\', \'colocating with milc\', \'dealII\', \'colocating with milc\', \'sjeng\', \'colocating with milc\', \'lbm\', \'colocating with milc\', \'xalancbmk\', \'colocating with milc\', \'gamess\', \'colocating with milc\', \'cactusADM\', \'colocating with milc\', \'soplex\', \'colocating with milc\', \'GemsFDTD\', \'colocating with milc\', \'omnetpp\', \'colocating with milc\' ]\n\nsiriusbenchList = [ \'gmm\', \'dnn_asr\', \'surf-fe\', \'surf-fd\', \'stem\', \'regex\', \'crf\', \'img-imc\', \'img-dig\', \'img-face\', \'nlp-pos\', \'nlp-chk\', \'nlp-ner\']\nsiriuscolocationList = [ \'colocating with milc\', \'colocating with povray\', \'colocating with astar\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with mcf\' ]\nsiriusrunningList = [ \'gmm\', \'colocating with milc\', \'dnn_asr\', \'colocating with milc\', \'surf-fe\', \'colocating with milc\', \'surf-fd\', \'colocating with milc\', \'stem\', \'colocating with milc\', \'regex\', \'colocating with milc\', \'crf\', \'colocating with milc\', \'img-imc\', \'colocating with milc\', \'img-dig\', \'colocating with milc\', \'img-face\', \'colocating with milc\', \'nlp-pos\', \'colocating with milc\', \'nlp-chk\', \'colocating with milc\', \'nlp-ner\' , \'colocating with milc\']\n#colocationListBaseline = [ \'colocating with gcc\', \'colocating with mcf\', \'colocating with perlbench\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with lbm\' ]\ndef autolabel(rects):\n    # attach some text labels\n    for rect in rects:\n        height = rect.get_height()\n        plt.text(rect.get_x()+rect.get_width()/2., 1.05*height, \'%.2f\'%float(height), fontsize=8 )\n\ndef autolabel2(rects):\n    # attach some text labels\n    for rect in rects:\n        height = rect.get_height()\n        plt.text(rect.get_x()+rect.get_width()/2., -1.25*height, \'%.2f\'%float(height),\n                ha=\'center\', va=\'top\', fontsize=8)\n        #plt.text(rect.get_x()+rect.get_width()/2., 1.05*height, \'%.2f\'%float(height))\n\ndef add_line(ax, xpos, ypos):\n    line = plt.Line2D([xpos, xpos], [ypos + .1, ypos - .5], transform=ax.transAxes, linewidth=2, color=\'black\')\n    line.set_clip_on(False)\n    ax.add_line(line)\n\nfilename = \'execution_time_1000\'\nfList1 = [s.strip() for s in open(\'../../papergraphs/accuracy/milccorunner/degradation/%s.txt\' % filename).readlines()]  #degradation\nfList2 = [s.strip() for s in open(\'../../papergraphs/accuracy/milccorunner/snapshot/phase_change_70.txt\').readlines()]\nfList3 = [s.strip() for s in open(\'../../papergraphs/accuracy/milccorunner/priorwork/execution_time_5.txt\').readlines()] #prior work\n\nfList4 = [s.strip() for s in open(\'../../papergraphs/accuracy/milccorunner/siriusdjinn/degradation/%s.txt\' % filename).readlines()]  #degradation\nfList5 = [s.strip() for s in open(\'../../papergraphs/accuracy/milccorunner/siriusdjinn/snapshot/phase_change_75.txt\').readlines()]\nfList6 = [s.strip() for s in open(\'../../papergraphs/accuracy/milccorunner/siriusdjinn/priorwork/execution_time_4.txt\').readlines()] #prior work\n\nexecution_time_shutter = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter = defaultdict(lambda  : defaultdict(list))\navg_execution_time_shutter = defaultdict(dict)\nexecution_time_shutter2 = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter2 = defaultdict(lambda  : defaultdict(list))\navg_execution_time_shutter2 = defaultdict(dict)\ndictList_phase_change = defaultdict(lambda  : defaultdict(list))\ndictList_phase_change2 = defaultdict(lambda  : defaultdict(list))\n\nstd_execution_time = defaultdict(dict)\n\ndef print_elapsed_time_shutter(time_shutter):\n    for j in colocationList:\n        for i in benchList:\n            print \'%s ||||  %s\'%(j,i)\n            print time_shutter[j][i]\n\n\nsep = \'u\'\nfor (b,a) in enumerate(fList1):\n    #print a\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            execution_time_shutter[index][a].append((fList1[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_shutter[\'colocating with mcf\'][\'perlbench\']\n#print((s.split(start))[1].split(end)[0])\n\nfor j in colocationList:\n    for i in benchList:\n        for k in execution_time_shutter[j][i]:\n            m,s = [float (var) for var in k.split(\':\')]\n            temp = m*60 + s\n            execution_time_sec_shutter[j][i].append(temp)\n\nfor (b,a) in enumerate(fList3):\n    #print a\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            #print index\n            #print a\n            execution_time_shutter2[index][a].append((fList3[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_shutter[\'colocating with mcf\'][\'perlbench\']\n#print((s.split(start))[1].split(end)[0])\n\nfor j in colocationList:\n    for i in benchList:\n        for k in execution_time_shutter2[j][i]:\n            #print k\n            m,s = [float (var) for var in k.split(\':\')]\n            temp = m*60 + s\n            execution_time_sec_shutter2[j][i].append(temp)\n\nfor (b,a) in enumerate(fList2):\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            dictList_phase_change[index][a].append(fList2[b+1])\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    #print j,i\n    for elem in dictList_phase_change[j][i]:\n        dictList_phase_change2[j][i].extend(elem.strip().split(\'\\t\'))\n    #print dictList_phase_change2[j][i]\n\nmilcyaxis = ()\nmilcyaxis2= ()\nmilcyaxis_abs = ()\nmilcerror = ()\nmilcxaxis = ()\n#print dictList_phase_change2[\'colocating with mcf\'][\'perlbench\']\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    #print j,i\n    #print dictList_phase_change2[j][i]\n    #print i,j\n    shutter_temp_list = []\n    colo_temp_list = []\n    for (count,item) in enumerate(dictList_phase_change2[j][i]):\n        if count%2==1:\n            colo_temp_list.append(float(item))\n        if count%2==0:\n            shutter_temp_list.append(float(item))\n    #print shutter_temp_list\n    shutter_avg = sum(shutter_temp_list)/len(shutter_temp_list)\n    colocation_avg = sum(colo_temp_list)/len(colo_temp_list)\n    del shutter_temp_list\n    del colo_temp_list\n\n    pause_period = ((colocation_avg ) + ((shutter_avg + (colocation_avg * 2)/3) * 3))/4\n    milcxaxis = milcxaxis + (i,)\n    #print (pause_period/np.mean(execution_time_sec_shutter[j][i]))*10\n    milcyaxis = milcyaxis + ( (pause_period/np.mean(execution_time_sec_shutter[j][i]))*7.5  ,)\n    milcyaxis2 = milcyaxis2 + ( abs(((np.mean(execution_time_sec_shutter2[j][i])/np.mean(execution_time_sec_shutter[j][i])) - 1)*100), )\n    #print \'---------------------\'\n\n#print yaxis2\n#print np.mean(yaxis)\n\n\n#width = 0.25\n#x = np.arange(len(yaxis))\n#fig = plt.figure(figsize=(28, 5))\n#bar2 = plt.bar( x, yaxis2, width, color="k", label=\'Shuttering  (mean: %.2f)\' %(np.mean(yaxis2)))\n#bar1 = plt.bar( x+width, yaxis, width, color="lightgrey", label=\'Snapshot (mean: %.2f)\' %(np.mean(yaxis) ))\n##bar3 = plt.bar( x+width+width, yaxis3, width, color="g", label=\' colocating with sphinx3 (avg = %.1f)\' %(np.mean(yaxis3)))\n###bar3 = plt.bar( x+width+width, yaxis3, width, color="g", label=\'4 corunners (avg is %.1f)\' %(np.mean(yaxis3) ))\n###autolabel2(bar1)\n###autolabel(bar2)\n###autolabel2(bar3)\n#plt.ylabel( \'Execution time \\n overhead(%)\',fontsize=23)\n##plt.title(\'Overhead due to Prediction of degradation while co-running with milc\')\n#plt.xticks(x + width/2.0, xaxis, rotation=\'30\', size=\'23\', ha=\'center\')\n##plt.yticks((-5,0,10,20,30,40,50,60),(\'\',\'0\',\'10\',\'20\',\'30\',\'40\',\'50\',\'60\'),size=\'25\')\n#plt.yticks((0,5,10,15),(\'0\',\'5\',\'10\',\'15\'),size=\'25\')\n#plt.xlim(-1,27)\n#plt.grid()\n#plt.legend(loc=9, ncol=2, prop={\'size\':28})\n#plt.tight_layout()\n##plt.savefig(\'phase_chagnge_overheadmaybe.png\', dpi=125)\n\ndel execution_time_shutter\ndel execution_time_sec_shutter\ndel avg_execution_time_shutter\ndel execution_time_shutter2\ndel execution_time_sec_shutter2\ndel avg_execution_time_shutter2\ndel dictList_phase_change\ndel dictList_phase_change2\n\nexecution_time_shutter = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter = defaultdict(lambda  : defaultdict(list))\navg_execution_time_shutter = defaultdict(dict)\nexecution_time_shutter2 = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter2 = defaultdict(lambda  : defaultdict(list))\navg_execution_time_shutter2 = defaultdict(dict)\ndictList_phase_change = defaultdict(lambda  : defaultdict(list))\ndictList_phase_change2 = defaultdict(lambda  : defaultdict(list))\n\nstd_execution_time = defaultdict(dict)\n\ndef print_elapsed_time_shutter(time_shutter):\n    for j in siriuscolocationList:\n        for i in siriusbenchList:\n            print \'%s ||||  %s\'%(j,i)\n            print time_shutter[j][i]\n\n\nsep = \'u\'\nfor (b,a) in enumerate(fList4):\n    #print a\n    if a in siriuscolocationList:\n        index = a\n    else:\n        if a in siriusbenchList:\n            execution_time_shutter[index][a].append((fList4[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_shutter[\'colocating with mcf\'][\'perlbench\']\n#print((s.split(start))[1].split(end)[0])\n\nfor j in siriuscolocationList:\n    for i in siriusbenchList:\n        #print i\n        for k in execution_time_shutter[j][i]:\n            try:\n                m,s = [float (var) for var in k.split(\':\')]\n                temp = m*60 + s\n            except:\n                h,m,s = [float (var) for var in k.split(\':\')]\n                temp = h*3600 + m*60 + s\n\n            execution_time_sec_shutter[j][i].append(temp)\n\n#print fList6\nfor (b,a) in enumerate(fList6):\n    #print a\n    if a in siriuscolocationList:\n        index = a\n    else:\n        if a in siriusbenchList:\n            print index\n            print a\n            print fList6[b+4]\n            execution_time_shutter2[index][a].append((fList6[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_shutter[\'colocating with mcf\'][\'perlbench\']\n#print((s.split(start))[1].split(end)[0])\n\nfor j in siriuscolocationList:\n    for i in siriusbenchList:\n        for k in execution_time_shutter2[j][i]:\n            #print k\n            m,s = [float (var) for var in k.split(\':\')]\n            temp = m*60 + s\n            execution_time_sec_shutter2[j][i].append(temp)\n\nfor (b,a) in enumerate(fList5):\n    if a in siriuscolocationList:\n        index = a\n    else:\n        if a in siriusbenchList:\n            dictList_phase_change[index][a].append(fList5[b+1])\n\nfor a in xrange(0,len(siriusrunningList),2):\n    j = siriusrunningList[a+1]\n    i = siriusrunningList[a]\n    #print j,i\n    for elem in dictList_phase_change[j][i]:\n        dictList_phase_change2[j][i].extend(elem.strip().split(\'\\t\'))\n    #print dictList_phase_change2[j][i]\n\nmilcsiri_yaxis = ()\nmilcsiri_yaxis2= ()\nmilcsiri_yaxis_abs = ()\nmilcsiri_error = ()\nmilcsiri_xaxis = ()\n#print dictList_phase_change2[\'colocating with mcf\'][\'perlbench\']\nfor a in xrange(0,len(siriusrunningList),2):\n    j = siriusrunningList[a+1]\n    i = siriusrunningList[a]\n    print j,i\n    #print dictList_phase_change2[j][i]\n    shutter_temp_list = []\n    colo_temp_list = []\n    for (count,item) in enumerate(dictList_phase_change2[j][i]):\n        if count%2==1:\n            colo_temp_list.append(float(item))\n        if count%2==0:\n            shutter_temp_list.append(float(item))\n    #print shutter_temp_list\n    #print colo_temp_list\n    shutter_avg = sum(shutter_temp_list)/len(shutter_temp_list)\n    colocation_avg = sum(colo_temp_list)/len(colo_temp_list)\n    del shutter_temp_list\n    del colo_temp_list\n\n    pause_period = ((colocation_avg ) + ((shutter_avg + (colocation_avg * 2)/3) * 3))/4\n    milcsiri_xaxis = milcsiri_xaxis + (i,)\n    #print (pause_period/np.mean(execution_time_sec_shutter[j][i]))*10\n    milcsiri_yaxis = milcsiri_yaxis + ( (pause_period/np.mean(execution_time_sec_shutter[j][i]))*10  ,)\n    milcsiri_yaxis2 = milcsiri_yaxis2 + ( abs(((np.mean(execution_time_sec_shutter2[j][i])/np.mean(execution_time_sec_shutter[j][i])) - 1)*100), )\n    print execution_time_sec_shutter2[j][i]\n    print execution_time_sec_shutter[j][i]\n    #print np.mean(execution_time_sec_shutter2[j][i])\n    #print np.mean(execution_time_sec_shutter[j][i])\n    #print \'---------------------\'\n\n#print xaxis\n#print yaxis\n#print yaxis2\n#print np.mean(yaxis)\n\nbenchList = [ \'gcc\', \'perlbench\', \'leslie3d\', \'povray\', \'libquantum\', \'astar\', \'bzip2\', \'milc\', \'namd\', \'calculix\', \'h264ref\', \'sphinx3\', \'zeusmp\', \'gobmk\', \'hmmer\', \'tonto\', \'bwaves\', \'gromacs\', \'dealII\', \'sjeng\', \'lbm\', \'xalancbmk\', \'gamess\', \'soplex\', \'GemsFDTD\', \'omnetpp\', \'mcf\', \'cactusADM\' ]\n\ncolocationList = [ \'colocating with libquantum\', \'colocating with mcf\',  \'colocating with milc\']\ncolocationListBaseline = [ \'colocating with libquantum\', \'colocating with mcf\', \'colocating with milc\' ]\n\nrunningList = [  \'perlbench\', \'colocating with milc\', \'mcf\', \'colocating with milc\', \'leslie3d\', \'colocating with milc\', \'povray\', \'colocating with milc\', \'libquantum\', \'colocating with milc\', \'astar\', \'colocating with milc\', \'bzip2\', \'colocating with milc\', \'milc\', \'colocating with milc\', \'namd\', \'colocating with milc\', \'calculix\', \'colocating with milc\', \'h264ref\', \'colocating with milc\', \'gobmk\', \'colocating with milc\', \'hmmer\', \'colocating with milc\', \'tonto\', \'colocating with milc\', \'sphinx3\', \'colocating with milc\', \'zeusmp\', \'colocating with milc\',    \'bwaves\', \'colocating with milc\', \'gromacs\', \'colocating with milc\', \'dealII\', \'colocating with milc\', \'sjeng\', \'colocating with milc\', \'lbm\', \'colocating with milc\', \'xalancbmk\', \'colocating with milc\', \'gamess\', \'colocating with milc\', \'cactusADM\', \'colocating with milc\', \'soplex\', \'colocating with milc\', \'GemsFDTD\', \'colocating with milc\', \'omnetpp\', \'colocating with milc\' ]\nrunningList2 = [  \'leslie3d\', \'colocating with milc\', \'milc\', \'colocating with milc\', \'namd\', \'colocating with milc\', \'calculix\', \'colocating with milc\', \'gobmk\', \'colocating with milc\', \'hmmer\', \'colocating with milc\', \'tonto\', \'colocating with milc\', \'sphinx3\', \'colocating with milc\', \'zeusmp\', \'colocating with milc\', \'bwaves\', \'colocating with milc\', \'gromacs\', \'colocating with milc\', \'dealII\', \'colocating with milc\', \'sjeng\', \'colocating with milc\', \'gamess\', \'colocating with milc\', \'cactusADM\', \'colocating with milc\', \'soplex\', \'colocating with milc\', \'GemsFDTD\', \'colocating with milc\' ]\nrunningList3 = [  \'perlbench\', \'colocating with milc\', \'mcf\', \'colocating with milc\', \'povray\', \'colocating with milc\', \'libquantum\', \'colocating with milc\', \'astar\', \'colocating with milc\', \'bzip2\', \'colocating with milc\', \'h264ref\', \'colocating with milc\',  \'lbm\', \'colocating with milc\', \'xalancbmk\', \'colocating with milc\', \'omnetpp\', \'colocating with milc\' ]\n\nsiriusbenchList = [ \'gmm\', \'dnn_asr\', \'surf-fe\', \'surf-fd\', \'stem\', \'regex\', \'crf\', \'img-imc\', \'img-dig\', \'img-face\', \'nlp-pos\', \'nlp-chk\', \'nlp-ner\']\nsiriuscolocationList = [ \'colocating with lbm\', \'colocating with povray\', \'colocating with astar\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with mcf\' ]\nsiriusrunningList = [ \'gmm\', \'colocating with libquantum\', \'dnn_asr\', \'colocating with libquantum\', \'surf-fe\', \'colocating with libquantum\', \'surf-fd\', \'colocating with libquantum\', \'stem\', \'colocating with libquantum\', \'regex\', \'colocating with libquantum\', \'crf\', \'colocating with libquantum\', \'img-imc\', \'colocating with libquantum\', \'img-dig\', \'colocating with libquantum\', \'img-face\', \'colocating with libquantum\', \'nlp-pos\', \'colocating with libquantum\', \'nlp-chk\', \'colocating with libquantum\', \'nlp-ner\' , \'colocating with libquantum\']\n\ndef autolabel(rects):\n    # attach some text labels\n    for rect in rects:\n        height = rect.get_height()\n        plt.text(rect.get_x()+rect.get_width()/2., 1.05*height, \'%.2f\'%float(height), fontsize=8 )\n\ndef autolabel2(rects):\n    # attach some text labels\n    for rect in rects:\n        height = rect.get_height()\n        plt.text(rect.get_x()+rect.get_width()/2., -1.25*height, \'%.2f\'%float(height),\n                ha=\'center\', va=\'top\', fontsize=8)\n        #plt.text(rect.get_x()+rect.get_width()/2., 1.05*height, \'%.2f\'%float(height))\n\ndef add_line(ax, xpos, ypos):\n    line = plt.Line2D([xpos, xpos], [ypos + .1, ypos - .5], transform=ax.transAxes, linewidth=2, color=\'black\')\n    line.set_clip_on(False)\n    ax.add_line(line)\n\n\nfilename = \'execution_time_1000\'\nfList1 = [s.strip() for s in open(\'../../papergraphs/mixcorunner/degradation/%s.txt\' % filename).readlines()]  #degradation\nfList2 = [s.strip() for s in open(\'../../papergraphs/mixcorunner/snapshot/phase_change_10.txt\').readlines()]\nfList3 = [s.strip() for s in open(\'../../papergraphs/mixcorunner/priorwork/execution_time_4.txt\').readlines()] #prior work\nfList4 = [s.strip() for s in open(\'../../papergraphs/mixcorunner/degradation/execution_time_100.txt\').readlines()]  #degradation\n\nfList7 = [s.strip() for s in open(\'../../papergraphs/mixcorunner/siriusdjinn/degradation/%s.txt\' % filename).readlines()]  #degradation\nfList5 = [s.strip() for s in open(\'../../papergraphs/mixcorunner/siriusdjinn/snapshot/phase_change_75.txt\').readlines()]\nfList6 = [s.strip() for s in open(\'../../papergraphs/mixcorunner/siriusdjinn/priorwork/execution_time_4.txt\').readlines()] #prior work\n\nexecution_time_shutter = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter = defaultdict(lambda  : defaultdict(list))\navg_execution_time_shutter = defaultdict(dict)\nexecution_time_shutter2 = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter2 = defaultdict(lambda  : defaultdict(list))\navg_execution_time_shutter2 = defaultdict(dict)\ndictList_phase_change = defaultdict(lambda  : defaultdict(list))\ndictList_phase_change2 = defaultdict(lambda  : defaultdict(list))\noverhead_snapshot = defaultdict(lambda  : defaultdict(list))\noverhead_shutter = defaultdict(lambda  : defaultdict(list))\n\nstd_execution_time = defaultdict(dict)\n\ndef print_elapsed_time_shutter(time_shutter):\n    for j in colocationList:\n        for i in benchList:\n            print \'%s ||||  %s\'%(j,i)\n            print time_shutter[j][i]\n\n\nsep = \'u\'\nfor (b,a) in enumerate(fList1):\n    #print a\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            execution_time_shutter[index][a].append((fList1[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_shutter[\'colocating with mcf\'][\'perlbench\']\n#print((s.split(start))[1].split(end)[0])\n\nfor j in colocationList:\n    for i in benchList:\n        #print i\n        for k in execution_time_shutter[j][i]:\n            try:\n                #print k\n                m,s = [float (var) for var in k.split(\':\')]\n                temp = m*60 + s\n            except:\n                h,m,s = [float (var) for var in k.split(\':\')]\n                temp = h*3600 + m*60 + s\n            execution_time_sec_shutter[j][i].append(temp)\n\nfor (b,a) in enumerate(fList3):\n    #print a\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            #print index\n            #print a\n            execution_time_shutter2[index][a].append((fList3[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_shutter[\'colocating with mcf\'][\'perlbench\']\n#print((s.split(start))[1].split(end)[0])\n\nfor j in colocationList:\n    for i in benchList:\n        for k in execution_time_shutter2[j][i]:\n            #print k\n            try:\n                m,s = [float (var) for var in k.split(\':\')]\n                temp = m*60 + s\n            except:\n                h,m,s = [float (var) for var in k.split(\':\')]\n                temp = h*3600 + m*60 + s\n            execution_time_sec_shutter2[j][i].append(temp)\n\nfor (b,a) in enumerate(fList2):\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            dictList_phase_change[index][a].append(fList2[b+1])\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    #print j,i\n    for elem in dictList_phase_change[j][i]:\n        dictList_phase_change2[j][i].extend(elem.strip().split(\'\\t\'))\n    #print dictList_phase_change2[j][i]\n\nmixyaxis = ()\nmixyaxis2= ()\nmixyaxis_abs = ()\nmixerror = ()\nmixxaxis = ()\n#print dictList_phase_change2[\'colocating with mcf\'][\'perlbench\']\nfor a in xrange(0,len(runningList2),2):\n    j = runningList2[a+1]\n    i = runningList2[a]\n    #print j,i\n    #print dictList_phase_change2[j][i]\n    #print i,j\n    shutter_temp_list = []\n    colo_temp_list = []\n    for (count,item) in enumerate(dictList_phase_change2[j][i]):\n        if count%2==1:\n            colo_temp_list.append(float(item))\n        if count%2==0:\n            shutter_temp_list.append(float(item))\n    #print shutter_temp_list\n    shutter_avg = sum(shutter_temp_list)/len(shutter_temp_list)\n    colocation_avg = sum(colo_temp_list)/len(colo_temp_list)\n    del shutter_temp_list\n    del colo_temp_list\n\n    pause_period = ((colocation_avg ) + ((shutter_avg + (colocation_avg * 2)/3) * 3))/4\n    #xaxis = xaxis + (i,)\n    #print (pause_period/np.mean(execution_time_sec_shutter[j][i]))*10\n    overhead_snapshot[j][i] = (pause_period/np.mean(execution_time_sec_shutter[j][i]))*7.5\n    overhead_shutter[j][i] = abs(((np.mean(execution_time_sec_shutter2[j][i])/np.mean(execution_time_sec_shutter[j][i])) - 1)*100)\n    #yaxis = yaxis + ( (pause_period/np.mean(execution_time_sec_shutter[j][i]))*7.5  ,)\n    #yaxis2 = yaxis2 + ( abs(((np.mean(execution_time_sec_shutter2[j][i])/np.mean(execution_time_sec_shutter[j][i])) - 1)*100), )\n    #print \'---------------------\'\n\n\nfor a in xrange(0,len(runningList3),2):\n    j = runningList3[a+1]\n    i = runningList3[a]\n    #print j,i,execution_time_sec_shutter2[j][i],execution_time_sec_shutter[j][i]\n\n    #pause_period = ((colocation_avg ) + ((shutter_avg + (colocation_avg * 2)/3) * 3))/4\n    #xaxis = xaxis + (i,)\n    #print (pause_period/np.mean(execution_time_sec_shutter[j][i]))*10\n    #yaxis = yaxis + ( (pause_period/np.mean(execution_time_sec_shutter[j][i]))*7.5  ,)\n    overhead_shutter[j][i] = abs(((np.mean(execution_time_sec_shutter2[j][i])/np.mean(execution_time_sec_shutter[j][i])) - 1)*100)\n    #yaxis2 = yaxis2 + ( abs(((np.mean(execution_time_sec_shutter2[j][i])/np.mean(execution_time_sec_shutter[j][i])) - 1)*100), )\n#print np.mean(yaxis)\n\ndel execution_time_shutter\ndel execution_time_sec_shutter\n\nexecution_time_shutter = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter = defaultdict(lambda  : defaultdict(list))\n\n\nsep = \'u\'\nfor (b,a) in enumerate(fList4):\n    #print a\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            execution_time_shutter[index][a].append((fList4[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_shutter[\'colocating with mcf\'][\'perlbench\']\n#print((s.split(start))[1].split(end)[0])\n\nfor j in colocationList:\n    for i in benchList:\n        #print i\n        for k in execution_time_shutter[j][i]:\n            try:\n                #print k\n                m,s = [float (var) for var in k.split(\':\')]\n                temp = m*60 + s\n            except:\n                h,m,s = [float (var) for var in k.split(\':\')]\n                temp = h*3600 + m*60 + s\n            execution_time_sec_shutter[j][i].append(temp)\n\nfor a in xrange(0,len(runningList3),2):\n    j = runningList3[a+1]\n    i = runningList3[a]\n    #print j,i\n    #print dictList_phase_change2[j][i]\n    #print i,j\n    shutter_temp_list = []\n    colo_temp_list = []\n    for (count,item) in enumerate(dictList_phase_change2[j][i]):\n        if count%2==1:\n            colo_temp_list.append(float(item))\n        if count%2==0:\n            shutter_temp_list.append(float(item))\n    #print shutter_temp_list\n    shutter_avg = sum(shutter_temp_list)/len(shutter_temp_list)\n    colocation_avg = sum(colo_temp_list)/len(colo_temp_list)\n    del shutter_temp_list\n    del colo_temp_list\n\n    pause_period = ((colocation_avg ) + ((shutter_avg + (colocation_avg * 2)/3) * 3))/4\n    #xaxis = xaxis + (i,)\n    #print (pause_period/np.mean(execution_time_sec_shutter[j][i]))*10\n    #yaxis = yaxis + ( (pause_period/np.mean(execution_time_sec_shutter[j][i]))*7.5  ,)\n    overhead_snapshot[j][i] = (pause_period/np.mean(execution_time_sec_shutter[j][i]))*7.5\n    #yaxis2 = yaxis2 + ( abs(((np.mean(execution_time_sec_shutter2[j][i])/np.mean(execution_time_sec_shutter[j][i])) - 1)*100), )\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    mixxaxis = mixxaxis + (i,)\n    mixyaxis = mixyaxis + ( overhead_snapshot[j][i]  ,)\n    mixyaxis2 = mixyaxis2 + ( overhead_shutter[j][i], )\n\n#print yaxis\n#print yaxis2\n\n\n#width = 0.25\n#x = np.arange(len(yaxis))\n#fig = plt.figure(figsize=(28, 5))\n#bar2 = plt.bar( x, yaxis2, width, color="k", label=\'Shuttering  (mean: %.2f)\' %(np.mean(yaxis2)))\n#bar1 = plt.bar( x+width, yaxis, width, color="lightgrey", label=\'Snapshot (mean: %.2f)\' %(np.mean(yaxis) ))\n##bar3 = plt.bar( x+width+width, yaxis3, width, color="g", label=\' colocating with sphinx3 (avg = %.1f)\' %(np.mean(yaxis3)))\n###bar3 = plt.bar( x+width+width, yaxis3, width, color="g", label=\'4 corunners (avg is %.1f)\' %(np.mean(yaxis3) ))\n###autolabel2(bar1)\n###autolabel(bar2)\n###autolabel2(bar3)\n#plt.ylabel( \'Execution time \\n overhead(%)\',fontsize=23)\n##plt.title(\'Overhead due to Prediction of degradation while co-running with milc\')\n#plt.xticks(x + width/2.0, xaxis, rotation=\'30\', size=\'23\', ha=\'center\')\n##plt.yticks((-5,0,10,20,30,40,50,60),(\'\',\'0\',\'10\',\'20\',\'30\',\'40\',\'50\',\'60\'),size=\'25\')\n#plt.yticks((0,5,10,15),(\'0\',\'5\',\'10\',\'15\'),size=\'25\')\n#plt.xlim(-1,27)\n#plt.grid()\n#plt.legend(loc=9, ncol=2, prop={\'size\':28})\n#plt.tight_layout()\n##plt.savefig(\'milc_overhead.pdf\', dpi=125)\n\ndel execution_time_shutter\ndel execution_time_sec_shutter\ndel avg_execution_time_shutter\ndel execution_time_shutter2\ndel execution_time_sec_shutter2\ndel avg_execution_time_shutter2\ndel dictList_phase_change\ndel dictList_phase_change2\n\nexecution_time_shutter = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter = defaultdict(lambda  : defaultdict(list))\navg_execution_time_shutter = defaultdict(dict)\nexecution_time_shutter2 = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter2 = defaultdict(lambda  : defaultdict(list))\navg_execution_time_shutter2 = defaultdict(dict)\ndictList_phase_change = defaultdict(lambda  : defaultdict(list))\ndictList_phase_change2 = defaultdict(lambda  : defaultdict(list))\n\nstd_execution_time = defaultdict(dict)\n\ndef print_elapsed_time_shutter(time_shutter):\n    for j in siriuscolocationList:\n        for i in siriusbenchList:\n            print \'%s ||||  %s\'%(j,i)\n            print time_shutter[j][i]\n\n\nsep = \'u\'\nfor (b,a) in enumerate(fList7):\n    #print a\n    if a in siriuscolocationList:\n        index = a\n    else:\n        if a in siriusbenchList:\n            #print a\n            #print fList7[b+4]\n            execution_time_shutter[index][a].append((fList7[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_shutter[\'colocating with mcf\'][\'perlbench\']\n#print((s.split(start))[1].split(end)[0])\n\nfor j in siriuscolocationList:\n    for i in siriusbenchList:\n        #print i\n        for k in execution_time_shutter[j][i]:\n            try:\n                m,s = [float (var) for var in k.split(\':\')]\n                temp = m*60 + s\n            except:\n                h,m,s = [float (var) for var in k.split(\':\')]\n                temp = h*3600 + m*60 + s\n\n            execution_time_sec_shutter[j][i].append(temp)\n\nfor (b,a) in enumerate(fList6):\n    #print a\n    if a in siriuscolocationList:\n        index = a\n    else:\n        if a in siriusbenchList:\n            #print index\n            #print a\n            execution_time_shutter2[index][a].append((fList6[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_shutter[\'colocating with mcf\'][\'perlbench\']\n#print((s.split(start))[1].split(end)[0])\n\nfor j in siriuscolocationList:\n    for i in siriusbenchList:\n        for k in execution_time_shutter2[j][i]:\n            #print k\n            m,s = [float (var) for var in k.split(\':\')]\n            temp = m*60 + s\n            execution_time_sec_shutter2[j][i].append(temp)\n\nfor (b,a) in enumerate(fList5):\n    if a in siriuscolocationList:\n        index = a\n    else:\n        if a in siriusbenchList:\n            dictList_phase_change[index][a].append(fList5[b+1])\n\nmixsiri_yaxis = ()\nmixsiri_yaxis2= ()\nmixsiri_yaxis_abs = ()\nmixsiri_error = ()\nmixsiri_xaxis = ()\nfor a in xrange(0,len(siriusrunningList),2):\n    j = siriusrunningList[a+1]\n    i = siriusrunningList[a]\n    #print j,i\n    for elem in dictList_phase_change[j][i]:\n        dictList_phase_change2[j][i].extend(elem.strip().split(\'\\t\'))\n    #print dictList_phase_change2[j][i]\n\n#print dictList_phase_change2[\'colocating with mcf\'][\'perlbench\']\nfor a in xrange(0,len(siriusrunningList),2):\n    j = siriusrunningList[a+1]\n    i = siriusrunningList[a]\n    print j,i\n    #print dictList_phase_change2[j][i]\n    #print i,j\n    shutter_temp_list = []\n    colo_temp_list = []\n    for (count,item) in enumerate(dictList_phase_change2[j][i]):\n        if count%2==1:\n            colo_temp_list.append(float(item))\n        if count%2==0:\n            shutter_temp_list.append(float(item))\n    print shutter_temp_list\n    print colo_temp_list\n    shutter_avg = sum(shutter_temp_list)/len(shutter_temp_list)\n    colocation_avg = sum(colo_temp_list)/len(colo_temp_list)\n    del shutter_temp_list\n    del colo_temp_list\n\n    pause_period = ((colocation_avg ) + ((shutter_avg + (colocation_avg * 2)/3) * 3))/4\n    mixsiri_xaxis = mixsiri_xaxis + (i,)\n    #print (pause_period/np.mean(execution_time_sec_shutter[j][i]))*10\n    mixsiri_yaxis = mixsiri_yaxis + ( (pause_period/np.mean(execution_time_sec_shutter[j][i]))*10  ,)\n    mixsiri_yaxis2 = mixsiri_yaxis2 + ( abs(((np.mean(execution_time_sec_shutter2[j][i])/np.mean(execution_time_sec_shutter[j][i])) - 1)*100), )\n    #print np.mean(execution_time_sec_shutter2[j][i])\n    #print np.mean(execution_time_sec_shutter[j][i])\n    #print \'---------------------\'\n\n#print xaxis\n#print yaxis\n#print yaxis2\n#print np.mean(yaxis)\n\n\n\nwidth = 0.15\nx = np.arange(len(mixyaxis))\nfig = plt.figure(figsize=(23, 5))\nax = fig.add_subplot(1,1,1)\n#bar2 = plt.bar( x, libsiri_yaxis2, width, color="r", label=\'libquantum (avg = %.2f)\' %(np.mean(libsiri_yaxis2)))\nbar1 = plt.bar( x, libyaxis, width, color="y", label=\'libquantum (avg = %.2f)\' %(np.mean(libyaxis) ))\nbar2 = plt.bar( x+width, mcfyaxis, width, color="r", label=\'mcf (avg = %.2f)\' %(np.mean(mcfyaxis) ))\nbar4 = plt.bar( x+width+width, milcyaxis, width, color="b", label=\'milc (avg = %.2f)\' %(np.mean(milcyaxis) ))\nbar4 = plt.bar( x+width+width+width, mixyaxis, width, color="g", label=\'mix (avg = %.2f)\' %(np.mean(mixyaxis) ))\n#ly = len(mixyaxis2)\n#add_line(ax, 0 * 1, -.1)\n#add_line(ax, 1 * 1.0, -.1)\n#add_line(ax, 1 * 0.55, -.1)\n#add_line(ax, 1 * 0.845, -.1)\n#bar3 = plt.bar( x+width+width, yaxis3, width, color="g", label=\' colocating with sphinx3 (avg = %.1f)\' %(np.mean(yaxis3)))\n##bar3 = plt.bar( x+width+width, yaxis3, width, color="g", label=\'4 corunners (avg is %.1f)\' %(np.mean(yaxis3) ))\n##autolabel2(bar1)\n##autolabel(bar2)\n##autolabel2(bar3)\nplt.ylabel( \'Execution time \\n overhead(%)\', fontsize=\'19\' )\n#plt.title(\'Overhead due to Prediction of degradation while co-running with LIBQUANTUM\')\nplt.xticks(x + width/2.0, mixxaxis, rotation=\'90\', size=\'18\', ha=\'center\')\nplt.ylim(0,20)\nplt.xlim(-1,26)\nplt.yticks(np.arange(0,25,5),size=\'20\')\nplt.grid()\nplt.legend(loc=1, ncol=4, prop={\'size\':18})\nplt.tight_layout()\n#plt.savefig(\'overheadlibquantum.pdf\', dpi=125)\n\n#ax.text(10, -10, r\'SPEC 2006\', fontsize=20)\n#ax.text(3, -10, r\'Sirius Suite\', fontsize=20)\n#ax.text(8, -10, r\'DjiNN & Tonic\', fontsize=20)'
p0
.I0
.S'Brief Architecture'
p0
.S'$p: We use Intel Xeon E5-2407 v2 (4-cores) and E5-2630 v3 (16-cores), respectively. To mimic IaaS public clouds, we take advantage of Linux KVM as the hypervisor and run applications on virtual machines~\\cite{Kivity2007}. Each virtual machine has 1 virtual CPU, 4GB main memory, and 16GB disk. We use Ubuntu 12.04 as guest operating systems with Linux kernel 3.11.0. We use the \\texttt{perf} tool to measure hardware events. \n'
p0
.I0
.S'$sub_fig*:mcfphase:Phase level behavior of snapshot for \\texttt{mcf} when running with 3 \\texttt{libquantum} and \\texttt{mcf} co-runners respectively. Snapshots are triggered effectively at phase boundaries  :mcfsnapshotlib,0.5:mcfsnapshotmcf,0.5:milcsnapshotlib,0.5:milcsnapshotmcf,0.5:!'
p0
.S''
p0
.I4
.S'$graph_fig:mcfsnapshotlib:\\texttt{mcf} (error 0.51\\%):1'
p0
.S"import matplotlib.pyplot as plt\nimport numpy as np\nfrom collections import defaultdict\n\nfilename = '5'\nf1 = [s.strip() for s in open('../../papergraphs/phases/phasedetection/single.txt').readlines()]\n#f2 = [s.strip() for s in open('degradation2/colocation_phase_5.txt').readlines()]\n#f2 = [s.strip() for s in open('../../papergraphs/phases/phasedetection/degradation.txt').readlines()]\nf3 = [s.strip() for s in open('../../papergraphs/phases/phasedetection/shutter_phase_%s.txt' % filename).readlines()]\n#f4 = [s.strip() for s in open('colocation_phase_%s.txt' % filename).readlines()]\n\n\nbenchListBaseline = [ 'gcc', 'perlbench', 'mcf', 'leslie3d', 'povray', 'libquantum', 'astar', 'bzip2', 'milc', 'namd', 'calculix', 'h264ref', 'zeusmp', 'gobmk', 'hmmer', 'tonto', 'sphinx3', 'bwaves', 'gromacs', 'dealII', 'sjeng', 'lbm', 'xalancbmk', 'gamess', 'cactusADM', 'soplex', 'GemsFDTD', 'omnetpp' ]\nbenchListExperiments = [ 'gcc', 'perlbench', 'mcf', 'leslie3d', 'povray', 'libquantum', 'astar', 'bzip2', 'milc', 'namd', 'calculix', 'h264ref', 'zeusmp', 'gobmk', 'hmmer', 'tonto', 'sphinx3', 'bwaves', 'gromacs', 'dealII', 'sjeng', 'lbm', 'xalancbmk', 'gamess', 'cactusADM', 'soplex', 'GemsFDTD', 'omnetpp' ]\n#benchListExperiments = [ 'perlbench', 'astar', 'soplex', 'xalancbmk', 'omnetpp', 'bzip2','povray']\n#benchListExperiments = [ 'gcc', 'perlbench', 'astar', 'soplex', 'xalancbmk', 'omnetpp']\ncolocationListBaseline = [ 'colocating with mcf', 'colocating with povray', 'colocating with astar', 'colocating with astar', 'colocating with libquantum', 'colocating with povray', 'colocating with omnetpp', 'colocating with bzip2' ]\ncolocationListExperiments = [ 'colocating with mcf', 'colocating with povray', 'colocating with perlbench', 'colocating with astar', 'colocating with libquantum', 'colocating with povray', 'colocating with omnetpp', 'colocating with bzip2' ]\n\nrunningList = [ 'mcf' ,'colocating with libquantum']\n\n\nphaseList_single = defaultdict(list)\nphaseList_degradation = defaultdict(lambda  : defaultdict(list))\nphaseList_shutter = defaultdict(lambda  : defaultdict(list))\nphaseList_colocation = defaultdict(lambda  : defaultdict(list))\n\n\nllc_miss_phaseList_single = defaultdict(list)\nllc_miss_phaseList_degradation = defaultdict(lambda  : defaultdict(list))\nllc_miss_phaseList_shutter = defaultdict(lambda  : defaultdict(list))\nllc_miss_phaseList_colocation = defaultdict(lambda  : defaultdict(list))\n\nfirstList1 = []\nsecondList1 = []\nthirdList1 = []\nfourthList1 = []\nfifthList1 = []\nsixthList1 = []\nseventhList1 = []\neighthList1 = []\n\nfor line in f1:\n    firstList1.append(line)\n\n#for line in f2:\n #   secondList1.append(line)\n\nfor line in f3:\n    thirdList1.append(line)\n\n\n\n#print sixthList1\n#print firstList1\nglobal index\nglobal index2\n\nfor (j,i) in enumerate(firstList1):\n    #print i\n    if i in benchListBaseline:\n        index = i\n    else:\n        phaseList_single[index].append(i.split())\n\n\nfor (j,i) in enumerate(secondList1):\n    if i in colocationListExperiments:\n        index2=i\n    elif i in benchListExperiments:\n        index=i\n    else:\n        phaseList_degradation[index2][index].append(i.split())\n\n\n\n\nfor (j,i) in enumerate(thirdList1):\n    if i in colocationListExperiments:\n        index2=i\n    elif i in benchListExperiments:\n        index=i\n    else:\n        phaseList_shutter[index2][index].append(i.split())\n\n#print len(phaseList_colocation['colocating with libquantum']['gcc'])\n#print len(llc_miss_phaseList_colocation['colocating with libquantum']['gcc'])\n##############place to get the lists to plot #############\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    print i\n    instruction_list1=[]\n    cpi_list1=[]\n    instruction_list2=[]\n    cpi_list2=[]\n    instruction_list3=[]\n    cpi_list3=[]\n    for (b,a) in enumerate(phaseList_shutter[j][i]):\n        if a[0][0] == '-':\n            break\n        else:\n            instruction_list1.append(float(a[1]))\n            cpi_list1.append(a[2])\n\n    for (b,a) in enumerate(phaseList_single[i]):\n        if a[0][0] == '-':\n            break\n        else:\n            instruction_list2.append(float(a[1])*1.58)\n            cpi_list2.append(a[2])\n\n    for (b,a) in enumerate(phaseList_degradation[j][i]):\n        if a[0][0] == '-':\n            break\n        else:\n            instruction_list3.append(float(a[1]))\n            cpi_list3.append(float(a[14])/10)\n\n    #print instruction_list\n    #print cpi_list\n\n    f, ax = plt.subplots(figsize=(12,5))\n  \n    ax.plot(instruction_list1,cpi_list1, color='r', label='mcf w/ libquantum')\n    ax.plot(instruction_list2,cpi_list2, color='y',  label= 'mcf w/o libquantum')\n    #ax.plot(instruction_list2,miss_list2, color='c', label='ground truth L3 cache miss rate (per thousand cycles) of %s running alone' %(i))\n    #ax.set_title('Phase of lone execution of %s VS phase of %s running with %s'%(i,i,j))\n    ax.set_xlabel('Executed instructions', fontsize=23)\n    ax.set_ylabel('CPI', fontsize=23)\n    #ax.set_ylabel('LLC store misses')\n    #ax.set_ylabel('L1 Dcache load misses')\n    ax.set_ylim(0.5,6.5)\n    ax.set_xlim(0,1080000000000)\n    ax.legend(loc=1,prop={'size':20})\n    ax.tick_params(axis='both', labelsize=18)\n    #plt.savefig('%s_and_libquantum.pdf'%(i),bbox_inches='tight' ,dpi=200)\n    del instruction_list1\n    del cpi_list1"
p0
.I0
.S'$graph_fig:mcfsnapshotmcf:\\texttt{mcf} (error 3.41\\%):1'
p0
.S"import matplotlib.pyplot as plt\nimport numpy as np\nfrom collections import defaultdict\n\nfilename = '5'\nf1 = [s.strip() for s in open('../../papergraphs/phases/phasedetection/single.txt').readlines()]\n#f2 = [s.strip() for s in open('degradation2/colocation_phase_5.txt').readlines()]\n#f2 = [s.strip() for s in open('../../papergraphs/phases/phasedetection/degradation.txt').readlines()]\nf3 = [s.strip() for s in open('../../papergraphs/phases/phasedetection/shutter_phase_%s.txt' % filename).readlines()]\n#f4 = [s.strip() for s in open('colocation_phase_%s.txt' % filename).readlines()]\n\n\nbenchListBaseline = [ 'gcc', 'perlbench', 'mcf', 'leslie3d', 'povray', 'libquantum', 'astar', 'bzip2', 'milc', 'namd', 'calculix', 'h264ref', 'zeusmp', 'gobmk', 'hmmer', 'tonto', 'sphinx3', 'bwaves', 'gromacs', 'dealII', 'sjeng', 'lbm', 'xalancbmk', 'gamess', 'cactusADM', 'soplex', 'GemsFDTD', 'omnetpp' ]\nbenchListExperiments = [ 'gcc', 'perlbench', 'mcf', 'leslie3d', 'povray', 'libquantum', 'astar', 'bzip2', 'milc', 'namd', 'calculix', 'h264ref', 'zeusmp', 'gobmk', 'hmmer', 'tonto', 'sphinx3', 'bwaves', 'gromacs', 'dealII', 'sjeng', 'lbm', 'xalancbmk', 'gamess', 'cactusADM', 'soplex', 'GemsFDTD', 'omnetpp' ]\n#benchListExperiments = [ 'perlbench', 'astar', 'soplex', 'xalancbmk', 'omnetpp', 'bzip2','povray']\n#benchListExperiments = [ 'gcc', 'perlbench', 'astar', 'soplex', 'xalancbmk', 'omnetpp']\ncolocationListBaseline = [ 'colocating with mcf', 'colocating with povray', 'colocating with astar', 'colocating with astar', 'colocating with libquantum', 'colocating with povray', 'colocating with omnetpp', 'colocating with bzip2' ]\ncolocationListExperiments = [ 'colocating with mcf', 'colocating with povray', 'colocating with perlbench', 'colocating with astar', 'colocating with libquantum', 'colocating with povray', 'colocating with omnetpp', 'colocating with bzip2' ]\n\nrunningList = [ 'mcf' ,'colocating with mcf']\n\n\nphaseList_single = defaultdict(list)\nphaseList_degradation = defaultdict(lambda  : defaultdict(list))\nphaseList_shutter = defaultdict(lambda  : defaultdict(list))\nphaseList_colocation = defaultdict(lambda  : defaultdict(list))\n\n\nllc_miss_phaseList_single = defaultdict(list)\nllc_miss_phaseList_degradation = defaultdict(lambda  : defaultdict(list))\nllc_miss_phaseList_shutter = defaultdict(lambda  : defaultdict(list))\nllc_miss_phaseList_colocation = defaultdict(lambda  : defaultdict(list))\n\nfirstList1 = []\nsecondList1 = []\nthirdList1 = []\nfourthList1 = []\nfifthList1 = []\nsixthList1 = []\nseventhList1 = []\neighthList1 = []\n\nfor line in f1:\n    firstList1.append(line)\n\n#for line in f2:\n #   secondList1.append(line)\n\nfor line in f3:\n    thirdList1.append(line)\n\n\n\n#print sixthList1\n#print firstList1\nglobal index\nglobal index2\n\nfor (j,i) in enumerate(firstList1):\n    #print i\n    if i in benchListBaseline:\n        index = i\n    else:\n        phaseList_single[index].append(i.split())\n\n\nfor (j,i) in enumerate(secondList1):\n    if i in colocationListExperiments:\n        index2=i\n    elif i in benchListExperiments:\n        index=i\n    else:\n        phaseList_degradation[index2][index].append(i.split())\n\n\n\n\nfor (j,i) in enumerate(thirdList1):\n    if i in colocationListExperiments:\n        index2=i\n    elif i in benchListExperiments:\n        index=i\n    else:\n        phaseList_shutter[index2][index].append(i.split())\n\n#print len(phaseList_colocation['colocating with libquantum']['gcc'])\n#print len(llc_miss_phaseList_colocation['colocating with libquantum']['gcc'])\n##############place to get the lists to plot #############\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    print i\n    instruction_list1=[]\n    cpi_list1=[]\n    instruction_list2=[]\n    cpi_list2=[]\n    instruction_list3=[]\n    cpi_list3=[]\n    for (b,a) in enumerate(phaseList_shutter[j][i]):\n        if a[0][0] == '-':\n            break\n        else:\n            instruction_list1.append(float(a[1]))\n            cpi_list1.append(a[2])\n\n    for (b,a) in enumerate(phaseList_single[i]):\n        if a[0][0] == '-':\n            break\n        else:\n            instruction_list2.append(float(a[1])*1.25)\n            cpi_list2.append(a[2])\n\n    for (b,a) in enumerate(phaseList_degradation[j][i]):\n        if a[0][0] == '-':\n            break\n        else:\n            instruction_list3.append(float(a[1]))\n            cpi_list3.append(float(a[14])/10)\n\n    #print instruction_list\n    #print cpi_list\n\n    f, ax = plt.subplots(figsize=(12,5))\n  \n    ax.plot(instruction_list1,cpi_list1, color='r', label='mcf w/ mcf')\n    ax.plot(instruction_list2,cpi_list2, color='y',  label= 'mcf w/o mcf')\n    #ax.plot(instruction_list2,miss_list2, color='c', label='ground truth L3 cache miss rate (per thousand cycles) of %s running alone' %(i))\n    #ax.set_title('Phase of lone execution of %s VS phase of %s running with %s'%(i,i,j))\n    ax.set_xlabel('Executed instructions', fontsize=23)\n    ax.set_ylabel('CPI', fontsize=23)\n    #ax.set_ylabel('LLC store misses')\n    #ax.set_ylabel('L1 Dcache load misses')\n    ax.set_ylim(0.5,6.5)\n    ax.set_xlim(0,850000000000)\n    ax.legend(loc=1,prop={'size':20})\n    ax.tick_params(axis='both', labelsize=18)\n    #plt.savefig('%s_and_libquantum.pdf'%(i),bbox_inches='tight' ,dpi=200)\n    del instruction_list1\n    del cpi_list1\n"
p0
.I0
.S'$graph_fig:milcsnapshotlib:\\texttt{milc} (error 1.23\\%):1'
p0
.S"import matplotlib.pyplot as plt\nimport numpy as np\nfrom collections import defaultdict\n\nfilename = '5'\nf1 = [s.strip() for s in open('../../papergraphs/phases/phasedetection/single.txt').readlines()]\n#f2 = [s.strip() for s in open('degradation2/colocation_phase_5.txt').readlines()]\n#f2 = [s.strip() for s in open('../../papergraphs/phases/phasedetection/degradation.txt').readlines()]\nf3 = [s.strip() for s in open('../../papergraphs/phases/phasedetection/shutter_phase_%s.txt' % filename).readlines()]\n#f4 = [s.strip() for s in open('colocation_phase_%s.txt' % filename).readlines()]\n\n\nbenchListBaseline = [ 'gcc', 'perlbench', 'mcf', 'leslie3d', 'povray', 'libquantum', 'astar', 'bzip2', 'milc', 'namd', 'calculix', 'h264ref', 'zeusmp', 'gobmk', 'hmmer', 'tonto', 'sphinx3', 'bwaves', 'gromacs', 'dealII', 'sjeng', 'lbm', 'xalancbmk', 'gamess', 'cactusADM', 'soplex', 'GemsFDTD', 'omnetpp' ]\nbenchListExperiments = [ 'gcc', 'perlbench', 'mcf', 'leslie3d', 'povray', 'libquantum', 'astar', 'bzip2', 'milc', 'namd', 'calculix', 'h264ref', 'zeusmp', 'gobmk', 'hmmer', 'tonto', 'sphinx3', 'bwaves', 'gromacs', 'dealII', 'sjeng', 'lbm', 'xalancbmk', 'gamess', 'cactusADM', 'soplex', 'GemsFDTD', 'omnetpp' ]\n#benchListExperiments = [ 'perlbench', 'astar', 'soplex', 'xalancbmk', 'omnetpp', 'bzip2','povray']\n#benchListExperiments = [ 'gcc', 'perlbench', 'astar', 'soplex', 'xalancbmk', 'omnetpp']\ncolocationListBaseline = [ 'colocating with mcf', 'colocating with povray', 'colocating with astar', 'colocating with astar', 'colocating with libquantum', 'colocating with povray', 'colocating with omnetpp', 'colocating with bzip2' ]\ncolocationListExperiments = [ 'colocating with mcf', 'colocating with povray', 'colocating with perlbench', 'colocating with astar', 'colocating with libquantum', 'colocating with povray', 'colocating with omnetpp', 'colocating with bzip2' ]\n\nrunningList = [ 'milc' ,'colocating with libquantum']\n\n\nphaseList_single = defaultdict(list)\nphaseList_degradation = defaultdict(lambda  : defaultdict(list))\nphaseList_shutter = defaultdict(lambda  : defaultdict(list))\nphaseList_colocation = defaultdict(lambda  : defaultdict(list))\n\n\nllc_miss_phaseList_single = defaultdict(list)\nllc_miss_phaseList_degradation = defaultdict(lambda  : defaultdict(list))\nllc_miss_phaseList_shutter = defaultdict(lambda  : defaultdict(list))\nllc_miss_phaseList_colocation = defaultdict(lambda  : defaultdict(list))\n\nfirstList1 = []\nsecondList1 = []\nthirdList1 = []\nfourthList1 = []\nfifthList1 = []\nsixthList1 = []\nseventhList1 = []\neighthList1 = []\n\nfor line in f1:\n    firstList1.append(line)\n\nfor line in f3:\n    thirdList1.append(line)\n\n\nglobal index\nglobal index2\n\nfor (j,i) in enumerate(firstList1):\n    #print i\n    if i in benchListBaseline:\n        index = i\n    else:\n        phaseList_single[index].append(i.split())\n\n\n\nfor (j,i) in enumerate(secondList1):\n    if i in colocationListExperiments:\n        index2=i\n    elif i in benchListExperiments:\n        index=i\n    else:\n        phaseList_degradation[index2][index].append(i.split())\n\n\n#for (j,i) in enumerate(sixthList1):\n#    if i in colocationListExperiments:\n#        index2=i\n#    elif i in benchListExperiments:\n#        index=i\n#    else:\n#        llc_miss_phaseList_degradation[index2][index].append(i.split())\n\n#print len(phaseList_degradation['colocating with libquantum']['gcc'])\n#print len(llc_miss_phaseList_degradation['colocating with libquantum']['gcc'])\n\nfor (j,i) in enumerate(thirdList1):\n    if i in colocationListExperiments:\n        index2=i\n    elif i in benchListExperiments:\n        index=i\n    else:\n        phaseList_shutter[index2][index].append(i.split())\n\n\n#for (j,i) in enumerate(seventhList1):\n#    if i in colocationListExperiments:\n#        index2=i\n#    elif i in benchListExperiments:\n#        index=i\n#    else:\n#        llc_miss_phaseList_shutter[index2][index].append(i.split())\n#print len(phaseList_shutter['colocating with libquantum']['gcc'])\n#print len(llc_miss_phaseList_shutter['colocating with libquantum']['gcc'])\n\n#for (j,i) in enumerate(fourthList1):\n#    if i in colocationListExperiments:\n#        index2=i\n#    elif i in benchListExperiments:\n#        index=i\n#    else:\n#        phaseList_colocation[index2][index].append(i.split())\n\n\n#for (j,i) in enumerate(eighthList1):\n#    if i in colocationListExperiments:\n#        index2=i\n#    elif i in benchListExperiments:\n#        index=i\n#    else:\n#        llc_miss_phaseList_colocation[index2][index].append(i.split())\n\n#print len(phaseList_colocation['colocating with libquantum']['gcc'])\n#print len(llc_miss_phaseList_colocation['colocating with libquantum']['gcc'])\n##############place to get the lists to plot #############\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    print i\n    instruction_list1=[]\n    cpi_list1=[]\n    instruction_list2=[]\n    cpi_list2=[]\n    instruction_list3=[]\n    cpi_list3=[]\n    for (b,a) in enumerate(phaseList_shutter[j][i]):\n        if a[0][0] == '-':\n            break\n        else:\n            instruction_list1.append(float(a[1]))\n            cpi_list1.append(a[2])\n\n    for (b,a) in enumerate(phaseList_single[i]):\n        if a[0][0] == '-':\n            break\n        else:\n            instruction_list2.append(float(a[1])*1.3)\n            cpi_list2.append(a[2])\n\n    for (b,a) in enumerate(phaseList_degradation[j][i]):\n        if a[0][0] == '-':\n            break\n        else:\n            instruction_list3.append(float(a[1]))\n            cpi_list3.append(float(a[14])/10)\n\n    #print instruction_list\n    #print cpi_list\n\n    f, ax = plt.subplots(figsize=(12,5))\n    #ax.plot(instruction_list1,miss_list1, color='b', label='ground truth degradation when %s is colocating with %s' %(i,j[16:]))\n    #ax.plot(instruction_list2,cpi_list2, color='g',  label='phase L3 cache miss rate (per thousand cycles) of %s during when 3 corunners (%s) are running ' %(i,j[16:]))\n    #ax.plot(instruction_list2,miss_list2, color='c', label='ground truth L3 cache miss rate (per thousand cycles) of %s when colocating with %s  ' %(i,j[16:]))\n\n\n\n    ax.plot(instruction_list1,cpi_list1, color='r', label='milc w/ libquantum')\n    ax.plot(instruction_list2,cpi_list2, color='y',  label= 'milc w/o libquantum')\n    #ax.plot(instruction_list2,miss_list2, color='c', label='ground truth L3 cache miss rate (per thousand cycles) of %s running alone' %(i))\n    #ax.set_title('Phase of lone execution of %s VS phase of %s running with %s'%(i,i,j))\n    ax.set_xlabel('Executed instructions', fontsize=23)\n    ax.set_ylabel('CPI', fontsize=23)\n    #ax.set_ylabel('LLC store misses')\n    #ax.set_ylabel('L1 Dcache load misses')\n    ax.set_ylim(0.3,3)\n    ax.legend(loc=1,prop={'size':20})\n    ax.tick_params(axis='both', labelsize=18)\n    #plt.savefig('%s_and_libquantum.pdf'%(i),bbox_inches='tight' ,dpi=200)\n    del instruction_list1\n    del cpi_list1\n"
p0
.I0
.S'$graph_fig:milcsnapshotmcf:\\texttt{milc} (error 2.52\\%):1'
p0
.S"import matplotlib.pyplot as plt\nimport numpy as np\nfrom collections import defaultdict\n\nfilename = '5'\nf1 = [s.strip() for s in open('../../papergraphs/phases/phasedetection/single.txt').readlines()]\n#f2 = [s.strip() for s in open('degradation2/colocation_phase_5.txt').readlines()]\n#f2 = [s.strip() for s in open('../../papergraphs/phases/phasedetection/degradation.txt').readlines()]\nf3 = [s.strip() for s in open('../../papergraphs/phases/phasedetection/shutter_phase_%s.txt' % filename).readlines()]\n#f4 = [s.strip() for s in open('colocation_phase_%s.txt' % filename).readlines()]\n\n\nbenchListBaseline = [ 'gcc', 'perlbench', 'mcf', 'leslie3d', 'povray', 'libquantum', 'astar', 'bzip2', 'milc', 'namd', 'calculix', 'h264ref', 'zeusmp', 'gobmk', 'hmmer', 'tonto', 'sphinx3', 'bwaves', 'gromacs', 'dealII', 'sjeng', 'lbm', 'xalancbmk', 'gamess', 'cactusADM', 'soplex', 'GemsFDTD', 'omnetpp' ]\nbenchListExperiments = [ 'gcc', 'perlbench', 'mcf', 'leslie3d', 'povray', 'libquantum', 'astar', 'bzip2', 'milc', 'namd', 'calculix', 'h264ref', 'zeusmp', 'gobmk', 'hmmer', 'tonto', 'sphinx3', 'bwaves', 'gromacs', 'dealII', 'sjeng', 'lbm', 'xalancbmk', 'gamess', 'cactusADM', 'soplex', 'GemsFDTD', 'omnetpp' ]\n#benchListExperiments = [ 'perlbench', 'astar', 'soplex', 'xalancbmk', 'omnetpp', 'bzip2','povray']\n#benchListExperiments = [ 'gcc', 'perlbench', 'astar', 'soplex', 'xalancbmk', 'omnetpp']\ncolocationListBaseline = [ 'colocating with mcf', 'colocating with povray', 'colocating with astar', 'colocating with astar', 'colocating with libquantum', 'colocating with povray', 'colocating with omnetpp', 'colocating with bzip2' ]\ncolocationListExperiments = [ 'colocating with mcf', 'colocating with povray', 'colocating with perlbench', 'colocating with astar', 'colocating with libquantum', 'colocating with povray', 'colocating with omnetpp', 'colocating with bzip2' ]\n\nrunningList = [ 'milc' ,'colocating with mcf']\n\n\nphaseList_single = defaultdict(list)\nphaseList_degradation = defaultdict(lambda  : defaultdict(list))\nphaseList_shutter = defaultdict(lambda  : defaultdict(list))\nphaseList_colocation = defaultdict(lambda  : defaultdict(list))\n\n\nllc_miss_phaseList_single = defaultdict(list)\nllc_miss_phaseList_degradation = defaultdict(lambda  : defaultdict(list))\nllc_miss_phaseList_shutter = defaultdict(lambda  : defaultdict(list))\nllc_miss_phaseList_colocation = defaultdict(lambda  : defaultdict(list))\n\nfirstList1 = []\nsecondList1 = []\nthirdList1 = []\nfourthList1 = []\nfifthList1 = []\nsixthList1 = []\nseventhList1 = []\neighthList1 = []\n\nfor line in f1:\n    firstList1.append(line)\n\n#for line in f2:\n #   secondList1.append(line)\n\nfor line in f3:\n    thirdList1.append(line)\n\n\n\n#print sixthList1\n#print firstList1\nglobal index\nglobal index2\n\nfor (j,i) in enumerate(firstList1):\n    #print i\n    if i in benchListBaseline:\n        index = i\n    else:\n        phaseList_single[index].append(i.split())\n\n\nfor (j,i) in enumerate(secondList1):\n    if i in colocationListExperiments:\n        index2=i\n    elif i in benchListExperiments:\n        index=i\n    else:\n        phaseList_degradation[index2][index].append(i.split())\n\n\n\n\nfor (j,i) in enumerate(thirdList1):\n    if i in colocationListExperiments:\n        index2=i\n    elif i in benchListExperiments:\n        index=i\n    else:\n        phaseList_shutter[index2][index].append(i.split())\n\n#print len(phaseList_colocation['colocating with libquantum']['gcc'])\n#print len(llc_miss_phaseList_colocation['colocating with libquantum']['gcc'])\n##############place to get the lists to plot #############\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    print i\n    instruction_list1=[]\n    cpi_list1=[]\n    instruction_list2=[]\n    cpi_list2=[]\n    instruction_list3=[]\n    cpi_list3=[]\n    for (b,a) in enumerate(phaseList_shutter[j][i]):\n        if a[0][0] == '-':\n            break\n        else:\n            instruction_list1.append(float(a[1]))\n            cpi_list1.append(a[2])\n\n    for (b,a) in enumerate(phaseList_single[i]):\n        if a[0][0] == '-':\n            break\n        else:\n            instruction_list2.append(float(a[1])*1.06)\n            cpi_list2.append(a[2])\n\n    for (b,a) in enumerate(phaseList_degradation[j][i]):\n        if a[0][0] == '-':\n            break\n        else:\n            instruction_list3.append(float(a[1]))\n            cpi_list3.append(float(a[14])/10)\n\n    #print instruction_list\n    #print cpi_list\n\n    f, ax = plt.subplots(figsize=(12,5))\n  \n    ax.plot(instruction_list1,cpi_list1, color='r', label='milc w/ mcf')\n    ax.plot(instruction_list2,cpi_list2, color='y',  label= 'milc w/o mcf')\n    #ax.plot(instruction_list2,miss_list2, color='c', label='ground truth L3 cache miss rate (per thousand cycles) of %s running alone' %(i))\n    #ax.set_title('Phase of lone execution of %s VS phase of %s running with %s'%(i,i,j))\n    ax.set_xlabel('Executed instructions', fontsize=23)\n    ax.set_ylabel('CPI', fontsize=23)\n    #ax.set_ylabel('LLC store misses')\n    #ax.set_ylabel('L1 Dcache load misses')\n    ax.set_ylim(0.5,3)\n    ax.set_xlim(0,1650000000000)\n    ax.legend(loc=1,prop={'size':20})\n    ax.tick_params(axis='both', labelsize=18)\n    #plt.savefig('%s_and_libquantum.pdf'%(i),bbox_inches='tight' ,dpi=200)\n    del instruction_list1\n    del cpi_list1\n"
p0
.I0
.S'Benchmark'
p0
.S'$s:Benchmark\n'
p0
.I2
.S'Benchmarks Description'
p0
.S"$p: To evaluate the effectiveness of our technique, we use the latest cloud datacenter applications from \\textit{SiriusSuite}~\\cite{sirius} and \\textit{DjiNN\\&Tonic suite}~\\cite{djinn}. Recent trends have also shown the demand for intelligent personal assistants such as Apple's Siri, Google's Google Now, Microsoft's Cortana, and Amazon's Echo. There is a promising direction executing such applications in public clouds. In this context, SiriusSuite and DjiNN \\& Tonic suite contain a class of applications which implement speech recognition, image matching, natural language processing, and question answering systems. We also evaluate \\textit{SPEC 2006} with \\texttt{ref} inputs.  SPEC 2006 consists of a class of scientific computing application which are standard CPU benchmarks. With the advent of high performance computing (HPC) in clouds, a class of academic research have started using public clouds for running their applications. Table~\\ref{table:benchmarks} shows the class of benchmarks and its use cases in Amazon Web Service. \n"
p0
.I0
.S'Benchmark table'
p0
.S'$t:\n\\begin{table}[!ht]\n\\resizebox{8cm}{!} {\n\\begin{tabular}{|l|l|l|}\n\\hline\n{\\bf \\begin{tabular}[c]{@{}l@{}}Benchmark \\end{tabular}}                  & {\\bf Class of applications}                                                                                      & {\\bf \\begin{tabular}[c]{@{}l@{}} AWS use cases ~\\cite{awscase} \\end{tabular}}                                                                                                                                  \\\\ \\hline\n{\\bf \\begin{tabular}[c]{@{}l@{}}Sirius Suite\\end{tabular}} & \\begin{tabular}[c]{@{}l@{}} Machine learning \\end{tabular} & \\begin{tabular}[c]{@{}l@{}}NTT Docomo (voice recognition)~\\cite{docomo} \\end{tabular}                                                                                                               \\\\\n{\\bf \\begin{tabular}[c]{@{}l@{}}DjiNN \\& Tonic\\end{tabular}} & \\begin{tabular}[c]{@{}l@{}} Deep neural network \\end{tabular} & \\begin{tabular}[c]{@{}l@{}} PIXNET (facial recognition)~\\cite{pixnet}\\end{tabular}                                                                                                               \\\\ \n{\\bf SPEC 2006}                                                                        & \\begin{tabular}[c]{@{}l@{}}General purpose \\& Scientific \\end{tabular} & \\begin{tabular}[c]{@{}l@{}}Penn State~\\cite{pennamazon} \\end{tabular}\n\\\\ \\hline\n\\end{tabular}\n}\n\\caption{Benchmark descriptions}\n\\label{table:benchmarks}\n\\end{table}'
p0
.I0
.S'Evaluation'
p0
.S'$s: Evaluation'
p0
.I9
.S'Outline'
p0
.S'$p: \nIn this section, we evaluate the our \\textit{snapshot} technique. We discuss the accuracy in estimating performance degradation and its overhead. We also test scalability by consolidating 16VMs on a single server and analyze detailed phase level behaviors. Finally, we compare our technique with prior work. '
p0
.I0
.S'Accuracy and Overhead of Snapshot'
p0
.S'$s: Analysis of Phase Level Behaviors'
p0
.I2
.S'Emerging Web Service Applications'
p0
.S'$p: \n\\textbf{Emerging Web Service Applications}\nToday, speech, vision and machine learning based web services have emerged in public clouds~\\cite{awscase,pennamazon,docomo,pixnet}. To evaluate our snapshot, we leverage the emerging applications, SiriusSuite~\\cite{sirius} and DjiNN\\&Tonic Suite~\\cite{djinn}. Firstly, we look into the accuracy of these web service applications. Then we look at the overhead of our runtime system.\n\n  \nFigure~\\ref{fig:sirius-accuracy} shows the accuracy of \\textit{snapshot} technique when four virtual machines are running on a single server. The x-axis shows the benchmarks from SiriusSuite and DjiNN\\&Tonic Suite and the y-axis presents the error in estimating performance degradation. Each bar indicates different co-runners. First three bars represent a single type of co-runners \\texttt{libquantum}, \\texttt{mcf} and \\texttt{milc}, respectively. The last bar indicates a mix of co-runners ,\\texttt{libquantum}, \\texttt{mcf}, and \\texttt{milc}, each running on a different virtual machine, respectively. From many prior studies, these applications are well known to highly incur resource contention in shared  architectural resources. We calculate the error by comparing the estimated performance degradation from our runtime engine with the actual performance degradation. We run each benchmark three times and take the mean to minimize run to run variability. From \\ref{fig:sirius-accuracy} we can see that our snapshot shows very low error rates across all the applications even when running with multiple instances of cache contentious co-runners like \\texttt{libquantum}. % except for \\texttt{img-imc} application from DjiNN \\& Tonic Suite. \n%The image classification predicts what the input of image means based on a pretrained neural network. The size of the neural network is relatively larger than other applications such as \\texttt{NLP}. \n\nNext, we discuss the overhead of our proposed technique. For a deployable design, we have to achieve low overheads so as to minimize the interference that the applications are subjected to when running on a production system.  Figure~\\ref{fig:sirius-overhead} indicates the overhead while estimating performance degradation. We evaluate the overhead at the same experimental setup under which we had evaluated accuracy. The y-axis presents the execution time overhead due to snapshot. We can see that our technique incurs extremely low overhead in many cases. On average, the overhead is only 0.34\\% when we co-locate applications with \\texttt{libquantum}, our technique shows resilient behavior. Even when we co-locate the applications with 3 instance of an application \\texttt{mcf} which has the most amount of phase changes with respect to SPEC benchmark suite, the overhead that our technique incurs around 0.86\\%.'
p0
.I0
.S'General purpose'
p0
.S'$p:\n\\textbf{General Purpose and Scientific Applications}\nIn addition to the emerging applications, we also evaluate SPEC CPU 2006 applications. SPEC CPU consists of general purpose and scientific applications. It is a very common practice to see users running such applications in public clouds. This can be clearly seen from \\ref{table:benchmarks}.\nFigure~\\ref{fig:spec-accuracy} and ~\\ref{fig:spec-overhead} show the accuracy and the overhead when co-locating \\texttt{libquantum} \\texttt{mcf} \\texttt{milc} and a mix set of co-runners respectively. On SPEC applications, we can see a similar trend as that present in SiriusSuite and DjiNN\\&Tonic Suite. Our technique shows low error rates in most applications and the overhead is also negligible.   \n'
p0
.I0
.S'$sub_fig*:scalability:4VM vs. 16 VMs for accuray and overhead on snapshot. Accuracy is unaffected and overhead is slightly affected when we execute even 16 applications at the same time:accuracy-4-16VMs,2:nl:overhead-4-16VMs,2:!'
p0
.S''
p0
.I2
.S'$graph_fig:accuracy-4-16VMs:Accuracy:1'
p0
.S'from collections import defaultdict\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nbenchListBaseline = [ \'gcc\', \'perlbench\', \'leslie3d\', \'povray\', \'libquantum\', \'astar\', \'bzip2\', \'milc\', \'namd\', \'calculix\', \'h264ref\', \'sphinx3\', \'zeusmp\', \'gobmk\', \'hmmer\', \'tonto\', \'bwaves\', \'gromacs\', \'dealII\', \'sjeng\', \'lbm\', \'xalancbmk\', \'gamess\', \'cactusADM\', \'soplex\', \'GemsFDTD\', \'omnetpp\', \'mcf\' ]\nbenchListExperiments = [ \'gcc\', \'perlbench\', \'leslie3d\', \'povray\', \'libquantum\', \'astar\', \'bzip2\', \'milc\', \'namd\', \'calculix\', \'h264ref\', \'sphinx3\', \'zeusmp\', \'gobmk\', \'hmmer\', \'tonto\', \'bwaves\', \'gromacs\', \'dealII\', \'sjeng\', \'lbm\', \'xalancbmk\', \'gamess\', \'cactusADM\', \'soplex\', \'GemsFDTD\', \'omnetpp\', \'mcf\' ]\ncolocationListBaseline = [ \'colocating with lbm\', \'colocating with povray\', \'colocating with milc\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with mcf\' ]\ncolocationListExperiments = [ \'colocating with lbm\', \'colocating with povray\', \'colocating with milc\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with mcf\' ]\n\nrunningList2 = [  \'perlbench\', \'colocating with libquantum\', \'mcf\', \'colocating with libquantum\', \'leslie3d\', \'colocating with libquantum\', \'povray\', \'colocating with libquantum\', \'libquantum\', \'colocating with libquantum\', \'astar\', \'colocating with libquantum\', \'milc\', \'colocating with libquantum\', \'namd\', \'colocating with libquantum\', \'calculix\', \'colocating with libquantum\', \'h264ref\', \'colocating with libquantum\', \'gobmk\', \'colocating with libquantum\', \'hmmer\', \'colocating with libquantum\', \'tonto\', \'colocating with libquantum\', \'sphinx3\', \'colocating with libquantum\', \'zeusmp\', \'colocating with libquantum\', \'bwaves\', \'colocating with libquantum\', \'gromacs\', \'colocating with libquantum\', \'dealII\', \'colocating with libquantum\', \'sjeng\', \'colocating with libquantum\', \'lbm\', \'colocating with libquantum\', \'xalancbmk\', \'colocating with libquantum\', \'gamess\', \'colocating with libquantum\', \'soplex\', \'colocating with libquantum\', \'GemsFDTD\', \'colocating with libquantum\', \'omnetpp\', \'colocating with libquantum\' ]\n\nsiriusbenchListBaseline = [ \'gmm\', \'dnn_asr\', \'surf-fe\', \'surf-fd\', \'stem\', \'regex\', \'crf\', \'img-imc\', \'img-dig\', \'img-face\', \'nlp-pos\', \'nlp-chk\', \'nlp-ner\']\nsiriusbenchListExperiments = [ \'gmm\', \'dnn_asr\', \'surf-fe\', \'surf-fd\', \'stem\', \'regex\', \'crf\', \'img-imc\', \'img-dig\', \'img-face\', \'nlp-pos\', \'nlp-chk\', \'nlp-ner\']\nsiriuscolocationListBaseline = [ \'colocating with lbm\', \'colocating with povray\', \'colocating with astar\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with mcf\' ]\nsiriuscolocationListExperiments = [ \'colocating with lbm\', \'colocating with povray\', \'colocating with perlbench\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with mcf\' ]\nsiriusrunningList2 = [ \'gmm\', \'colocating with libquantum\', \'surf-fe\', \'colocating with libquantum\', \'surf-fd\', \'colocating with libquantum\', \'stem\', \'colocating with libquantum\', \'regex\', \'colocating with libquantum\', \'crf\', \'colocating with libquantum\', \'img-imc\', \'colocating with libquantum\', \'img-dig\', \'colocating with libquantum\', \'img-face\', \'colocating with libquantum\', \'nlp-pos\', \'colocating with libquantum\', \'nlp-chk\', \'colocating with libquantum\', \'nlp-ner\' , \'colocating with libquantum\']\n\n\ndef autolabel(rects):\n    # attach some text labels\n    for rect in rects:\n        height = rect.get_height()\n        plt.text(rect.get_x()+rect.get_width()/2., 1.05*height, \'%.2f\'%float(height))\n\ndef autolabel2(rects):\n    # attach some text labels\n    for rect in rects:\n        height = rect.get_height()\n        plt.text(rect.get_x()+rect.get_width()/2., 1.05*height, \'%.2f\'%float(height))\n\ndef add_line(ax, xpos, ypos):\n    line = plt.Line2D([xpos, xpos], [ypos + .1, ypos - .5], transform=ax.transAxes, linewidth=2, color=\'black\')\n    line.set_clip_on(False)\n    ax.add_line(line)\n\n\nfilename = \'shutter_cpi_10\'\n#fList = [s.strip() for s in open(\'../../papergraphs/2.fullspec/accuracy/libquantumcorunner/single_vm_ground_truth/shutter_cpi_1000.txt\').readlines()]\n#fList2 = [s.strip() for s in open(\'../../papergraphs/2.fullspec/accuracy/libquantumcorunner/degradation_ground_truth/shutter_cpi_1000.txt\').readlines()]\n#fList3 = [s.strip() for s in open(\'../../papergraphs/2.fullspec/accuracy/libquantumcorunner/experiment_1/%s.txt\' % filename).readlines()]\nfList3= [s.strip() for s in open(\'../../papergraphs/scalability/libquantumcorunner/spec/priorwork/shutter_cpi_4.txt\').readlines()]\n\nfList4 = [s.strip() for s in open(\'../../papergraphs/scalability/libquantumcorunner/spec/singlevm/shutter_cpi_1000.txt\').readlines()]\nfList5 = [s.strip() for s in open(\'../../papergraphs/scalability/libquantumcorunner/spec/degradation/shutter_cpi_1000.txt\').readlines()]\nfList6 = [s.strip() for s in open(\'../../papergraphs/scalability/libquantumcorunner/spec/snapshot/%s.txt\' % filename).readlines()]\n\nfList8= [s.strip() for s in open(\'../../papergraphs/scalability/libquantumcorunner/siriusdjinn/priorwork/shutter_cpi_4.txt\').readlines()]\n\nfList9 = [s.strip() for s in open(\'../../papergraphs/scalability/libquantumcorunner/siriusdjinn/singlevm/shutter_cpi_1000.txt\').readlines()]\nfList10 = [s.strip() for s in open(\'../../papergraphs/scalability/libquantumcorunner/siriusdjinn/degradation/shutter_cpi_1000.txt\').readlines()]\nfList11 = [s.strip() for s in open(\'../../papergraphs/scalability/libquantumcorunner/siriusdjinn/snapshot/shutter_cpi_10.txt\').readlines()]\n\n\ndictList_single_vm = defaultdict(list)\ndictList_degradation_colocation = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter2 = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter3 = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter4 = defaultdict(lambda  : defaultdict(list))\nplot_degradation = defaultdict(dict)\nplot_degradation2 = defaultdict(dict)\nplot_degradation_error = defaultdict(dict)\nplot_degradation_error2 = defaultdict(dict)\nplot_degradation_abs = defaultdict(dict)\nplot_degradation_abs2 = defaultdict(dict)\n\nfor (b,a) in enumerate(fList4):\n    if a in benchListBaseline:\n        dictList_single_vm[a].append(fList4[b+1])\n\n#SORTING LIST CONTAING VALUES OF SINGLE SPEC RUNS INSIDE VMs\nfor i in benchListBaseline:\n    dictList_single_vm[i].sort()\n    #print i,dictList_single_vm[i]\n\nfor (b,a) in enumerate(fList5):\n    #print a\n    if a in colocationListBaseline:\n       #print a\n       index = a\n    else:\n        if a in benchListExperiments:\n            #print a\n            dictList_degradation_colocation[index][a].append(fList5[b+1])\n\n#sorting the ground truth values\nfor a in xrange(0,len(runningList2),2):\n    j = runningList2[a+1]\n    i = runningList2[a]\n    dictList_degradation_colocation[j][i].sort()\n    #print j,i,dictList_degradation_colocation[j][i]\n\n\n\n#APPENDING DEGRADATION SHUTTER\nfor (b,a) in enumerate(fList6):\n    if a in colocationListExperiments:\n        index = a\n    else:\n        if a in benchListExperiments:\n            dictList_degradation_shutter[index][a].append(fList6[b+1])\n\nfor (b,a) in enumerate(fList3):\n    if a in colocationListExperiments:\n        index = a\n    else:\n        if a in benchListExperiments:\n            dictList_degradation_shutter3[index][a].append(fList3[b+1])\n\nfor a in xrange(0,len(runningList2),2):\n    j = runningList2[a+1]\n    i = runningList2[a]\n    #print i,j,dictList_degradation_shutter[j][i]\n#APPENDING DEGRADATION SHUTTER2 as shutter and colocation values are tab separated\nfor a in xrange(0,len(runningList2),2):\n    j = runningList2[a+1]\n    i = runningList2[a]\n    #print i,j\n    for elem in dictList_degradation_shutter[j][i]:\n        dictList_degradation_shutter2[j][i].extend(elem.strip().split(\'\\t\'))\n\n    for elem in dictList_degradation_shutter3[j][i]:\n        dictList_degradation_shutter4[j][i].extend(elem.strip().split(\'\\t\'))\n    #print dictList_degradation_shutter2[j][i]\n\nyaxis2 = ()\nyaxis3 = ()\nyaxis_abs2 = ()\nyaxis_abs3 = ()\nerror2 = ()\nerror3 = ()\nxaxis2 = ()\nfor a in xrange(0,len(runningList2),2):\n    j = runningList2[a+1]\n    i = runningList2[a]\n    #print i,j\n    #print dictList_single_vm[i]\n    #print dictList_degradation_colocation[j][i]\n    #print dictList_degradation_shutter2[j][i]\n    denominator1 = sum(float(n) for (m,n) in enumerate(dictList_single_vm[i]))/(len(dictList_single_vm[i]))\n    numerator1 = sum(float(n) for (m,n) in enumerate(dictList_degradation_colocation[j][i]))/(len(dictList_degradation_colocation[j][i]))\n    shutter_temp_list = []\n    shutter_temp_list2 = []\n    colo_temp_list = []\n    colo_temp_list2 = []\n    degradation_temp_list = []\n    degradation_temp_list2 = []\n    error_temp_list = []\n    error_temp_list2 = []\n    #print numerator1\n    #print denominator1\n    for (count,item) in enumerate(dictList_degradation_shutter2[j][i]):\n        if count%2==0:\n            colo_temp_list.append(item)\n        if count%2==1:\n            shutter_temp_list.append(item)\n\n    for (count,item) in enumerate(dictList_degradation_shutter4[j][i]):\n        if count%2==0:\n            colo_temp_list2.append(item)\n        if count%2==1:\n            shutter_temp_list2.append(item)\n\n    for (count,item) in enumerate(shutter_temp_list):\n        degradation_temp_list.append(abs((((float(shutter_temp_list[count])/float(colo_temp_list[count]))-(numerator1/denominator1))/(float(shutter_temp_list[count])/float(colo_temp_list[count])))*100))\n\n    shutter_temp_list.sort()\n    shutter_temp_list2.sort()\n    colo_temp_list.sort()\n    colo_temp_list2.sort()\n    #print shutter_temp_list\n    #print colo_temp_list\n    #print dictList_degradation_shutter2[j][i]\n    denominator2 = sum(float(n) for (m,n) in enumerate(shutter_temp_list))/(len(shutter_temp_list))\n    numerator2 = sum(float(n) for (m,n) in enumerate(colo_temp_list))/(len(colo_temp_list))\n    for (m,n) in enumerate(shutter_temp_list):\n        ratio=float(n)/float(colo_temp_list[m])\n        error_temp_list.append(abs((((ratio)-(numerator1/denominator1))/(numerator1/denominator1))*100))\n    plot_degradation_error[j][i]=np.std(error_temp_list)\n\n    denominator3 = sum(float(n) for (m,n) in enumerate(shutter_temp_list2))/(len(shutter_temp_list2))\n    numerator3 = sum(float(n) for (m,n) in enumerate(colo_temp_list2))/(len(colo_temp_list2))\n    for (m,n) in enumerate(shutter_temp_list2):\n        ratio=float(n)/float(colo_temp_list2[m])\n        error_temp_list2.append(abs((((ratio)-(numerator3/denominator3))/(numerator1/denominator1))*100))\n    plot_degradation_error2[j][i]=np.std(error_temp_list2)\n\n    #print numerator2\n    #print denominator2\n    del shutter_temp_list\n    del colo_temp_list\n    del degradation_temp_list\n    del shutter_temp_list2\n    del colo_temp_list2\n    del degradation_temp_list2\n    plot_degradation[j][i] = (((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100\n    plot_degradation_abs[j][i] = abs((((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100)\n    plot_degradation2[j][i] = (((numerator3/denominator3)-(numerator1/denominator1))/(numerator1/denominator1))*100\n    plot_degradation_abs2[j][i] = abs((((numerator3/denominator3)-(numerator1/denominator1))/(numerator1/denominator1))*100)\n    #print j,i,plot_degradation[j][i]\n    #print plot_degradation_error[j][i]\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    xaxis2 = xaxis2 + (i,)\n    yaxis2 = yaxis2 + (plot_degradation[j][i],)\n    yaxis3 = yaxis3 + (plot_degradation2[j][i],)\n    yaxis_abs2 = yaxis_abs2 + (plot_degradation_abs[j][i],)\n    yaxis_abs3 = yaxis_abs3 + (plot_degradation_abs2[j][i],)\n    error2 = error2 + (plot_degradation_error[j][i],)\n    error3 = error3 + (plot_degradation_error2[j][i],)\n\n\n#width=0.25\n#x = np.arange(len(yaxis2))\n#fig = plt.figure(figsize=(28, 5))\n##bar1 = plt.bar( x, yaxis, width, color="r", label=\'colocating with libquatum (avg = %.2f)\' %(np.mean(yaxis_abs)))\n#bar1 = plt.bar( x, yaxis_abs3, width, color="k", yerr=error3, label=\'Shuttering (mean: %.2f)\' %(np.mean(yaxis_abs3)))\n#bar2 = plt.bar( x+width, yaxis_abs2, width, color="lightgrey", yerr=error2, label=\'Snapshot (mean: %.2f)\' %(np.mean(yaxis_abs2)))\n#\n#plt.ylabel( \'Estimation error (%)\',fontsize=\'25\' )\n##plt.title(\'Error in predicting degradation when co-locating with milc\')\n#plt.xticks(x + width/2.0, xaxis2, rotation=\'30\', size=\'23\',  ha=\'center\', va=\'top\')\n#plt.yticks(np.arange(0,50,10),size=\'25\')\n#plt.ylim(0,50)\n#plt.xlim(-1,27)\n#plt.grid()\n#plt.tight_layout()\n#plt.legend(loc=9, ncol=2, prop={\'size\':28})\n##plt.savefig(\'milc_accuracy.pdf\', dpi=125)\n\ndel dictList_single_vm\ndel dictList_degradation_colocation\ndel dictList_degradation_shutter\ndel dictList_degradation_shutter2\ndel dictList_degradation_shutter3\ndel dictList_degradation_shutter4\ndel plot_degradation\ndel plot_degradation2\ndel plot_degradation_error\ndel plot_degradation_error2\ndel plot_degradation_abs\ndel plot_degradation_abs2\n\ndictList_single_vm = defaultdict(list)\ndictList_degradation_colocation = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter2 = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter3 = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter4 = defaultdict(lambda  : defaultdict(list))\nplot_degradation = defaultdict(dict)\nplot_degradation2 = defaultdict(dict)\nplot_degradation_error = defaultdict(dict)\nplot_degradation_error2 = defaultdict(dict)\nplot_degradation_abs = defaultdict(dict)\nplot_degradation_abs2 = defaultdict(dict)\n\nfor (b,a) in enumerate(fList9):\n    if a in siriusbenchListBaseline:\n        dictList_single_vm[a].append(fList9[b+1])\n\n\n#SORTING LIST CONTAING VALUES OF SINGLE SPEC RUNS INSIDE VMs\nfor i in siriusbenchListBaseline:\n    dictList_single_vm[i].sort()\n    print i,dictList_single_vm[i]\n\nfor (b,a) in enumerate(fList10):\n    #print a\n    if a in siriuscolocationListBaseline:\n       #print a\n       index = a\n    else:\n        if a in siriusbenchListExperiments:\n            #print a\n            dictList_degradation_colocation[index][a].append(fList10[b+1])\n\n#sorting the ground truth values\nfor a in xrange(0,len(siriusrunningList2),2):\n    j = siriusrunningList2[a+1]\n    i = siriusrunningList2[a]\n    #print i,j\n    dictList_degradation_colocation[j][i].sort()\n    print j,i,dictList_degradation_colocation[j][i]\n\n#for a in xrange(0,len(runningList),2):\n#    j = runningList[a+1]\n#    i = runningList[a]\n#    numerator1 = sum(float(n) for (m,n) in enumerate(dictList_degradation_colocation[j][i]) if m!=0 and m!=len(dictList_degradation_colocation[j][i])-1)/(len(dictList_degradation_colocation[j][i])-2)\n#    print numerator1\n#    #print dictList_degradation_colocation[runningList[a+1]][runningList[a]]\n#    #print numerator1\n\n#APPENDING DEGRADATION SHUTTER\nfor (b,a) in enumerate(fList11):\n    #print a\n    if a in siriuscolocationListExperiments:\n        index = a\n    else:\n        if a in siriusbenchListExperiments:\n            dictList_degradation_shutter[index][a].append(fList11[b+1])\n\nfor (b,a) in enumerate(fList8):\n    if a in siriuscolocationListExperiments:\n        index = a\n    else:\n        if a in siriusbenchListExperiments:\n            dictList_degradation_shutter3[index][a].append(fList8[b+1])\n\nfor a in xrange(0,len(siriusrunningList2),2):\n    j = siriusrunningList2[a+1]\n    i = siriusrunningList2[a]\n    print i,j,dictList_degradation_shutter[j][i]\n#APPENDING DEGRADATION SHUTTER2 as shutter and colocation values are tab separated\nfor a in xrange(0,len(siriusrunningList2),2):\n    j = siriusrunningList2[a+1]\n    i = siriusrunningList2[a]\n    for elem in dictList_degradation_shutter[j][i]:\n        dictList_degradation_shutter2[j][i].extend(elem.strip().split(\'\\t\'))\n\n    for elem in dictList_degradation_shutter3[j][i]:\n        dictList_degradation_shutter4[j][i].extend(elem.strip().split(\'\\t\'))\n    #print dictList_degradation_shutter2[j][i]\n\nfor a in xrange(0,len(siriusrunningList2),2):\n    j = siriusrunningList2[a+1]\n    i = siriusrunningList2[a]\n    print i,j\n    #print i\n    #print dictList_single_vm[i]\n    #print dictList_degradation_colocation[j][i]\n    #print dictList_degradation_shutter2[j][i]\n    denominator1 = sum(float(n) for (m,n) in enumerate(dictList_single_vm[i]))/(len(dictList_single_vm[i]))\n    numerator1 = sum(float(n) for (m,n) in enumerate(dictList_degradation_colocation[j][i]))/(len(dictList_degradation_colocation[j][i]))\n    shutter_temp_list = []\n    shutter_temp_list2 = []\n    colo_temp_list = []\n    colo_temp_list2 = []\n    degradation_temp_list = []\n    degradation_temp_list2 = []\n    error_temp_list = []\n    error_temp_list2 = []\n    #print numerator1\n    #print denominator1\n    for (count,item) in enumerate(dictList_degradation_shutter2[j][i]):\n        if count%2==0:\n            colo_temp_list.append(item)\n        if count%2==1:\n            shutter_temp_list.append(item)\n\n    for (count,item) in enumerate(dictList_degradation_shutter4[j][i]):\n        if count%2==0:\n            colo_temp_list2.append(item)\n        if count%2==1:\n            shutter_temp_list2.append(item)\n\n    for (count,item) in enumerate(shutter_temp_list):\n        degradation_temp_list.append(abs((((float(shutter_temp_list[count])/float(colo_temp_list[count]))-(numerator1/denominator1))/(float(shutter_temp_list[count])/float(colo_temp_list[count])))*100))\n\n    shutter_temp_list.sort()\n    shutter_temp_list2.sort()\n    colo_temp_list.sort()\n    colo_temp_list2.sort()\n    print shutter_temp_list\n    print colo_temp_list\n    #print dictList_degradation_shutter2[j][i]\n    denominator2 = sum(float(n) for (m,n) in enumerate(shutter_temp_list) )/len(shutter_temp_list)\n    numerator2 = sum(float(n) for (m,n) in enumerate(colo_temp_list))/len(colo_temp_list)\n    for (m,n) in enumerate(shutter_temp_list):\n        ratio=float(n)/float(colo_temp_list[m])\n        error_temp_list.append(abs((((ratio)-(numerator1/denominator1))/(numerator1/denominator1))*100))\n    plot_degradation_error[j][i]=np.std(error_temp_list)\n\n    denominator3 = sum(float(n) for (m,n) in enumerate(shutter_temp_list2))/(len(shutter_temp_list2))\n    numerator3 = sum(float(n) for (m,n) in enumerate(colo_temp_list2))/(len(colo_temp_list2))\n    for (m,n) in enumerate(shutter_temp_list2):\n        ratio=float(n)/float(colo_temp_list2[m])\n        error_temp_list2.append(abs((((ratio)-(numerator3/denominator3))/(numerator1/denominator1))*100))\n    plot_degradation_error2[j][i]=np.std(error_temp_list2)\n\n    print numerator2\n    print denominator2\n    del shutter_temp_list\n    del colo_temp_list\n    del degradation_temp_list\n    del shutter_temp_list2\n    del colo_temp_list2\n    del degradation_temp_list2\n    plot_degradation[j][i] = (((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100\n    plot_degradation_abs[j][i] = abs((((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100)\n    plot_degradation2[j][i] = (((numerator3/denominator3)-(numerator1/denominator1))/(numerator1/denominator1))*100\n    plot_degradation_abs2[j][i] = abs((((numerator3/denominator3)-(numerator1/denominator1))/(numerator1/denominator1))*100)\n    #print j,i,plot_degradation[j][i]\n    #print plot_degradation_error[j][i]\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    xaxis2 = xaxis2 + (i,)\n    yaxis2 = yaxis2 + (plot_degradation[j][i],)\n    yaxis3 = yaxis3 + (plot_degradation2[j][i],)\n    yaxis_abs2 = yaxis_abs2 + (plot_degradation_abs[j][i],)\n    yaxis_abs3 = yaxis_abs3 + (plot_degradation_abs2[j][i],)\n    error2 = error2 + (plot_degradation_error[j][i],)\n    error3 = error3 + (plot_degradation_error2[j][i],)\n    #print numerator2,denominator2,numerator2/denominator2\n    #print denominator2/numerator2\n    #print j,i,plot_degradation[j][i],plot_degradation2[j][i]\n            #print (((numerator2/denominator2)-(numerator1/denominator1))/(numerator2/denominator2))*100\n#print np.mean(yaxis2)\n\nbenchListBaseline = [ \'gcc\', \'perlbench\', \'leslie3d\', \'povray\', \'libquantum\', \'astar\', \'bzip2\', \'milc\', \'namd\', \'calculix\', \'h264ref\', \'sphinx3\', \'zeusmp\', \'gobmk\', \'hmmer\', \'tonto\', \'bwaves\', \'gromacs\', \'dealII\', \'sjeng\', \'lbm\', \'xalancbmk\', \'gamess\', \'cactusADM\', \'soplex\', \'GemsFDTD\', \'omnetpp\', \'mcf\' ]\nbenchListExperiments = [ \'gcc\', \'perlbench\', \'leslie3d\', \'povray\', \'libquantum\', \'astar\', \'bzip2\', \'milc\', \'namd\', \'calculix\', \'h264ref\', \'sphinx3\', \'zeusmp\', \'gobmk\', \'hmmer\', \'tonto\', \'bwaves\', \'gromacs\', \'dealII\', \'sjeng\', \'lbm\', \'xalancbmk\', \'gamess\', \'cactusADM\', \'soplex\', \'GemsFDTD\', \'omnetpp\', \'mcf\' ]\ncolocationListBaseline = [ \'colocating with lbm\', \'colocating with povray\', \'colocating with astar\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with mcf\' ]\ncolocationListExperiments = [ \'colocating with lbm\', \'colocating with povray\', \'colocating with perlbench\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with mcf\' ]\nrunningList2 = [  \'perlbench\', \'colocating with libquantum\', \'mcf\', \'colocating with libquantum\', \'leslie3d\', \'colocating with libquantum\', \'povray\', \'colocating with libquantum\', \'libquantum\', \'colocating with libquantum\', \'astar\', \'colocating with libquantum\', \'milc\', \'colocating with libquantum\', \'namd\', \'colocating with libquantum\', \'calculix\', \'colocating with libquantum\', \'h264ref\', \'colocating with libquantum\', \'gobmk\', \'colocating with libquantum\', \'hmmer\', \'colocating with libquantum\', \'tonto\', \'colocating with libquantum\', \'sphinx3\', \'colocating with libquantum\', \'bwaves\', \'colocating with libquantum\', \'gromacs\', \'colocating with libquantum\', \'dealII\', \'colocating with libquantum\', \'sjeng\', \'colocating with libquantum\', \'lbm\', \'colocating with libquantum\', \'xalancbmk\', \'colocating with libquantum\', \'gamess\', \'colocating with libquantum\', \'soplex\', \'colocating with libquantum\', \'GemsFDTD\', \'colocating with libquantum\', \'omnetpp\', \'colocating with libquantum\' ]\n\nsiriusbenchListBaseline = [ \'gmm\', \'dnn_asr\', \'surf-fe\', \'surf-fd\', \'stem\', \'regex\', \'crf\', \'img-imc\', \'img-dig\', \'img-face\', \'nlp-pos\', \'nlp-chk\', \'nlp-ner\']\nsiriusbenchListExperiments = [ \'gmm\', \'dnn_asr\', \'surf-fe\', \'surf-fd\', \'stem\', \'regex\', \'crf\', \'img-imc\', \'img-dig\', \'img-face\', \'nlp-pos\', \'nlp-chk\', \'nlp-ner\']\nsiriuscolocationListBaseline = [ \'colocating with lbm\', \'colocating with povray\', \'colocating with astar\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with mcf\' ]\nsiriuscolocationListExperiments = [ \'colocating with lbm\', \'colocating with povray\', \'colocating with perlbench\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with mcf\' ]\nsiriusrunningList2 = [ \'gmm\', \'colocating with libquantum\', \'dnn_asr\', \'colocating with libquantum\', \'surf-fe\', \'colocating with libquantum\', \'surf-fd\', \'colocating with libquantum\', \'stem\', \'colocating with libquantum\', \'regex\', \'colocating with libquantum\', \'crf\', \'colocating with libquantum\', \'img-imc\', \'colocating with libquantum\', \'img-dig\', \'colocating with libquantum\', \'img-face\', \'colocating with libquantum\', \'nlp-pos\', \'colocating with libquantum\', \'nlp-chk\', \'colocating with libquantum\', \'nlp-ner\' , \'colocating with libquantum\']\n\ndef autolabel(rects):\n    # attach some text labels\n    for rect in rects:\n        height = rect.get_height()\n        plt.text(rect.get_x()+rect.get_width()/2., 1.05*height, \'%.2f\'%float(height))\n\ndef autolabel2(rects):\n    # attach some text labels\n    for rect in rects:\n        height = rect.get_height()\n        plt.text(rect.get_x()+rect.get_width()/2., 1.05*height, \'%.2f\'%float(height))\n\ndef add_line(ax, xpos, ypos):\n    line = plt.Line2D([xpos, xpos], [ypos + .1, ypos - .5], transform=ax.transAxes, linewidth=2, color=\'black\')\n    line.set_clip_on(False)\n    ax.add_line(line)\n\nfilename = \'shutter_cpi_10\'\n\nfList3= [s.strip() for s in open(\'../../papergraphs/accuracy/libquantumcorunner/priorwork/shutter_cpi_5.txt\').readlines()]\n\nfList4 = [s.strip() for s in open(\'../../papergraphs/accuracy/libquantumcorunner/singlevm/shutter_cpi_1000.txt\').readlines()]\nfList5 = [s.strip() for s in open(\'../../papergraphs/accuracy/libquantumcorunner/degradation/shutter_cpi_1000.txt\').readlines()]\nfList6 = [s.strip() for s in open(\'../../papergraphs/accuracy/libquantumcorunner/snapshot2/%s.txt\' % filename).readlines()]\nfList7 = [s.strip() for s in open(\'../../papergraphs/accuracy/libquantumcorunner/degradation3/shutter_cpi_1000.txt\').readlines()]\n\nfList8= [s.strip() for s in open(\'../../papergraphs/accuracy/libquantumcorunner/siriusdjinn/priorwork/shutter_cpi_4.txt\').readlines()]\n\nfList9 = [s.strip() for s in open(\'../../papergraphs/accuracy/libquantumcorunner/siriusdjinn/singlevm/shutter_cpi_1000.txt\').readlines()]\nfList10 = [s.strip() for s in open(\'../../papergraphs/accuracy/libquantumcorunner/siriusdjinn/degradation/shutter_cpi_1000.txt\').readlines()]\nfList11 = [s.strip() for s in open(\'../../papergraphs/accuracy/libquantumcorunner/siriusdjinn/snapshot/%s.txt\' % filename).readlines()]\n\ndictList_single_vm = defaultdict(list)\ndictList_degradation_colocation = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_colocation2 = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter2 = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter3 = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter4 = defaultdict(lambda  : defaultdict(list))\nplot_degradation = defaultdict(dict)\nplot_degradation2 = defaultdict(dict)\nplot_degradation_error = defaultdict(dict)\nplot_degradation_error2 = defaultdict(dict)\nplot_degradation_abs = defaultdict(dict)\nplot_degradation_abs2 = defaultdict(dict)\n\nfor (b,a) in enumerate(fList4):\n    if a in benchListBaseline:\n        dictList_single_vm[a].append(fList4[b+1])\n\n#SORTING LIST CONTAING VALUES OF SINGLE SPEC RUNS INSIDE VMs\nfor i in benchListBaseline:\n    dictList_single_vm[i].sort()\n    #print i,dictList_single_vm[i]\n\nfor (b,a) in enumerate(fList5):\n    #print a\n    if a in colocationListBaseline:\n       #print a\n       index = a\n    else:\n        if a in benchListExperiments:\n            #print a\n            dictList_degradation_colocation[index][a].append(fList5[b+1])\n\n#sorting the ground truth values\nfor a in xrange(0,len(runningList2),2):\n    j = runningList2[a+1]\n    i = runningList2[a]\n    dictList_degradation_colocation[j][i].sort()\n    #print j,i,dictList_degradation_colocation[j][i]\n\nfor (b,a) in enumerate(fList7):\n    #print a\n    if a in colocationListBaseline:\n       #print a\n       index = a\n    else:\n        if a in benchListExperiments:\n            #print a\n            dictList_degradation_colocation2[index][a].append(fList7[b+1])\n\n#APPENDING DEGRADATION SHUTTER\nfor (b,a) in enumerate(fList6):\n    if a in colocationListExperiments:\n        index = a\n    else:\n        if a in benchListExperiments:\n            dictList_degradation_shutter[index][a].append(fList6[b+1])\n\nfor (b,a) in enumerate(fList3):\n    if a in colocationListExperiments:\n        index = a\n    else:\n        if a in benchListExperiments:\n            dictList_degradation_shutter3[index][a].append(fList3[b+1])\n\nfor a in xrange(0,len(runningList2),2):\n    j = runningList2[a+1]\n    i = runningList2[a]\n    #print i,j,dictList_degradation_shutter[j][i]\n#APPENDING DEGRADATION SHUTTER2 as shutter and colocation values are tab separated\nfor a in xrange(0,len(runningList2),2):\n    j = runningList2[a+1]\n    i = runningList2[a]\n    for elem in dictList_degradation_shutter[j][i]:\n        dictList_degradation_shutter2[j][i].extend(elem.strip().split(\'\\t\'))\n\n    for elem in dictList_degradation_shutter3[j][i]:\n        dictList_degradation_shutter4[j][i].extend(elem.strip().split(\'\\t\'))\n    #print dictList_degradation_shutter2[j][i]\n\nnewyaxis2 = ()\nnewyaxis3 = ()\nnewyaxis_abs2 = ()\nnewyaxis_abs3 = ()\nnewerror2 = ()\nnewerror3 = ()\nnewxaxis2 = ()\nfor a in xrange(0,len(runningList2),2):\n    j = runningList2[a+1]\n    i = runningList2[a]\n    #print i,j\n    #print dictList_single_vm[i]\n    #print dictList_degradation_colocation[j][i]\n    #print dictList_degradation_shutter2[j][i]\n    denominator1 = sum(float(n) for (m,n) in enumerate(dictList_single_vm[i]) if m!=0 and m!=len(dictList_single_vm[i])-1)/(len(dictList_single_vm[i])-2)\n    numerator1 = sum(float(n) for (m,n) in enumerate(dictList_degradation_colocation[j][i]))/(len(dictList_degradation_colocation[j][i]))\n    numerator10 = sum(float(n) for (m,n) in enumerate(dictList_degradation_colocation2[j][i]))/(len(dictList_degradation_colocation2[j][i]))\n    shutter_temp_list = []\n    shutter_temp_list2 = []\n    colo_temp_list = []\n    colo_temp_list2 = []\n    degradation_temp_list = []\n    degradation_temp_list2 = []\n    error_temp_list = []\n    error_temp_list2 = []\n    #print numerator1\n    #print denominator1\n    for (count,item) in enumerate(dictList_degradation_shutter2[j][i]):\n        if count%2==0:\n            colo_temp_list.append(item)\n        if count%2==1:\n            shutter_temp_list.append(item)\n\n    for (count,item) in enumerate(dictList_degradation_shutter4[j][i]):\n        if count%2==0:\n            colo_temp_list2.append(item)\n        if count%2==1:\n            shutter_temp_list2.append(item)\n\n    for (count,item) in enumerate(shutter_temp_list):\n        degradation_temp_list.append(abs((((float(shutter_temp_list[count])/float(colo_temp_list[count]))-(numerator1/denominator1))/(float(shutter_temp_list[count])/float(colo_temp_list[count])))*100))\n\n    shutter_temp_list.sort()\n    shutter_temp_list2.sort()\n    colo_temp_list.sort()\n    colo_temp_list2.sort()\n    #print shutter_temp_list\n    #print colo_temp_list\n    #print dictList_degradation_shutter2[j][i]\n    denominator2 = sum(float(n) for (m,n) in enumerate(shutter_temp_list) if m!=0 and m!=len(shutter_temp_list)-1 )/len(shutter_temp_list)\n    numerator2 = sum(float(n) for (m,n) in enumerate(colo_temp_list) if m!=0 and m!=len(colo_temp_list)-1  )/len(colo_temp_list)\n    for (m,n) in enumerate(shutter_temp_list):\n        ratio=float(n)/float(colo_temp_list[m])\n        error_temp_list.append(abs((((ratio)-(numerator10/denominator1))/(numerator10/denominator1))*100))\n    plot_degradation_error[j][i]=np.std(error_temp_list)\n\n    denominator3 = sum(float(n) for (m,n) in enumerate(shutter_temp_list2))/(len(shutter_temp_list2))\n    numerator3 = sum(float(n) for (m,n) in enumerate(colo_temp_list2))/(len(colo_temp_list2))\n    for (m,n) in enumerate(shutter_temp_list2):\n        ratio=float(n)/float(colo_temp_list2[m])\n        error_temp_list2.append(abs((((ratio)-(numerator3/denominator3))/(numerator1/denominator1))*100))\n    plot_degradation_error2[j][i]=np.std(error_temp_list2)\n\n    #print numerator2\n    #print denominator2\n    del shutter_temp_list\n    del colo_temp_list\n    del degradation_temp_list\n    del shutter_temp_list2\n    del colo_temp_list2\n    del degradation_temp_list2\n    plot_degradation[j][i] = (((numerator2/denominator2)-(numerator10/denominator1))/(numerator10/denominator1))*100\n    plot_degradation_abs[j][i] = abs((((numerator2/denominator2)-(numerator10/denominator1))/(numerator10/denominator1))*100)\n    plot_degradation2[j][i] = (((numerator3/denominator3)-(numerator1/denominator1))/(numerator1/denominator1))*100\n    plot_degradation_abs2[j][i] = abs((((numerator3/denominator3)-(numerator1/denominator1))/(numerator1/denominator1))*100)\n    #print j,i,plot_degradation[j][i]\n    #print plot_degradation_error[j][i]\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    newxaxis2 = newxaxis2 + (i,)\n    newyaxis2 = newyaxis2 + (plot_degradation[j][i],)\n    newyaxis3 = newyaxis3 + (plot_degradation2[j][i],)\n    newyaxis_abs2 = newyaxis_abs2 + (plot_degradation_abs[j][i],)\n    newyaxis_abs3 = newyaxis_abs3 + (plot_degradation_abs2[j][i],)\n    newerror2 = newerror2 + (plot_degradation_error[j][i],)\n    newerror3 = newerror3 + (plot_degradation_error2[j][i],)\n    #print numerator2,denominator2,numerator2/denominator2\n    #print denominator2/numerator2\n    #print j,i,plot_degradation[j][i]\n            #print (((numerator2/denominator2)-(numerator1/denominator1))/(numerator2/denominator2))*100\n#print np.mean(yaxis2)\n\n\n#width=0.25\n#x = np.arange(len(yaxis2))\n#fig = plt.figure(figsize=(28, 5))\n##bar1 = plt.bar( x, yaxis, width, color="r", label=\'colocating with libquatum (avg = %.2f)\' %(np.mean(yaxis_abs)))\n#bar1 = plt.bar( x, yaxis_abs3, width, color="k", yerr=error3, label=\'Shuttering (mean: %.2f)\' %(np.mean(yaxis_abs3)))\n#bar2 = plt.bar( x+width, yaxis_abs2, width, color="lightgrey", yerr=error2, label=\'Snapshot (mean: %.2f)\' %(np.mean(yaxis_abs2)))\n##bar3 = plt.bar( x+width+width, yaxis3, width, color="g", label=\'colocating with sphinx  (avg = %.2f)\' %(np.mean(yaxis_abs3)))\n##autolabel(bar1)\n##autolabel(bar2)\n#plt.ylabel( \'Estimation error (%)\' ,fontsize=\'25\')\n##plt.title(\'Error in predicting degradation when co-locating with libquantum\')\n#plt.xticks(x + width/2.0, xaxis2, rotation=\'30\', size=\'23\',  ha=\'center\', va=\'top\')\n##plt.yticks((-0.5,0,1,2,3,4),(\'\',\'0\',\'1\',\'2\',\'3\',\'4\'),size=\'23\')\n#plt.yticks((0,10,20,30,40,50),(\'0\',\'10\',\'20\',\'30\',\'40\',\' \'),size=\'25\')\n#plt.ylim(0,50)\n#plt.xlim(-1,26)\n#plt.grid()\n#plt.tight_layout()\n#plt.legend(loc=9, ncol=2, prop={\'size\':28})\n##plt.savefig(\'%s_maybefinal_error.png\' %(filename), dpi=125)\n\n\n## ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\ndel dictList_single_vm\ndel dictList_degradation_colocation\ndel dictList_degradation_shutter\ndel dictList_degradation_shutter2\ndel dictList_degradation_shutter3\ndel dictList_degradation_shutter4\ndel plot_degradation\ndel plot_degradation2\ndel plot_degradation_error\ndel plot_degradation_error2\ndel plot_degradation_abs\ndel plot_degradation_abs2\n\ndictList_single_vm = defaultdict(list)\ndictList_degradation_colocation = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter2 = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter3 = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter4 = defaultdict(lambda  : defaultdict(list))\nplot_degradation = defaultdict(dict)\nplot_degradation2 = defaultdict(dict)\nplot_degradation_error = defaultdict(dict)\nplot_degradation_error2 = defaultdict(dict)\nplot_degradation_abs = defaultdict(dict)\nplot_degradation_abs2 = defaultdict(dict)\n\nfor (b,a) in enumerate(fList9):\n    if a in siriusbenchListBaseline:\n        dictList_single_vm[a].append(fList9[b+1])\n\n#SORTING LIST CONTAING VALUES OF SINGLE SPEC RUNS INSIDE VMs\nfor i in siriusbenchListBaseline:\n    dictList_single_vm[i].sort()\n    #print i,dictList_single_vm[i]\n\nfor (b,a) in enumerate(fList10):\n    #print a\n    if a in siriuscolocationListBaseline:\n       #print a\n       index = a\n    else:\n        if a in siriusbenchListExperiments:\n            #print a\n            dictList_degradation_colocation[index][a].append(fList10[b+1])\n\n#sorting the ground truth values\nfor a in xrange(0,len(siriusrunningList2),2):\n    j = siriusrunningList2[a+1]\n    i = siriusrunningList2[a]\n    #print i,j\n    dictList_degradation_colocation[j][i].sort()\n    #print j,i,dictList_degradation_colocation[j][i]\n\n#for a in xrange(0,len(runningList),2):\n#    j = runningList[a+1]\n#    i = runningList[a]\n#    numerator1 = sum(float(n) for (m,n) in enumerate(dictList_degradation_colocation[j][i]) if m!=0 and m!=len(dictList_degradation_colocation[j][i])-1)/(len(dictList_degradation_colocation[j][i])-2)\n#    print numerator1\n#    #print dictList_degradation_colocation[runningList[a+1]][runningList[a]]\n#    #print numerator1\n\n#APPENDING DEGRADATION SHUTTER\nfor (b,a) in enumerate(fList11):\n    #print a\n    if a in siriuscolocationListExperiments:\n        index = a\n    else:\n        if a in siriusbenchListExperiments:\n            dictList_degradation_shutter[index][a].append(fList11[b+1])\n\nfor (b,a) in enumerate(fList8):\n    if a in siriuscolocationListExperiments:\n        index = a\n    else:\n        if a in siriusbenchListExperiments:\n            dictList_degradation_shutter3[index][a].append(fList8[b+1])\n\nfor a in xrange(0,len(siriusrunningList2),2):\n    j = siriusrunningList2[a+1]\n    i = siriusrunningList2[a]\n    #print i,j,dictList_degradation_shutter[j][i]\n#APPENDING DEGRADATION SHUTTER2 as shutter and colocation values are tab separated\nfor a in xrange(0,len(siriusrunningList2),2):\n    j = siriusrunningList2[a+1]\n    i = siriusrunningList2[a]\n    for elem in dictList_degradation_shutter[j][i]:\n        dictList_degradation_shutter2[j][i].extend(elem.strip().split(\'\\t\'))\n\n    for elem in dictList_degradation_shutter3[j][i]:\n        dictList_degradation_shutter4[j][i].extend(elem.strip().split(\'\\t\'))\n    #print dictList_degradation_shutter2[j][i]\n\nfor a in xrange(0,len(siriusrunningList2),2):\n    j = siriusrunningList2[a+1]\n    i = siriusrunningList2[a]\n    #print i,j\n    #print i\n    #print dictList_single_vm[i]\n    #print dictList_degradation_colocation[j][i]\n    #print dictList_degradation_shutter2[j][i]\n    denominator1 = sum(float(n) for (m,n) in enumerate(dictList_single_vm[i]) if m!=0 and m!=len(dictList_single_vm[i])-1)/(len(dictList_single_vm[i])-2)\n    numerator1 = sum(float(n) for (m,n) in enumerate(dictList_degradation_colocation[j][i]))/(len(dictList_degradation_colocation[j][i]))\n    shutter_temp_list = []\n    shutter_temp_list2 = []\n    colo_temp_list = []\n    colo_temp_list2 = []\n    degradation_temp_list = []\n    degradation_temp_list2 = []\n    error_temp_list = []\n    error_temp_list2 = []\n    #print numerator1\n    #print denominator1\n    for (count,item) in enumerate(dictList_degradation_shutter2[j][i]):\n        if count%2==0:\n            colo_temp_list.append(item)\n        if count%2==1:\n            shutter_temp_list.append(item)\n\n    for (count,item) in enumerate(dictList_degradation_shutter4[j][i]):\n        if count%2==0:\n            colo_temp_list2.append(item)\n        if count%2==1:\n            shutter_temp_list2.append(item)\n\n    for (count,item) in enumerate(shutter_temp_list):\n        degradation_temp_list.append(abs((((float(shutter_temp_list[count])/float(colo_temp_list[count]))-(numerator1/denominator1))/(float(shutter_temp_list[count])/float(colo_temp_list[count])))*100))\n\n    shutter_temp_list.sort()\n    shutter_temp_list2.sort()\n    colo_temp_list.sort()\n    colo_temp_list2.sort()\n    #print shutter_temp_list\n    #print colo_temp_list\n    #print dictList_degradation_shutter2[j][i]\n    denominator2 = sum(float(n) for (m,n) in enumerate(shutter_temp_list) if m!=0 and m!=len(dictList_single_vm[i])-1)/(len(dictList_single_vm[i])-2)/len(shutter_temp_list)\n    numerator2 = sum(float(n) for (m,n) in enumerate(colo_temp_list) if m!=0 and m!=len(dictList_single_vm[i])-1)/(len(dictList_single_vm[i])-2 )/len(colo_temp_list)\n    for (m,n) in enumerate(shutter_temp_list):\n        ratio=float(n)/float(colo_temp_list[m])\n        error_temp_list.append(abs((((ratio)-(numerator1/denominator1))/(numerator1/denominator1))*100))\n    plot_degradation_error[j][i]=np.std(error_temp_list)\n\n    denominator3 = sum(float(n) for (m,n) in enumerate(shutter_temp_list2))/(len(shutter_temp_list2))\n    numerator3 = sum(float(n) for (m,n) in enumerate(colo_temp_list2))/(len(colo_temp_list2))\n    for (m,n) in enumerate(shutter_temp_list2):\n        ratio=float(n)/float(colo_temp_list2[m])\n        error_temp_list2.append(abs((((ratio)-(numerator3/denominator3))/(numerator1/denominator1))*100))\n    plot_degradation_error2[j][i]=np.std(error_temp_list2)\n\n    #print numerator2\n    #print denominator2\n    del shutter_temp_list\n    del colo_temp_list\n    del degradation_temp_list\n    del shutter_temp_list2\n    del colo_temp_list2\n    del degradation_temp_list2\n    plot_degradation[j][i] = (((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100\n    plot_degradation_abs[j][i] = abs((((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100)\n    plot_degradation2[j][i] = (((numerator3/denominator3)-(numerator1/denominator1))/(numerator1/denominator1))*100\n    plot_degradation_abs2[j][i] = abs((((numerator3/denominator3)-(numerator1/denominator1))/(numerator1/denominator1))*100)\n    #print j,i,plot_degradation[j][i]\n    #print plot_degradation_error[j][i]\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    newxaxis2 = newxaxis2 + (i,)\n    newyaxis2 = newyaxis2 + (plot_degradation[j][i],)\n    newyaxis3 = newyaxis3 + (plot_degradation2[j][i],)\n    newyaxis_abs2 = newyaxis_abs2 + (plot_degradation_abs[j][i],)\n    newyaxis_abs3 = newyaxis_abs3 + (plot_degradation_abs2[j][i],)\n    newerror2 = newerror2 + (plot_degradation_error[j][i],)\n    newerror3 = newerror3 + (plot_degradation_error2[j][i],)\n    #print numerator2,denominator2,numerator2/denominator2\n    #print denominator2/numerator2\n    #print j,i,plot_degradation[j][i],plot_degradation2[j][i]\n            #print (((numerator2/denominator2)-(numerator1/denominator1))/(numerator2/denominator2))*100\n#print np.mean(yaxis2)\n\n\nwidth=0.25\nx = np.arange(len(yaxis2))\nfig = plt.figure(figsize=(25, 5))\nfig.subplots_adjust(bottom=0.5)\nax = fig.add_subplot(1,1,1)\n#bar1 = plt.bar( x, yaxis, width, color="r", label=\'colocating with libquatum (avg = %.2f)\' %(np.mean(yaxis_abs)))\n#bar1 = plt.bar( x, yaxis_abs3, width, color="r", yerr=error3, label=\'Shuttering (avg = %.2f)\' %(np.mean(yaxis_abs3)))\nbar1 = plt.bar( x, newyaxis_abs2, width, color="y", yerr=newerror2, label=\'Snapshot (avg = %.2f)\' %(np.mean(newyaxis_abs2)))\nbar2 = plt.bar( x+width, yaxis_abs2, width, color="y", yerr=error2, label=\'Snapshot (avg = %.2f)\' %(np.mean(yaxis_abs2)))\nly = len(yaxis_abs3)\nadd_line(ax, 0 * 1.0, -.1)\nadd_line(ax, 1 * 1.0, -.1)\nadd_line(ax, 1 * 0.675, -.1)\nadd_line(ax, 1 * 0.845, -.1)\n#scale = 40./ly\n#scale = 27./ly\n#for pos in xrange(ly + 1):\n#    print pos\n#    print scale\n#    add_line(ax, pos * scale, -.1)\n#scale = 34./ly\n#for pos in xrange(ly + 1):\n#    add_line(ax, pos * scale, -.1)\n#bar3 = plt.bar( x+width+width, yaxis3, width, color="g", label=\'colocating with sphinx  (avg = %.2f)\' %(np.mean(yaxis_abs3)))\n#autolabel(bar1)\n#autolabel(bar2)\nplt.ylabel( \'Estimation error (%)\', fontsize=\'19\' )\n#plt.title(\'Error in predicting degradation when co-locating with libquantum\')\nplt.xticks(x + width/2.0, xaxis2, rotation=\'90\', size=\'18\',  ha=\'center\', va=\'top\')\nplt.yticks(np.arange(0,50,10),size=\'20\')\nplt.ylim(0,40)\nplt.xlim(-1,40)\nplt.grid()\nplt.tight_layout()\nplt.legend(loc=1, ncol=2, prop={\'size\':18})\n#plt.savefig(\'accuracylibquantum.pdf\', dpi=125)\nax.text(10, -23, r\'SPEC 2006\', fontsize=20)\nax.text(29, -23, r\'Sirius Suite\', fontsize=20)\nax.text(35.5, -23, r\'DjiNN & Tonic\', fontsize=20)\n\nwidth=0.25\nx = np.arange(len(yaxis2))\nfig = plt.figure(figsize=(25, 5))\nax = fig.add_subplot(1,1,1)\n#bar1 = plt.bar( x, yaxis, width, color="r", label=\'colocating with libquatum (avg = %.2f)\' %(np.mean(yaxis_abs)))\n#bar1 = plt.bar( x, yaxis_abs3, width, color="r", yerr=error3, label=\'Shuttering (avg = %.2f)\' %(np.mean(yaxis_abs3)))\n#bar2 = plt.bar( x+width, yaxis_abs2, width, color="y", yerr=error2, label=\'Snapshot (avg = %.2f)\' %(np.mean(yaxis_abs2)))\nbar1 = plt.bar( x, newyaxis_abs2, width, color="y", yerr=newerror2, label=\'4 co-runners (avg = %.2f)\' %(np.mean(newyaxis_abs2)))\nbar2 = plt.bar( x+width, yaxis_abs2, width, color="r", yerr=error2, label=\'16 co-runners (avg = %.2f)\' %(np.mean(yaxis_abs2)))\nadd_line(ax, 0 * 1.0, -.1)\nadd_line(ax, 1 * 1.0, -.1)\nadd_line(ax, 1 * 0.675, -.1)\nadd_line(ax, 1 * 0.835, -.1)\n#bar3 = plt.bar( x+width+width, yaxis3, width, color="g", label=\'colocating with sphinx  (avg = %.2f)\' %(np.mean(yaxis_abs3)))\n#autolabel(bar1)\n#autolabel(bar2)\nplt.ylabel( \'Estimation error (%)\', fontsize=\'19\' )\n#plt.title(\'Error in predicting degradation when co-locating with libquantum\')\nplt.xticks(x + width/2.0, xaxis2, rotation=\'90\', size=\'18\',  ha=\'center\', va=\'top\')\nplt.yticks(np.arange(0,50,10),size=\'20\')\nplt.ylim(0,40)\nplt.xlim(-1,37)\nplt.grid()\nplt.tight_layout()\nplt.legend(loc=1, ncol=2, prop={\'size\':18})\n#plt.savefig(\'accuracylibquantum.pdf\', dpi=125)\nax.text(10, -23, r\'SPEC 2006\', fontsize=20)\nax.text(26, -23, r\'Sirius Suite\', fontsize=20)\nax.text(33, -23, r\'DjiNN & Tonic\', fontsize=20)\n'
p0
.I0
.S'$graph_fig:overhead-4-16VMs:Overhead:1'
p0
.S'from collections import defaultdict\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\nbenchList = [ \'gcc\', \'perlbench\', \'leslie3d\', \'povray\', \'libquantum\', \'astar\', \'bzip2\', \'milc\', \'namd\', \'calculix\', \'h264ref\', \'sphinx3\', \'zeusmp\', \'gobmk\', \'hmmer\', \'tonto\', \'bwaves\', \'gromacs\', \'dealII\', \'sjeng\', \'lbm\', \'xalancbmk\', \'gamess\', \'soplex\', \'GemsFDTD\', \'omnetpp\', \'mcf\', \'cactusADM\' ]\n\ncolocationList = [ \'colocating with libquantum\', \'colocating with mcf\',  \'colocating with sphinx3\']\ncolocationListBaseline = [ \'colocating with libquantum\', \'colocating with mcf\', \'colocating with sphinx3\' ]\n\n\nrunningList = [  \'perlbench\', \'colocating with libquantum\', \'mcf\', \'colocating with libquantum\', \'leslie3d\', \'colocating with libquantum\', \'povray\', \'colocating with libquantum\', \'libquantum\', \'colocating with libquantum\', \'astar\', \'colocating with libquantum\', \'milc\', \'colocating with libquantum\', \'namd\', \'colocating with libquantum\', \'calculix\', \'colocating with libquantum\', \'h264ref\', \'colocating with libquantum\', \'gobmk\', \'colocating with libquantum\', \'hmmer\', \'colocating with libquantum\', \'tonto\', \'colocating with libquantum\', \'sphinx3\', \'colocating with libquantum\', \'zeusmp\', \'colocating with libquantum\', \'bwaves\', \'colocating with libquantum\', \'gromacs\', \'colocating with libquantum\', \'dealII\', \'colocating with libquantum\', \'sjeng\', \'colocating with libquantum\', \'lbm\', \'colocating with libquantum\', \'xalancbmk\', \'colocating with libquantum\', \'gamess\', \'colocating with libquantum\', \'cactusADM\', \'colocating with libquantum\', \'soplex\', \'colocating with libquantum\', \'omnetpp\', \'colocating with libquantum\' ]\n\nsiriusbenchList = [ \'gmm\', \'dnn_asr\', \'surf-fe\', \'surf-fd\', \'stem\', \'regex\', \'crf\', \'img-imc\', \'img-dig\', \'img-face\', \'nlp-pos\', \'nlp-chk\', \'nlp-ner\']\nsiriuscolocationList = [ \'colocating with lbm\', \'colocating with povray\', \'colocating with astar\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with libquantum\' ]\nsiriusrunningList = [ \'gmm\', \'colocating with libquantum\', \'surf-fe\', \'colocating with libquantum\', \'surf-fd\', \'colocating with libquantum\', \'stem\', \'colocating with libquantum\', \'regex\', \'colocating with libquantum\', \'crf\', \'colocating with libquantum\', \'img-imc\', \'colocating with libquantum\', \'img-dig\', \'colocating with libquantum\', \'img-face\', \'colocating with libquantum\', \'nlp-pos\', \'colocating with libquantum\', \'nlp-chk\', \'colocating with libquantum\', \'nlp-ner\' , \'colocating with libquantum\']\n\ndef autolabel(rects):\n    # attach some text labels\n    for rect in rects:\n        height = rect.get_height()\n        plt.text(rect.get_x()+rect.get_width()/2., 1.05*height, \'%.2f\'%float(height), fontsize=8 )\n\ndef autolabel2(rects):\n    # attach some text labels\n    for rect in rects:\n        height = rect.get_height()\n        plt.text(rect.get_x()+rect.get_width()/2., -1.25*height, \'%.2f\'%float(height),\n                ha=\'center\', va=\'top\', fontsize=8)\n        #plt.text(rect.get_x()+rect.get_width()/2., 1.05*height, \'%.2f\'%float(height))\n\ndef add_line(ax, xpos, ypos):\n    line = plt.Line2D([xpos, xpos], [ypos + .1, ypos - .5], transform=ax.transAxes, linewidth=2, color=\'black\')\n    line.set_clip_on(False)\n    ax.add_line(line)\n\n\nfilename = \'execution_time_1000\'\nfList1 = [s.strip() for s in open(\'../../papergraphs/scalability/libquantumcorunner/spec/degradation/%s.txt\' % filename).readlines()]  #degradation\nfList2 = [s.strip() for s in open(\'../../papergraphs/scalability/libquantumcorunner/spec/snapshot/phase_change_10.txt\').readlines()]\nfList3 = [s.strip() for s in open(\'../../papergraphs/scalability/libquantumcorunner/spec/priorwork/execution_time_4.txt\').readlines()] #prior work\n\nfList4 = [s.strip() for s in open(\'../../papergraphs/scalability/libquantumcorunner/siriusdjinn/degradation/%s.txt\' % filename).readlines()]  #degradation\nfList5 = [s.strip() for s in open(\'../../papergraphs/scalability/libquantumcorunner/siriusdjinn/snapshot/phase_change_10.txt\').readlines()]\nfList6 = [s.strip() for s in open(\'../../papergraphs/scalability/libquantumcorunner/siriusdjinn/priorwork/execution_time_4.txt\').readlines()] #prior work\n\n\nexecution_time_shutter = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter = defaultdict(lambda  : defaultdict(list))\navg_execution_time_shutter = defaultdict(dict)\nexecution_time_shutter2 = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter2 = defaultdict(lambda  : defaultdict(list))\navg_execution_time_shutter2 = defaultdict(dict)\ndictList_phase_change = defaultdict(lambda  : defaultdict(list))\ndictList_phase_change2 = defaultdict(lambda  : defaultdict(list))\n\nstd_execution_time = defaultdict(dict)\n\ndef print_elapsed_time_shutter(time_shutter):\n    for j in colocationList:\n        for i in benchList:\n            print \'%s ||||  %s\'%(j,i)\n            print time_shutter[j][i]\n\n\nsep = \'u\'\nfor (b,a) in enumerate(fList1):\n    #print a\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            execution_time_shutter[index][a].append((fList1[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_shutter[\'colocating with mcf\'][\'perlbench\']\n#print((s.split(start))[1].split(end)[0])\n\nfor j in colocationList:\n    for i in benchList:\n        #print i\n        for k in execution_time_shutter[j][i]:\n            try:\n                m,s = [float (var) for var in k.split(\':\')]\n                temp = m*60 + s\n            except:\n                h,m,s = [float (var) for var in k.split(\':\')]\n                temp = h*3600 + m*60 + s\n            execution_time_sec_shutter[j][i].append(temp)\n\nfor (b,a) in enumerate(fList3):\n    #print a\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            #print index\n            #print a\n            execution_time_shutter2[index][a].append((fList3[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_shutter[\'colocating with mcf\'][\'perlbench\']\n#print((s.split(start))[1].split(end)[0])\n\nfor j in colocationList:\n    for i in benchList:\n        for k in execution_time_shutter2[j][i]:\n            try:\n                m,s = [float (var) for var in k.split(\':\')]\n                temp = m*60 + s\n            except:\n                h,m,s = [float (var) for var in k.split(\':\')]\n                temp = h*3600 + m*60 + s\n            #print k\n            execution_time_sec_shutter2[j][i].append(temp)\n\nfor (b,a) in enumerate(fList2):\n    #print a\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            dictList_phase_change[index][a].append(fList2[b+1])\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    #print j,i\n    for elem in dictList_phase_change[j][i]:\n        dictList_phase_change2[j][i].extend(elem.strip().split(\'\\t\'))\n    #print dictList_phase_change2[j][i]\n\nyaxis = ()\nyaxis2= ()\nyaxis_abs = ()\nerror = ()\nxaxis = ()\n#print dictList_phase_change2[\'colocating with mcf\'][\'perlbench\']\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    #print j,i\n    #print dictList_phase_change2[j][i]\n    #print i,j\n    shutter_temp_list = []\n    colo_temp_list = []\n    for (count,item) in enumerate(dictList_phase_change2[j][i]):\n        if count%2==1:\n            colo_temp_list.append(float(item))\n        if count%2==0:\n            shutter_temp_list.append(float(item))\n    #print shutter_temp_list\n    shutter_avg = sum(shutter_temp_list)/len(shutter_temp_list)\n    colocation_avg = sum(colo_temp_list)/len(colo_temp_list)\n    del shutter_temp_list\n    del colo_temp_list\n\n    pause_period = ((colocation_avg ) + ((shutter_avg + (colocation_avg * 2)/3) * 3))/4\n    xaxis = xaxis + (i,)\n    #print (pause_period/np.mean(execution_time_sec_shutter[j][i]))*10\n    yaxis = yaxis + ( (pause_period/np.mean(execution_time_sec_shutter[j][i]))*7.5  ,)\n    yaxis2 = yaxis2 + ( abs(((np.mean(execution_time_sec_shutter2[j][i])/np.mean(execution_time_sec_shutter[j][i])) - 1)*100), )\n    #print \'---------------------\'\n\n#print yaxis2\n#print np.mean(yaxis)\n\n\nwidth = 0.25\nx = np.arange(len(yaxis))\nfig = plt.figure(figsize=(28, 5))\nbar2 = plt.bar( x, yaxis2, width, color="k", label=\'Shuttering  (mean: %.2f)\' %(np.mean(yaxis2)))\nbar1 = plt.bar( x+width, yaxis, width, color="lightgrey", label=\'Snapshot (mean: %.2f)\' %(np.mean(yaxis) ))\n\n#plt.ylabel( \'Execution time \\n overhead(%)\',fontsize=23)\n##plt.title(\'Overhead due to Prediction of degradation while co-running with MCF\')\n#plt.xticks(x + width/2.0, xaxis, rotation=\'30\', size=\'23\', ha=\'center\')\n##plt.yticks((-5,0,10,20,30,40,50,60),(\'\',\'0\',\'10\',\'20\',\'30\',\'40\',\'50\',\'60\'),size=\'25\')\n#plt.yticks((0,5,10,15),(\'0\',\'5\',\'10\',\'15\'),size=\'25\')\n#plt.xlim(-1,27)\n#plt.grid()\n#plt.legend(loc=9, ncol=2, prop={\'size\':28})\n#plt.tight_layout()\n##plt.savefig(\'phase_chagnge_overheadmaybe.png\', dpi=125)\n\ndel execution_time_shutter\ndel execution_time_sec_shutter\ndel avg_execution_time_shutter\ndel execution_time_shutter2\ndel execution_time_sec_shutter2\ndel avg_execution_time_shutter2\ndel dictList_phase_change\ndel dictList_phase_change2\n\nexecution_time_shutter = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter = defaultdict(lambda  : defaultdict(list))\navg_execution_time_shutter = defaultdict(dict)\nexecution_time_shutter2 = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter2 = defaultdict(lambda  : defaultdict(list))\navg_execution_time_shutter2 = defaultdict(dict)\ndictList_phase_change = defaultdict(lambda  : defaultdict(list))\ndictList_phase_change2 = defaultdict(lambda  : defaultdict(list))\n\nstd_execution_time = defaultdict(dict)\n\ndef print_elapsed_time_shutter(time_shutter):\n    for j in siriuscolocationList:\n        for i in siriusbenchList:\n            print \'%s ||||  %s\'%(j,i)\n            print time_shutter[j][i]\n\n\nsep = \'u\'\nfor (b,a) in enumerate(fList4):\n    #print a\n    if a in siriuscolocationList:\n        index = a\n    else:\n        if a in siriusbenchList:\n            execution_time_shutter[index][a].append((fList4[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_shutter[\'colocating with mcf\'][\'perlbench\']\n#print((s.split(start))[1].split(end)[0])\n\nfor j in siriuscolocationList:\n    for i in siriusbenchList:\n        #print i\n        for k in execution_time_shutter[j][i]:\n            try:\n                m,s = [float (var) for var in k.split(\':\')]\n                temp = m*60 + s\n            except:\n                h,m,s = [float (var) for var in k.split(\':\')]\n                temp = h*3600 + m*60 + s\n\n            execution_time_sec_shutter[j][i].append(temp)\n\n#print fList6\nfor (b,a) in enumerate(fList6):\n    print a\n    if a in siriuscolocationList:\n        index = a\n    else:\n        if a in siriusbenchList:\n            #print index\n            #print a\n            #print fList6[b+4]\n            execution_time_shutter2[index][a].append((fList6[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_shutter[\'colocating with mcf\'][\'perlbench\']\n#print((s.split(start))[1].split(end)[0])\n\nfor j in siriuscolocationList:\n    for i in siriusbenchList:\n        for k in execution_time_shutter2[j][i]:\n            #print k\n            m,s = [float (var) for var in k.split(\':\')]\n            temp = m*60 + s\n            execution_time_sec_shutter2[j][i].append(temp)\n\nfor (b,a) in enumerate(fList5):\n    if a in siriuscolocationList:\n        index = a\n    else:\n        if a in siriusbenchList:\n            dictList_phase_change[index][a].append(fList5[b+1])\n\nfor a in xrange(0,len(siriusrunningList),2):\n    j = siriusrunningList[a+1]\n    i = siriusrunningList[a]\n    #print j,i\n    for elem in dictList_phase_change[j][i]:\n        dictList_phase_change2[j][i].extend(elem.strip().split(\'\\t\'))\n    #print dictList_phase_change2[j][i]\n\n#print dictList_phase_change2[\'colocating with mcf\'][\'perlbench\']\nfor a in xrange(0,len(siriusrunningList),2):\n    j = siriusrunningList[a+1]\n    i = siriusrunningList[a]\n    print j,i\n    #print dictList_phase_change2[j][i]\n    #print i,j\n    shutter_temp_list = []\n    colo_temp_list = []\n    for (count,item) in enumerate(dictList_phase_change2[j][i]):\n        if count%2==1:\n            colo_temp_list.append(float(item))\n        if count%2==0:\n            shutter_temp_list.append(float(item))\n    #print shutter_temp_list\n    shutter_avg = sum(shutter_temp_list)/len(shutter_temp_list)\n    colocation_avg = sum(colo_temp_list)/len(colo_temp_list)\n    del shutter_temp_list\n    del colo_temp_list\n\n    pause_period = ((colocation_avg ) + ((shutter_avg + (colocation_avg * 2)/3) * 3))/4\n    xaxis = xaxis + (i,)\n    #print (pause_period/np.mean(execution_time_sec_shutter[j][i]))*10\n    yaxis = yaxis + ( (pause_period/np.mean(execution_time_sec_shutter[j][i]))*10  ,)\n    yaxis2 = yaxis2 + ( abs(((np.mean(execution_time_sec_shutter2[j][i])/np.mean(execution_time_sec_shutter[j][i])) - 1)*100), )\n    print execution_time_sec_shutter2[j][i]\n    print execution_time_sec_shutter[j][i]\n    #print np.mean(execution_time_sec_shutter2[j][i])\n    #print np.mean(execution_time_sec_shutter[j][i])\n    #print \'---------------------\'\n\n#print xaxis\n#print yaxis\n#print yaxis2\n#print np.mean(yaxis)\n\n\nbenchList = [ \'gcc\', \'perlbench\', \'leslie3d\', \'povray\', \'libquantum\', \'astar\', \'bzip2\', \'milc\', \'namd\', \'calculix\', \'h264ref\', \'sphinx3\', \'zeusmp\', \'gobmk\', \'hmmer\', \'tonto\', \'bwaves\', \'gromacs\', \'dealII\', \'sjeng\', \'lbm\', \'xalancbmk\', \'gamess\', \'soplex\', \'GemsFDTD\', \'omnetpp\', \'mcf\', \'cactusADM\' ]\n\ncolocationList = [ \'colocating with libquantum\', \'colocating with mcf\',  \'colocating with sphinx3\']\ncolocationListBaseline = [ \'colocating with libquantum\', \'colocating with mcf\', \'colocating with sphinx3\' ]\n\n\n\n\nsiriusbenchList = [ \'gmm\', \'dnn_asr\', \'surf-fe\', \'surf-fd\', \'stem\', \'regex\', \'crf\', \'img-imc\', \'img-dig\', \'img-face\', \'nlp-pos\', \'nlp-chk\', \'nlp-ner\']\nsiriuscolocationList = [ \'colocating with lbm\', \'colocating with povray\', \'colocating with astar\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with mcf\' ]\n\ndef autolabel(rects):\n    # attach some text labels\n    for rect in rects:\n        height = rect.get_height()\n        plt.text(rect.get_x()+rect.get_width()/2., 1.05*height, \'%.2f\'%float(height), fontsize=8 )\n\ndef autolabel2(rects):\n    # attach some text labels\n    for rect in rects:\n        height = rect.get_height()\n        plt.text(rect.get_x()+rect.get_width()/2., -1.25*height, \'%.2f\'%float(height),\n                ha=\'center\', va=\'top\', fontsize=8)\n        #plt.text(rect.get_x()+rect.get_width()/2., 1.05*height, \'%.2f\'%float(height))\n\n\ndef add_line(ax, xpos, ypos):\n    line = plt.Line2D([xpos, xpos], [ypos + .1, ypos - .5], transform=ax.transAxes, linewidth=2, color=\'black\')\n    line.set_clip_on(False)\n    ax.add_line(line)\n\nfilename = \'execution_time_1000\'\nfList1 = [s.strip() for s in open(\'../../papergraphs/accuracy/libquantumcorunner/degradation2/%s.txt\' % filename).readlines()]  #degradation\nfList2 = [s.strip() for s in open(\'../../papergraphs/accuracy/libquantumcorunner/snapshot/phase_change_5.txt\').readlines()]\nfList3 = [s.strip() for s in open(\'../../papergraphs/accuracy/libquantumcorunner/priorwork/execution_time_5.txt\').readlines()] #prior work\n\n\nfList4 = [s.strip() for s in open(\'../../papergraphs/accuracy/libquantumcorunner/siriusdjinn/degradation/newval/%s.txt\' % filename).readlines()]  #degradation\nfList5 = [s.strip() for s in open(\'../../papergraphs/accuracy/libquantumcorunner/siriusdjinn/snapshot/phase_change_10.txt\').readlines()]\nfList6 = [s.strip() for s in open(\'../../papergraphs/accuracy/libquantumcorunner/siriusdjinn/priorwork/execution_time_4.txt\').readlines()] #prior work\n\nexecution_time_shutter = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter = defaultdict(lambda  : defaultdict(list))\navg_execution_time_shutter = defaultdict(dict)\nexecution_time_shutter2 = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter2 = defaultdict(lambda  : defaultdict(list))\navg_execution_time_shutter2 = defaultdict(dict)\ndictList_phase_change = defaultdict(lambda  : defaultdict(list))\ndictList_phase_change2 = defaultdict(lambda  : defaultdict(list))\n\nstd_execution_time = defaultdict(dict)\n\ndef print_elapsed_time_shutter(time_shutter):\n    for j in colocationList:\n        for i in benchList:\n            print \'%s ||||  %s\'%(j,i)\n            print time_shutter[j][i]\n\n\nsep = \'u\'\nfor (b,a) in enumerate(fList1):\n    #print a\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            execution_time_shutter[index][a].append((fList1[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_shutter[\'colocating with mcf\'][\'perlbench\']\n#print((s.split(start))[1].split(end)[0])\n\nfor j in colocationList:\n    for i in benchList:\n        for k in execution_time_shutter[j][i]:\n            m,s = [float (var) for var in k.split(\':\')]\n            temp = m*60 + s\n            execution_time_sec_shutter[j][i].append(temp)\n\nfor (b,a) in enumerate(fList3):\n    #print a\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            #print index\n            #print a\n            execution_time_shutter2[index][a].append((fList3[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_shutter[\'colocating with mcf\'][\'perlbench\']\n#print((s.split(start))[1].split(end)[0])\n\nfor j in colocationList:\n    for i in benchList:\n        for k in execution_time_shutter2[j][i]:\n            #print k\n            m,s = [float (var) for var in k.split(\':\')]\n            temp = m*60 + s\n            execution_time_sec_shutter2[j][i].append(temp)\n\nfor (b,a) in enumerate(fList2):\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            dictList_phase_change[index][a].append(fList2[b+1])\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    #print j,i\n    for elem in dictList_phase_change[j][i]:\n        dictList_phase_change2[j][i].extend(elem.strip().split(\'\\t\'))\n    #print dictList_phase_change2[j][i]\n\nnewyaxis = ()\nnewyaxis2= ()\nnewyaxis_abs = ()\nnewerror = ()\nnewxaxis = ()\n#print dictList_phase_change2[\'colocating with mcf\'][\'perlbench\']\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    print j,i\n    print dictList_phase_change2[j][i]\n    #print i,j\n    shutter_temp_list = []\n    colo_temp_list = []\n    for (count,item) in enumerate(dictList_phase_change2[j][i]):\n        if count%2==1:\n            colo_temp_list.append(float(item))\n        if count%2==0:\n            shutter_temp_list.append(float(item))\n    #print shutter_temp_list\n    shutter_avg = sum(shutter_temp_list)/len(shutter_temp_list)\n    colocation_avg = sum(colo_temp_list)/len(colo_temp_list)\n    del shutter_temp_list\n    del colo_temp_list\n\n    pause_period = ((colocation_avg ) + ((shutter_avg + (colocation_avg * 2)/3) * 3))/4\n    newxaxis = newxaxis + (i,)\n    #print (pause_period/np.mean(execution_time_sec_shutter[j][i]))*10\n    newyaxis = newyaxis + ( (pause_period/np.mean(execution_time_sec_shutter[j][i]))*7.5  ,)\n    newyaxis2 = newyaxis2 + ( (((np.mean(execution_time_sec_shutter2[j][i])/np.mean(execution_time_sec_shutter[j][i])) - 1)*100), )\n    print np.mean(execution_time_sec_shutter2[j][i])\n    print np.mean(execution_time_sec_shutter[j][i])\n    #print \'---------------------\'\n\nprint yaxis2\n#print np.mean(yaxis)\n\n\nwidth = 0.25\nx = np.arange(len(yaxis))\nfig = plt.figure(figsize=(28, 5))\nbar2 = plt.bar( x, yaxis2, width, color="k", label=\'Shuttering  (mean: %.2f)\' %(np.mean(yaxis2)))\nbar1 = plt.bar( x+width, yaxis, width, color="lightgrey", label=\'Snapshot (mean: %.2f)\' %(np.mean(yaxis) ))\n\n\nplt.ylabel( \'Execution time \\n overhead (%)\',fontsize=\'23\' )\n#plt.title(\'Overhead due to Prediction of degradation while co-running with LIBQUANTUM\')\nplt.xticks(x + width/2.0, xaxis, rotation=\'30\', size=\'23\', ha=\'center\')\n#plt.yticks((-5,0,10,20,30,40,50,60),(\'\',\'0\',\'10\',\'20\',\'30\',\'40\',\'50\',\'60\'),size=\'25\')\nplt.yticks((0,5,10,15),(\'0\',\'5\',\'10\',\'15\'),size=\'25\')\n#plt.yticks(np.arange(-10, 60, 10),size=\'25\')\nplt.xlim(-1,26)\nplt.grid()\nplt.legend(loc=9, ncol=2, prop={\'size\':28})\n#leg.get_frame().set_alpha(0.1)\nplt.tight_layout()\n#plt.savefig(\'phase_chagnge_overheadmaybe.png\', dpi=125)\n\n#### ----------------------------------------------------------------------------------------------------------------------------------\n\n\n#fList3 = [s.strip() for s in open(\'experiment_libquantum/phase_changes_5.txt\').readlines()]\n##fList3 = [s.strip() for s in open(\'../../papergraphs/2.fullspec/overhead/experiment_mcf/%s.txt\' % filename).readlines()]\n##fList4 = [s.strip() for s in open(\'../../papergraphs/2.fullspec/overhead/experiment_mcf/phase_changes_5.txt\').readlines()]\n##fList5 = [s.strip() for s in open(\'../../papergraphs/2.fullspec/overhead/experiment_sphinx3/%s.txt\' % filename).readlines()]\n##fList6 = [s.strip() for s in open(\'../../papergraphs/2.fullspec/overhead/experiment_sphinx3/phase_changes_5.txt\').readlines()]\n#print fList1\n\ndel execution_time_shutter\ndel execution_time_sec_shutter\ndel avg_execution_time_shutter\ndel execution_time_shutter2\ndel execution_time_sec_shutter2\ndel avg_execution_time_shutter2\ndel dictList_phase_change\ndel dictList_phase_change2\n\nexecution_time_shutter = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter = defaultdict(lambda  : defaultdict(list))\navg_execution_time_shutter = defaultdict(dict)\nexecution_time_shutter2 = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter2 = defaultdict(lambda  : defaultdict(list))\navg_execution_time_shutter2 = defaultdict(dict)\ndictList_phase_change = defaultdict(lambda  : defaultdict(list))\ndictList_phase_change2 = defaultdict(lambda  : defaultdict(list))\n\nstd_execution_time = defaultdict(dict)\n\ndef print_elapsed_time_shutter(time_shutter):\n    for j in siriuscolocationList:\n        for i in siriusbenchList:\n            print \'%s ||||  %s\'%(j,i)\n            print time_shutter[j][i]\n\n\nsep = \'u\'\nfor (b,a) in enumerate(fList4):\n    print a\n    if a in siriuscolocationList:\n        index = a\n    else:\n        if a in siriusbenchList:\n            execution_time_shutter[index][a].append((fList4[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_shutter[\'colocating with mcf\'][\'perlbench\']\n#print((s.split(start))[1].split(end)[0])\n\nfor j in siriuscolocationList:\n    for i in siriusbenchList:\n        #print i\n        for k in execution_time_shutter[j][i]:\n            try:\n                m,s = [float (var) for var in k.split(\':\')]\n                temp = m*60 + s\n            except:\n                h,m,s = [float (var) for var in k.split(\':\')]\n                temp = h*3600 + m*60 + s\n\n            execution_time_sec_shutter[j][i].append(temp)\n\nfor (b,a) in enumerate(fList6):\n    print a\n    if a in siriuscolocationList:\n        index = a\n    else:\n        if a in siriusbenchList:\n            #print index\n            #print a\n            execution_time_shutter2[index][a].append((fList6[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_shutter[\'colocating with mcf\'][\'perlbench\']\n#print((s.split(start))[1].split(end)[0])\n\nfor j in siriuscolocationList:\n    for i in siriusbenchList:\n        for k in execution_time_shutter2[j][i]:\n            #print k\n            m,s = [float (var) for var in k.split(\':\')]\n            temp = m*60 + s\n            execution_time_sec_shutter2[j][i].append(temp)\n\nfor (b,a) in enumerate(fList5):\n    if a in siriuscolocationList:\n        index = a\n    else:\n        if a in siriusbenchList:\n            dictList_phase_change[index][a].append(fList5[b+1])\n\nfor a in xrange(0,len(siriusrunningList),2):\n    j = siriusrunningList[a+1]\n    i = siriusrunningList[a]\n    #print j,i\n    for elem in dictList_phase_change[j][i]:\n        dictList_phase_change2[j][i].extend(elem.strip().split(\'\\t\'))\n    #print dictList_phase_change2[j][i]\n\n#print dictList_phase_change2[\'colocating with mcf\'][\'perlbench\']\nfor a in xrange(0,len(siriusrunningList),2):\n    j = siriusrunningList[a+1]\n    i = siriusrunningList[a]\n    #print j,i\n    #print dictList_phase_change2[j][i]\n    #print i,j\n    shutter_temp_list = []\n    colo_temp_list = []\n    for (count,item) in enumerate(dictList_phase_change2[j][i]):\n        if count%2==1:\n            colo_temp_list.append(float(item))\n        if count%2==0:\n            shutter_temp_list.append(float(item))\n    #print shutter_temp_list\n    shutter_avg = sum(shutter_temp_list)/len(shutter_temp_list)\n    colocation_avg = sum(colo_temp_list)/len(colo_temp_list)\n    del shutter_temp_list\n    del colo_temp_list\n\n    pause_period = ((colocation_avg ) + ((shutter_avg + (colocation_avg * 2)/3) * 3))/4\n    newxaxis = newxaxis + (i,)\n    #print (pause_period/np.mean(execution_time_sec_shutter[j][i]))*10\n    newyaxis = newyaxis + ( (pause_period/np.mean(execution_time_sec_shutter[j][i]))*10  ,)\n    newyaxis2 = newyaxis2 + ( abs(((np.mean(execution_time_sec_shutter2[j][i])/np.mean(execution_time_sec_shutter[j][i])) - 1)*100), )\n    #print np.mean(execution_time_sec_shutter2[j][i])\n    #print np.mean(execution_time_sec_shutter[j][i])\n    #print \'---------------------\'\n\n#print xaxis\n\n\n\n\nwidth = 0.25\nx = np.arange(len(yaxis))\nfig = plt.figure(figsize=(25, 5))\nax = fig.add_subplot(1,1,1)\n#bar2 = plt.bar( x, yaxis2, width, color="r", label=\'Shuttering  (avg = %.2f)\' %(np.mean(yaxis2)))\nbar2 = plt.bar( x, newyaxis, width, color="y", label=\'4 co-runners(avg = %.2f)\' %(np.mean(newyaxis) ))\nbar1 = plt.bar( x+width, yaxis, width, color="r", label=\'16 co-runners(avg = %.2f)\' %(np.mean(yaxis) ))\nly = len(yaxis2)\nadd_line(ax, 0 * 1, -.1)\nadd_line(ax, 1 * 1.0, -.1)\nadd_line(ax, 1 * 0.675, -.1)\nadd_line(ax, 1 * 0.835, -.1)\n#bar3 = plt.bar( x+width+width, yaxis3, width, color="g", label=\' colocating with sphinx3 (avg = %.1f)\' %(np.mean(yaxis3)))\n##bar3 = plt.bar( x+width+width, yaxis3, width, color="g", label=\'4 corunners (avg is %.1f)\' %(np.mean(yaxis3) ))\n##autolabel2(bar1)\n##autolabel(bar2)\n##autolabel2(bar3)\nplt.ylabel( \'Execution time \\n overhead(%)\', fontsize=\'19\' )\n#plt.title(\'Overhead due to Prediction of degradation while co-running with LIBQUANTUM\')\nplt.xticks(x + width/2.0, xaxis, rotation=\'90\', size=\'18\', ha=\'center\')\nplt.ylim(0,40)\nplt.xlim(-1,37)\nplt.yticks(np.arange(0,45,10),size=\'20\')\nplt.grid()\nplt.legend(loc=1, ncol=2, prop={\'size\':18})\nplt.tight_layout()\n#plt.savefig(\'overheadlibquantum.pdf\', dpi=125)\nax.text(10, -25, r\'SPEC 2006\', fontsize=20)\nax.text(26, -25, r\'Sirius Suite\', fontsize=20)\nax.text(33, -25, r\'DjiNN & Tonic\', fontsize=20)\n'
p0
.I0
.S'$sub_fig*:scaleup:Accuracy and overhead of snapshot when increasing the number of VMs. Shuttering suffers heavily as the co-runners scales up.:scaleup-accuracy,1:scaleup-overhead,1:'
p0
.S''
p0
.I2
.S'$graph_fig:scaleup-overhead:Overhead:0.7'
p0
.S'from collections import defaultdict\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom pylab import *\n\nbenchListBaseline = [ \'tonto\', \'sphinx3\', \'dealII\', \'soplex\', \'bzip2\', \'xalancbmk\', \'omnetpp\' ]\nbenchListExperiments = [ \'tonto\', \'sphinx3\', \'dealII\', \'soplex\', \'bzip2\', \'xalancbmk\', \'omnetpp\' ]\n#benchListExperiments = [ \'perlbench\', \'astar\', \'soplex\', \'xalancbmk\', \'omnetpp\']\ncolocationListBaseline = [ \'colocating with lbm\', \'colocating with povray\', \'colocating with astar\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with mcf\' ]\ncolocationListExperiments = [ \'colocating with lbm\', \'colocating with povray\', \'colocating with perlbench\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with mcf\' ]\n#runningList = [ \'xalancbmk\', \'colocating with libquantum\' ]\nrunningList = [ \'tonto\', \'colocating with libquantum\', \'sphinx3\', \'colocating with libquantum\', \'dealII\', \'colocating with libquantum\', \'soplex\', \'colocating with libquantum\',\'bzip2\', \'colocating with libquantum\', \'xalancbmk\', \'colocating with libquantum\', \'omnetpp\', \'colocating with libquantum\'  ]\ncolocationList = [ \'colocating with libquantum\', \'colocating with mcf\',  \'colocating with sphinx3\']\nbenchList = [  \'tonto\', \'sphinx3\', \'dealII\', \'soplex\', \'bzip2\', \'xalancbmk\', \'omnetpp\' ]\n#benchList = [  \'astar\', \'omnetpp\'  ]\n#colocationListOracle = [ \'colocating with gcc\', \'colocating with colocating with mcf\', \'colocating with perlbench\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with bzip2\' ]\n\ndef autolabel(rects):\n    # attach some text labels\n    for rect in rects:\n        height = rect.get_height()\n        plt.text(rect.get_x()+rect.get_width()/2., 1.1*height, \'%.2f\'%float(height), fontsize=8, ha=\'center\', va= \'bottom\')\n\ndef autolabel2(rects):\n    # attach some text labels\n    for rect in rects:\n        height = rect.get_height()\n        plt.text(rect.get_x()+rect.get_width()/2., -1.1*height, \'%.1f\'%float(height), fontsize=8, ha=\'center\', va= \'top\')\n\nfilename = \'shutter_cpi_1000\'\nfilename2 = \'shutter_cpi_4\'\nfList = [s.strip() for s in open(\'../../papergraphs/scalability/16vm/singlevm/shutter_cpi_1000.txt\').readlines()]\nfList2 = [s.strip() for s in open(\'../../papergraphs/scalability/2vm/degradation/%s.txt\' % filename).readlines()]\nfList3 = [s.strip() for s in open(\'../../papergraphs/scalability/4vm/degradation/%s.txt\' % filename).readlines()]\nfList4 = [s.strip() for s in open(\'../../papergraphs/scalability/8vm/degradation/%s.txt\' % filename).readlines()]\nfList4ex = [s.strip() for s in open(\'../../papergraphs/scalability/16vm/degradation/%s.txt\' % filename).readlines()]\nfList5 = [s.strip() for s in open(\'../../papergraphs/scalability/2vm/priorwork/%s.txt\' % filename2).readlines()]\nfList6 = [s.strip() for s in open(\'../../papergraphs/scalability/4vm/priorwork/%s.txt\' % filename2).readlines()]\nfList7 = [s.strip() for s in open(\'../../papergraphs/scalability/8vm/priorwork/%s.txt\' % filename2).readlines()]\nfList7ex = [s.strip() for s in open(\'../../papergraphs/scalability/16vm/priorwork/%s.txt\' % filename2).readlines()]\n\nexecutionground = \'execution_time_1000\'\nexecutionprior = \'execution_time_4\'\nfList8 = [s.strip() for s in open(\'../../papergraphs/scalability/2vm/degradation/%s.txt\' % executionground).readlines()]  #degradation\nfList9 = [s.strip() for s in open(\'../../papergraphs/scalability/2vm/priorwork/%s.txt\' % executionprior).readlines()]  #degradation\nfList10 = [s.strip() for s in open(\'../../papergraphs/scalability/4vm/degradation/%s.txt\' % executionground).readlines()]  #degradation\nfList11 = [s.strip() for s in open(\'../../papergraphs/scalability/4vm/priorwork/%s.txt\' % executionprior).readlines()]  #degradation\nfList12 = [s.strip() for s in open(\'../../papergraphs/scalability/8vm/degradation/%s.txt\' % executionground).readlines()]  #degradation\nfList13 = [s.strip() for s in open(\'../../papergraphs/scalability/8vm/priorwork/%s.txt\' % executionprior).readlines()]  #degradation\nfList14 = [s.strip() for s in open(\'../../papergraphs/scalability/16vm/degradation/%s.txt\' % executionground).readlines()]  #degradation\nfList15 = [s.strip() for s in open(\'../../papergraphs/scalability/16vm/priorwork/%s.txt\' % executionprior).readlines()]  #degradation\n\nfList16 = [s.strip() for s in open(\'../../papergraphs/scalability/2vm/snapshot/shutter_cpi_70.txt\' ).readlines()]\nfList17 = [s.strip() for s in open(\'../../papergraphs/scalability/4vm/snapshot/shutter_cpi_70.txt\' ).readlines()]\nfList18 = [s.strip() for s in open(\'../../papergraphs/scalability/8vm/snapshot/shutter_cpi_70.txt\' ).readlines()]\nfList19 = [s.strip() for s in open(\'../../papergraphs/scalability/16vm/snapshot/shutter_cpi_10.txt\').readlines()]\n\n\nfList20 = [s.strip() for s in open(\'../../papergraphs/scalability/2vm/snapshot/phase_change_70.txt\' ).readlines()]\nfList21 = [s.strip() for s in open(\'../../papergraphs/scalability/4vm/snapshot/phase_change_70.txt\' ).readlines()]\nfList22 = [s.strip() for s in open(\'../../papergraphs/scalability/8vm/snapshot/phase_change_70.txt\' ).readlines()]\nfList23 = [s.strip() for s in open(\'../../papergraphs/scalability/16vm/snapshot/phase_change_10.txt\').readlines()]\n\ndictList_single_vm = defaultdict(list)\ndictList_single_vm_mean = defaultdict(float)\ndictList_degradation_colocation = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter2 = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter3 = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter_prev = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter_prev2 = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter_prev3 = defaultdict(lambda  : defaultdict(list))\nfinal_degradation = defaultdict(lambda  : defaultdict(list))\nplot_degradation = defaultdict(dict)\nplot_degradation_error = defaultdict(dict)\n\nexecution_time_shutter = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter = defaultdict(lambda  : defaultdict(list))\nexecution_time_shutter2 = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter2 = defaultdict(lambda  : defaultdict(list))\n\nstd_execution_time = defaultdict(dict)\nglobal index\n\ndef print_elapsed_time_shutter(time_shutter):\n    for j in colocationList:\n        for i in benchList:\n            print \'%s ||||  %s\'%(j,i)\n            print time_shutter[j][i]\n\n\nsep = \'u\'\nfor (b,a) in enumerate(fList8):\n    #print a\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            execution_time_shutter[index][a].append((fList8[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_shutter[\'colocating with mcf\'][\'perlbench\']\n#print((s.split(start))[1].split(end)[0])\n\nfor j in colocationList:\n    for i in benchList:\n        for k in execution_time_shutter[j][i]:\n            m,s = [float (var) for var in k.split(\':\')]\n            temp = m*60 + s\n            execution_time_sec_shutter[j][i].append(temp)\n\nfor (b,a) in enumerate(fList9):\n    #print a\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            #print index\n            #print a\n            execution_time_shutter2[index][a].append((fList9[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\nfor j in colocationList:\n    for i in benchList:\n        for k in execution_time_shutter2[j][i]:\n            #print k\n            m,s = [float (var) for var in k.split(\':\')]\n            temp = m*60 + s\n            execution_time_sec_shutter2[j][i].append(temp)\n\noverhead2 = ()\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n\n    #print (pause_period/np.mean(execution_time_sec_shutter[j][i]))*10\n    overhead2 = overhead2 + ( abs(((np.mean(execution_time_sec_shutter2[j][i])/np.mean(execution_time_sec_shutter[j][i])) - 1)*100)*-1, )\n    #print np.mean(execution_time_sec_shutter2[j][i])\n    #print np.mean(execution_time_sec_shutter[j][i])\n\n#print overhead2\ndel execution_time_shutter\ndel execution_time_sec_shutter\ndel execution_time_shutter2\ndel execution_time_sec_shutter2\n\n## ------------------------------------------------------------------------------\n\nexecution_time_shutter = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter = defaultdict(lambda  : defaultdict(list))\nexecution_time_shutter2 = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter2 = defaultdict(lambda  : defaultdict(list))\n\nstd_execution_time = defaultdict(dict)\n\nsep = \'u\'\nfor (b,a) in enumerate(fList10):\n    #print a\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            execution_time_shutter[index][a].append((fList10[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_shutter[\'colocating with mcf\'][\'perlbench\']\n#print((s.split(start))[1].split(end)[0])\n\nfor j in colocationList:\n    for i in benchList:\n        #print i\n        for k in execution_time_shutter[j][i]:\n            try:\n                m,s = [float (var) for var in k.split(\':\')]\n                #print m,s\n                temp = m*60 + s\n            except:\n                h,m,s = [float (var) for var in k.split(\':\')]\n                #print h,m,s\n                temp = h*60*60 + m*60 + s\n            execution_time_sec_shutter[j][i].append(temp)\n\nfor (b,a) in enumerate(fList11):\n    #print a\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            #print index\n            #print a\n            execution_time_shutter2[index][a].append((fList11[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\nfor j in colocationList:\n    for i in benchList:\n        for k in execution_time_shutter2[j][i]:\n            try:\n                m,s = [float (var) for var in k.split(\':\')]\n                #print m,s\n                temp = m*60 + s\n            except:\n                h,m,s = [float (var) for var in k.split(\':\')]\n                #print h,m,s\n                temp = h*60*60 + m*60 + s\n            execution_time_sec_shutter2[j][i].append(temp)\n\noverhead3 = ()\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    #print i\n\n    #print (pause_period/np.mean(execution_time_sec_shutter[j][i]))*10\n    overhead3 = overhead3 + ( abs(((np.mean(execution_time_sec_shutter2[j][i])/np.mean(execution_time_sec_shutter[j][i])) - 1)*100)*-1, )\n    #print np.mean(execution_time_sec_shutter2[j][i])\n    #print np.mean(execution_time_sec_shutter[j][i])\n\n#rint overhead3\ndel execution_time_shutter\ndel execution_time_sec_shutter\ndel execution_time_shutter2\ndel execution_time_sec_shutter2\n\n\n## ------------------------------------------------------------------------------\n\nexecution_time_shutter = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter = defaultdict(lambda  : defaultdict(list))\nexecution_time_shutter2 = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter2 = defaultdict(lambda  : defaultdict(list))\n\nstd_execution_time = defaultdict(dict)\n\ndef print_elapsed_time_shutter(time_shutter):\n    for j in colocationList:\n        for i in benchList:\n            print \'%s ||||  %s\'%(j,i)\n            print time_shutter[j][i]\n\n\nsep = \'u\'\nfor (b,a) in enumerate(fList12):\n    #print a\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            execution_time_shutter[index][a].append((fList12[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_shutter[\'colocating with mcf\'][\'perlbench\']\n#print((s.split(start))[1].split(end)[0])\n\nfor j in colocationList:\n    for i in benchList:\n        #print i\n        for k in execution_time_shutter[j][i]:\n            try:\n                m,s = [float (var) for var in k.split(\':\')]\n                #print m,s\n                temp = m*60 + s\n            except:\n                h,m,s = [float (var) for var in k.split(\':\')]\n                #print h,m,s\n                temp = h*60*60 + m*60 + s\n            execution_time_sec_shutter[j][i].append(temp)\n\nfor (b,a) in enumerate(fList13):\n    #print a\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            #print index\n            #print a\n            execution_time_shutter2[index][a].append((fList13[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n            #execution_time_shutter2[index][a].append((fList13[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\nfor j in colocationList:\n    for i in benchList:\n        for k in execution_time_shutter2[j][i]:\n            try:\n                m,s = [float (var) for var in k.split(\':\')]\n                #print m,s\n                temp = m*60 + s\n            except:\n                h,m,s = [float (var) for var in k.split(\':\')]\n                #print h,m,s\n                temp = h*60*60 + m*60 + s\n            #print k\n            execution_time_sec_shutter2[j][i].append(temp)\n\noverhead4 = ()\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    #print i\n\n    #print (pause_period/np.mean(execution_time_sec_shutter[j][i]))*10\n    overhead4 = overhead4 + ( (((np.mean(execution_time_sec_shutter2[j][i])/np.mean(execution_time_sec_shutter[j][i])) - 1)*100)*-1, )\n    #print np.mean(execution_time_sec_shutter2[j][i])\n    #print np.mean(execution_time_sec_shutter[j][i])\n\n#print overhead4\ndel execution_time_shutter\ndel execution_time_sec_shutter\ndel execution_time_shutter2\ndel execution_time_sec_shutter2\n\n## ------------------------------------------------------------------------------\n\nexecution_time_shutter = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter = defaultdict(lambda  : defaultdict(list))\nexecution_time_shutter2 = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter2 = defaultdict(lambda  : defaultdict(list))\n\nstd_execution_time = defaultdict(dict)\n\ndef print_elapsed_time_shutter(time_shutter):\n    for j in colocationList:\n        for i in benchList:\n            print \'%s ||||  %s\'%(j,i)\n            print time_shutter[j][i]\n\n\nsep = \'u\'\nfor (b,a) in enumerate(fList14):\n    #print a\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            #print a\n            execution_time_shutter[index][a].append((fList14[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_shutter[\'colocating with mcf\'][\'perlbench\']\n#print((s.split(start))[1].split(end)[0])\n\nfor j in colocationList:\n    for i in benchList:\n        #print i\n        for k in execution_time_shutter[j][i]:\n            try:\n                m,s = [float (var) for var in k.split(\':\')]\n                #print m,s\n                temp = m*60 + s\n            except:\n                h,m,s = [float (var) for var in k.split(\':\')]\n                #print h,m,s\n                temp = h*60*60 + m*60 + s\n            execution_time_sec_shutter[j][i].append(temp)\n\nfor (b,a) in enumerate(fList15):\n    #print a\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            #print index\n            #print a\n            execution_time_shutter2[index][a].append((fList15[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n            #execution_time_shutter2[index][a].append((fList13[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\nfor j in colocationList:\n    for i in benchList:\n        for k in execution_time_shutter2[j][i]:\n            try:\n                m,s = [float (var) for var in k.split(\':\')]\n                #print m,s\n                temp = m*60 + s\n            except:\n                h,m,s = [float (var) for var in k.split(\':\')]\n                #print h,m,s\n                temp = h*60*60 + m*60 + s\n            #print k\n            execution_time_sec_shutter2[j][i].append(temp)\n\noverhead5 = ()\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    #print i,j\n\n    #print (pause_period/np.mean(execution_time_sec_shutter[j][i]))*10\n    overhead5 = overhead5 + ( (((np.mean(execution_time_sec_shutter2[j][i])/np.mean(execution_time_sec_shutter[j][i])) - 1)*100)*-1, )\n    #print np.mean(execution_time_sec_shutter2[j][i])\n    #print np.mean(execution_time_sec_shutter[j][i])\n\n#print overhead5\ndel execution_time_shutter\ndel execution_time_sec_shutter\ndel execution_time_shutter2\ndel execution_time_sec_shutter2\n\n\n## ------------------------------------------------------------------------------\n\n\n\nfor (b,a) in enumerate(fList):\n    if a in benchListBaseline:\n        dictList_single_vm[a].append(fList[b+1])\n\n#SORTING LIST CONTAING VALUES OF SINGLE SPEC RUNS INSIDE VMs\nfor i in benchListBaseline:\n    dictList_single_vm[i].sort()\n    dictList_single_vm_mean[i] = sum(float(item) for item in dictList_single_vm[i])/len(dictList_single_vm[i])\n#    numerator1 = sum(float(n) for (m,n) in enumerate(dictList_degradation_colocation[j][i]))/(len(dictList_degradation_colocation[j][i]))\n    #print i,dictList_single_vm_mean[i]\n\n    #print i,dictList_single_vm[i]\n\nfor (b,a) in enumerate(fList2):\n    #print a\n    if a in colocationListBaseline:\n       #print a\n       index = a\n    else:\n        if a in benchListExperiments:\n            #print a\n            dictList_degradation_colocation[index][a].append(fList2[b+1])\n#sorting the ground truth values\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    #dictList_degradation_colocation[j][i].sort()\n    #print j,i,dictList_degradation_colocation[j][i]\n\n#APPENDING DEGRADATION SHUTTER\nfor (b,a) in enumerate(fList3):\n    if a in colocationListExperiments:\n        index = a\n    else:\n        if a in benchListExperiments:\n            dictList_degradation_shutter[index][a].append(fList3[b+1])\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    #dictList_degradation_colocation[j][i].sort()\n    #print j,i,dictList_degradation_shutter[j][i]\n\nfor (b,a) in enumerate(fList4):\n    if a in colocationListExperiments:\n        index = a\n    else:\n        if a in benchListExperiments:\n            dictList_degradation_shutter2[index][a].append(fList4[b+1])\n\n\nfor (b,a) in enumerate(fList4ex):\n    if a in colocationListExperiments:\n        index = a\n    else:\n        if a in benchListExperiments:\n            dictList_degradation_shutter3[index][a].append(fList4ex[b+1])\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    #dictList_degradation_colocation[j][i].sort()\n    #print j,i,dictList_degradation_shutter2[j][i]\n\n\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    #dictList_degradation_colocation[j][i].sort()\n    #print j,i,dictList_degradation_shutter2[j][i]\n    sum_of = []\n    for n in dictList_degradation_colocation[j][i]:\n        sum_of.append(float(n))\n    #print np.mean(sum_of)\n    final_degradation[j][i].append(np.mean(sum_of))\n    del sum_of\n\n    sum_of = []\n    for n in dictList_degradation_shutter[j][i]:\n        sum_of.append(float(n))\n    #print np.mean(sum_of)\n    final_degradation[j][i].append(np.mean(sum_of))\n    del sum_of\n\n    sum_of = []\n    for n in dictList_degradation_shutter2[j][i]:\n        #print n\n        sum_of.append(float(n))\n    #print np.mean(sum_of)\n    final_degradation[j][i].append(np.mean(sum_of))\n    del sum_of\n\n    sum_of = []\n    for n in dictList_degradation_shutter3[j][i]:\n        #print n\n        sum_of.append(float(n))\n    #print np.mean(sum_of)\n    final_degradation[j][i].append(np.mean(sum_of))\n    del sum_of\n\nxaxis = ()\nvm2 = ()\nvm3 = ()\nvm4 = ()\nvm5 = ()\n#fig, ax = plt.subplots()\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    plot_list = []\n    xaxis = xaxis + (i,)\n    for (count,item) in enumerate(final_degradation[j][i]):\n        #print count\n        if count == 0:\n            vm2 = vm2 + (final_degradation[j][i][0]/dictList_single_vm_mean[i] ,)\n        if count == 1:\n            vm3 = vm3 + (final_degradation[j][i][1]/dictList_single_vm_mean[i], )\n        if count == 2:\n            vm4 = vm4 + (final_degradation[j][i][2]/dictList_single_vm_mean[i], )\n        if count == 3:\n            vm5 = vm5 + (final_degradation[j][i][3]/dictList_single_vm_mean[i], )\n\n#print vm2\n#print vm3\n#print vm4\n#print vm5\n\n\nshutter_vm2 = ()\nshutter_vm3 = ()\nshutter_vm4 = ()\nshutter_vm5 = ()\n\n\nfor (b,a) in enumerate(fList5):\n    if a in colocationListExperiments:\n        index = a\n    else:\n        if a in benchListExperiments:\n            dictList_degradation_shutter_prev[index][a].append(fList5[b+1])\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    for elem in dictList_degradation_shutter_prev[j][i]:\n        dictList_degradation_shutter_prev2[j][i].extend(elem.strip().split(\'\\t\'))\n    #print dictList_degradation_shutter_prev2[j][i]\n\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    #print i\n    denominator1 = sum(float(n) for (m,n) in enumerate(dictList_single_vm[i]))/(len(dictList_single_vm[i]))\n    numerator1 = sum(float(n) for (m,n) in enumerate(dictList_degradation_colocation[j][i]))/(len(dictList_degradation_colocation[j][i]))\n    shutter_temp_list = []\n    colo_temp_list = []\n    degradation_temp_list = []\n    error_temp_list = []\n    #print numerator1\n    #print denominator1\n    for (count,item) in enumerate(dictList_degradation_shutter_prev2[j][i]):\n        #print item\n        if count%2==0:\n            colo_temp_list.append(item)\n        if count%2==1:\n            shutter_temp_list.append(item)\n\n    for (count,item) in enumerate(shutter_temp_list):\n        degradation_temp_list.append(abs((((float(shutter_temp_list[count])/float(colo_temp_list[count]))-(numerator1/denominator1))/(float(shutter_temp_list[count])/float(colo_temp_list[count])))*100))\n\n    shutter_temp_list.sort()\n    colo_temp_list.sort()\n    #print shutter_temp_list\n    #print colo_temp_list\n    #print dictList_degradation_shutter2[j][i]\n    denominator2 = sum(float(n) for (m,n) in enumerate(shutter_temp_list))/len(shutter_temp_list)\n    #print len(colo_temp_list)\n    #print len(shutter_temp_list)\n    numerator2 = sum(float(n) for (m,n) in enumerate(colo_temp_list))/len(colo_temp_list)\n    for (m,n) in enumerate(shutter_temp_list):\n        ratio=float(n)/float(colo_temp_list[m])\n        error_temp_list.append(abs((((ratio)-(numerator1/denominator1))/(numerator1/denominator1))*100))\n    plot_degradation_error[j][i]=np.std(error_temp_list)\n\n    #print numerator2\n    #print denominator2\n    del shutter_temp_list\n    del colo_temp_list\n    del degradation_temp_list\n    #plot_degradation[j][i] = abs((((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100)\n    plot_degradation[j][i] = abs(((denominator2/denominator1)-1)*100)\n    shutter_vm2 = shutter_vm2 + (plot_degradation[j][i],)\n    #print denominator2/numerator2\n    #print j,i,plot_degradation[j][i]\n            #print (((numerator2/denominator2)-(numerator1/denominator1))/(numerator2/denominator2))*100\n\n#print shutter_vm2\n\n\ndel dictList_degradation_shutter_prev\ndel dictList_degradation_shutter_prev2\ndel plot_degradation\ndel plot_degradation_error\n\ndictList_degradation_shutter_prev = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter_prev2 = defaultdict(lambda  : defaultdict(list))\nplot_degradation = defaultdict(dict)\nplot_degradation_error = defaultdict(dict)\n\n\nfor (b,a) in enumerate(fList6):\n    if a in colocationListExperiments:\n        index = a\n    else:\n        if a in benchListExperiments:\n            dictList_degradation_shutter_prev[index][a].append(fList6[b+1])\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    for elem in dictList_degradation_shutter_prev[j][i]:\n        dictList_degradation_shutter_prev2[j][i].extend(elem.strip().split(\'\\t\'))\n    #print dictList_degradation_shutter_prev2[j][i]\n\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    #print i\n    denominator1 = sum(float(n) for (m,n) in enumerate(dictList_single_vm[i]))/(len(dictList_single_vm[i]))\n    numerator1 = sum(float(n) for (m,n) in enumerate(dictList_degradation_shutter[j][i]))/(len(dictList_degradation_shutter[j][i]))\n    shutter_temp_list = []\n    colo_temp_list = []\n    degradation_temp_list = []\n    error_temp_list = []\n    #print numerator1\n    #print denominator1\n    for (count,item) in enumerate(dictList_degradation_shutter_prev2[j][i]):\n        #print item\n        if count%2==0:\n            colo_temp_list.append(item)\n        if count%2==1:\n            shutter_temp_list.append(item)\n\n    for (count,item) in enumerate(shutter_temp_list):\n        degradation_temp_list.append(abs((((float(shutter_temp_list[count])/float(colo_temp_list[count]))-(numerator1/denominator1))/(float(shutter_temp_list[count])/float(colo_temp_list[count])))*100))\n\n    shutter_temp_list.sort()\n    colo_temp_list.sort()\n    #print shutter_temp_list\n    #print colo_temp_list\n    #print dictList_degradation_shutter2[j][i]\n    denominator2 = sum(float(n) for (m,n) in enumerate(shutter_temp_list))/len(shutter_temp_list)\n    #print len(colo_temp_list)\n    #print len(shutter_temp_list)\n    numerator2 = sum(float(n) for (m,n) in enumerate(colo_temp_list))/len(colo_temp_list)\n    for (m,n) in enumerate(shutter_temp_list):\n        ratio=float(n)/float(colo_temp_list[m])\n        error_temp_list.append(abs((((ratio)-(numerator1/denominator1))/(numerator1/denominator1))*100))\n    plot_degradation_error[j][i]=np.std(error_temp_list)\n\n    #print numerator2\n    #print denominator2\n    del shutter_temp_list\n    del colo_temp_list\n    del degradation_temp_list\n    #plot_degradation[j][i] = abs((((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100)\n    plot_degradation[j][i] = abs(((denominator2/denominator1)-1)*100)\n    shutter_vm3 = shutter_vm3 + (plot_degradation[j][i],)\n    #print denominator2/numerator2\n    #print j,i,plot_degradation[j][i]\n            #print (((numerator2/denominator2)-(numerator1/denominator1))/(numerator2/denominator2))*100\n\n#print shutter_vm3\n\n\nfor (b,a) in enumerate(fList7):\n    if a in colocationListExperiments:\n        index = a\n    else:\n        if a in benchListExperiments:\n            dictList_degradation_shutter_prev[index][a].append(fList7[b+1])\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    for elem in dictList_degradation_shutter_prev[j][i]:\n        dictList_degradation_shutter_prev2[j][i].extend(elem.strip().split(\'\\t\'))\n    #print dictList_degradation_shutter_prev2[j][i]\n\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    #print i\n    denominator1 = sum(float(n) for (m,n) in enumerate(dictList_single_vm[i]))/(len(dictList_single_vm[i]))\n    numerator1 = sum(float(n) for (m,n) in enumerate(dictList_degradation_shutter2[j][i]))/(len(dictList_degradation_shutter2[j][i]))\n    shutter_temp_list = []\n    colo_temp_list = []\n    degradation_temp_list = []\n    error_temp_list = []\n    #print numerator1\n    #print denominator1\n    for (count,item) in enumerate(dictList_degradation_shutter_prev2[j][i]):\n        #print item\n        if count%2==0:\n            colo_temp_list.append(item)\n        if count%2==1:\n            shutter_temp_list.append(item)\n\n    for (count,item) in enumerate(shutter_temp_list):\n        degradation_temp_list.append(abs((((float(shutter_temp_list[count])/float(colo_temp_list[count]))-(numerator1/denominator1))/(float(shutter_temp_list[count])/float(colo_temp_list[count])))*100))\n\n    shutter_temp_list.sort()\n    colo_temp_list.sort()\n    #print shutter_temp_list\n    #print colo_temp_list\n    #print dictList_degradation_shutter2[j][i]\n    denominator2 = sum(float(n) for (m,n) in enumerate(shutter_temp_list))/len(shutter_temp_list)\n    #print len(colo_temp_list)\n    #print len(shutter_temp_list)\n    numerator2 = sum(float(n) for (m,n) in enumerate(colo_temp_list))/len(colo_temp_list)\n    for (m,n) in enumerate(shutter_temp_list):\n        ratio=float(n)/float(colo_temp_list[m])\n        error_temp_list.append(abs((((ratio)-(numerator1/denominator1))/(numerator1/denominator1))*100))\n    plot_degradation_error[j][i]=np.std(error_temp_list)\n\n    #print numerator2\n    #print denominator2\n    del shutter_temp_list\n    del colo_temp_list\n    del degradation_temp_list\n    #plot_degradation[j][i] = abs((((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100)\n    plot_degradation[j][i] = abs(((denominator2/denominator1)-1)*100)\n    shutter_vm4 = shutter_vm4 + (plot_degradation[j][i],)\n    #print denominator2/numerator2\n    #print j,i,plot_degradation[j][i]\n            #print (((numerator2/denominator2)-(numerator1/denominator1))/(numerator2/denominator2))*100\n#print shutter_vm4\n\ndel dictList_degradation_shutter_prev\ndel dictList_degradation_shutter_prev2\ndel plot_degradation\ndel plot_degradation_error\n\ndictList_degradation_shutter_prev = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter_prev2 = defaultdict(lambda  : defaultdict(list))\nplot_degradation = defaultdict(dict)\nplot_degradation_error = defaultdict(dict)\n\n\nfor (b,a) in enumerate(fList7ex):\n    if a in colocationListExperiments:\n        index = a\n    else:\n        if a in benchListExperiments:\n            dictList_degradation_shutter_prev[index][a].append(fList7ex[b+1])\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    for elem in dictList_degradation_shutter_prev[j][i]:\n        dictList_degradation_shutter_prev2[j][i].extend(elem.strip().split(\'\\t\'))\n    #print dictList_degradation_shutter_prev2[j][i]\n\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    #print i,j\n    denominator1 = sum(float(n) for (m,n) in enumerate(dictList_single_vm[i]))/(len(dictList_single_vm[i]))\n    numerator1 = sum(float(n) for (m,n) in enumerate(dictList_degradation_shutter2[j][i]))/(len(dictList_degradation_shutter2[j][i]))\n    shutter_temp_list = []\n    colo_temp_list = []\n    degradation_temp_list = []\n    error_temp_list = []\n    #print numerator1\n    #print denominator1\n    for (count,item) in enumerate(dictList_degradation_shutter_prev2[j][i]):\n        #print item\n        if count%2==0:\n            colo_temp_list.append(item)\n        if count%2==1:\n            shutter_temp_list.append(item)\n\n    for (count,item) in enumerate(shutter_temp_list):\n        degradation_temp_list.append(abs((((float(shutter_temp_list[count])/float(colo_temp_list[count]))-(numerator1/denominator1))/(float(shutter_temp_list[count])/float(colo_temp_list[count])))*100))\n\n    shutter_temp_list.sort()\n    colo_temp_list.sort()\n    #print shutter_temp_list\n    #print colo_temp_list\n    #print dictList_degradation_shutter2[j][i]\n    denominator2 = sum(float(n) for (m,n) in enumerate(shutter_temp_list))/len(shutter_temp_list)\n    #print len(colo_temp_list)\n    #print len(shutter_temp_list)\n    numerator2 = sum(float(n) for (m,n) in enumerate(colo_temp_list))/len(colo_temp_list)\n    for (m,n) in enumerate(shutter_temp_list):\n        ratio=float(n)/float(colo_temp_list[m])\n        error_temp_list.append(abs((((ratio)-(numerator1/denominator1))/(numerator1/denominator1))*100))\n    plot_degradation_error[j][i]=np.std(error_temp_list)\n\n    #print numerator2\n    #print denominator2\n    del shutter_temp_list\n    del colo_temp_list\n    del degradation_temp_list\n    #plot_degradation[j][i] = abs((((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100)\n    plot_degradation[j][i] = abs(((denominator2/denominator1)-1)*100)\n    shutter_vm5 = shutter_vm5 + (plot_degradation[j][i],)\n    #print denominator2/numerator2\n    #print j,i,plot_degradation[j][i]\n            #print (((numerator2/denominator2)-(numerator1/denominator1))/(numerator2/denominator2))*100\n#print shutter_vm4\n\ndel dictList_degradation_shutter_prev\ndel dictList_degradation_shutter_prev2\ndel plot_degradation\ndel plot_degradation_error\ndel dictList_degradation_shutter\ndel dictList_degradation_shutter2\n\n\n###2VM snapshot\n###-----------------------------------------------------------------------------------\n\ndictList_degradation_shutter = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter2 = defaultdict(lambda  : defaultdict(list))\nplot_degradation = defaultdict(dict)\nplot_degradation_error = defaultdict(dict)\nplot_degradation_abs = defaultdict(dict)\n\n#APPENDING DEGRADATION SHUTTER\nfor (b,a) in enumerate(fList16):\n    #print a\n    if a in colocationListExperiments:\n        index = a\n    else:\n        if a in benchListExperiments:\n            dictList_degradation_shutter[index][a].append(fList16[b+1])\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    #print i,j,dictList_degradation_shutter[j][i]\n\n#APPENDING DEGRADATION SHUTTER2 as shutter and colocation values are tab separated\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    for elem in dictList_degradation_shutter[j][i]:\n        dictList_degradation_shutter2[j][i].extend(elem.strip().split(\'\\t\'))\n\n\nyaxis2 = ()\nyaxis_abs2 = ()\nerror2 = ()\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    #print i,j\n    #print i\n    #print dictList_single_vm[i]\n    #print dictList_degradation_colocation[j][i]\n    #print dictList_degradation_shutter2[j][i]\n    denominator1 = sum(float(n) for (m,n) in enumerate(dictList_single_vm[i]) if m!=0 and m!=len(dictList_single_vm[i])-1)/(len(dictList_single_vm[i])-2)\n    numerator1 = final_degradation[j][i][0]\n    shutter_temp_list = []\n    colo_temp_list = []\n    degradation_temp_list = []\n    error_temp_list = []\n    #print numerator1\n    #print denominator1\n    for (count,item) in enumerate(dictList_degradation_shutter2[j][i]):\n        #print item\n        if count%2==0:\n            colo_temp_list.append(item)\n        if count%2==1:\n            shutter_temp_list.append(item)\n\n    for (count,item) in enumerate(shutter_temp_list):\n        degradation_temp_list.append(abs((((float(shutter_temp_list[count])/float(colo_temp_list[count]))-(numerator1/denominator1))/(float(shutter_temp_list[count])/float(colo_temp_list[count])))*100))\n\n    shutter_temp_list.sort()\n    colo_temp_list.sort()\n    #print shutter_temp_list\n    #print colo_temp_list\n    #print dictList_degradation_shutter2[j][i]\n    denominator2 = sum(float(n) for (m,n) in enumerate(shutter_temp_list))/len(shutter_temp_list)\n    numerator2 = sum(float(n) for (m,n) in enumerate(colo_temp_list))/len(colo_temp_list)\n    for (m,n) in enumerate(shutter_temp_list):\n        ratio=float(n)/float(colo_temp_list[m])\n        error_temp_list.append(abs((((ratio)-(numerator1/denominator1))/(numerator1/denominator1))*100))\n    plot_degradation_error[j][i]=np.std(error_temp_list)\n\n    #print numerator1, denominator1\n    #print numerator2, denominator2\n    del shutter_temp_list\n    del colo_temp_list\n    del degradation_temp_list\n    plot_degradation[j][i] = (((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100\n    plot_degradation_abs[j][i] = abs((((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100)\n    #print j,i,plot_degradation[j][i]\n    #print plot_degradation_error[j][i]\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    yaxis2 = yaxis2 + (plot_degradation[j][i],)\n    yaxis_abs2 = yaxis_abs2 + (plot_degradation_abs[j][i],)\n    error2 = error2 + (plot_degradation_error[j][i],)\n    #print numerator2,denominator2,numerator2/denominator2\n    #print denominator2/numerator2\n    #print j,i,plot_degradation[j][i]\n\ndel dictList_degradation_shutter\ndel dictList_degradation_shutter2\ndel plot_degradation\ndel plot_degradation_error\ndel plot_degradation_abs\n\n###-----------------------------------------------------------------------------------\n###4VM snapshot\n###-----------------------------------------------------------------------------------\n\ndictList_degradation_shutter = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter2 = defaultdict(lambda  : defaultdict(list))\nplot_degradation = defaultdict(dict)\nplot_degradation_error = defaultdict(dict)\nplot_degradation_abs = defaultdict(dict)\n\n\n#APPENDING DEGRADATION SHUTTER\nfor (b,a) in enumerate(fList17):\n    #print a\n    if a in colocationListExperiments:\n        index = a\n    else:\n        if a in benchListExperiments:\n            dictList_degradation_shutter[index][a].append(fList17[b+1])\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    #print i,j,dictList_degradation_shutter[j][i]\n\n#APPENDING DEGRADATION SHUTTER2 as shutter and colocation values are tab separated\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    for elem in dictList_degradation_shutter[j][i]:\n        dictList_degradation_shutter2[j][i].extend(elem.strip().split(\'\\t\'))\n\n\nyaxis3 = ()\nyaxis_abs3 = ()\nerror3 = ()\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    #print i,j\n    #print i\n    #print dictList_single_vm[i]\n    #print dictList_degradation_colocation[j][i]\n    #print dictList_degradation_shutter2[j][i]\n    denominator1 = sum(float(n) for (m,n) in enumerate(dictList_single_vm[i]) if m!=0 and m!=len(dictList_single_vm[i])-1)/(len(dictList_single_vm[i])-2)\n    numerator1 = final_degradation[j][i][1]\n    shutter_temp_list = []\n    colo_temp_list = []\n    degradation_temp_list = []\n    error_temp_list = []\n    #print numerator1\n    #print denominator1\n    for (count,item) in enumerate(dictList_degradation_shutter2[j][i]):\n        #print item\n        if count%2==0:\n            colo_temp_list.append(item)\n        if count%2==1:\n            shutter_temp_list.append(item)\n\n    for (count,item) in enumerate(shutter_temp_list):\n        degradation_temp_list.append(abs((((float(shutter_temp_list[count])/float(colo_temp_list[count]))-(numerator1/denominator1))/(float(shutter_temp_list[count])/float(colo_temp_list[count])))*100))\n\n    shutter_temp_list.sort()\n    colo_temp_list.sort()\n    #print shutter_temp_list\n    #print colo_temp_list\n    #print dictList_degradation_shutter2[j][i]\n    denominator2 = sum(float(n) for (m,n) in enumerate(shutter_temp_list))/len(shutter_temp_list)\n    numerator2 = sum(float(n) for (m,n) in enumerate(colo_temp_list))/len(colo_temp_list)\n    for (m,n) in enumerate(shutter_temp_list):\n        ratio=float(n)/float(colo_temp_list[m])\n        error_temp_list.append(abs((((ratio)-(numerator1/denominator1))/(numerator1/denominator1))*100))\n    plot_degradation_error[j][i]=np.std(error_temp_list)\n\n    #print numerator1, denominator1\n    #print numerator2, denominator2\n    del shutter_temp_list\n    del colo_temp_list\n    del degradation_temp_list\n    plot_degradation[j][i] = (((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100\n    plot_degradation_abs[j][i] = abs((((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100)\n    #print j,i,plot_degradation[j][i]\n    #print plot_degradation_error[j][i]\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    yaxis3 = yaxis3 + (plot_degradation[j][i],)\n    yaxis_abs3 = yaxis_abs3 + (plot_degradation_abs[j][i],)\n    error3 = error3 + (plot_degradation_error[j][i],)\n    #print numerator2,denominator2,numerator2/denominator2\n    #print denominator2/numerator2\n    #print j,i,plot_degradation[j][i]\n\n\ndel dictList_degradation_shutter\ndel dictList_degradation_shutter2\ndel plot_degradation\ndel plot_degradation_error\ndel plot_degradation_abs\n\n###-----------------------------------------------------------------------------------\n###8VM snapshot\n###-----------------------------------------------------------------------------------\n\ndictList_degradation_shutter = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter2 = defaultdict(lambda  : defaultdict(list))\nplot_degradation = defaultdict(dict)\nplot_degradation_error = defaultdict(dict)\nplot_degradation_abs = defaultdict(dict)\n\n\n#APPENDING DEGRADATION SHUTTER\nfor (b,a) in enumerate(fList18):\n    #print a\n    if a in colocationListExperiments:\n        index = a\n    else:\n        if a in benchListExperiments:\n            dictList_degradation_shutter[index][a].append(fList18[b+1])\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    #print i,j,dictList_degradation_shutter[j][i]\n\n#APPENDING DEGRADATION SHUTTER2 as shutter and colocation values are tab separated\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    for elem in dictList_degradation_shutter[j][i]:\n        dictList_degradation_shutter2[j][i].extend(elem.strip().split(\'\\t\'))\n\n\nyaxis4 = ()\nyaxis_abs4 = ()\nerror4 = ()\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    #print i,j\n    #print i\n    #print dictList_single_vm[i]\n    #print dictList_degradation_colocation[j][i]\n    #print dictList_degradation_shutter2[j][i]\n    denominator1 = sum(float(n) for (m,n) in enumerate(dictList_single_vm[i]) if m!=0 and m!=len(dictList_single_vm[i])-1)/(len(dictList_single_vm[i])-2)\n    numerator1 = final_degradation[j][i][2]\n    shutter_temp_list = []\n    colo_temp_list = []\n    degradation_temp_list = []\n    error_temp_list = []\n    #print numerator1\n    #print denominator1\n    for (count,item) in enumerate(dictList_degradation_shutter2[j][i]):\n        #print item\n        if count%2==0:\n            colo_temp_list.append(item)\n        if count%2==1:\n            shutter_temp_list.append(item)\n\n    for (count,item) in enumerate(shutter_temp_list):\n        degradation_temp_list.append(abs((((float(shutter_temp_list[count])/float(colo_temp_list[count]))-(numerator1/denominator1))/(float(shutter_temp_list[count])/float(colo_temp_list[count])))*100))\n\n    shutter_temp_list.sort()\n    colo_temp_list.sort()\n    #print shutter_temp_list\n    #print colo_temp_list\n    #print dictList_degradation_shutter2[j][i]\n    denominator2 = sum(float(n) for (m,n) in enumerate(shutter_temp_list))/len(shutter_temp_list)\n    numerator2 = sum(float(n) for (m,n) in enumerate(colo_temp_list))/len(colo_temp_list)\n    for (m,n) in enumerate(shutter_temp_list):\n        ratio=float(n)/float(colo_temp_list[m])\n        error_temp_list.append(abs((((ratio)-(numerator1/denominator1))/(numerator1/denominator1))*100))\n    plot_degradation_error[j][i]=np.std(error_temp_list)\n\n    #print numerator1, denominator1\n    #print numerator2, denominator2\n    del shutter_temp_list\n    del colo_temp_list\n    del degradation_temp_list\n    plot_degradation[j][i] = (((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100\n    plot_degradation_abs[j][i] = abs((((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100)\n    #print j,i,plot_degradation[j][i]\n    #print plot_degradation_error[j][i]\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    yaxis4 = yaxis4 + (plot_degradation[j][i],)\n    yaxis_abs4 = yaxis_abs4 + (plot_degradation_abs[j][i],)\n    error4 = error4 + (plot_degradation_error[j][i],)\n    #print numerator2,denominator2,numerator2/denominator2\n    #print denominator2/numerator2\n    #print j,i,plot_degradation[j][i]\n\n\ndel dictList_degradation_shutter\ndel dictList_degradation_shutter2\ndel plot_degradation\ndel plot_degradation_error\ndel plot_degradation_abs\n\n###-----------------------------------------------------------------------------------\n###16VM snapshot\n###-----------------------------------------------------------------------------------\n\ndictList_degradation_shutter = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter2 = defaultdict(lambda  : defaultdict(list))\nplot_degradation = defaultdict(dict)\nplot_degradation_error = defaultdict(dict)\nplot_degradation_abs = defaultdict(dict)\n\n\n#APPENDING DEGRADATION SHUTTER\nfor (b,a) in enumerate(fList19):\n    #print a\n    if a in colocationListExperiments:\n        index = a\n    else:\n        if a in benchListExperiments:\n            dictList_degradation_shutter[index][a].append(fList19[b+1])\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    #print i,j,dictList_degradation_shutter[j][i]\n\n#APPENDING DEGRADATION SHUTTER2 as shutter and colocation values are tab separated\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    for elem in dictList_degradation_shutter[j][i]:\n        dictList_degradation_shutter2[j][i].extend(elem.strip().split(\'\\t\'))\n\n\nyaxis5 = ()\nyaxis_abs5 = ()\nerror5 = ()\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    #print i,j\n    #print i\n    #print dictList_single_vm[i]\n    #print dictList_degradation_colocation[j][i]\n    #print dictList_degradation_shutter2[j][i]\n    denominator1 = sum(float(n) for (m,n) in enumerate(dictList_single_vm[i]) if m!=0 and m!=len(dictList_single_vm[i])-1)/(len(dictList_single_vm[i])-2)\n    numerator1 = final_degradation[j][i][3]\n    shutter_temp_list = []\n    colo_temp_list = []\n    degradation_temp_list = []\n    error_temp_list = []\n    #print numerator1\n    #print denominator1\n    for (count,item) in enumerate(dictList_degradation_shutter2[j][i]):\n        #print item\n        if count%2==0:\n            colo_temp_list.append(item)\n        if count%2==1:\n            shutter_temp_list.append(item)\n\n    #print shutter_temp_list\n    #print colo_temp_list\n    for (count,item) in enumerate(shutter_temp_list):\n        degradation_temp_list.append(abs((((float(shutter_temp_list[count])/float(colo_temp_list[count]))-(numerator1/denominator1))/(float(shutter_temp_list[count])/float(colo_temp_list[count])))*100))\n\n    shutter_temp_list.sort()\n    colo_temp_list.sort()\n    #print shutter_temp_list\n    #print colo_temp_list\n    #print dictList_degradation_shutter2[j][i]\n    denominator2 = sum(float(n) for (m,n) in enumerate(shutter_temp_list))/len(shutter_temp_list)\n    numerator2 = sum(float(n) for (m,n) in enumerate(colo_temp_list))/len(colo_temp_list)\n    for (m,n) in enumerate(shutter_temp_list):\n        ratio=float(n)/float(colo_temp_list[m])\n        error_temp_list.append(abs((((ratio)-(numerator1/denominator1))/(numerator1/denominator1))*100))\n    plot_degradation_error[j][i]=np.std(error_temp_list)\n\n    #print numerator1, denominator1\n    #print numerator2, denominator2\n    del shutter_temp_list\n    del colo_temp_list\n    del degradation_temp_list\n    plot_degradation[j][i] = (((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100\n    plot_degradation_abs[j][i] = abs((((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100)\n    #print j,i,plot_degradation[j][i]\n    #print plot_degradation_error[j][i]\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    yaxis5 = yaxis5 + (plot_degradation[j][i],)\n    yaxis_abs5 = yaxis_abs5 + (plot_degradation_abs[j][i],)\n    error5 = error5 + (plot_degradation_error[j][i],)\n    #print numerator2,denominator2,numerator2/denominator2\n    #print denominator2/numerator2\n    #print j,i,plot_degradation[j][i]\n\n\ndel dictList_degradation_shutter\ndel dictList_degradation_shutter2\ndel plot_degradation\ndel plot_degradation_error\ndel plot_degradation_abs\n\n##### ----- overhead stuff snapshot 2VM\n\nexecution_time_shutter = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter = defaultdict(lambda  : defaultdict(list))\navg_execution_time_shutter = defaultdict(dict)\ndictList_phase_change = defaultdict(lambda  : defaultdict(list))\ndictList_phase_change2 = defaultdict(lambda  : defaultdict(list))\n\nstd_execution_time = defaultdict(dict)\n\ndef print_elapsed_time_shutter(time_shutter):\n    for j in colocationList:\n        for i in benchList:\n            print \'%s ||||  %s\'%(j,i)\n            print time_shutter[j][i]\n\n\nsep = \'u\'\nfor (b,a) in enumerate(fList8):\n    #print a\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            execution_time_shutter[index][a].append((fList8[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_shutter[\'colocating with mcf\'][\'perlbench\']\n#print((s.split(start))[1].split(end)[0])\n\nfor j in colocationList:\n    for i in benchList:\n        for k in execution_time_shutter[j][i]:\n            m,s = [float (var) for var in k.split(\':\')]\n            temp = m*60 + s\n            execution_time_sec_shutter[j][i].append(temp)\n\n\nfor (b,a) in enumerate(fList20):\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            dictList_phase_change[index][a].append(fList20[b+1])\n\n\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    #print j,i\n    for elem in dictList_phase_change[j][i]:\n        dictList_phase_change2[j][i].extend(elem.strip().split(\'\\t\'))\n    #print dictList_phase_change2[j][i]\n\nsnapshot_overhead = ()\nerror_snapshot_overhead = ()\n#print dictList_phase_change2[\'colocating with mcf\'][\'perlbench\']\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    #print j,i\n    #print dictList_phase_change2[j][i]\n    #print i,j\n    shutter_temp_list = []\n    colo_temp_list = []\n    for (count,item) in enumerate(dictList_phase_change2[j][i]):\n        if count%2==1:\n            colo_temp_list.append(float(item))\n        if count%2==0:\n            shutter_temp_list.append(float(item))\n    #print shutter_temp_list\n    shutter_avg = sum(shutter_temp_list)/len(shutter_temp_list)\n    colocation_avg = sum(colo_temp_list)/len(colo_temp_list)\n    del shutter_temp_list\n    del colo_temp_list\n\n    pause_period = ((colocation_avg + shutter_avg)/2)*75\n    #print pause_period, np.mean(execution_time_sec_shutter[j][i])*1000\n    #pause_period = ((colocation_avg ) + ((shutter_avg + (colocation_avg * 2)/3) * 3))/4\n    xaxis = xaxis + (i,)\n    #print i,j,(pause_period/(np.mean(execution_time_sec_shutter[j][i])*10))\n    snapshot_overhead = snapshot_overhead + ( (pause_period/(np.mean(execution_time_sec_shutter[j][i])*10)), )\n    #print np.mean(execution_time_sec_shutter2[j][i])\n    #print \'---------------------\'\n\ndel execution_time_shutter\ndel execution_time_sec_shutter\ndel avg_execution_time_shutter\ndel dictList_phase_change\ndel dictList_phase_change2\n\n\n### ----- overhead stuff snapshot 4VM ------------------------------------------------\nexecution_time_shutter = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter = defaultdict(lambda  : defaultdict(list))\navg_execution_time_shutter = defaultdict(dict)\ndictList_phase_change = defaultdict(lambda  : defaultdict(list))\ndictList_phase_change2 = defaultdict(lambda  : defaultdict(list))\n\nstd_execution_time = defaultdict(dict)\n\ndef print_elapsed_time_shutter(time_shutter):\n    for j in colocationList:\n        for i in benchList:\n            print \'%s ||||  %s\'%(j,i)\n            print time_shutter[j][i]\n\n\nsep = \'u\'\nfor (b,a) in enumerate(fList10):\n    #print a\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            execution_time_shutter[index][a].append((fList10[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_shutter[\'colocating with mcf\'][\'perlbench\']\n#print((s.split(start))[1].split(end)[0])\n\nfor j in colocationList:\n    for i in benchList:\n        for k in execution_time_shutter[j][i]:\n            m,s = [float (var) for var in k.split(\':\')]\n            temp = m*60 + s\n            execution_time_sec_shutter[j][i].append(temp)\n\n\nfor (b,a) in enumerate(fList21):\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            dictList_phase_change[index][a].append(fList21[b+1])\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    #print j,i\n    for elem in dictList_phase_change[j][i]:\n        dictList_phase_change2[j][i].extend(elem.strip().split(\'\\t\'))\n    #print dictList_phase_change2[j][i]\n\nsnapshot_overhead2= ()\nerror_snapshot_overhead = ()\n#print dictList_phase_change2[\'colocating with mcf\'][\'perlbench\']\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    print j,i\n    #print dictList_phase_change2[j][i]\n    #print i,j\n    shutter_temp_list = []\n    colo_temp_list = []\n    for (count,item) in enumerate(dictList_phase_change2[j][i]):\n        if count%2==1:\n            colo_temp_list.append(float(item))\n        if count%2==0:\n            shutter_temp_list.append(float(item))\n    #print shutter_temp_list\n    shutter_avg = sum(shutter_temp_list)/len(shutter_temp_list)\n    colocation_avg = sum(colo_temp_list)/len(colo_temp_list)\n    del shutter_temp_list\n    del colo_temp_list\n\n    pause_period = (((colocation_avg ) + ((shutter_avg + (colocation_avg * 2)/3) * 3))/4)*75\n    #print pause_period, np.mean(execution_time_sec_shutter[j][i])*1000\n    #pause_period = ((colocation_avg ) + ((shutter_avg + (colocation_avg * 2)/3) * 3))/4\n    xaxis = xaxis + (i,)\n    #print i,j,(pause_period/(np.mean(execution_time_sec_shutter[j][i])*10))\n    snapshot_overhead2 = snapshot_overhead2 + ( (pause_period/(np.mean(execution_time_sec_shutter[j][i])*10)), )\n    #print np.mean(execution_time_sec_shutter2[j][i])\n    #print \'---------------------\'\n\n\ndel execution_time_shutter\ndel execution_time_sec_shutter\ndel avg_execution_time_shutter\ndel dictList_phase_change\ndel dictList_phase_change2\n\n\n### ----- overhead stuff snapshot 8VM ------------------------------------------------\nexecution_time_shutter = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter = defaultdict(lambda  : defaultdict(list))\navg_execution_time_shutter = defaultdict(dict)\ndictList_phase_change = defaultdict(lambda  : defaultdict(list))\ndictList_phase_change2 = defaultdict(lambda  : defaultdict(list))\n\nstd_execution_time = defaultdict(dict)\n\ndef print_elapsed_time_shutter(time_shutter):\n    for j in colocationList:\n        for i in benchList:\n            print \'%s ||||  %s\'%(j,i)\n            print time_shutter[j][i]\n\n\nsep = \'u\'\nfor (b,a) in enumerate(fList11):\n    #print a\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            execution_time_shutter[index][a].append((fList11[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_shutter[\'colocating with mcf\'][\'perlbench\']\n#print((s.split(start))[1].split(end)[0])\n\nfor j in colocationList:\n    for i in benchList:\n        for k in execution_time_shutter[j][i]:\n            m,s = [float (var) for var in k.split(\':\')]\n            temp = m*60 + s\n            execution_time_sec_shutter[j][i].append(temp)\n\n\nfor (b,a) in enumerate(fList22):\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            dictList_phase_change[index][a].append(fList22[b+1])\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    #print j,i\n    for elem in dictList_phase_change[j][i]:\n        dictList_phase_change2[j][i].extend(elem.strip().split(\'\\t\'))\n    #print dictList_phase_change2[j][i]\n\nsnapshot_overhead3 = ()\nerror_snapshot_overhead = ()\n#print dictList_phase_change2[\'colocating with mcf\'][\'perlbench\']\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    #print j,i\n    #print dictList_phase_change2[j][i]\n    #print i,j\n    shutter_temp_list = []\n    colo_temp_list = []\n    for (count,item) in enumerate(dictList_phase_change2[j][i]):\n        if count%2==1:\n            colo_temp_list.append(float(item))\n        if count%2==0:\n            shutter_temp_list.append(float(item))\n    #print shutter_temp_list\n    shutter_avg = sum(shutter_temp_list)/len(shutter_temp_list)\n    colocation_avg = sum(colo_temp_list)/len(colo_temp_list)\n    del shutter_temp_list\n    del colo_temp_list\n\n    pause_period = (((colocation_avg ) + ((shutter_avg + (colocation_avg * 6)/7) * 7))/8)*75\n    #print pause_period, np.mean(execution_time_sec_shutter[j][i])*1000\n    #pause_period = ((colocation_avg ) + ((shutter_avg + (colocation_avg * 2)/3) * 3))/4\n    xaxis = xaxis + (i,)\n    #print i,j,(pause_period/(np.mean(execution_time_sec_shutter[j][i])*10))\n    snapshot_overhead3 = snapshot_overhead3 + ( (pause_period/(np.mean(execution_time_sec_shutter[j][i])*10)), )\n    #print np.mean(execution_time_sec_shutter2[j][i])\n    #print \'---------------------\'\n\ndel execution_time_shutter\ndel execution_time_sec_shutter\ndel avg_execution_time_shutter\ndel dictList_phase_change\ndel dictList_phase_change2\n### ----- overhead stuff snapshot 16VM ------------------------------------------------\nexecution_time_shutter = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter = defaultdict(lambda  : defaultdict(list))\navg_execution_time_shutter = defaultdict(dict)\ndictList_phase_change = defaultdict(lambda  : defaultdict(list))\ndictList_phase_change2 = defaultdict(lambda  : defaultdict(list))\n\nstd_execution_time = defaultdict(dict)\n\ndef print_elapsed_time_shutter(time_shutter):\n    for j in colocationList:\n        for i in benchList:\n            print \'%s ||||  %s\'%(j,i)\n            print time_shutter[j][i]\n\n\nsep = \'u\'\nfor (b,a) in enumerate(fList12):\n    #print a\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            execution_time_shutter[index][a].append((fList12[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_shutter[\'colocating with mcf\'][\'perlbench\']\n#print((s.split(start))[1].split(end)[0])\n\nfor j in colocationList:\n    for i in benchList:\n        for k in execution_time_shutter[j][i]:\n            m,s = [float (var) for var in k.split(\':\')]\n            temp = m*60 + s\n            execution_time_sec_shutter[j][i].append(temp)\n\n\nfor (b,a) in enumerate(fList23):\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            dictList_phase_change[index][a].append(fList23[b+1])\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    #print j,i\n    for elem in dictList_phase_change[j][i]:\n        dictList_phase_change2[j][i].extend(elem.strip().split(\'\\t\'))\n    #print dictList_phase_change2[j][i]\n\nsnapshot_overhead4 = ()\nerror_snapshot_overhead = ()\n#print dictList_phase_change2[\'colocating with mcf\'][\'perlbench\']\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    print j,i\n    #print dictList_phase_change2[j][i]\n    #print i,j\n    shutter_temp_list = []\n    colo_temp_list = []\n    for (count,item) in enumerate(dictList_phase_change2[j][i]):\n        if count%2==1:\n            colo_temp_list.append(float(item))\n        if count%2==0:\n            shutter_temp_list.append(float(item))\n    #print shutter_temp_list\n    shutter_avg = sum(shutter_temp_list)/len(shutter_temp_list)\n    colocation_avg = sum(colo_temp_list)/len(colo_temp_list)\n    del shutter_temp_list\n    del colo_temp_list\n\n    pause_period = (((colocation_avg ) + ((shutter_avg + (colocation_avg * 14)/15) * 15))/17)*75\n    #print pause_period, np.mean(execution_time_sec_shutter[j][i])*1000\n    #pause_period = ((colocation_avg ) + ((shutter_avg + (colocation_avg * 2)/3) * 3))/4\n    xaxis = xaxis + (i,)\n    print i,j,(pause_period/(np.mean(execution_time_sec_shutter[j][i])*10))\n    snapshot_overhead4 = snapshot_overhead4 + ( (pause_period/(np.mean(execution_time_sec_shutter[j][i])*10))  ,)\n    #print np.mean(execution_time_sec_shutter2[j][i])\n    #print \'---------------------\'\n\ndel execution_time_shutter\ndel execution_time_sec_shutter\ndel avg_execution_time_shutter\ndel dictList_phase_change\ndel dictList_phase_change2\n\n\n#shutteroverhead\n#overhead5,overhead4,overhead3,overhead2\n#snapshotoverhead\n#snapshot_overhead4, snapshot_overhead3, snapshot_overhead2, snapshot_overhead\n#shutteraccuracy\n#shutter_vm5,shutter_vm4,shutter_vm3,shutter_vm2\n#snapshotaccuracy\n#yaxis5,yaxis4, yaxis3, yaxis2\n\n#print xaxis[0]\n\nf = figure(figsize=(5, 3))\nlabels = [\'\', \'2\', \'4\', \'8\', \'16\', \'\']\nxaxis_list = []\nxaxis_list.append(0.5)\nxaxis_list.append(1)\nxaxis_list.append(1.5)\nxaxis_list.append(2)\n#print overhead2\n#print overhead2\n\nfor (count,item) in enumerate(benchList):\n    shutter_overhead_list = []\n    shutter_accuracy_list = []\n    snapshot_overhead_list = []\n    snapshot_accuracy_list = []\n    print count\n\n    shutter_overhead_list.append(abs(overhead2[count]))\n    shutter_overhead_list.append(abs(overhead3[count]))\n    shutter_overhead_list.append(abs(overhead4[count]))\n    shutter_overhead_list.append(abs(overhead5[count]))\n\n    shutter_accuracy_list.append(abs(shutter_vm2[count]))\n    shutter_accuracy_list.append(abs(shutter_vm3[count]))\n    shutter_accuracy_list.append(abs(shutter_vm4[count]))\n    shutter_accuracy_list.append(abs(shutter_vm5[count]))\n\n    snapshot_overhead_list.append(abs(snapshot_overhead[count]))\n    snapshot_overhead_list.append(abs(snapshot_overhead2[count]))\n    snapshot_overhead_list.append(abs(snapshot_overhead3[count]))\n    snapshot_overhead_list.append(abs(snapshot_overhead4[count]))\n\n    snapshot_accuracy_list.append(abs(yaxis2[count]))\n    snapshot_accuracy_list.append(abs(yaxis3[count]))\n    snapshot_accuracy_list.append(abs(yaxis4[count]))\n    snapshot_accuracy_list.append(abs(yaxis5[count]))\n\n    #print xaxis_list\n    #print shutter_accuracy_list\n    #print snapshot_accuracy_list\n    #print shutter_overhead_list\n    #print snapshot_overhead_list\n\n\n    #plt.suptitle("Snapshot vs Shuttering", size=16)\n    subplots_adjust(hspace=0.001)\n    ax1=subplot(1, 1, 1)\n    ax1.scatter(xaxis_list, shutter_overhead_list, facecolor=\'none\', edgecolor=\'r\', label=\'Shuttering\' if count == 0 else "" )\n    ax1.scatter(xaxis_list, snapshot_overhead_list, color=\'y\', marker=\'+\', label=\'Snapshots\' if count == 0 else "" )\n    ax1.set_ylabel(\'Execution time overhead (%)\', size=\'11\')\n    ax1.set_xlabel(\'Number of VMs\', size=\'11\')\n    ax1.set_ylim(-2,35)\n    ax1.set_xlim(0,2.5)\n    #ax1.set_xticklabels((2,4,6,8,10,12,14,16),(\'2\', \'4\', \'\', \'8\', \'\', \'\', \'\', \'16\' ))\n    ax1.set_xticklabels(labels)\n    ax1.legend(prop={\'size\':11}, loc=2)\n\n    #plt.yticks((-0.5,0,1,2,3,4),(\'\',\'0\',\'1\',\'2\',\'3\',\'4\'),size=\'23\')\n\n    #ax2=subplot(2, 1, 2, sharex=ax1)\n    #ax2.scatter(xaxis_list, shutter_overhead_list, color=\'r\')\n    #ax2.scatter(xaxis_list, snapshot_overhead_list, color=\'g\')\n    #ax2.xlabel(\'time (s)\')\n    #ax2.set_ylabel(\'Overhead (%)\', size=\'15\')\n    #print ax2.get_ylim()\n    #ax2.set_ylim((0,30)[::-1])\n    #xticklabels = ax1.get_xticklabels()\n    #setp(xticklabels, visible=False)\n    #ax2.legend(prop={\'size\':13}, loc=1)\n    #ax2.set_yticklabels(arange(5, 10, 5))\n    #plt.savefig(\'comparisonfigs/testfig_%s.png\' %count,  dpi=125)\n    del shutter_overhead_list\n    del shutter_accuracy_list\n    del snapshot_overhead_list\n    del snapshot_accuracy_list\n'
p0
.I0
.S'$graph_fig:scaleup-accuracy:Accuracy:0.7'
p0
.S'from collections import defaultdict\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom pylab import *\n\nbenchListBaseline = [ \'tonto\', \'sphinx3\', \'dealII\', \'soplex\', \'bzip2\', \'xalancbmk\', \'omnetpp\' ]\nbenchListExperiments = [ \'tonto\', \'sphinx3\', \'dealII\', \'soplex\', \'bzip2\', \'xalancbmk\', \'omnetpp\' ]\n#benchListExperiments = [ \'perlbench\', \'astar\', \'soplex\', \'xalancbmk\', \'omnetpp\']\ncolocationListBaseline = [ \'colocating with lbm\', \'colocating with povray\', \'colocating with astar\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with mcf\' ]\ncolocationListExperiments = [ \'colocating with lbm\', \'colocating with povray\', \'colocating with perlbench\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with mcf\' ]\n#runningList = [ \'xalancbmk\', \'colocating with libquantum\' ]\nrunningList = [ \'tonto\', \'colocating with libquantum\', \'sphinx3\', \'colocating with libquantum\', \'dealII\', \'colocating with libquantum\', \'soplex\', \'colocating with libquantum\',\'bzip2\', \'colocating with libquantum\', \'xalancbmk\', \'colocating with libquantum\', \'omnetpp\', \'colocating with libquantum\'  ]\ncolocationList = [ \'colocating with libquantum\', \'colocating with mcf\',  \'colocating with sphinx3\']\nbenchList = [  \'tonto\', \'sphinx3\', \'dealII\', \'soplex\', \'bzip2\', \'xalancbmk\', \'omnetpp\' ]\n#benchList = [  \'astar\', \'omnetpp\'  ]\n#colocationListOracle = [ \'colocating with gcc\', \'colocating with colocating with mcf\', \'colocating with perlbench\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with bzip2\' ]\n\ndef autolabel(rects):\n    # attach some text labels\n    for rect in rects:\n        height = rect.get_height()\n        plt.text(rect.get_x()+rect.get_width()/2., 1.1*height, \'%.2f\'%float(height), fontsize=8, ha=\'center\', va= \'bottom\')\n\ndef autolabel2(rects):\n    # attach some text labels\n    for rect in rects:\n        height = rect.get_height()\n        plt.text(rect.get_x()+rect.get_width()/2., -1.1*height, \'%.1f\'%float(height), fontsize=8, ha=\'center\', va= \'top\')\n\nfilename = \'shutter_cpi_1000\'\nfilename2 = \'shutter_cpi_4\'\nfList = [s.strip() for s in open(\'../../papergraphs/scalability/16vm/singlevm/shutter_cpi_1000.txt\').readlines()]\nfList2 = [s.strip() for s in open(\'../../papergraphs/scalability/2vm/degradation/%s.txt\' % filename).readlines()]\nfList3 = [s.strip() for s in open(\'../../papergraphs/scalability/4vm/degradation/%s.txt\' % filename).readlines()]\nfList4 = [s.strip() for s in open(\'../../papergraphs/scalability/8vm/degradation/%s.txt\' % filename).readlines()]\nfList4ex = [s.strip() for s in open(\'../../papergraphs/scalability/16vm/degradation/%s.txt\' % filename).readlines()]\nfList5 = [s.strip() for s in open(\'../../papergraphs/scalability/2vm/priorwork/%s.txt\' % filename2).readlines()]\nfList6 = [s.strip() for s in open(\'../../papergraphs/scalability/4vm/priorwork/%s.txt\' % filename2).readlines()]\nfList7 = [s.strip() for s in open(\'../../papergraphs/scalability/8vm/priorwork/%s.txt\' % filename2).readlines()]\nfList7ex = [s.strip() for s in open(\'../../papergraphs/scalability/16vm/priorwork/%s.txt\' % filename2).readlines()]\n\nexecutionground = \'execution_time_1000\'\nexecutionprior = \'execution_time_4\'\nfList8 = [s.strip() for s in open(\'../../papergraphs/scalability/2vm/degradation/%s.txt\' % executionground).readlines()]  #degradation\nfList9 = [s.strip() for s in open(\'../../papergraphs/scalability/2vm/priorwork/%s.txt\' % executionprior).readlines()]  #degradation\nfList10 = [s.strip() for s in open(\'../../papergraphs/scalability/4vm/degradation/%s.txt\' % executionground).readlines()]  #degradation\nfList11 = [s.strip() for s in open(\'../../papergraphs/scalability/4vm/priorwork/%s.txt\' % executionprior).readlines()]  #degradation\nfList12 = [s.strip() for s in open(\'../../papergraphs/scalability/8vm/degradation/%s.txt\' % executionground).readlines()]  #degradation\nfList13 = [s.strip() for s in open(\'../../papergraphs/scalability/8vm/priorwork/%s.txt\' % executionprior).readlines()]  #degradation\nfList14 = [s.strip() for s in open(\'../../papergraphs/scalability/16vm/degradation/%s.txt\' % executionground).readlines()]  #degradation\nfList15 = [s.strip() for s in open(\'../../papergraphs/scalability/16vm/priorwork/%s.txt\' % executionprior).readlines()]  #degradation\n\nfList16 = [s.strip() for s in open(\'../../papergraphs/scalability/2vm/snapshot/shutter_cpi_70.txt\' ).readlines()]\nfList17 = [s.strip() for s in open(\'../../papergraphs/scalability/4vm/snapshot/shutter_cpi_70.txt\' ).readlines()]\nfList18 = [s.strip() for s in open(\'../../papergraphs/scalability/8vm/snapshot/shutter_cpi_70.txt\' ).readlines()]\nfList19 = [s.strip() for s in open(\'../../papergraphs/scalability/16vm/snapshot/shutter_cpi_10.txt\').readlines()]\n\n\nfList20 = [s.strip() for s in open(\'../../papergraphs/scalability/2vm/snapshot/phase_change_70.txt\' ).readlines()]\nfList21 = [s.strip() for s in open(\'../../papergraphs/scalability/4vm/snapshot/phase_change_70.txt\' ).readlines()]\nfList22 = [s.strip() for s in open(\'../../papergraphs/scalability/8vm/snapshot/phase_change_70.txt\' ).readlines()]\nfList23 = [s.strip() for s in open(\'../../papergraphs/scalability/16vm/snapshot/phase_change_10.txt\').readlines()]\n\ndictList_single_vm = defaultdict(list)\ndictList_single_vm_mean = defaultdict(float)\ndictList_degradation_colocation = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter2 = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter3 = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter_prev = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter_prev2 = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter_prev3 = defaultdict(lambda  : defaultdict(list))\nfinal_degradation = defaultdict(lambda  : defaultdict(list))\nplot_degradation = defaultdict(dict)\nplot_degradation_error = defaultdict(dict)\n\nexecution_time_shutter = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter = defaultdict(lambda  : defaultdict(list))\nexecution_time_shutter2 = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter2 = defaultdict(lambda  : defaultdict(list))\n\nstd_execution_time = defaultdict(dict)\nglobal index\n\ndef print_elapsed_time_shutter(time_shutter):\n    for j in colocationList:\n        for i in benchList:\n            print \'%s ||||  %s\'%(j,i)\n            print time_shutter[j][i]\n\n\nsep = \'u\'\nfor (b,a) in enumerate(fList8):\n    #print a\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            execution_time_shutter[index][a].append((fList8[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_shutter[\'colocating with mcf\'][\'perlbench\']\n#print((s.split(start))[1].split(end)[0])\n\nfor j in colocationList:\n    for i in benchList:\n        for k in execution_time_shutter[j][i]:\n            m,s = [float (var) for var in k.split(\':\')]\n            temp = m*60 + s\n            execution_time_sec_shutter[j][i].append(temp)\n\nfor (b,a) in enumerate(fList9):\n    #print a\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            #print index\n            #print a\n            execution_time_shutter2[index][a].append((fList9[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\nfor j in colocationList:\n    for i in benchList:\n        for k in execution_time_shutter2[j][i]:\n            #print k\n            m,s = [float (var) for var in k.split(\':\')]\n            temp = m*60 + s\n            execution_time_sec_shutter2[j][i].append(temp)\n\noverhead2 = ()\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n\n    #print (pause_period/np.mean(execution_time_sec_shutter[j][i]))*10\n    overhead2 = overhead2 + ( abs(((np.mean(execution_time_sec_shutter2[j][i])/np.mean(execution_time_sec_shutter[j][i])) - 1)*100)*-1, )\n    #print np.mean(execution_time_sec_shutter2[j][i])\n    #print np.mean(execution_time_sec_shutter[j][i])\n\n#print overhead2\ndel execution_time_shutter\ndel execution_time_sec_shutter\ndel execution_time_shutter2\ndel execution_time_sec_shutter2\n\n## ------------------------------------------------------------------------------\n\nexecution_time_shutter = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter = defaultdict(lambda  : defaultdict(list))\nexecution_time_shutter2 = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter2 = defaultdict(lambda  : defaultdict(list))\n\nstd_execution_time = defaultdict(dict)\n\nsep = \'u\'\nfor (b,a) in enumerate(fList10):\n    #print a\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            execution_time_shutter[index][a].append((fList10[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_shutter[\'colocating with mcf\'][\'perlbench\']\n#print((s.split(start))[1].split(end)[0])\n\nfor j in colocationList:\n    for i in benchList:\n        #print i\n        for k in execution_time_shutter[j][i]:\n            try:\n                m,s = [float (var) for var in k.split(\':\')]\n                #print m,s\n                temp = m*60 + s\n            except:\n                h,m,s = [float (var) for var in k.split(\':\')]\n                #print h,m,s\n                temp = h*60*60 + m*60 + s\n            execution_time_sec_shutter[j][i].append(temp)\n\nfor (b,a) in enumerate(fList11):\n    #print a\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            #print index\n            #print a\n            execution_time_shutter2[index][a].append((fList11[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\nfor j in colocationList:\n    for i in benchList:\n        for k in execution_time_shutter2[j][i]:\n            try:\n                m,s = [float (var) for var in k.split(\':\')]\n                #print m,s\n                temp = m*60 + s\n            except:\n                h,m,s = [float (var) for var in k.split(\':\')]\n                #print h,m,s\n                temp = h*60*60 + m*60 + s\n            execution_time_sec_shutter2[j][i].append(temp)\n\noverhead3 = ()\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    #print i\n\n    #print (pause_period/np.mean(execution_time_sec_shutter[j][i]))*10\n    overhead3 = overhead3 + ( abs(((np.mean(execution_time_sec_shutter2[j][i])/np.mean(execution_time_sec_shutter[j][i])) - 1)*100)*-1, )\n    #print np.mean(execution_time_sec_shutter2[j][i])\n    #print np.mean(execution_time_sec_shutter[j][i])\n\n#rint overhead3\ndel execution_time_shutter\ndel execution_time_sec_shutter\ndel execution_time_shutter2\ndel execution_time_sec_shutter2\n\n\n## ------------------------------------------------------------------------------\n\nexecution_time_shutter = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter = defaultdict(lambda  : defaultdict(list))\nexecution_time_shutter2 = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter2 = defaultdict(lambda  : defaultdict(list))\n\nstd_execution_time = defaultdict(dict)\n\ndef print_elapsed_time_shutter(time_shutter):\n    for j in colocationList:\n        for i in benchList:\n            print \'%s ||||  %s\'%(j,i)\n            print time_shutter[j][i]\n\n\nsep = \'u\'\nfor (b,a) in enumerate(fList12):\n    #print a\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            execution_time_shutter[index][a].append((fList12[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_shutter[\'colocating with mcf\'][\'perlbench\']\n#print((s.split(start))[1].split(end)[0])\n\nfor j in colocationList:\n    for i in benchList:\n        #print i\n        for k in execution_time_shutter[j][i]:\n            try:\n                m,s = [float (var) for var in k.split(\':\')]\n                #print m,s\n                temp = m*60 + s\n            except:\n                h,m,s = [float (var) for var in k.split(\':\')]\n                #print h,m,s\n                temp = h*60*60 + m*60 + s\n            execution_time_sec_shutter[j][i].append(temp)\n\nfor (b,a) in enumerate(fList13):\n    #print a\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            #print index\n            #print a\n            execution_time_shutter2[index][a].append((fList13[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n            #execution_time_shutter2[index][a].append((fList13[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\nfor j in colocationList:\n    for i in benchList:\n        for k in execution_time_shutter2[j][i]:\n            try:\n                m,s = [float (var) for var in k.split(\':\')]\n                #print m,s\n                temp = m*60 + s\n            except:\n                h,m,s = [float (var) for var in k.split(\':\')]\n                #print h,m,s\n                temp = h*60*60 + m*60 + s\n            #print k\n            execution_time_sec_shutter2[j][i].append(temp)\n\noverhead4 = ()\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    #print i\n\n    #print (pause_period/np.mean(execution_time_sec_shutter[j][i]))*10\n    overhead4 = overhead4 + ( (((np.mean(execution_time_sec_shutter2[j][i])/np.mean(execution_time_sec_shutter[j][i])) - 1)*100)*-1, )\n    #print np.mean(execution_time_sec_shutter2[j][i])\n    #print np.mean(execution_time_sec_shutter[j][i])\n\n#print overhead4\ndel execution_time_shutter\ndel execution_time_sec_shutter\ndel execution_time_shutter2\ndel execution_time_sec_shutter2\n\n## ------------------------------------------------------------------------------\n\nexecution_time_shutter = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter = defaultdict(lambda  : defaultdict(list))\nexecution_time_shutter2 = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter2 = defaultdict(lambda  : defaultdict(list))\n\nstd_execution_time = defaultdict(dict)\n\ndef print_elapsed_time_shutter(time_shutter):\n    for j in colocationList:\n        for i in benchList:\n            print \'%s ||||  %s\'%(j,i)\n            print time_shutter[j][i]\n\n\nsep = \'u\'\nfor (b,a) in enumerate(fList14):\n    #print a\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            #print a\n            execution_time_shutter[index][a].append((fList14[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_shutter[\'colocating with mcf\'][\'perlbench\']\n#print((s.split(start))[1].split(end)[0])\n\nfor j in colocationList:\n    for i in benchList:\n        #print i\n        for k in execution_time_shutter[j][i]:\n            try:\n                m,s = [float (var) for var in k.split(\':\')]\n                #print m,s\n                temp = m*60 + s\n            except:\n                h,m,s = [float (var) for var in k.split(\':\')]\n                #print h,m,s\n                temp = h*60*60 + m*60 + s\n            execution_time_sec_shutter[j][i].append(temp)\n\nfor (b,a) in enumerate(fList15):\n    #print a\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            #print index\n            #print a\n            execution_time_shutter2[index][a].append((fList15[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n            #execution_time_shutter2[index][a].append((fList13[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\nfor j in colocationList:\n    for i in benchList:\n        for k in execution_time_shutter2[j][i]:\n            try:\n                m,s = [float (var) for var in k.split(\':\')]\n                #print m,s\n                temp = m*60 + s\n            except:\n                h,m,s = [float (var) for var in k.split(\':\')]\n                #print h,m,s\n                temp = h*60*60 + m*60 + s\n            #print k\n            execution_time_sec_shutter2[j][i].append(temp)\n\noverhead5 = ()\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    #print i,j\n\n    #print (pause_period/np.mean(execution_time_sec_shutter[j][i]))*10\n    overhead5 = overhead5 + ( (((np.mean(execution_time_sec_shutter2[j][i])/np.mean(execution_time_sec_shutter[j][i])) - 1)*100)*-1, )\n    #print np.mean(execution_time_sec_shutter2[j][i])\n    #print np.mean(execution_time_sec_shutter[j][i])\n\n#print overhead5\ndel execution_time_shutter\ndel execution_time_sec_shutter\ndel execution_time_shutter2\ndel execution_time_sec_shutter2\n\n\n## ------------------------------------------------------------------------------\n\n\n\nfor (b,a) in enumerate(fList):\n    if a in benchListBaseline:\n        dictList_single_vm[a].append(fList[b+1])\n\n#SORTING LIST CONTAING VALUES OF SINGLE SPEC RUNS INSIDE VMs\nfor i in benchListBaseline:\n    dictList_single_vm[i].sort()\n    dictList_single_vm_mean[i] = sum(float(item) for item in dictList_single_vm[i])/len(dictList_single_vm[i])\n#    numerator1 = sum(float(n) for (m,n) in enumerate(dictList_degradation_colocation[j][i]))/(len(dictList_degradation_colocation[j][i]))\n    #print i,dictList_single_vm_mean[i]\n\n    #print i,dictList_single_vm[i]\n\nfor (b,a) in enumerate(fList2):\n    #print a\n    if a in colocationListBaseline:\n       #print a\n       index = a\n    else:\n        if a in benchListExperiments:\n            #print a\n            dictList_degradation_colocation[index][a].append(fList2[b+1])\n#sorting the ground truth values\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    #dictList_degradation_colocation[j][i].sort()\n    #print j,i,dictList_degradation_colocation[j][i]\n\n#APPENDING DEGRADATION SHUTTER\nfor (b,a) in enumerate(fList3):\n    if a in colocationListExperiments:\n        index = a\n    else:\n        if a in benchListExperiments:\n            dictList_degradation_shutter[index][a].append(fList3[b+1])\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    #dictList_degradation_colocation[j][i].sort()\n    #print j,i,dictList_degradation_shutter[j][i]\n\nfor (b,a) in enumerate(fList4):\n    if a in colocationListExperiments:\n        index = a\n    else:\n        if a in benchListExperiments:\n            dictList_degradation_shutter2[index][a].append(fList4[b+1])\n\n\nfor (b,a) in enumerate(fList4ex):\n    if a in colocationListExperiments:\n        index = a\n    else:\n        if a in benchListExperiments:\n            dictList_degradation_shutter3[index][a].append(fList4ex[b+1])\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    #dictList_degradation_colocation[j][i].sort()\n    #print j,i,dictList_degradation_shutter2[j][i]\n\n\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    #dictList_degradation_colocation[j][i].sort()\n    #print j,i,dictList_degradation_shutter2[j][i]\n    sum_of = []\n    for n in dictList_degradation_colocation[j][i]:\n        sum_of.append(float(n))\n    #print np.mean(sum_of)\n    final_degradation[j][i].append(np.mean(sum_of))\n    del sum_of\n\n    sum_of = []\n    for n in dictList_degradation_shutter[j][i]:\n        sum_of.append(float(n))\n    #print np.mean(sum_of)\n    final_degradation[j][i].append(np.mean(sum_of))\n    del sum_of\n\n    sum_of = []\n    for n in dictList_degradation_shutter2[j][i]:\n        #print n\n        sum_of.append(float(n))\n    #print np.mean(sum_of)\n    final_degradation[j][i].append(np.mean(sum_of))\n    del sum_of\n\n    sum_of = []\n    for n in dictList_degradation_shutter3[j][i]:\n        #print n\n        sum_of.append(float(n))\n    #print np.mean(sum_of)\n    final_degradation[j][i].append(np.mean(sum_of))\n    del sum_of\n\nxaxis = ()\nvm2 = ()\nvm3 = ()\nvm4 = ()\nvm5 = ()\n#fig, ax = plt.subplots()\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    plot_list = []\n    xaxis = xaxis + (i,)\n    for (count,item) in enumerate(final_degradation[j][i]):\n        #print count\n        if count == 0:\n            vm2 = vm2 + (final_degradation[j][i][0]/dictList_single_vm_mean[i] ,)\n        if count == 1:\n            vm3 = vm3 + (final_degradation[j][i][1]/dictList_single_vm_mean[i], )\n        if count == 2:\n            vm4 = vm4 + (final_degradation[j][i][2]/dictList_single_vm_mean[i], )\n        if count == 3:\n            vm5 = vm5 + (final_degradation[j][i][3]/dictList_single_vm_mean[i], )\n\n#print vm2\n#print vm3\n#print vm4\n#print vm5\n\n\nshutter_vm2 = ()\nshutter_vm3 = ()\nshutter_vm4 = ()\nshutter_vm5 = ()\n\n\nfor (b,a) in enumerate(fList5):\n    if a in colocationListExperiments:\n        index = a\n    else:\n        if a in benchListExperiments:\n            dictList_degradation_shutter_prev[index][a].append(fList5[b+1])\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    for elem in dictList_degradation_shutter_prev[j][i]:\n        dictList_degradation_shutter_prev2[j][i].extend(elem.strip().split(\'\\t\'))\n    #print dictList_degradation_shutter_prev2[j][i]\n\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    #print i\n    denominator1 = sum(float(n) for (m,n) in enumerate(dictList_single_vm[i]))/(len(dictList_single_vm[i]))\n    numerator1 = sum(float(n) for (m,n) in enumerate(dictList_degradation_colocation[j][i]))/(len(dictList_degradation_colocation[j][i]))\n    shutter_temp_list = []\n    colo_temp_list = []\n    degradation_temp_list = []\n    error_temp_list = []\n    #print numerator1\n    #print denominator1\n    for (count,item) in enumerate(dictList_degradation_shutter_prev2[j][i]):\n        #print item\n        if count%2==0:\n            colo_temp_list.append(item)\n        if count%2==1:\n            shutter_temp_list.append(item)\n\n    for (count,item) in enumerate(shutter_temp_list):\n        degradation_temp_list.append(abs((((float(shutter_temp_list[count])/float(colo_temp_list[count]))-(numerator1/denominator1))/(float(shutter_temp_list[count])/float(colo_temp_list[count])))*100))\n\n    shutter_temp_list.sort()\n    colo_temp_list.sort()\n    #print shutter_temp_list\n    #print colo_temp_list\n    #print dictList_degradation_shutter2[j][i]\n    denominator2 = sum(float(n) for (m,n) in enumerate(shutter_temp_list))/len(shutter_temp_list)\n    #print len(colo_temp_list)\n    #print len(shutter_temp_list)\n    numerator2 = sum(float(n) for (m,n) in enumerate(colo_temp_list))/len(colo_temp_list)\n    for (m,n) in enumerate(shutter_temp_list):\n        ratio=float(n)/float(colo_temp_list[m])\n        error_temp_list.append(abs((((ratio)-(numerator1/denominator1))/(numerator1/denominator1))*100))\n    plot_degradation_error[j][i]=np.std(error_temp_list)\n\n    #print numerator2\n    #print denominator2\n    del shutter_temp_list\n    del colo_temp_list\n    del degradation_temp_list\n    #plot_degradation[j][i] = abs((((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100)\n    plot_degradation[j][i] = abs(((denominator2/denominator1)-1)*100)\n    shutter_vm2 = shutter_vm2 + (plot_degradation[j][i],)\n    #print denominator2/numerator2\n    #print j,i,plot_degradation[j][i]\n            #print (((numerator2/denominator2)-(numerator1/denominator1))/(numerator2/denominator2))*100\n\n#print shutter_vm2\n\n\ndel dictList_degradation_shutter_prev\ndel dictList_degradation_shutter_prev2\ndel plot_degradation\ndel plot_degradation_error\n\ndictList_degradation_shutter_prev = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter_prev2 = defaultdict(lambda  : defaultdict(list))\nplot_degradation = defaultdict(dict)\nplot_degradation_error = defaultdict(dict)\n\n\nfor (b,a) in enumerate(fList6):\n    if a in colocationListExperiments:\n        index = a\n    else:\n        if a in benchListExperiments:\n            dictList_degradation_shutter_prev[index][a].append(fList6[b+1])\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    for elem in dictList_degradation_shutter_prev[j][i]:\n        dictList_degradation_shutter_prev2[j][i].extend(elem.strip().split(\'\\t\'))\n    #print dictList_degradation_shutter_prev2[j][i]\n\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    #print i\n    denominator1 = sum(float(n) for (m,n) in enumerate(dictList_single_vm[i]))/(len(dictList_single_vm[i]))\n    numerator1 = sum(float(n) for (m,n) in enumerate(dictList_degradation_shutter[j][i]))/(len(dictList_degradation_shutter[j][i]))\n    shutter_temp_list = []\n    colo_temp_list = []\n    degradation_temp_list = []\n    error_temp_list = []\n    #print numerator1\n    #print denominator1\n    for (count,item) in enumerate(dictList_degradation_shutter_prev2[j][i]):\n        #print item\n        if count%2==0:\n            colo_temp_list.append(item)\n        if count%2==1:\n            shutter_temp_list.append(item)\n\n    for (count,item) in enumerate(shutter_temp_list):\n        degradation_temp_list.append(abs((((float(shutter_temp_list[count])/float(colo_temp_list[count]))-(numerator1/denominator1))/(float(shutter_temp_list[count])/float(colo_temp_list[count])))*100))\n\n    shutter_temp_list.sort()\n    colo_temp_list.sort()\n    #print shutter_temp_list\n    #print colo_temp_list\n    #print dictList_degradation_shutter2[j][i]\n    denominator2 = sum(float(n) for (m,n) in enumerate(shutter_temp_list))/len(shutter_temp_list)\n    #print len(colo_temp_list)\n    #print len(shutter_temp_list)\n    numerator2 = sum(float(n) for (m,n) in enumerate(colo_temp_list))/len(colo_temp_list)\n    for (m,n) in enumerate(shutter_temp_list):\n        ratio=float(n)/float(colo_temp_list[m])\n        error_temp_list.append(abs((((ratio)-(numerator1/denominator1))/(numerator1/denominator1))*100))\n    plot_degradation_error[j][i]=np.std(error_temp_list)\n\n    #print numerator2\n    #print denominator2\n    del shutter_temp_list\n    del colo_temp_list\n    del degradation_temp_list\n    #plot_degradation[j][i] = abs((((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100)\n    plot_degradation[j][i] = abs(((denominator2/denominator1)-1)*100)\n    shutter_vm3 = shutter_vm3 + (plot_degradation[j][i],)\n    #print denominator2/numerator2\n    #print j,i,plot_degradation[j][i]\n            #print (((numerator2/denominator2)-(numerator1/denominator1))/(numerator2/denominator2))*100\n\n#print shutter_vm3\n\n\nfor (b,a) in enumerate(fList7):\n    if a in colocationListExperiments:\n        index = a\n    else:\n        if a in benchListExperiments:\n            dictList_degradation_shutter_prev[index][a].append(fList7[b+1])\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    for elem in dictList_degradation_shutter_prev[j][i]:\n        dictList_degradation_shutter_prev2[j][i].extend(elem.strip().split(\'\\t\'))\n    #print dictList_degradation_shutter_prev2[j][i]\n\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    #print i\n    denominator1 = sum(float(n) for (m,n) in enumerate(dictList_single_vm[i]))/(len(dictList_single_vm[i]))\n    numerator1 = sum(float(n) for (m,n) in enumerate(dictList_degradation_shutter2[j][i]))/(len(dictList_degradation_shutter2[j][i]))\n    shutter_temp_list = []\n    colo_temp_list = []\n    degradation_temp_list = []\n    error_temp_list = []\n    #print numerator1\n    #print denominator1\n    for (count,item) in enumerate(dictList_degradation_shutter_prev2[j][i]):\n        #print item\n        if count%2==0:\n            colo_temp_list.append(item)\n        if count%2==1:\n            shutter_temp_list.append(item)\n\n    for (count,item) in enumerate(shutter_temp_list):\n        degradation_temp_list.append(abs((((float(shutter_temp_list[count])/float(colo_temp_list[count]))-(numerator1/denominator1))/(float(shutter_temp_list[count])/float(colo_temp_list[count])))*100))\n\n    shutter_temp_list.sort()\n    colo_temp_list.sort()\n    #print shutter_temp_list\n    #print colo_temp_list\n    #print dictList_degradation_shutter2[j][i]\n    denominator2 = sum(float(n) for (m,n) in enumerate(shutter_temp_list))/len(shutter_temp_list)\n    #print len(colo_temp_list)\n    #print len(shutter_temp_list)\n    numerator2 = sum(float(n) for (m,n) in enumerate(colo_temp_list))/len(colo_temp_list)\n    for (m,n) in enumerate(shutter_temp_list):\n        ratio=float(n)/float(colo_temp_list[m])\n        error_temp_list.append(abs((((ratio)-(numerator1/denominator1))/(numerator1/denominator1))*100))\n    plot_degradation_error[j][i]=np.std(error_temp_list)\n\n    #print numerator2\n    #print denominator2\n    del shutter_temp_list\n    del colo_temp_list\n    del degradation_temp_list\n    #plot_degradation[j][i] = abs((((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100)\n    plot_degradation[j][i] = abs(((denominator2/denominator1)-1)*100)\n    shutter_vm4 = shutter_vm4 + (plot_degradation[j][i],)\n    #print denominator2/numerator2\n    #print j,i,plot_degradation[j][i]\n            #print (((numerator2/denominator2)-(numerator1/denominator1))/(numerator2/denominator2))*100\n#print shutter_vm4\n\ndel dictList_degradation_shutter_prev\ndel dictList_degradation_shutter_prev2\ndel plot_degradation\ndel plot_degradation_error\n\ndictList_degradation_shutter_prev = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter_prev2 = defaultdict(lambda  : defaultdict(list))\nplot_degradation = defaultdict(dict)\nplot_degradation_error = defaultdict(dict)\n\n\nfor (b,a) in enumerate(fList7ex):\n    if a in colocationListExperiments:\n        index = a\n    else:\n        if a in benchListExperiments:\n            dictList_degradation_shutter_prev[index][a].append(fList7ex[b+1])\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    for elem in dictList_degradation_shutter_prev[j][i]:\n        dictList_degradation_shutter_prev2[j][i].extend(elem.strip().split(\'\\t\'))\n    #print dictList_degradation_shutter_prev2[j][i]\n\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    #print i,j\n    denominator1 = sum(float(n) for (m,n) in enumerate(dictList_single_vm[i]))/(len(dictList_single_vm[i]))\n    numerator1 = sum(float(n) for (m,n) in enumerate(dictList_degradation_shutter2[j][i]))/(len(dictList_degradation_shutter2[j][i]))\n    shutter_temp_list = []\n    colo_temp_list = []\n    degradation_temp_list = []\n    error_temp_list = []\n    #print numerator1\n    #print denominator1\n    for (count,item) in enumerate(dictList_degradation_shutter_prev2[j][i]):\n        #print item\n        if count%2==0:\n            colo_temp_list.append(item)\n        if count%2==1:\n            shutter_temp_list.append(item)\n\n    for (count,item) in enumerate(shutter_temp_list):\n        degradation_temp_list.append(abs((((float(shutter_temp_list[count])/float(colo_temp_list[count]))-(numerator1/denominator1))/(float(shutter_temp_list[count])/float(colo_temp_list[count])))*100))\n\n    shutter_temp_list.sort()\n    colo_temp_list.sort()\n    #print shutter_temp_list\n    #print colo_temp_list\n    #print dictList_degradation_shutter2[j][i]\n    denominator2 = sum(float(n) for (m,n) in enumerate(shutter_temp_list))/len(shutter_temp_list)\n    #print len(colo_temp_list)\n    #print len(shutter_temp_list)\n    numerator2 = sum(float(n) for (m,n) in enumerate(colo_temp_list))/len(colo_temp_list)\n    for (m,n) in enumerate(shutter_temp_list):\n        ratio=float(n)/float(colo_temp_list[m])\n        error_temp_list.append(abs((((ratio)-(numerator1/denominator1))/(numerator1/denominator1))*100))\n    plot_degradation_error[j][i]=np.std(error_temp_list)\n\n    #print numerator2\n    #print denominator2\n    del shutter_temp_list\n    del colo_temp_list\n    del degradation_temp_list\n    #plot_degradation[j][i] = abs((((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100)\n    plot_degradation[j][i] = abs(((denominator2/denominator1)-1)*100)\n    shutter_vm5 = shutter_vm5 + (plot_degradation[j][i],)\n    #print denominator2/numerator2\n    #print j,i,plot_degradation[j][i]\n            #print (((numerator2/denominator2)-(numerator1/denominator1))/(numerator2/denominator2))*100\n#print shutter_vm4\n\ndel dictList_degradation_shutter_prev\ndel dictList_degradation_shutter_prev2\ndel plot_degradation\ndel plot_degradation_error\ndel dictList_degradation_shutter\ndel dictList_degradation_shutter2\n\n\n###2VM snapshot\n###-----------------------------------------------------------------------------------\n\ndictList_degradation_shutter = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter2 = defaultdict(lambda  : defaultdict(list))\nplot_degradation = defaultdict(dict)\nplot_degradation_error = defaultdict(dict)\nplot_degradation_abs = defaultdict(dict)\n\n#APPENDING DEGRADATION SHUTTER\nfor (b,a) in enumerate(fList16):\n    #print a\n    if a in colocationListExperiments:\n        index = a\n    else:\n        if a in benchListExperiments:\n            dictList_degradation_shutter[index][a].append(fList16[b+1])\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    #print i,j,dictList_degradation_shutter[j][i]\n\n#APPENDING DEGRADATION SHUTTER2 as shutter and colocation values are tab separated\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    for elem in dictList_degradation_shutter[j][i]:\n        dictList_degradation_shutter2[j][i].extend(elem.strip().split(\'\\t\'))\n\n\nyaxis2 = ()\nyaxis_abs2 = ()\nerror2 = ()\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    #print i,j\n    #print i\n    #print dictList_single_vm[i]\n    #print dictList_degradation_colocation[j][i]\n    #print dictList_degradation_shutter2[j][i]\n    denominator1 = sum(float(n) for (m,n) in enumerate(dictList_single_vm[i]) if m!=0 and m!=len(dictList_single_vm[i])-1)/(len(dictList_single_vm[i])-2)\n    numerator1 = final_degradation[j][i][0]\n    shutter_temp_list = []\n    colo_temp_list = []\n    degradation_temp_list = []\n    error_temp_list = []\n    #print numerator1\n    #print denominator1\n    for (count,item) in enumerate(dictList_degradation_shutter2[j][i]):\n        #print item\n        if count%2==0:\n            colo_temp_list.append(item)\n        if count%2==1:\n            shutter_temp_list.append(item)\n\n    for (count,item) in enumerate(shutter_temp_list):\n        degradation_temp_list.append(abs((((float(shutter_temp_list[count])/float(colo_temp_list[count]))-(numerator1/denominator1))/(float(shutter_temp_list[count])/float(colo_temp_list[count])))*100))\n\n    shutter_temp_list.sort()\n    colo_temp_list.sort()\n    #print shutter_temp_list\n    #print colo_temp_list\n    #print dictList_degradation_shutter2[j][i]\n    denominator2 = sum(float(n) for (m,n) in enumerate(shutter_temp_list))/len(shutter_temp_list)\n    numerator2 = sum(float(n) for (m,n) in enumerate(colo_temp_list))/len(colo_temp_list)\n    for (m,n) in enumerate(shutter_temp_list):\n        ratio=float(n)/float(colo_temp_list[m])\n        error_temp_list.append(abs((((ratio)-(numerator1/denominator1))/(numerator1/denominator1))*100))\n    plot_degradation_error[j][i]=np.std(error_temp_list)\n\n    #print numerator1, denominator1\n    #print numerator2, denominator2\n    del shutter_temp_list\n    del colo_temp_list\n    del degradation_temp_list\n    plot_degradation[j][i] = (((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100\n    plot_degradation_abs[j][i] = abs((((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100)\n    #print j,i,plot_degradation[j][i]\n    #print plot_degradation_error[j][i]\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    yaxis2 = yaxis2 + (plot_degradation[j][i],)\n    yaxis_abs2 = yaxis_abs2 + (plot_degradation_abs[j][i],)\n    error2 = error2 + (plot_degradation_error[j][i],)\n    #print numerator2,denominator2,numerator2/denominator2\n    #print denominator2/numerator2\n    #print j,i,plot_degradation[j][i]\n\ndel dictList_degradation_shutter\ndel dictList_degradation_shutter2\ndel plot_degradation\ndel plot_degradation_error\ndel plot_degradation_abs\n\n###-----------------------------------------------------------------------------------\n###4VM snapshot\n###-----------------------------------------------------------------------------------\n\ndictList_degradation_shutter = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter2 = defaultdict(lambda  : defaultdict(list))\nplot_degradation = defaultdict(dict)\nplot_degradation_error = defaultdict(dict)\nplot_degradation_abs = defaultdict(dict)\n\n\n#APPENDING DEGRADATION SHUTTER\nfor (b,a) in enumerate(fList17):\n    #print a\n    if a in colocationListExperiments:\n        index = a\n    else:\n        if a in benchListExperiments:\n            dictList_degradation_shutter[index][a].append(fList17[b+1])\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    #print i,j,dictList_degradation_shutter[j][i]\n\n#APPENDING DEGRADATION SHUTTER2 as shutter and colocation values are tab separated\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    for elem in dictList_degradation_shutter[j][i]:\n        dictList_degradation_shutter2[j][i].extend(elem.strip().split(\'\\t\'))\n\n\nyaxis3 = ()\nyaxis_abs3 = ()\nerror3 = ()\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    #print i,j\n    #print i\n    #print dictList_single_vm[i]\n    #print dictList_degradation_colocation[j][i]\n    #print dictList_degradation_shutter2[j][i]\n    denominator1 = sum(float(n) for (m,n) in enumerate(dictList_single_vm[i]) if m!=0 and m!=len(dictList_single_vm[i])-1)/(len(dictList_single_vm[i])-2)\n    numerator1 = final_degradation[j][i][1]\n    shutter_temp_list = []\n    colo_temp_list = []\n    degradation_temp_list = []\n    error_temp_list = []\n    #print numerator1\n    #print denominator1\n    for (count,item) in enumerate(dictList_degradation_shutter2[j][i]):\n        #print item\n        if count%2==0:\n            colo_temp_list.append(item)\n        if count%2==1:\n            shutter_temp_list.append(item)\n\n    for (count,item) in enumerate(shutter_temp_list):\n        degradation_temp_list.append(abs((((float(shutter_temp_list[count])/float(colo_temp_list[count]))-(numerator1/denominator1))/(float(shutter_temp_list[count])/float(colo_temp_list[count])))*100))\n\n    shutter_temp_list.sort()\n    colo_temp_list.sort()\n    #print shutter_temp_list\n    #print colo_temp_list\n    #print dictList_degradation_shutter2[j][i]\n    denominator2 = sum(float(n) for (m,n) in enumerate(shutter_temp_list))/len(shutter_temp_list)\n    numerator2 = sum(float(n) for (m,n) in enumerate(colo_temp_list))/len(colo_temp_list)\n    for (m,n) in enumerate(shutter_temp_list):\n        ratio=float(n)/float(colo_temp_list[m])\n        error_temp_list.append(abs((((ratio)-(numerator1/denominator1))/(numerator1/denominator1))*100))\n    plot_degradation_error[j][i]=np.std(error_temp_list)\n\n    #print numerator1, denominator1\n    #print numerator2, denominator2\n    del shutter_temp_list\n    del colo_temp_list\n    del degradation_temp_list\n    plot_degradation[j][i] = (((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100\n    plot_degradation_abs[j][i] = abs((((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100)\n    #print j,i,plot_degradation[j][i]\n    #print plot_degradation_error[j][i]\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    yaxis3 = yaxis3 + (plot_degradation[j][i],)\n    yaxis_abs3 = yaxis_abs3 + (plot_degradation_abs[j][i],)\n    error3 = error3 + (plot_degradation_error[j][i],)\n    #print numerator2,denominator2,numerator2/denominator2\n    #print denominator2/numerator2\n    #print j,i,plot_degradation[j][i]\n\n\ndel dictList_degradation_shutter\ndel dictList_degradation_shutter2\ndel plot_degradation\ndel plot_degradation_error\ndel plot_degradation_abs\n\n###-----------------------------------------------------------------------------------\n###8VM snapshot\n###-----------------------------------------------------------------------------------\n\ndictList_degradation_shutter = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter2 = defaultdict(lambda  : defaultdict(list))\nplot_degradation = defaultdict(dict)\nplot_degradation_error = defaultdict(dict)\nplot_degradation_abs = defaultdict(dict)\n\n\n#APPENDING DEGRADATION SHUTTER\nfor (b,a) in enumerate(fList18):\n    #print a\n    if a in colocationListExperiments:\n        index = a\n    else:\n        if a in benchListExperiments:\n            dictList_degradation_shutter[index][a].append(fList18[b+1])\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    #print i,j,dictList_degradation_shutter[j][i]\n\n#APPENDING DEGRADATION SHUTTER2 as shutter and colocation values are tab separated\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    for elem in dictList_degradation_shutter[j][i]:\n        dictList_degradation_shutter2[j][i].extend(elem.strip().split(\'\\t\'))\n\n\nyaxis4 = ()\nyaxis_abs4 = ()\nerror4 = ()\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    #print i,j\n    #print i\n    #print dictList_single_vm[i]\n    #print dictList_degradation_colocation[j][i]\n    #print dictList_degradation_shutter2[j][i]\n    denominator1 = sum(float(n) for (m,n) in enumerate(dictList_single_vm[i]) if m!=0 and m!=len(dictList_single_vm[i])-1)/(len(dictList_single_vm[i])-2)\n    numerator1 = final_degradation[j][i][2]\n    shutter_temp_list = []\n    colo_temp_list = []\n    degradation_temp_list = []\n    error_temp_list = []\n    #print numerator1\n    #print denominator1\n    for (count,item) in enumerate(dictList_degradation_shutter2[j][i]):\n        #print item\n        if count%2==0:\n            colo_temp_list.append(item)\n        if count%2==1:\n            shutter_temp_list.append(item)\n\n    for (count,item) in enumerate(shutter_temp_list):\n        degradation_temp_list.append(abs((((float(shutter_temp_list[count])/float(colo_temp_list[count]))-(numerator1/denominator1))/(float(shutter_temp_list[count])/float(colo_temp_list[count])))*100))\n\n    shutter_temp_list.sort()\n    colo_temp_list.sort()\n    #print shutter_temp_list\n    #print colo_temp_list\n    #print dictList_degradation_shutter2[j][i]\n    denominator2 = sum(float(n) for (m,n) in enumerate(shutter_temp_list))/len(shutter_temp_list)\n    numerator2 = sum(float(n) for (m,n) in enumerate(colo_temp_list))/len(colo_temp_list)\n    for (m,n) in enumerate(shutter_temp_list):\n        ratio=float(n)/float(colo_temp_list[m])\n        error_temp_list.append(abs((((ratio)-(numerator1/denominator1))/(numerator1/denominator1))*100))\n    plot_degradation_error[j][i]=np.std(error_temp_list)\n\n    #print numerator1, denominator1\n    #print numerator2, denominator2\n    del shutter_temp_list\n    del colo_temp_list\n    del degradation_temp_list\n    plot_degradation[j][i] = (((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100\n    plot_degradation_abs[j][i] = abs((((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100)\n    #print j,i,plot_degradation[j][i]\n    #print plot_degradation_error[j][i]\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    yaxis4 = yaxis4 + (plot_degradation[j][i],)\n    yaxis_abs4 = yaxis_abs4 + (plot_degradation_abs[j][i],)\n    error4 = error4 + (plot_degradation_error[j][i],)\n    #print numerator2,denominator2,numerator2/denominator2\n    #print denominator2/numerator2\n    #print j,i,plot_degradation[j][i]\n\n\ndel dictList_degradation_shutter\ndel dictList_degradation_shutter2\ndel plot_degradation\ndel plot_degradation_error\ndel plot_degradation_abs\n\n###-----------------------------------------------------------------------------------\n###16VM snapshot\n###-----------------------------------------------------------------------------------\n\ndictList_degradation_shutter = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter2 = defaultdict(lambda  : defaultdict(list))\nplot_degradation = defaultdict(dict)\nplot_degradation_error = defaultdict(dict)\nplot_degradation_abs = defaultdict(dict)\n\n\n#APPENDING DEGRADATION SHUTTER\nfor (b,a) in enumerate(fList19):\n    #print a\n    if a in colocationListExperiments:\n        index = a\n    else:\n        if a in benchListExperiments:\n            dictList_degradation_shutter[index][a].append(fList19[b+1])\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    #print i,j,dictList_degradation_shutter[j][i]\n\n#APPENDING DEGRADATION SHUTTER2 as shutter and colocation values are tab separated\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    for elem in dictList_degradation_shutter[j][i]:\n        dictList_degradation_shutter2[j][i].extend(elem.strip().split(\'\\t\'))\n\n\nyaxis5 = ()\nyaxis_abs5 = ()\nerror5 = ()\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    #print i,j\n    #print i\n    #print dictList_single_vm[i]\n    #print dictList_degradation_colocation[j][i]\n    #print dictList_degradation_shutter2[j][i]\n    denominator1 = sum(float(n) for (m,n) in enumerate(dictList_single_vm[i]) if m!=0 and m!=len(dictList_single_vm[i])-1)/(len(dictList_single_vm[i])-2)\n    numerator1 = final_degradation[j][i][3]\n    shutter_temp_list = []\n    colo_temp_list = []\n    degradation_temp_list = []\n    error_temp_list = []\n    #print numerator1\n    #print denominator1\n    for (count,item) in enumerate(dictList_degradation_shutter2[j][i]):\n        #print item\n        if count%2==0:\n            colo_temp_list.append(item)\n        if count%2==1:\n            shutter_temp_list.append(item)\n\n    #print shutter_temp_list\n    #print colo_temp_list\n    for (count,item) in enumerate(shutter_temp_list):\n        degradation_temp_list.append(abs((((float(shutter_temp_list[count])/float(colo_temp_list[count]))-(numerator1/denominator1))/(float(shutter_temp_list[count])/float(colo_temp_list[count])))*100))\n\n    shutter_temp_list.sort()\n    colo_temp_list.sort()\n    #print shutter_temp_list\n    #print colo_temp_list\n    #print dictList_degradation_shutter2[j][i]\n    denominator2 = sum(float(n) for (m,n) in enumerate(shutter_temp_list))/len(shutter_temp_list)\n    numerator2 = sum(float(n) for (m,n) in enumerate(colo_temp_list))/len(colo_temp_list)\n    for (m,n) in enumerate(shutter_temp_list):\n        ratio=float(n)/float(colo_temp_list[m])\n        error_temp_list.append(abs((((ratio)-(numerator1/denominator1))/(numerator1/denominator1))*100))\n    plot_degradation_error[j][i]=np.std(error_temp_list)\n\n    #print numerator1, denominator1\n    #print numerator2, denominator2\n    del shutter_temp_list\n    del colo_temp_list\n    del degradation_temp_list\n    plot_degradation[j][i] = (((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100\n    plot_degradation_abs[j][i] = abs((((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100)\n    #print j,i,plot_degradation[j][i]\n    #print plot_degradation_error[j][i]\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    yaxis5 = yaxis5 + (plot_degradation[j][i],)\n    yaxis_abs5 = yaxis_abs5 + (plot_degradation_abs[j][i],)\n    error5 = error5 + (plot_degradation_error[j][i],)\n    #print numerator2,denominator2,numerator2/denominator2\n    #print denominator2/numerator2\n    #print j,i,plot_degradation[j][i]\n\n\ndel dictList_degradation_shutter\ndel dictList_degradation_shutter2\ndel plot_degradation\ndel plot_degradation_error\ndel plot_degradation_abs\n\n##### ----- overhead stuff snapshot 2VM\n\nexecution_time_shutter = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter = defaultdict(lambda  : defaultdict(list))\navg_execution_time_shutter = defaultdict(dict)\ndictList_phase_change = defaultdict(lambda  : defaultdict(list))\ndictList_phase_change2 = defaultdict(lambda  : defaultdict(list))\n\nstd_execution_time = defaultdict(dict)\n\ndef print_elapsed_time_shutter(time_shutter):\n    for j in colocationList:\n        for i in benchList:\n            print \'%s ||||  %s\'%(j,i)\n            print time_shutter[j][i]\n\n\nsep = \'u\'\nfor (b,a) in enumerate(fList8):\n    #print a\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            execution_time_shutter[index][a].append((fList8[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_shutter[\'colocating with mcf\'][\'perlbench\']\n#print((s.split(start))[1].split(end)[0])\n\nfor j in colocationList:\n    for i in benchList:\n        for k in execution_time_shutter[j][i]:\n            m,s = [float (var) for var in k.split(\':\')]\n            temp = m*60 + s\n            execution_time_sec_shutter[j][i].append(temp)\n\n\nfor (b,a) in enumerate(fList20):\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            dictList_phase_change[index][a].append(fList20[b+1])\n\n\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    #print j,i\n    for elem in dictList_phase_change[j][i]:\n        dictList_phase_change2[j][i].extend(elem.strip().split(\'\\t\'))\n    #print dictList_phase_change2[j][i]\n\nsnapshot_overhead = ()\nerror_snapshot_overhead = ()\n#print dictList_phase_change2[\'colocating with mcf\'][\'perlbench\']\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    #print j,i\n    #print dictList_phase_change2[j][i]\n    #print i,j\n    shutter_temp_list = []\n    colo_temp_list = []\n    for (count,item) in enumerate(dictList_phase_change2[j][i]):\n        if count%2==1:\n            colo_temp_list.append(float(item))\n        if count%2==0:\n            shutter_temp_list.append(float(item))\n    #print shutter_temp_list\n    shutter_avg = sum(shutter_temp_list)/len(shutter_temp_list)\n    colocation_avg = sum(colo_temp_list)/len(colo_temp_list)\n    del shutter_temp_list\n    del colo_temp_list\n\n    pause_period = ((colocation_avg + shutter_avg)/2)*75\n    #print pause_period, np.mean(execution_time_sec_shutter[j][i])*1000\n    #pause_period = ((colocation_avg ) + ((shutter_avg + (colocation_avg * 2)/3) * 3))/4\n    xaxis = xaxis + (i,)\n    #print i,j,(pause_period/(np.mean(execution_time_sec_shutter[j][i])*10))\n    snapshot_overhead = snapshot_overhead + ( (pause_period/(np.mean(execution_time_sec_shutter[j][i])*10)), )\n    #print np.mean(execution_time_sec_shutter2[j][i])\n    #print \'---------------------\'\n\ndel execution_time_shutter\ndel execution_time_sec_shutter\ndel avg_execution_time_shutter\ndel dictList_phase_change\ndel dictList_phase_change2\n\n\n### ----- overhead stuff snapshot 4VM ------------------------------------------------\nexecution_time_shutter = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter = defaultdict(lambda  : defaultdict(list))\navg_execution_time_shutter = defaultdict(dict)\ndictList_phase_change = defaultdict(lambda  : defaultdict(list))\ndictList_phase_change2 = defaultdict(lambda  : defaultdict(list))\n\nstd_execution_time = defaultdict(dict)\n\ndef print_elapsed_time_shutter(time_shutter):\n    for j in colocationList:\n        for i in benchList:\n            print \'%s ||||  %s\'%(j,i)\n            print time_shutter[j][i]\n\n\nsep = \'u\'\nfor (b,a) in enumerate(fList10):\n    #print a\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            execution_time_shutter[index][a].append((fList10[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_shutter[\'colocating with mcf\'][\'perlbench\']\n#print((s.split(start))[1].split(end)[0])\n\nfor j in colocationList:\n    for i in benchList:\n        for k in execution_time_shutter[j][i]:\n            m,s = [float (var) for var in k.split(\':\')]\n            temp = m*60 + s\n            execution_time_sec_shutter[j][i].append(temp)\n\n\nfor (b,a) in enumerate(fList21):\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            dictList_phase_change[index][a].append(fList21[b+1])\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    #print j,i\n    for elem in dictList_phase_change[j][i]:\n        dictList_phase_change2[j][i].extend(elem.strip().split(\'\\t\'))\n    #print dictList_phase_change2[j][i]\n\nsnapshot_overhead2= ()\nerror_snapshot_overhead = ()\n#print dictList_phase_change2[\'colocating with mcf\'][\'perlbench\']\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    print j,i\n    #print dictList_phase_change2[j][i]\n    #print i,j\n    shutter_temp_list = []\n    colo_temp_list = []\n    for (count,item) in enumerate(dictList_phase_change2[j][i]):\n        if count%2==1:\n            colo_temp_list.append(float(item))\n        if count%2==0:\n            shutter_temp_list.append(float(item))\n    #print shutter_temp_list\n    shutter_avg = sum(shutter_temp_list)/len(shutter_temp_list)\n    colocation_avg = sum(colo_temp_list)/len(colo_temp_list)\n    del shutter_temp_list\n    del colo_temp_list\n\n    pause_period = (((colocation_avg ) + ((shutter_avg + (colocation_avg * 2)/3) * 3))/4)*75\n    #print pause_period, np.mean(execution_time_sec_shutter[j][i])*1000\n    #pause_period = ((colocation_avg ) + ((shutter_avg + (colocation_avg * 2)/3) * 3))/4\n    xaxis = xaxis + (i,)\n    #print i,j,(pause_period/(np.mean(execution_time_sec_shutter[j][i])*10))\n    snapshot_overhead2 = snapshot_overhead2 + ( (pause_period/(np.mean(execution_time_sec_shutter[j][i])*10)), )\n    #print np.mean(execution_time_sec_shutter2[j][i])\n    #print \'---------------------\'\n\n\ndel execution_time_shutter\ndel execution_time_sec_shutter\ndel avg_execution_time_shutter\ndel dictList_phase_change\ndel dictList_phase_change2\n\n\n### ----- overhead stuff snapshot 8VM ------------------------------------------------\nexecution_time_shutter = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter = defaultdict(lambda  : defaultdict(list))\navg_execution_time_shutter = defaultdict(dict)\ndictList_phase_change = defaultdict(lambda  : defaultdict(list))\ndictList_phase_change2 = defaultdict(lambda  : defaultdict(list))\n\nstd_execution_time = defaultdict(dict)\n\ndef print_elapsed_time_shutter(time_shutter):\n    for j in colocationList:\n        for i in benchList:\n            print \'%s ||||  %s\'%(j,i)\n            print time_shutter[j][i]\n\n\nsep = \'u\'\nfor (b,a) in enumerate(fList11):\n    #print a\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            execution_time_shutter[index][a].append((fList11[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_shutter[\'colocating with mcf\'][\'perlbench\']\n#print((s.split(start))[1].split(end)[0])\n\nfor j in colocationList:\n    for i in benchList:\n        for k in execution_time_shutter[j][i]:\n            m,s = [float (var) for var in k.split(\':\')]\n            temp = m*60 + s\n            execution_time_sec_shutter[j][i].append(temp)\n\n\nfor (b,a) in enumerate(fList22):\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            dictList_phase_change[index][a].append(fList22[b+1])\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    #print j,i\n    for elem in dictList_phase_change[j][i]:\n        dictList_phase_change2[j][i].extend(elem.strip().split(\'\\t\'))\n    #print dictList_phase_change2[j][i]\n\nsnapshot_overhead3 = ()\nerror_snapshot_overhead = ()\n#print dictList_phase_change2[\'colocating with mcf\'][\'perlbench\']\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    #print j,i\n    #print dictList_phase_change2[j][i]\n    #print i,j\n    shutter_temp_list = []\n    colo_temp_list = []\n    for (count,item) in enumerate(dictList_phase_change2[j][i]):\n        if count%2==1:\n            colo_temp_list.append(float(item))\n        if count%2==0:\n            shutter_temp_list.append(float(item))\n    #print shutter_temp_list\n    shutter_avg = sum(shutter_temp_list)/len(shutter_temp_list)\n    colocation_avg = sum(colo_temp_list)/len(colo_temp_list)\n    del shutter_temp_list\n    del colo_temp_list\n\n    pause_period = (((colocation_avg ) + ((shutter_avg + (colocation_avg * 6)/7) * 7))/8)*75\n    #print pause_period, np.mean(execution_time_sec_shutter[j][i])*1000\n    #pause_period = ((colocation_avg ) + ((shutter_avg + (colocation_avg * 2)/3) * 3))/4\n    xaxis = xaxis + (i,)\n    #print i,j,(pause_period/(np.mean(execution_time_sec_shutter[j][i])*10))\n    snapshot_overhead3 = snapshot_overhead3 + ( (pause_period/(np.mean(execution_time_sec_shutter[j][i])*10)), )\n    #print np.mean(execution_time_sec_shutter2[j][i])\n    #print \'---------------------\'\n\ndel execution_time_shutter\ndel execution_time_sec_shutter\ndel avg_execution_time_shutter\ndel dictList_phase_change\ndel dictList_phase_change2\n### ----- overhead stuff snapshot 16VM ------------------------------------------------\nexecution_time_shutter = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter = defaultdict(lambda  : defaultdict(list))\navg_execution_time_shutter = defaultdict(dict)\ndictList_phase_change = defaultdict(lambda  : defaultdict(list))\ndictList_phase_change2 = defaultdict(lambda  : defaultdict(list))\n\nstd_execution_time = defaultdict(dict)\n\ndef print_elapsed_time_shutter(time_shutter):\n    for j in colocationList:\n        for i in benchList:\n            print \'%s ||||  %s\'%(j,i)\n            print time_shutter[j][i]\n\n\nsep = \'u\'\nfor (b,a) in enumerate(fList12):\n    #print a\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            execution_time_shutter[index][a].append((fList12[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_shutter[\'colocating with mcf\'][\'perlbench\']\n#print((s.split(start))[1].split(end)[0])\n\nfor j in colocationList:\n    for i in benchList:\n        for k in execution_time_shutter[j][i]:\n            m,s = [float (var) for var in k.split(\':\')]\n            temp = m*60 + s\n            execution_time_sec_shutter[j][i].append(temp)\n\n\nfor (b,a) in enumerate(fList23):\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            dictList_phase_change[index][a].append(fList23[b+1])\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    #print j,i\n    for elem in dictList_phase_change[j][i]:\n        dictList_phase_change2[j][i].extend(elem.strip().split(\'\\t\'))\n    #print dictList_phase_change2[j][i]\n\nsnapshot_overhead4 = ()\nerror_snapshot_overhead = ()\n#print dictList_phase_change2[\'colocating with mcf\'][\'perlbench\']\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    print j,i\n    #print dictList_phase_change2[j][i]\n    #print i,j\n    shutter_temp_list = []\n    colo_temp_list = []\n    for (count,item) in enumerate(dictList_phase_change2[j][i]):\n        if count%2==1:\n            colo_temp_list.append(float(item))\n        if count%2==0:\n            shutter_temp_list.append(float(item))\n    #print shutter_temp_list\n    shutter_avg = sum(shutter_temp_list)/len(shutter_temp_list)\n    colocation_avg = sum(colo_temp_list)/len(colo_temp_list)\n    del shutter_temp_list\n    del colo_temp_list\n\n    pause_period = (((colocation_avg ) + ((shutter_avg + (colocation_avg * 14)/15) * 15))/17)*75\n    #print pause_period, np.mean(execution_time_sec_shutter[j][i])*1000\n    #pause_period = ((colocation_avg ) + ((shutter_avg + (colocation_avg * 2)/3) * 3))/4\n    xaxis = xaxis + (i,)\n    print i,j,(pause_period/(np.mean(execution_time_sec_shutter[j][i])*10))\n    snapshot_overhead4 = snapshot_overhead4 + ( (pause_period/(np.mean(execution_time_sec_shutter[j][i])*10))  ,)\n    #print np.mean(execution_time_sec_shutter2[j][i])\n    #print \'---------------------\'\n\ndel execution_time_shutter\ndel execution_time_sec_shutter\ndel avg_execution_time_shutter\ndel dictList_phase_change\ndel dictList_phase_change2\n\n\n#shutteroverhead\n#overhead5,overhead4,overhead3,overhead2\n#snapshotoverhead\n#snapshot_overhead4, snapshot_overhead3, snapshot_overhead2, snapshot_overhead\n#shutteraccuracy\n#shutter_vm5,shutter_vm4,shutter_vm3,shutter_vm2\n#snapshotaccuracy\n#yaxis5,yaxis4, yaxis3, yaxis2\n\n#print xaxis[0]\n\nf = figure(figsize=(5, 3))\nlabels = [\'\' , \'2\', \'4\', \'8\', \'16\', \'\']\nxaxis_list = []\nxaxis_list.append(0.5)\nxaxis_list.append(1)\nxaxis_list.append(1.5)\nxaxis_list.append(2)\n#print overhead2\n\nfor (count,item) in enumerate(benchList):\n    shutter_overhead_list = []\n    shutter_accuracy_list = []\n    snapshot_overhead_list = []\n    snapshot_accuracy_list = []\n    print count\n\n    shutter_overhead_list.append(abs(overhead2[count]))\n    shutter_overhead_list.append(abs(overhead3[count]))\n    shutter_overhead_list.append(abs(overhead4[count]))\n    shutter_overhead_list.append(abs(overhead5[count]))\n\n    shutter_accuracy_list.append(abs(shutter_vm2[count]))\n    shutter_accuracy_list.append(abs(shutter_vm3[count]))\n    shutter_accuracy_list.append(abs(shutter_vm4[count]))\n    shutter_accuracy_list.append(abs(shutter_vm5[count]))\n\n    snapshot_overhead_list.append(abs(snapshot_overhead[count]))\n    snapshot_overhead_list.append(abs(snapshot_overhead2[count]))\n    snapshot_overhead_list.append(abs(snapshot_overhead3[count]))\n    snapshot_overhead_list.append(abs(snapshot_overhead4[count]))\n\n    snapshot_accuracy_list.append(abs(yaxis2[count]))\n    snapshot_accuracy_list.append(abs(yaxis3[count]))\n    snapshot_accuracy_list.append(abs(yaxis4[count]))\n    snapshot_accuracy_list.append(abs(yaxis5[count]))\n\n    #print xaxis_list\n    #print shutter_accuracy_list\n    #print snapshot_accuracy_list\n    #print shutter_overhead_list\n    #print snapshot_overhead_list\n\n\n    #plt.suptitle("Snapshot vs Shuttering", size=16)\n    subplots_adjust(hspace=0.001)\n    ax1=subplot(1, 1, 1)\n    ax1.scatter(xaxis_list, shutter_accuracy_list, facecolor=\'none\', edgecolor=\'r\', label=\'Shuttering\' if count == 0 else "" )\n    ax1.scatter(xaxis_list, snapshot_accuracy_list, color=\'y\', marker=\'+\', label=\'Snapshots\' if count == 0 else "" )\n    ax1.set_ylabel(\'Estimation error (%)\', size=\'11\')\n    ax1.set_xlabel(\'Number of VMs\', size=\'11\')\n    ax1.set_ylim(-5,70)\n    ax1.set_xlim(0,2.5)\n    #ax1.set_xticklabels((2,4,6,8,10,12,14,16),(\'2\', \'4\', \'\', \'8\', \'\', \'\', \'\', \'16\' ))\n    ax1.set_xticklabels(labels,size=\'13\')\n    #ax1.set_yticklabels(size=\'10\')\n    ax1.legend(prop={\'size\':10}, loc=2)\n\n    #plt.yticks((-0.5,0,1,2,3,4),(\'\',\'0\',\'1\',\'2\',\'3\',\'4\'),size=\'23\')\n\n    #ax2=subplot(2, 1, 2, sharex=ax1)\n    #ax2.scatter(xaxis_list, shutter_overhead_list, color=\'r\')\n    #ax2.scatter(xaxis_list, snapshot_overhead_list, color=\'g\')\n    #ax2.xlabel(\'time (s)\')\n    #ax2.set_ylabel(\'Overhead (%)\', size=\'15\')\n    #print ax2.get_ylim()\n    #ax2.set_ylim((0,30)[::-1])\n    #xticklabels = ax1.get_xticklabels()\n    #setp(xticklabels, visible=False)\n    #ax2.legend(prop={\'size\':13}, loc=1)\n    #ax2.set_yticklabels(arange(5, 10, 5))\n    #plt.savefig(\'comparisonfigs/testfig_%s.png\' %count,  dpi=125)\n    del shutter_overhead_list\n    del shutter_accuracy_list\n    del snapshot_overhead_list\n    del snapshot_accuracy_list\n'
p0
.I0
.S'$sub_fig*:astarcompare:Phase level behavior of shuttering for \\texttt{astar} when running with \\texttt{libquantum} and \\texttt{povray}:astarpriorlib,0.5:astarpriorlib2,0.5:astarpriorpovray,0.5:astarpovray,0.5:!t'
p0
.S''
p0
.I4
.S'$graph_fig:astarpriorlib:Short measurement time with high frequency (error 15.06\\%):0.83'
p0
.S"import matplotlib.pyplot as plt\nimport numpy as np\nfrom collections import defaultdict\n\nfilename = '5'\nf1 = [s.strip() for s in open('../../papergraphs/phases/phasedetection/single.txt').readlines()]\nf3 = [s.strip() for s in open('../../papergraphs/phases/phasedetection/shutter_phase_%s_prior.txt' % filename).readlines()]\n\n\nbenchListBaseline = [ 'gcc', 'perlbench', 'mcf', 'leslie3d', 'povray', 'libquantum', 'astar', 'bzip2', 'milc', 'namd', 'calculix', 'h264ref', 'zeusmp', 'gobmk', 'hmmer', 'tonto', 'sphinx3', 'bwaves', 'gromacs', 'dealII', 'sjeng', 'lbm', 'xalancbmk', 'gamess', 'cactusADM', 'soplex', 'GemsFDTD', 'omnetpp' ]\nbenchListExperiments = [ 'gcc', 'perlbench', 'mcf', 'leslie3d', 'povray', 'libquantum', 'astar', 'bzip2', 'milc', 'namd', 'calculix', 'h264ref', 'zeusmp', 'gobmk', 'hmmer', 'tonto', 'sphinx3', 'bwaves', 'gromacs', 'dealII', 'sjeng', 'lbm', 'xalancbmk', 'gamess', 'cactusADM', 'soplex', 'GemsFDTD', 'omnetpp' ]\n#benchListExperiments = [ 'perlbench', 'astar', 'soplex', 'xalancbmk', 'omnetpp', 'bzip2','povray']\n#benchListExperiments = [ 'gcc', 'perlbench', 'astar', 'soplex', 'xalancbmk', 'omnetpp']\ncolocationListBaseline = [ 'colocating with mcf', 'colocating with povray', 'colocating with astar', 'colocating with astar', 'colocating with libquantum', 'colocating with povray', 'colocating with omnetpp', 'colocating with bzip2' ]\ncolocationListExperiments = [ 'colocating with mcf', 'colocating with povray', 'colocating with perlbench', 'colocating with astar', 'colocating with libquantum', 'colocating with povray', 'colocating with omnetpp', 'colocating with bzip2' ]\n\nrunningList = [ 'astar' ,'colocating with libquantum']\n\n\nphaseList_single = defaultdict(list)\nphaseList_degradation = defaultdict(lambda  : defaultdict(list))\nphaseList_shutter = defaultdict(lambda  : defaultdict(list))\nphaseList_colocation = defaultdict(lambda  : defaultdict(list))\n\n\nllc_miss_phaseList_single = defaultdict(list)\nllc_miss_phaseList_degradation = defaultdict(lambda  : defaultdict(list))\nllc_miss_phaseList_shutter = defaultdict(lambda  : defaultdict(list))\nllc_miss_phaseList_colocation = defaultdict(lambda  : defaultdict(list))\n\nfirstList1 = []\nsecondList1 = []\nthirdList1 = []\nfourthList1 = []\nfifthList1 = []\nsixthList1 = []\nseventhList1 = []\neighthList1 = []\n\nfor line in f1:\n    firstList1.append(line)\n\n#for line in f2:\n #   secondList1.append(line)\n\nfor line in f3:\n    thirdList1.append(line)\n\n\n\n#print sixthList1\n#print firstList1\nglobal index\nglobal index2\n\nfor (j,i) in enumerate(firstList1):\n    #print i\n    if i in benchListBaseline:\n        index = i\n    else:\n        phaseList_single[index].append(i.split())\n\n\n#for (j,i) in enumerate(fifthList1):\n#    if i in benchListExperiments:\n#        index = i\n#    else:\n#        llc_miss_phaseList_single[index].append(i.split())\n\n#print len(phaseList_single['gcc'])\n#print len(llc_miss_phaseList_single['gcc'])\n\nfor (j,i) in enumerate(secondList1):\n    if i in colocationListExperiments:\n        index2=i\n    elif i in benchListExperiments:\n        index=i\n    else:\n        phaseList_degradation[index2][index].append(i.split())\n\n\n#for (j,i) in enumerate(sixthList1):\n#    if i in colocationListExperiments:\n#        index2=i\n#    elif i in benchListExperiments:\n#        index=i\n#    else:\n#        llc_miss_phaseList_degradation[index2][index].append(i.split())\n\n#print len(phaseList_degradation['colocating with libquantum']['gcc'])\n#print len(llc_miss_phaseList_degradation['colocating with libquantum']['gcc'])\n\nfor (j,i) in enumerate(thirdList1):\n    if i in colocationListExperiments:\n        index2=i\n    elif i in benchListExperiments:\n        index=i\n    else:\n        phaseList_shutter[index2][index].append(i.split())\n\n\n#for (j,i) in enumerate(seventhList1):\n#    if i in colocationListExperiments:\n#        index2=i\n#    elif i in benchListExperiments:\n#        index=i\n#    else:\n#        llc_miss_phaseList_shutter[index2][index].append(i.split())\n#print len(phaseList_shutter['colocating with libquantum']['gcc'])\n#print len(llc_miss_phaseList_shutter['colocating with libquantum']['gcc'])\n\n#for (j,i) in enumerate(fourthList1):\n#    if i in colocationListExperiments:\n#        index2=i\n#    elif i in benchListExperiments:\n#        index=i\n#    else:\n#        phaseList_colocation[index2][index].append(i.split())\n\n\n#for (j,i) in enumerate(eighthList1):\n#    if i in colocationListExperiments:\n#        index2=i\n#    elif i in benchListExperiments:\n#        index=i\n#    else:\n#        llc_miss_phaseList_colocation[index2][index].append(i.split())\n\n#print len(phaseList_colocation['colocating with libquantum']['gcc'])\n#print len(llc_miss_phaseList_colocation['colocating with libquantum']['gcc'])\n##############place to get the lists to plot #############\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    print i\n    instruction_list1=[]\n    cpi_list1=[]\n    instruction_list2=[]\n    cpi_list2=[]\n    instruction_list3=[]\n    cpi_list3=[]\n    for (b,a) in enumerate(phaseList_shutter[j][i]):\n        if a[0][0] == '-':\n            break\n        else:\n            instruction_list1.append(float(a[1]))\n            cpi_list1.append(a[2])\n\n    for (b,a) in enumerate(phaseList_single[i]):\n        if a[0][0] == '-':\n            break\n        else:\n            instruction_list2.append(float(a[1])*1.2)\n            cpi_list2.append(a[2])\n\n    for (b,a) in enumerate(phaseList_degradation[j][i]):\n        if a[0][0] == '-':\n            break\n        else:\n            instruction_list3.append(float(a[1]))\n            cpi_list3.append(float(a[14])/10)\n\n    #print instruction_list\n    #print cpi_list\n\n    f, ax = plt.subplots(figsize=(12,5))\n    #ax.plot(instruction_list1,miss_list1, color='b', label='ground truth degradation when %s is colocating with %s' %(i,j[16:]))\n    #ax.plot(instruction_list2,cpi_list2, color='g',  label='phase L3 cache miss rate (per thousand cycles) of %s during when 3 corunners (%s) are running ' %(i,j[16:]))\n    #ax.plot(instruction_list2,miss_list2, color='c', label='ground truth L3 cache miss rate (per thousand cycles) of %s when colocating with %s  ' %(i,j[16:]))\n\n\n\n    ax.plot(instruction_list1,cpi_list1, color='r', label='astar w/ libquantum')\n    ax.plot(instruction_list2,cpi_list2, color='y',  label= 'astar w/o libquantum')\n    #ax.plot(instruction_list2,miss_list2, color='c', label='ground truth L3 cache miss rate (per thousand cycles) of %s running alone' %(i))\n    #ax.set_title('Phase of lone execution of %s VS phase of %s running with %s'%(i,i,j))\n    ax.set_xlabel('Executed instructions', fontsize=23)\n    ax.set_ylabel('CPI', fontsize=23)\n    #ax.set_ylabel('LLC store misses')\n    #ax.set_ylabel('L1 Dcache load misses')\n    ax.set_ylim(0.1,6)\n    ax.legend(loc=1,prop={'size':20})\n    ax.tick_params(axis='both', labelsize=18)\n    #plt.savefig('%s_and_libquantum.pdf'%(i),bbox_inches='tight' ,dpi=200)\n    del instruction_list1\n    del cpi_list1\n"
p0
.I0
.S'$graph_fig:astarpriorlib2:Long measurement time with low frequency (error 7.52\\%):0.8'
p0
.S"import matplotlib.pyplot as plt\nimport numpy as np\nfrom collections import defaultdict\n\nfilename = '75'\nf1 = [s.strip() for s in open('../../papergraphs/phases/phasedetection/single.txt').readlines()]\nf3 = [s.strip() for s in open('../../papergraphs/phases/phasedetection/shutter_phase_%s_prior.txt' % filename).readlines()]\n\n\nbenchListBaseline = [ 'gcc', 'perlbench', 'mcf', 'leslie3d', 'povray', 'libquantum', 'astar', 'bzip2', 'milc', 'namd', 'calculix', 'h264ref', 'zeusmp', 'gobmk', 'hmmer', 'tonto', 'sphinx3', 'bwaves', 'gromacs', 'dealII', 'sjeng', 'lbm', 'xalancbmk', 'gamess', 'cactusADM', 'soplex', 'GemsFDTD', 'omnetpp' ]\nbenchListExperiments = [ 'gcc', 'perlbench', 'mcf', 'leslie3d', 'povray', 'libquantum', 'astar', 'bzip2', 'milc', 'namd', 'calculix', 'h264ref', 'zeusmp', 'gobmk', 'hmmer', 'tonto', 'sphinx3', 'bwaves', 'gromacs', 'dealII', 'sjeng', 'lbm', 'xalancbmk', 'gamess', 'cactusADM', 'soplex', 'GemsFDTD', 'omnetpp' ]\n#benchListExperiments = [ 'perlbench', 'astar', 'soplex', 'xalancbmk', 'omnetpp', 'bzip2','povray']\n#benchListExperiments = [ 'gcc', 'perlbench', 'astar', 'soplex', 'xalancbmk', 'omnetpp']\ncolocationListBaseline = [ 'colocating with mcf', 'colocating with povray', 'colocating with astar', 'colocating with astar', 'colocating with libquantum', 'colocating with povray', 'colocating with omnetpp', 'colocating with bzip2' ]\ncolocationListExperiments = [ 'colocating with mcf', 'colocating with povray', 'colocating with perlbench', 'colocating with astar', 'colocating with libquantum', 'colocating with povray', 'colocating with omnetpp', 'colocating with bzip2' ]\n\nrunningList = [ 'astar' ,'colocating with libquantum']\n\n\nphaseList_single = defaultdict(list)\nphaseList_degradation = defaultdict(lambda  : defaultdict(list))\nphaseList_shutter = defaultdict(lambda  : defaultdict(list))\nphaseList_colocation = defaultdict(lambda  : defaultdict(list))\n\n\nllc_miss_phaseList_single = defaultdict(list)\nllc_miss_phaseList_degradation = defaultdict(lambda  : defaultdict(list))\nllc_miss_phaseList_shutter = defaultdict(lambda  : defaultdict(list))\nllc_miss_phaseList_colocation = defaultdict(lambda  : defaultdict(list))\n\nfirstList1 = []\nsecondList1 = []\nthirdList1 = []\nfourthList1 = []\nfifthList1 = []\nsixthList1 = []\nseventhList1 = []\neighthList1 = []\n\nfor line in f1:\n    firstList1.append(line)\n\n#for line in f2:\n #   secondList1.append(line)\n\nfor line in f3:\n    thirdList1.append(line)\n\n\n\n#print sixthList1\n#print firstList1\nglobal index\nglobal index2\n\nfor (j,i) in enumerate(firstList1):\n    #print i\n    if i in benchListBaseline:\n        index = i\n    else:\n        phaseList_single[index].append(i.split())\n\n\n#for (j,i) in enumerate(fifthList1):\n#    if i in benchListExperiments:\n#        index = i\n#    else:\n#        llc_miss_phaseList_single[index].append(i.split())\n\n#print len(phaseList_single['gcc'])\n#print len(llc_miss_phaseList_single['gcc'])\n\nfor (j,i) in enumerate(secondList1):\n    if i in colocationListExperiments:\n        index2=i\n    elif i in benchListExperiments:\n        index=i\n    else:\n        phaseList_degradation[index2][index].append(i.split())\n\n\n#for (j,i) in enumerate(sixthList1):\n#    if i in colocationListExperiments:\n#        index2=i\n#    elif i in benchListExperiments:\n#        index=i\n#    else:\n#        llc_miss_phaseList_degradation[index2][index].append(i.split())\n\n#print len(phaseList_degradation['colocating with libquantum']['gcc'])\n#print len(llc_miss_phaseList_degradation['colocating with libquantum']['gcc'])\n\nfor (j,i) in enumerate(thirdList1):\n    if i in colocationListExperiments:\n        index2=i\n    elif i in benchListExperiments:\n        index=i\n    else:\n        phaseList_shutter[index2][index].append(i.split())\n\n\n#for (j,i) in enumerate(seventhList1):\n#    if i in colocationListExperiments:\n#        index2=i\n#    elif i in benchListExperiments:\n#        index=i\n#    else:\n#        llc_miss_phaseList_shutter[index2][index].append(i.split())\n#print len(phaseList_shutter['colocating with libquantum']['gcc'])\n#print len(llc_miss_phaseList_shutter['colocating with libquantum']['gcc'])\n\n#for (j,i) in enumerate(fourthList1):\n#    if i in colocationListExperiments:\n#        index2=i\n#    elif i in benchListExperiments:\n#        index=i\n#    else:\n#        phaseList_colocation[index2][index].append(i.split())\n\n\n#for (j,i) in enumerate(eighthList1):\n#    if i in colocationListExperiments:\n#        index2=i\n#    elif i in benchListExperiments:\n#        index=i\n#    else:\n#        llc_miss_phaseList_colocation[index2][index].append(i.split())\n\n#print len(phaseList_colocation['colocating with libquantum']['gcc'])\n#print len(llc_miss_phaseList_colocation['colocating with libquantum']['gcc'])\n##############place to get the lists to plot #############\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    print i\n    instruction_list1=[]\n    cpi_list1=[]\n    instruction_list2=[]\n    cpi_list2=[]\n    instruction_list3=[]\n    cpi_list3=[]\n    for (b,a) in enumerate(phaseList_shutter[j][i]):\n        if a[0][0] == '-':\n            break\n        else:\n            instruction_list1.append(float(a[1]))\n            cpi_list1.append(a[2])\n\n    for (b,a) in enumerate(phaseList_single[i]):\n        if a[0][0] == '-':\n            break\n        else:\n            instruction_list2.append(float(a[1])*1.3)\n            cpi_list2.append(a[2])\n\n    for (b,a) in enumerate(phaseList_degradation[j][i]):\n        if a[0][0] == '-':\n            break\n        else:\n            instruction_list3.append(float(a[1]))\n            cpi_list3.append(float(a[14])/10)\n\n    #print instruction_list\n    #print cpi_list\n\n    f, ax = plt.subplots(figsize=(12,5))\n    #ax.plot(instruction_list1,miss_list1, color='b', label='ground truth degradation when %s is colocating with %s' %(i,j[16:]))\n    #ax.plot(instruction_list2,cpi_list2, color='g',  label='phase L3 cache miss rate (per thousand cycles) of %s during when 3 corunners (%s) are running ' %(i,j[16:]))\n    #ax.plot(instruction_list2,miss_list2, color='c', label='ground truth L3 cache miss rate (per thousand cycles) of %s when colocating with %s  ' %(i,j[16:]))\n\n\n\n    ax.plot(instruction_list1,cpi_list1, color='r', label='astar w/ libquantum')\n    ax.plot(instruction_list2,cpi_list2, color='y',  label= 'astar w/o libquantum')\n    #ax.plot(instruction_list2,miss_list2, color='c', label='ground truth L3 cache miss rate (per thousand cycles) of %s running alone' %(i))\n    #ax.set_title('Phase of lone execution of %s VS phase of %s running with %s'%(i,i,j))\n    ax.set_xlabel('Executed instructions', fontsize=23)\n    ax.set_ylabel('CPI', fontsize=23)\n    #ax.set_ylabel('LLC store misses')\n    #ax.set_ylabel('L1 Dcache load misses')\n    ax.set_ylim(0.1,6)\n    ax.set_xlim(0,750000000000)\n    ax.legend(loc=1,prop={'size':20})\n    ax.tick_params(axis='both', labelsize=18)\n    #plt.savefig('%s_and_libquantum.pdf'%(i),bbox_inches='tight' ,dpi=200)\n    del instruction_list1\n    del cpi_list1\n"
p0
.I0
.S'$graph_fig:astarpriorpovray:Short measurement time with high frequency (error 5.2\\%):0.83'
p0
.S"import matplotlib.pyplot as plt\nimport numpy as np\nfrom collections import defaultdict\n\nfilename = '4'\nf1 = [s.strip() for s in open('../../papergraphs/phases/phasedetection/single.txt').readlines()]\nf3 = [s.strip() for s in open('../../papergraphs/phases/phasedetection/shutter_phase_%s_prior.txt' % filename).readlines()]\n\n\nbenchListBaseline = [ 'gcc', 'perlbench', 'mcf', 'leslie3d', 'povray', 'libquantum', 'astar', 'bzip2', 'milc', 'namd', 'calculix', 'h264ref', 'zeusmp', 'gobmk', 'hmmer', 'tonto', 'sphinx3', 'bwaves', 'gromacs', 'dealII', 'sjeng', 'lbm', 'xalancbmk', 'gamess', 'cactusADM', 'soplex', 'GemsFDTD', 'omnetpp' ]\nbenchListExperiments = [ 'gcc', 'perlbench', 'mcf', 'leslie3d', 'povray', 'libquantum', 'astar', 'bzip2', 'milc', 'namd', 'calculix', 'h264ref', 'zeusmp', 'gobmk', 'hmmer', 'tonto', 'sphinx3', 'bwaves', 'gromacs', 'dealII', 'sjeng', 'lbm', 'xalancbmk', 'gamess', 'cactusADM', 'soplex', 'GemsFDTD', 'omnetpp' ]\n#benchListExperiments = [ 'perlbench', 'astar', 'soplex', 'xalancbmk', 'omnetpp', 'bzip2','povray']\n#benchListExperiments = [ 'gcc', 'perlbench', 'astar', 'soplex', 'xalancbmk', 'omnetpp']\ncolocationListBaseline = [ 'colocating with mcf', 'colocating with povray', 'colocating with astar', 'colocating with astar', 'colocating with libquantum', 'colocating with povray', 'colocating with omnetpp', 'colocating with bzip2' ]\ncolocationListExperiments = [ 'colocating with mcf', 'colocating with povray', 'colocating with perlbench', 'colocating with astar', 'colocating with libquantum', 'colocating with povray', 'colocating with omnetpp', 'colocating with bzip2' ]\n\nrunningList = [ 'astar' ,'colocating with povray']\n\n\nphaseList_single = defaultdict(list)\nphaseList_degradation = defaultdict(lambda  : defaultdict(list))\nphaseList_shutter = defaultdict(lambda  : defaultdict(list))\nphaseList_colocation = defaultdict(lambda  : defaultdict(list))\n\n\nllc_miss_phaseList_single = defaultdict(list)\nllc_miss_phaseList_degradation = defaultdict(lambda  : defaultdict(list))\nllc_miss_phaseList_shutter = defaultdict(lambda  : defaultdict(list))\nllc_miss_phaseList_colocation = defaultdict(lambda  : defaultdict(list))\n\nfirstList1 = []\nsecondList1 = []\nthirdList1 = []\nfourthList1 = []\nfifthList1 = []\nsixthList1 = []\nseventhList1 = []\neighthList1 = []\n\nfor line in f1:\n    firstList1.append(line)\n\n#for line in f2:\n #   secondList1.append(line)\n\nfor line in f3:\n    thirdList1.append(line)\n\n\n\n#print sixthList1\n#print firstList1\nglobal index\nglobal index2\n\nfor (j,i) in enumerate(firstList1):\n    #print i\n    if i in benchListBaseline:\n        index = i\n    else:\n        phaseList_single[index].append(i.split())\n\n\n#for (j,i) in enumerate(fifthList1):\n#    if i in benchListExperiments:\n#        index = i\n#    else:\n#        llc_miss_phaseList_single[index].append(i.split())\n\n#print len(phaseList_single['gcc'])\n#print len(llc_miss_phaseList_single['gcc'])\n\nfor (j,i) in enumerate(secondList1):\n    if i in colocationListExperiments:\n        index2=i\n    elif i in benchListExperiments:\n        index=i\n    else:\n        phaseList_degradation[index2][index].append(i.split())\n\n\n#for (j,i) in enumerate(sixthList1):\n#    if i in colocationListExperiments:\n#        index2=i\n#    elif i in benchListExperiments:\n#        index=i\n#    else:\n#        llc_miss_phaseList_degradation[index2][index].append(i.split())\n\n#print len(phaseList_degradation['colocating with libquantum']['gcc'])\n#print len(llc_miss_phaseList_degradation['colocating with libquantum']['gcc'])\n\nfor (j,i) in enumerate(thirdList1):\n    if i in colocationListExperiments:\n        index2=i\n    elif i in benchListExperiments:\n        index=i\n    else:\n        phaseList_shutter[index2][index].append(i.split())\n\n\n#for (j,i) in enumerate(seventhList1):\n#    if i in colocationListExperiments:\n#        index2=i\n#    elif i in benchListExperiments:\n#        index=i\n#    else:\n#        llc_miss_phaseList_shutter[index2][index].append(i.split())\n#print len(phaseList_shutter['colocating with libquantum']['gcc'])\n#print len(llc_miss_phaseList_shutter['colocating with libquantum']['gcc'])\n\n#for (j,i) in enumerate(fourthList1):\n#    if i in colocationListExperiments:\n#        index2=i\n#    elif i in benchListExperiments:\n#        index=i\n#    else:\n#        phaseList_colocation[index2][index].append(i.split())\n\n\n#for (j,i) in enumerate(eighthList1):\n#    if i in colocationListExperiments:\n#        index2=i\n#    elif i in benchListExperiments:\n#        index=i\n#    else:\n#        llc_miss_phaseList_colocation[index2][index].append(i.split())\n\n#print len(phaseList_colocation['colocating with libquantum']['gcc'])\n#print len(llc_miss_phaseList_colocation['colocating with libquantum']['gcc'])\n##############place to get the lists to plot #############\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    print i\n    instruction_list1=[]\n    cpi_list1=[]\n    instruction_list2=[]\n    cpi_list2=[]\n    instruction_list3=[]\n    cpi_list3=[]\n    for (b,a) in enumerate(phaseList_shutter[j][i]):\n        if a[0][0] == '-':\n            break\n        else:\n            instruction_list1.append(float(a[1])*1.1)\n            cpi_list1.append(a[2])\n\n    for (b,a) in enumerate(phaseList_single[i]):\n        if a[0][0] == '-':\n            break\n        else:\n            instruction_list2.append(float(a[1]))\n            cpi_list2.append(a[2])\n\n    for (b,a) in enumerate(phaseList_degradation[j][i]):\n        if a[0][0] == '-':\n            break\n        else:\n            instruction_list3.append(float(a[1]))\n            cpi_list3.append(float(a[14])/10)\n\n    #print instruction_list\n    #print cpi_list\n\n    f, ax = plt.subplots(figsize=(12,5))\n    #ax.plot(instruction_list1,miss_list1, color='b', label='ground truth degradation when %s is colocating with %s' %(i,j[16:]))\n    #ax.plot(instruction_list2,cpi_list2, color='g',  label='phase L3 cache miss rate (per thousand cycles) of %s during when 3 corunners (%s) are running ' %(i,j[16:]))\n    #ax.plot(instruction_list2,miss_list2, color='c', label='ground truth L3 cache miss rate (per thousand cycles) of %s when colocating with %s  ' %(i,j[16:]))\n\n\n\n    ax.plot(instruction_list1,cpi_list1, color='r', label='astar w/ povray')\n    ax.plot(instruction_list2,cpi_list2, color='y',  label= 'astar w/o povray')\n    #ax.plot(instruction_list2,miss_list2, color='c', label='ground truth L3 cache miss rate (per thousand cycles) of %s running alone' %(i))\n    #ax.set_title('Phase of lone execution of %s VS phase of %s running with %s'%(i,i,j))\n    ax.set_xlabel('Executed instructions', fontsize=23)\n    ax.set_ylabel('CPI', fontsize=23)\n    #ax.set_ylabel('LLC store misses')\n    #ax.set_ylabel('L1 Dcache load misses')\n    ax.set_ylim(0.1,5)\n    ax.legend(loc=1,prop={'size':20})\n    ax.tick_params(axis='both', labelsize=18)\n    #plt.savefig('%s_and_libquantum.pdf'%(i),bbox_inches='tight' ,dpi=200)\n    del instruction_list1\n    del cpi_list1\n"
p0
.I0
.S'$graph_fig:astarpovray:Long measurement time with low frequency (error 28.03\\%):0.8'
p0
.S"import matplotlib.pyplot as plt\nimport numpy as np\nfrom collections import defaultdict\n\nfilename = '80'\nf1 = [s.strip() for s in open('../../papergraphs/phases/phasedetection/single.txt').readlines()]\n#f2 = [s.strip() for s in open('../../papergraphs/1.3parameters/degradation/phase_1000.txt').readlines()]\nf3 = [s.strip() for s in open('../../papergraphs/1.3parameters/shutter_phase_%s.txt' % filename).readlines()]\n\nbenchListBaseline = [ 'gcc', 'perlbench', 'mcf', 'leslie3d', 'povray', 'libquantum', 'astar', 'bzip2', 'milc', 'namd', 'calculix', 'h264ref', 'zeusmp', 'gobmk', 'hmmer', 'tonto', 'sphinx3', 'bwaves', 'gromacs', 'dealII', 'sjeng', 'lbm', 'xalancbmk', 'gamess', 'cactusADM', 'soplex', 'GemsFDTD', 'omnetpp' ]\nbenchListExperiments = [ 'gcc', 'perlbench', 'mcf', 'leslie3d', 'povray', 'libquantum', 'astar', 'bzip2', 'milc', 'namd', 'calculix', 'h264ref', 'zeusmp', 'gobmk', 'hmmer', 'tonto', 'sphinx3', 'bwaves', 'gromacs', 'dealII', 'sjeng', 'lbm', 'xalancbmk', 'gamess', 'cactusADM', 'soplex', 'GemsFDTD', 'omnetpp' ]\n#benchListExperiments = [ 'perlbench', 'astar', 'soplex', 'xalancbmk', 'omnetpp', 'bzip2','povray']\n#benchListExperiments = [ 'gcc', 'perlbench', 'astar', 'soplex', 'xalancbmk', 'omnetpp']\ncolocationListBaseline = [ 'colocating with mcf', 'colocating with povray', 'colocating with astar', 'colocating with astar', 'colocating with libquantum', 'colocating with povray', 'colocating with omnetpp', 'colocating with bzip2' ]\ncolocationListExperiments = [ 'colocating with mcf', 'colocating with povray', 'colocating with perlbench', 'colocating with astar', 'colocating with libquantum', 'colocating with povray', 'colocating with omnetpp', 'colocating with bzip2' ]\nrunningList = [ 'astar' ,'colocating with povray']\n\n\nphaseList_single = defaultdict(list)\nphaseList_degradation = defaultdict(lambda  : defaultdict(list))\nphaseList_shutter = defaultdict(lambda  : defaultdict(list))\nphaseList_colocation = defaultdict(lambda  : defaultdict(list))\n\n\nllc_miss_phaseList_single = defaultdict(list)\nllc_miss_phaseList_degradation = defaultdict(lambda  : defaultdict(list))\nllc_miss_phaseList_shutter = defaultdict(lambda  : defaultdict(list))\nllc_miss_phaseList_colocation = defaultdict(lambda  : defaultdict(list))\n\nfirstList1 = []\nsecondList1 = []\nthirdList1 = []\nfourthList1 = []\nfifthList1 = []\nsixthList1 = []\nseventhList1 = []\neighthList1 = []\n\nfor line in f1:\n    firstList1.append(line)\n\n#for line in f2:\n #   secondList1.append(line)\n\nfor line in f3:\n    thirdList1.append(line)\n\n#print firstList1\nglobal index\nglobal index2\n\nfor (j,i) in enumerate(firstList1):\n    #print i\n    if i in benchListBaseline:\n        index = i\n    else:\n        phaseList_single[index].append(i.split())\n\n\nfor (j,i) in enumerate(secondList1):\n    if i in colocationListExperiments:\n        index2=i\n    elif i in benchListExperiments:\n        index=i\n    else:\n        phaseList_degradation[index2][index].append(i.split())\n\n\nfor (j,i) in enumerate(thirdList1):\n    if i in colocationListExperiments:\n        index2=i\n    elif i in benchListExperiments:\n        index=i\n    else:\n        phaseList_shutter[index2][index].append(i.split())\n\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    print i\n    instruction_list1=[]\n    cpi_list1=[]\n    instruction_list2=[]\n    cpi_list2=[]\n    instruction_list3=[]\n    cpi_list3=[]\n    for (b,a) in enumerate(phaseList_shutter[j][i]):\n        if a[0][0] == '-':\n            break\n        else:\n            instruction_list1.append(float(a[1]))\n            cpi_list1.append(a[2])\n\n    for (b,a) in enumerate(phaseList_single[i]):\n        if a[0][0] == '-':\n            break\n        else:\n            instruction_list2.append(float(a[1]))\n            cpi_list2.append(a[2])\n\n    for (b,a) in enumerate(phaseList_degradation[j][i]):\n        if a[0][0] == '-':\n            break\n        else:\n            instruction_list3.append(float(a[1]))\n            cpi_list3.append(float(a[11])/1)\n\n    #print instruction_list\n    #print cpi_list\n\n    f, ax = plt.subplots(figsize=(12,5))\n\n\n    ax.plot(instruction_list1,cpi_list1, color='r', label='%s w/ %s' %(i,j[16:]))\n    ax.plot(instruction_list2,cpi_list2, color='y',  label= '%s w/o %s' %(i,j[16:]))\n    #ax.plot(instruction_list2,miss_list2, color='c', label='ground truth L3 cache miss rate (per thousand cycles) of %s running alone' %(i))\n    #ax.set_title('Phase of lone execution of %s VS phase of %s running with %s'%(i,i,j))\n    ax.set_xlabel('Executed instructions', fontsize=25)\n    ax.set_ylabel('CPI', fontsize=23)\n    ax.set_ylim(-0,5)\n    ax.set_xlim(-0,570000000000)\n    #ax.set_yticks(np.arange(0,4,1))\n    ax.tick_params(axis='both', labelsize=18)\n    ax.legend(loc=1,prop={'size':21})\n    #plt.savefig('tempcpi/%s_and_libquantum.pdf'%(i),bbox_inches='tight' ,dpi=200)\n    del instruction_list1\n    del cpi_list1\n"
p0
.I0
.S'$sub_fig*:comparison:Shuttering vs. snapshot for accuracy and overhead on 16VMs:accuracy-comparison,2:nl:overhead-comparison,2:'
p0
.S''
p0
.I2
.S'$graph:accuracy-comparison: Accuracy:0.96'
p0
.S'from collections import defaultdict\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nbenchListBaseline = [ \'gcc\', \'perlbench\', \'leslie3d\', \'povray\', \'libquantum\', \'astar\', \'bzip2\', \'milc\', \'namd\', \'calculix\', \'h264ref\', \'sphinx3\', \'zeusmp\', \'gobmk\', \'hmmer\', \'tonto\', \'bwaves\', \'gromacs\', \'dealII\', \'sjeng\', \'lbm\', \'xalancbmk\', \'gamess\', \'cactusADM\', \'soplex\', \'GemsFDTD\', \'omnetpp\', \'mcf\' ]\nbenchListExperiments = [ \'gcc\', \'perlbench\', \'leslie3d\', \'povray\', \'libquantum\', \'astar\', \'bzip2\', \'milc\', \'namd\', \'calculix\', \'h264ref\', \'sphinx3\', \'zeusmp\', \'gobmk\', \'hmmer\', \'tonto\', \'bwaves\', \'gromacs\', \'dealII\', \'sjeng\', \'lbm\', \'xalancbmk\', \'gamess\', \'cactusADM\', \'soplex\', \'GemsFDTD\', \'omnetpp\', \'mcf\' ]\ncolocationListBaseline = [ \'colocating with lbm\', \'colocating with povray\', \'colocating with milc\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with mcf\' ]\ncolocationListExperiments = [ \'colocating with lbm\', \'colocating with povray\', \'colocating with milc\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with mcf\' ]\n\nrunningList2 = [  \'perlbench\', \'colocating with libquantum\', \'mcf\', \'colocating with libquantum\', \'leslie3d\', \'colocating with libquantum\', \'povray\', \'colocating with libquantum\', \'libquantum\', \'colocating with libquantum\', \'astar\', \'colocating with libquantum\', \'milc\', \'colocating with libquantum\', \'namd\', \'colocating with libquantum\', \'calculix\', \'colocating with libquantum\', \'h264ref\', \'colocating with libquantum\', \'gobmk\', \'colocating with libquantum\', \'hmmer\', \'colocating with libquantum\', \'tonto\', \'colocating with libquantum\', \'sphinx3\', \'colocating with libquantum\', \'zeusmp\', \'colocating with libquantum\', \'bwaves\', \'colocating with libquantum\', \'gromacs\', \'colocating with libquantum\', \'dealII\', \'colocating with libquantum\', \'sjeng\', \'colocating with libquantum\', \'lbm\', \'colocating with libquantum\', \'xalancbmk\', \'colocating with libquantum\', \'gamess\', \'colocating with libquantum\', \'soplex\', \'colocating with libquantum\', \'GemsFDTD\', \'colocating with libquantum\', \'omnetpp\', \'colocating with libquantum\' ]\n\nsiriusbenchListBaseline = [ \'gmm\', \'dnn_asr\', \'surf-fe\', \'surf-fd\', \'stem\', \'regex\', \'crf\', \'img-imc\', \'img-dig\', \'img-face\', \'nlp-pos\', \'nlp-chk\', \'nlp-ner\']\nsiriusbenchListExperiments = [ \'gmm\', \'dnn_asr\', \'surf-fe\', \'surf-fd\', \'stem\', \'regex\', \'crf\', \'img-imc\', \'img-dig\', \'img-face\', \'nlp-pos\', \'nlp-chk\', \'nlp-ner\']\nsiriuscolocationListBaseline = [ \'colocating with lbm\', \'colocating with povray\', \'colocating with astar\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with mcf\' ]\nsiriuscolocationListExperiments = [ \'colocating with lbm\', \'colocating with povray\', \'colocating with perlbench\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with mcf\' ]\nsiriusrunningList2 = [ \'gmm\', \'colocating with libquantum\', \'surf-fe\', \'colocating with libquantum\', \'surf-fd\', \'colocating with libquantum\', \'stem\', \'colocating with libquantum\', \'regex\', \'colocating with libquantum\', \'crf\', \'colocating with libquantum\', \'img-imc\', \'colocating with libquantum\', \'img-dig\', \'colocating with libquantum\', \'img-face\', \'colocating with libquantum\', \'nlp-pos\', \'colocating with libquantum\', \'nlp-chk\', \'colocating with libquantum\', \'nlp-ner\' , \'colocating with libquantum\']\n\n\ndef autolabel(rects):\n    # attach some text labels\n    for rect in rects:\n        height = rect.get_height()\n        plt.text(rect.get_x()+rect.get_width()/2., 1.05*height, \'%.2f\'%float(height))\n\ndef autolabel2(rects):\n    # attach some text labels\n    for rect in rects:\n        height = rect.get_height()\n        plt.text(rect.get_x()+rect.get_width()/2., 1.05*height, \'%.2f\'%float(height))\n\ndef add_line(ax, xpos, ypos):\n    line = plt.Line2D([xpos, xpos], [ypos + .1, ypos - .5], transform=ax.transAxes, linewidth=2, color=\'black\')\n    line.set_clip_on(False)\n    ax.add_line(line)\n\n\nfilename = \'shutter_cpi_10\'\n#fList = [s.strip() for s in open(\'../../papergraphs/2.fullspec/accuracy/libquantumcorunner/single_vm_ground_truth/shutter_cpi_1000.txt\').readlines()]\n#fList2 = [s.strip() for s in open(\'../../papergraphs/2.fullspec/accuracy/libquantumcorunner/degradation_ground_truth/shutter_cpi_1000.txt\').readlines()]\n#fList3 = [s.strip() for s in open(\'../../papergraphs/2.fullspec/accuracy/libquantumcorunner/experiment_1/%s.txt\' % filename).readlines()]\nfList3= [s.strip() for s in open(\'../../papergraphs/scalability/libquantumcorunner/spec/priorwork/shutter_cpi_4.txt\').readlines()]\n\nfList4 = [s.strip() for s in open(\'../../papergraphs/scalability/libquantumcorunner/spec/singlevm/shutter_cpi_1000.txt\').readlines()]\nfList5 = [s.strip() for s in open(\'../../papergraphs/scalability/libquantumcorunner/spec/degradation/shutter_cpi_1000.txt\').readlines()]\nfList6 = [s.strip() for s in open(\'../../papergraphs/scalability/libquantumcorunner/spec/snapshot/%s.txt\' % filename).readlines()]\n\nfList8= [s.strip() for s in open(\'../../papergraphs/scalability/libquantumcorunner/siriusdjinn/priorwork/shutter_cpi_4.txt\').readlines()]\n\nfList9 = [s.strip() for s in open(\'../../papergraphs/scalability/libquantumcorunner/siriusdjinn/singlevm/shutter_cpi_1000.txt\').readlines()]\nfList10 = [s.strip() for s in open(\'../../papergraphs/scalability/libquantumcorunner/siriusdjinn/degradation/shutter_cpi_1000.txt\').readlines()]\nfList11 = [s.strip() for s in open(\'../../papergraphs/scalability/libquantumcorunner/siriusdjinn/snapshot/shutter_cpi_10.txt\').readlines()]\n\ndictList_single_vm = defaultdict(list)\ndictList_degradation_colocation = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter2 = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter3 = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter4 = defaultdict(lambda  : defaultdict(list))\nplot_degradation = defaultdict(dict)\nplot_degradation2 = defaultdict(dict)\nplot_degradation_error = defaultdict(dict)\nplot_degradation_error2 = defaultdict(dict)\nplot_degradation_abs = defaultdict(dict)\nplot_degradation_abs2 = defaultdict(dict)\n\n\nyaxis2 = ()\nyaxis3 = ()\nyaxis_abs2 = ()\nyaxis_abs3 = ()\nerror2 = ()\nerror3 = ()\nxaxis2 = ()\n\nfor (b,a) in enumerate(fList9):\n    if a in siriusbenchListBaseline:\n        dictList_single_vm[a].append(fList9[b+1])\n\n\n#SORTING LIST CONTAING VALUES OF SINGLE SPEC RUNS INSIDE VMs\nfor i in siriusbenchListBaseline:\n    dictList_single_vm[i].sort()\n    print i,dictList_single_vm[i]\n\nfor (b,a) in enumerate(fList10):\n    #print a\n    if a in siriuscolocationListBaseline:\n       #print a\n       index = a\n    else:\n        if a in siriusbenchListExperiments:\n            #print a\n            dictList_degradation_colocation[index][a].append(fList10[b+1])\n\n#sorting the ground truth values\nfor a in xrange(0,len(siriusrunningList2),2):\n    j = siriusrunningList2[a+1]\n    i = siriusrunningList2[a]\n    #print i,j\n    dictList_degradation_colocation[j][i].sort()\n    print j,i,dictList_degradation_colocation[j][i]\n\n#for a in xrange(0,len(runningList),2):\n#    j = runningList[a+1]\n#    i = runningList[a]\n#    numerator1 = sum(float(n) for (m,n) in enumerate(dictList_degradation_colocation[j][i]) if m!=0 and m!=len(dictList_degradation_colocation[j][i])-1)/(len(dictList_degradation_colocation[j][i])-2)\n#    print numerator1\n#    #print dictList_degradation_colocation[runningList[a+1]][runningList[a]]\n#    #print numerator1\n\n#APPENDING DEGRADATION SHUTTER\nfor (b,a) in enumerate(fList11):\n    #print a\n    if a in siriuscolocationListExperiments:\n        index = a\n    else:\n        if a in siriusbenchListExperiments:\n            dictList_degradation_shutter[index][a].append(fList11[b+1])\n\nfor (b,a) in enumerate(fList8):\n    if a in siriuscolocationListExperiments:\n        index = a\n    else:\n        if a in siriusbenchListExperiments:\n            dictList_degradation_shutter3[index][a].append(fList8[b+1])\n\nfor a in xrange(0,len(siriusrunningList2),2):\n    j = siriusrunningList2[a+1]\n    i = siriusrunningList2[a]\n    print i,j,dictList_degradation_shutter[j][i]\n#APPENDING DEGRADATION SHUTTER2 as shutter and colocation values are tab separated\nfor a in xrange(0,len(siriusrunningList2),2):\n    j = siriusrunningList2[a+1]\n    i = siriusrunningList2[a]\n    for elem in dictList_degradation_shutter[j][i]:\n        dictList_degradation_shutter2[j][i].extend(elem.strip().split(\'\\t\'))\n\n    for elem in dictList_degradation_shutter3[j][i]:\n        dictList_degradation_shutter4[j][i].extend(elem.strip().split(\'\\t\'))\n    #print dictList_degradation_shutter2[j][i]\n\nfor a in xrange(0,len(siriusrunningList2),2):\n    j = siriusrunningList2[a+1]\n    i = siriusrunningList2[a]\n    print i,j\n    #print i\n    #print dictList_single_vm[i]\n    #print dictList_degradation_colocation[j][i]\n    #print dictList_degradation_shutter2[j][i]\n    denominator1 = sum(float(n) for (m,n) in enumerate(dictList_single_vm[i]))/(len(dictList_single_vm[i]))\n    numerator1 = sum(float(n) for (m,n) in enumerate(dictList_degradation_colocation[j][i]))/(len(dictList_degradation_colocation[j][i]))\n    shutter_temp_list = []\n    shutter_temp_list2 = []\n    colo_temp_list = []\n    colo_temp_list2 = []\n    degradation_temp_list = []\n    degradation_temp_list2 = []\n    error_temp_list = []\n    error_temp_list2 = []\n    #print numerator1\n    #print denominator1\n    for (count,item) in enumerate(dictList_degradation_shutter2[j][i]):\n        if count%2==0:\n            colo_temp_list.append(item)\n        if count%2==1:\n            shutter_temp_list.append(item)\n\n    for (count,item) in enumerate(dictList_degradation_shutter4[j][i]):\n        if count%2==0:\n            colo_temp_list2.append(item)\n        if count%2==1:\n            shutter_temp_list2.append(item)\n\n    for (count,item) in enumerate(shutter_temp_list):\n        degradation_temp_list.append(abs((((float(shutter_temp_list[count])/float(colo_temp_list[count]))-(numerator1/denominator1))/(float(shutter_temp_list[count])/float(colo_temp_list[count])))*100))\n\n    shutter_temp_list.sort()\n    shutter_temp_list2.sort()\n    colo_temp_list.sort()\n    colo_temp_list2.sort()\n    print shutter_temp_list\n    print colo_temp_list\n    #print dictList_degradation_shutter2[j][i]\n    denominator2 = sum(float(n) for (m,n) in enumerate(shutter_temp_list) )/len(shutter_temp_list)\n    numerator2 = sum(float(n) for (m,n) in enumerate(colo_temp_list))/len(colo_temp_list)\n    for (m,n) in enumerate(shutter_temp_list):\n        ratio=float(n)/float(colo_temp_list[m])\n        error_temp_list.append(abs((((ratio)-(numerator1/denominator1))/(numerator1/denominator1))*100))\n    plot_degradation_error[j][i]=np.std(error_temp_list)\n\n    denominator3 = sum(float(n) for (m,n) in enumerate(shutter_temp_list2))/(len(shutter_temp_list2))\n    numerator3 = sum(float(n) for (m,n) in enumerate(colo_temp_list2))/(len(colo_temp_list2))\n    for (m,n) in enumerate(shutter_temp_list2):\n        ratio=float(n)/float(colo_temp_list2[m])\n        error_temp_list2.append(abs((((ratio)-(numerator3/denominator3))/(numerator1/denominator1))*100))\n    plot_degradation_error2[j][i]=np.std(error_temp_list2)\n\n    print numerator2\n    print denominator2\n    del shutter_temp_list\n    del colo_temp_list\n    del degradation_temp_list\n    del shutter_temp_list2\n    del colo_temp_list2\n    del degradation_temp_list2\n    plot_degradation[j][i] = (((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100\n    plot_degradation_abs[j][i] = abs((((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100)\n    plot_degradation2[j][i] = (((numerator3/denominator3)-(numerator1/denominator1))/(numerator1/denominator1))*100\n    plot_degradation_abs2[j][i] = abs((((numerator3/denominator3)-(numerator1/denominator1))/(numerator1/denominator1))*100)\n    #print j,i,plot_degradation[j][i]\n    #print plot_degradation_error[j][i]\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    xaxis2 = xaxis2 + (i,)\n    yaxis2 = yaxis2 + (plot_degradation[j][i],)\n    yaxis3 = yaxis3 + (plot_degradation2[j][i],)\n    yaxis_abs2 = yaxis_abs2 + (plot_degradation_abs[j][i],)\n    yaxis_abs3 = yaxis_abs3 + (plot_degradation_abs2[j][i],)\n    error2 = error2 + (plot_degradation_error[j][i],)\n    error3 = error3 + (plot_degradation_error2[j][i],)\n    #print numerator2,denominator2,numerator2/denominator2\n    #print denominator2/numerator2\n    #print j,i,plot_degradation[j][i],plot_degradation2[j][i]\n            #print (((numerator2/denominator2)-(numerator1/denominator1))/(numerator2/denominator2))*100\n#print np.mean(yaxis2)\n\n\n#width=0.25\n#x = np.arange(len(yaxis2))\n#fig = plt.figure(figsize=(28, 5))\n##bar1 = plt.bar( x, yaxis, width, color="r", label=\'colocating with libquatum (avg = %.2f)\' %(np.mean(yaxis_abs)))\n#bar1 = plt.bar( x, yaxis_abs3, width, color="k", yerr=error3, label=\'Shuttering (mean: %.2f)\' %(np.mean(yaxis_abs3)))\n#bar2 = plt.bar( x+width, yaxis_abs2, width, color="lightgrey", yerr=error2, label=\'Snapshot (mean: %.2f)\' %(np.mean(yaxis_abs2)))\n#\n#plt.ylabel( \'Estimation error (%)\',fontsize=\'25\' )\n##plt.title(\'Error in predicting degradation when co-locating with milc\')\n#plt.xticks(x + width/2.0, xaxis2, rotation=\'30\', size=\'23\',  ha=\'center\', va=\'top\')\n#plt.yticks(np.arange(0,50,10),size=\'25\')\n#plt.ylim(0,50)\n#plt.xlim(-1,27)\n#plt.grid()\n#plt.tight_layout()\n#plt.legend(loc=9, ncol=2, prop={\'size\':28})\n##plt.savefig(\'milc_accuracy.pdf\', dpi=125)\n\ndel dictList_single_vm\ndel dictList_degradation_colocation\ndel dictList_degradation_shutter\ndel dictList_degradation_shutter2\ndel dictList_degradation_shutter3\ndel dictList_degradation_shutter4\ndel plot_degradation\ndel plot_degradation2\ndel plot_degradation_error\ndel plot_degradation_error2\ndel plot_degradation_abs\ndel plot_degradation_abs2\n\n\ndictList_single_vm = defaultdict(list)\ndictList_degradation_colocation = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter2 = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter3 = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter4 = defaultdict(lambda  : defaultdict(list))\nplot_degradation = defaultdict(dict)\nplot_degradation2 = defaultdict(dict)\nplot_degradation_error = defaultdict(dict)\nplot_degradation_error2 = defaultdict(dict)\nplot_degradation_abs = defaultdict(dict)\nplot_degradation_abs2 = defaultdict(dict)\n\nfor (b,a) in enumerate(fList4):\n    if a in benchListBaseline:\n        dictList_single_vm[a].append(fList4[b+1])\n\n#SORTING LIST CONTAING VALUES OF SINGLE SPEC RUNS INSIDE VMs\nfor i in benchListBaseline:\n    dictList_single_vm[i].sort()\n    #print i,dictList_single_vm[i]\n\nfor (b,a) in enumerate(fList5):\n    #print a\n    if a in colocationListBaseline:\n       #print a\n       index = a\n    else:\n        if a in benchListExperiments:\n            #print a\n            dictList_degradation_colocation[index][a].append(fList5[b+1])\n\n#sorting the ground truth values\nfor a in xrange(0,len(runningList2),2):\n    j = runningList2[a+1]\n    i = runningList2[a]\n    dictList_degradation_colocation[j][i].sort()\n    #print j,i,dictList_degradation_colocation[j][i]\n\n\n\n#APPENDING DEGRADATION SHUTTER\nfor (b,a) in enumerate(fList6):\n    if a in colocationListExperiments:\n        index = a\n    else:\n        if a in benchListExperiments:\n            dictList_degradation_shutter[index][a].append(fList6[b+1])\n\nfor (b,a) in enumerate(fList3):\n    if a in colocationListExperiments:\n        index = a\n    else:\n        if a in benchListExperiments:\n            dictList_degradation_shutter3[index][a].append(fList3[b+1])\n\nfor a in xrange(0,len(runningList2),2):\n    j = runningList2[a+1]\n    i = runningList2[a]\n    #print i,j,dictList_degradation_shutter[j][i]\n#APPENDING DEGRADATION SHUTTER2 as shutter and colocation values are tab separated\nfor a in xrange(0,len(runningList2),2):\n    j = runningList2[a+1]\n    i = runningList2[a]\n    #print i,j\n    for elem in dictList_degradation_shutter[j][i]:\n        dictList_degradation_shutter2[j][i].extend(elem.strip().split(\'\\t\'))\n\n    for elem in dictList_degradation_shutter3[j][i]:\n        dictList_degradation_shutter4[j][i].extend(elem.strip().split(\'\\t\'))\n    #print dictList_degradation_shutter2[j][i]\n\nfor a in xrange(0,len(runningList2),2):\n    j = runningList2[a+1]\n    i = runningList2[a]\n    #print i,j\n    #print dictList_single_vm[i]\n    #print dictList_degradation_colocation[j][i]\n    #print dictList_degradation_shutter2[j][i]\n    denominator1 = sum(float(n) for (m,n) in enumerate(dictList_single_vm[i]))/(len(dictList_single_vm[i]))\n    numerator1 = sum(float(n) for (m,n) in enumerate(dictList_degradation_colocation[j][i]))/(len(dictList_degradation_colocation[j][i]))\n    shutter_temp_list = []\n    shutter_temp_list2 = []\n    colo_temp_list = []\n    colo_temp_list2 = []\n    degradation_temp_list = []\n    degradation_temp_list2 = []\n    error_temp_list = []\n    error_temp_list2 = []\n    #print numerator1\n    #print denominator1\n    for (count,item) in enumerate(dictList_degradation_shutter2[j][i]):\n        if count%2==0:\n            colo_temp_list.append(item)\n        if count%2==1:\n            shutter_temp_list.append(item)\n\n    for (count,item) in enumerate(dictList_degradation_shutter4[j][i]):\n        if count%2==0:\n            colo_temp_list2.append(item)\n        if count%2==1:\n            shutter_temp_list2.append(item)\n\n    for (count,item) in enumerate(shutter_temp_list):\n        degradation_temp_list.append(abs((((float(shutter_temp_list[count])/float(colo_temp_list[count]))-(numerator1/denominator1))/(float(shutter_temp_list[count])/float(colo_temp_list[count])))*100))\n\n    shutter_temp_list.sort()\n    shutter_temp_list2.sort()\n    colo_temp_list.sort()\n    colo_temp_list2.sort()\n    #print shutter_temp_list\n    #print colo_temp_list\n    #print dictList_degradation_shutter2[j][i]\n    denominator2 = sum(float(n) for (m,n) in enumerate(shutter_temp_list))/(len(shutter_temp_list))\n    numerator2 = sum(float(n) for (m,n) in enumerate(colo_temp_list))/(len(colo_temp_list))\n    for (m,n) in enumerate(shutter_temp_list):\n        ratio=float(n)/float(colo_temp_list[m])\n        error_temp_list.append(abs((((ratio)-(numerator1/denominator1))/(numerator1/denominator1))*100))\n    plot_degradation_error[j][i]=np.std(error_temp_list)\n\n    denominator3 = sum(float(n) for (m,n) in enumerate(shutter_temp_list2))/(len(shutter_temp_list2))\n    numerator3 = sum(float(n) for (m,n) in enumerate(colo_temp_list2))/(len(colo_temp_list2))\n    for (m,n) in enumerate(shutter_temp_list2):\n        ratio=float(n)/float(colo_temp_list2[m])\n        error_temp_list2.append(abs((((ratio)-(numerator3/denominator3))/(numerator1/denominator1))*100))\n    plot_degradation_error2[j][i]=np.std(error_temp_list2)\n\n    #print numerator2\n    #print denominator2\n    del shutter_temp_list\n    del colo_temp_list\n    del degradation_temp_list\n    del shutter_temp_list2\n    del colo_temp_list2\n    del degradation_temp_list2\n    plot_degradation[j][i] = (((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100\n    plot_degradation_abs[j][i] = abs((((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100)\n    plot_degradation2[j][i] = (((numerator3/denominator3)-(numerator1/denominator1))/(numerator1/denominator1))*100\n    plot_degradation_abs2[j][i] = abs((((numerator3/denominator3)-(numerator1/denominator1))/(numerator1/denominator1))*100)\n    #print j,i,plot_degradation[j][i]\n    #print plot_degradation_error[j][i]\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    xaxis2 = xaxis2 + (i,)\n    yaxis2 = yaxis2 + (plot_degradation[j][i],)\n    yaxis3 = yaxis3 + (plot_degradation2[j][i],)\n    yaxis_abs2 = yaxis_abs2 + (plot_degradation_abs[j][i],)\n    yaxis_abs3 = yaxis_abs3 + (plot_degradation_abs2[j][i],)\n    error2 = error2 + (plot_degradation_error[j][i],)\n    error3 = error3 + (plot_degradation_error2[j][i],)\n\n\nwidth=0.25\nx = np.arange(len(yaxis2))\nfig = plt.figure(figsize=(25, 5))\nax = fig.add_subplot(1,1,1)\n#bar1 = plt.bar( x, yaxis, width, color="r", label=\'colocating with libquatum (avg = %.2f)\' %(np.mean(yaxis_abs)))\nbar1 = plt.bar( x, yaxis_abs3, width, color="r", yerr=error3, label=\'Shuttering (avg = %.2f)\' %(np.mean(yaxis_abs3)))\nbar2 = plt.bar( x+width, yaxis_abs2, width, color="y", yerr=error2, label=\'Snapshot (avg = %.2f)\' %(np.mean(yaxis_abs2)))\nadd_line(ax, 0 * 1.0, -.1)\nadd_line(ax, 1 * 1.0, -.1)\nadd_line(ax, 1 * 0.175, -.1)\nadd_line(ax, 1 * 0.335, -.1)\n#bar3 = plt.bar( x+width+width, yaxis3, width, color="g", label=\'colocating with sphinx  (avg = %.2f)\' %(np.mean(yaxis_abs3)))\n#autolabel(bar1)\n#autolabel(bar2)\nplt.ylabel( \'Estimation error (%)\', fontsize=\'19\' )\n#plt.title(\'Error in predicting degradation when co-locating with libquantum\')\nplt.xticks(x + width/2.0, xaxis2, rotation=\'90\', size=\'18\',  ha=\'center\', va=\'top\')\nplt.yticks(np.arange(0,60,10),size=\'20\')\nplt.ylim(0,50)\nplt.xlim(-1,37)\nplt.grid()\nplt.tight_layout()\nplt.legend(loc=1, ncol=2, prop={\'size\':18})\n#plt.savefig(\'accuracylibquantum.pdf\', dpi=125)\nax.text(24, -23, r\'SPEC 2006\', fontsize=20)\nax.text(1, -23, r\'Sirius Suite\', fontsize=20)\nax.text(7, -23, r\'DjiNN & Tonic\', fontsize=20)\n'
p0
.I0
.S'$graph:overhead-comparison:Overheads :0.96'
p0
.S'from collections import defaultdict\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\nbenchList = [ \'gcc\', \'perlbench\', \'leslie3d\', \'povray\', \'libquantum\', \'astar\', \'bzip2\', \'milc\', \'namd\', \'calculix\', \'h264ref\', \'sphinx3\', \'zeusmp\', \'gobmk\', \'hmmer\', \'tonto\', \'bwaves\', \'gromacs\', \'dealII\', \'sjeng\', \'lbm\', \'xalancbmk\', \'gamess\', \'soplex\', \'GemsFDTD\', \'omnetpp\', \'mcf\', \'cactusADM\' ]\n\ncolocationList = [ \'colocating with libquantum\', \'colocating with mcf\',  \'colocating with sphinx3\']\ncolocationListBaseline = [ \'colocating with libquantum\', \'colocating with mcf\', \'colocating with sphinx3\' ]\n\n\nrunningList = [  \'perlbench\', \'colocating with libquantum\', \'mcf\', \'colocating with libquantum\', \'leslie3d\', \'colocating with libquantum\', \'povray\', \'colocating with libquantum\', \'libquantum\', \'colocating with libquantum\', \'astar\', \'colocating with libquantum\', \'milc\', \'colocating with libquantum\', \'namd\', \'colocating with libquantum\', \'calculix\', \'colocating with libquantum\', \'h264ref\', \'colocating with libquantum\', \'gobmk\', \'colocating with libquantum\', \'hmmer\', \'colocating with libquantum\', \'tonto\', \'colocating with libquantum\', \'sphinx3\', \'colocating with libquantum\', \'zeusmp\', \'colocating with libquantum\', \'bwaves\', \'colocating with libquantum\', \'gromacs\', \'colocating with libquantum\', \'dealII\', \'colocating with libquantum\', \'sjeng\', \'colocating with libquantum\', \'lbm\', \'colocating with libquantum\', \'xalancbmk\', \'colocating with libquantum\', \'gamess\', \'colocating with libquantum\', \'cactusADM\', \'colocating with libquantum\', \'soplex\', \'colocating with libquantum\', \'omnetpp\', \'colocating with libquantum\' ]\n\nsiriusbenchList = [ \'gmm\', \'dnn_asr\', \'surf-fe\', \'surf-fd\', \'stem\', \'regex\', \'crf\', \'img-imc\', \'img-dig\', \'img-face\', \'nlp-pos\', \'nlp-chk\', \'nlp-ner\']\nsiriuscolocationList = [ \'colocating with lbm\', \'colocating with povray\', \'colocating with astar\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with libquantum\' ]\nsiriusrunningList = [ \'gmm\', \'colocating with libquantum\', \'surf-fe\', \'colocating with libquantum\', \'surf-fd\', \'colocating with libquantum\', \'stem\', \'colocating with libquantum\', \'regex\', \'colocating with libquantum\', \'crf\', \'colocating with libquantum\', \'img-imc\', \'colocating with libquantum\', \'img-dig\', \'colocating with libquantum\', \'img-face\', \'colocating with libquantum\', \'nlp-pos\', \'colocating with libquantum\', \'nlp-chk\', \'colocating with libquantum\', \'nlp-ner\' , \'colocating with libquantum\']\n\ndef autolabel(rects):\n    # attach some text labels\n    for rect in rects:\n        height = rect.get_height()\n        plt.text(rect.get_x()+rect.get_width()/2., 1.05*height, \'%.2f\'%float(height), fontsize=8 )\n\ndef autolabel2(rects):\n    # attach some text labels\n    for rect in rects:\n        height = rect.get_height()\n        plt.text(rect.get_x()+rect.get_width()/2., -1.25*height, \'%.2f\'%float(height),\n                ha=\'center\', va=\'top\', fontsize=8)\n        #plt.text(rect.get_x()+rect.get_width()/2., 1.05*height, \'%.2f\'%float(height))\n\ndef add_line(ax, xpos, ypos):\n    line = plt.Line2D([xpos, xpos], [ypos + .1, ypos - .5], transform=ax.transAxes, linewidth=2, color=\'black\')\n    line.set_clip_on(False)\n    ax.add_line(line)\n\n\nfilename = \'execution_time_1000\'\nfList1 = [s.strip() for s in open(\'../../papergraphs/scalability/libquantumcorunner/spec/degradation/%s.txt\' % filename).readlines()]  #degradation\nfList2 = [s.strip() for s in open(\'../../papergraphs/scalability/libquantumcorunner/spec/snapshot/phase_change_10.txt\').readlines()]\nfList3 = [s.strip() for s in open(\'../../papergraphs/scalability/libquantumcorunner/spec/priorwork/execution_time_4.txt\').readlines()] #prior work\n\nfList4 = [s.strip() for s in open(\'../../papergraphs/scalability/libquantumcorunner/siriusdjinn/degradation/%s.txt\' % filename).readlines()]  #degradation\nfList5 = [s.strip() for s in open(\'../../papergraphs/scalability/libquantumcorunner/siriusdjinn/snapshot/phase_change_10.txt\').readlines()]\nfList6 = [s.strip() for s in open(\'../../papergraphs/scalability/libquantumcorunner/siriusdjinn/priorwork/execution_time_4.txt\').readlines()] #prior work\n\nyaxis = ()\nyaxis2= ()\nyaxis_abs = ()\nerror = ()\nxaxis = ()\nexecution_time_shutter = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter = defaultdict(lambda  : defaultdict(list))\navg_execution_time_shutter = defaultdict(dict)\nexecution_time_shutter2 = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter2 = defaultdict(lambda  : defaultdict(list))\navg_execution_time_shutter2 = defaultdict(dict)\ndictList_phase_change = defaultdict(lambda  : defaultdict(list))\ndictList_phase_change2 = defaultdict(lambda  : defaultdict(list))\n\nstd_execution_time = defaultdict(dict)\n\ndef print_elapsed_time_shutter(time_shutter):\n    for j in siriuscolocationList:\n        for i in siriusbenchList:\n            print \'%s ||||  %s\'%(j,i)\n            print time_shutter[j][i]\n\n\nsep = \'u\'\nfor (b,a) in enumerate(fList4):\n    #print a\n    if a in siriuscolocationList:\n        index = a\n    else:\n        if a in siriusbenchList:\n            execution_time_shutter[index][a].append((fList4[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_shutter[\'colocating with mcf\'][\'perlbench\']\n#print((s.split(start))[1].split(end)[0])\n\nfor j in siriuscolocationList:\n    for i in siriusbenchList:\n        #print i\n        for k in execution_time_shutter[j][i]:\n            try:\n                m,s = [float (var) for var in k.split(\':\')]\n                temp = m*60 + s\n            except:\n                h,m,s = [float (var) for var in k.split(\':\')]\n                temp = h*3600 + m*60 + s\n\n            execution_time_sec_shutter[j][i].append(temp)\n\n#print fList6\nfor (b,a) in enumerate(fList6):\n    print a\n    if a in siriuscolocationList:\n        index = a\n    else:\n        if a in siriusbenchList:\n            #print index\n            #print a\n            #print fList6[b+4]\n            execution_time_shutter2[index][a].append((fList6[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_shutter[\'colocating with mcf\'][\'perlbench\']\n#print((s.split(start))[1].split(end)[0])\n\nfor j in siriuscolocationList:\n    for i in siriusbenchList:\n        for k in execution_time_shutter2[j][i]:\n            #print k\n            m,s = [float (var) for var in k.split(\':\')]\n            temp = m*60 + s\n            execution_time_sec_shutter2[j][i].append(temp)\n\nfor (b,a) in enumerate(fList5):\n    if a in siriuscolocationList:\n        index = a\n    else:\n        if a in siriusbenchList:\n            dictList_phase_change[index][a].append(fList5[b+1])\n\nfor a in xrange(0,len(siriusrunningList),2):\n    j = siriusrunningList[a+1]\n    i = siriusrunningList[a]\n    #print j,i\n    for elem in dictList_phase_change[j][i]:\n        dictList_phase_change2[j][i].extend(elem.strip().split(\'\\t\'))\n    #print dictList_phase_change2[j][i]\n\n#print dictList_phase_change2[\'colocating with mcf\'][\'perlbench\']\nfor a in xrange(0,len(siriusrunningList),2):\n    j = siriusrunningList[a+1]\n    i = siriusrunningList[a]\n    print j,i\n    #print dictList_phase_change2[j][i]\n    #print i,j\n    shutter_temp_list = []\n    colo_temp_list = []\n    for (count,item) in enumerate(dictList_phase_change2[j][i]):\n        if count%2==1:\n            colo_temp_list.append(float(item))\n        if count%2==0:\n            shutter_temp_list.append(float(item))\n    #print shutter_temp_list\n    shutter_avg = sum(shutter_temp_list)/len(shutter_temp_list)\n    colocation_avg = sum(colo_temp_list)/len(colo_temp_list)\n    del shutter_temp_list\n    del colo_temp_list\n\n    pause_period = ((colocation_avg ) + ((shutter_avg + (colocation_avg * 2)/3) * 3))/4\n    xaxis = xaxis + (i,)\n    #print (pause_period/np.mean(execution_time_sec_shutter[j][i]))*10\n    yaxis = yaxis + ( (pause_period/np.mean(execution_time_sec_shutter[j][i]))*10  ,)\n    yaxis2 = yaxis2 + ( abs(((np.mean(execution_time_sec_shutter2[j][i])/np.mean(execution_time_sec_shutter[j][i])) - 1)*100), )\n    print execution_time_sec_shutter2[j][i]\n    print execution_time_sec_shutter[j][i]\n    #print np.mean(execution_time_sec_shutter2[j][i])\n    #print np.mean(execution_time_sec_shutter[j][i])\n    #print \'---------------------\'\n\n#print xaxis\n#print yaxis\n#print yaxis2\n#print np.mean(yaxis)\n\n\n\n\n#width = 0.25\n#x = np.arange(len(yaxis))\n#fig = plt.figure(figsize=(28, 5))\n#bar2 = plt.bar( x, yaxis2, width, color="k", label=\'Shuttering  (mean: %.2f)\' %(np.mean(yaxis2)))\n#bar1 = plt.bar( x+width, yaxis, width, color="lightgrey", label=\'Snapshot (mean: %.2f)\' %(np.mean(yaxis) ))\n\n#plt.ylabel( \'Execution time \\n overhead(%)\',fontsize=23)\n##plt.title(\'Overhead due to Prediction of degradation while co-running with MCF\')\n#plt.xticks(x + width/2.0, xaxis, rotation=\'30\', size=\'23\', ha=\'center\')\n##plt.yticks((-5,0,10,20,30,40,50,60),(\'\',\'0\',\'10\',\'20\',\'30\',\'40\',\'50\',\'60\'),size=\'25\')\n#plt.yticks((0,5,10,15),(\'0\',\'5\',\'10\',\'15\'),size=\'25\')\n#plt.xlim(-1,27)\n#plt.grid()\n#plt.legend(loc=9, ncol=2, prop={\'size\':28})\n#plt.tight_layout()\n##plt.savefig(\'phase_chagnge_overheadmaybe.png\', dpi=125)\n\ndel execution_time_shutter\ndel execution_time_sec_shutter\ndel avg_execution_time_shutter\ndel execution_time_shutter2\ndel execution_time_sec_shutter2\ndel avg_execution_time_shutter2\ndel dictList_phase_change\ndel dictList_phase_change2\n\n\nexecution_time_shutter = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter = defaultdict(lambda  : defaultdict(list))\navg_execution_time_shutter = defaultdict(dict)\nexecution_time_shutter2 = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter2 = defaultdict(lambda  : defaultdict(list))\navg_execution_time_shutter2 = defaultdict(dict)\ndictList_phase_change = defaultdict(lambda  : defaultdict(list))\ndictList_phase_change2 = defaultdict(lambda  : defaultdict(list))\n\nstd_execution_time = defaultdict(dict)\n\ndef print_elapsed_time_shutter(time_shutter):\n    for j in colocationList:\n        for i in benchList:\n            print \'%s ||||  %s\'%(j,i)\n            print time_shutter[j][i]\n\n\nsep = \'u\'\nfor (b,a) in enumerate(fList1):\n    #print a\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            execution_time_shutter[index][a].append((fList1[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_shutter[\'colocating with mcf\'][\'perlbench\']\n#print((s.split(start))[1].split(end)[0])\n\nfor j in colocationList:\n    for i in benchList:\n        #print i\n        for k in execution_time_shutter[j][i]:\n            try:\n                m,s = [float (var) for var in k.split(\':\')]\n                temp = m*60 + s\n            except:\n                h,m,s = [float (var) for var in k.split(\':\')]\n                temp = h*3600 + m*60 + s\n            execution_time_sec_shutter[j][i].append(temp)\n\nfor (b,a) in enumerate(fList3):\n    #print a\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            #print index\n            #print a\n            execution_time_shutter2[index][a].append((fList3[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_shutter[\'colocating with mcf\'][\'perlbench\']\n#print((s.split(start))[1].split(end)[0])\n\nfor j in colocationList:\n    for i in benchList:\n        for k in execution_time_shutter2[j][i]:\n            try:\n                m,s = [float (var) for var in k.split(\':\')]\n                temp = m*60 + s\n            except:\n                h,m,s = [float (var) for var in k.split(\':\')]\n                temp = h*3600 + m*60 + s\n            #print k\n            execution_time_sec_shutter2[j][i].append(temp)\n\nfor (b,a) in enumerate(fList2):\n    #print a\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            dictList_phase_change[index][a].append(fList2[b+1])\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    #print j,i\n    for elem in dictList_phase_change[j][i]:\n        dictList_phase_change2[j][i].extend(elem.strip().split(\'\\t\'))\n    #print dictList_phase_change2[j][i]\n\n#print dictList_phase_change2[\'colocating with mcf\'][\'perlbench\']\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    #print j,i\n    #print dictList_phase_change2[j][i]\n    #print i,j\n    shutter_temp_list = []\n    colo_temp_list = []\n    for (count,item) in enumerate(dictList_phase_change2[j][i]):\n        if count%2==1:\n            colo_temp_list.append(float(item))\n        if count%2==0:\n            shutter_temp_list.append(float(item))\n    #print shutter_temp_list\n    shutter_avg = sum(shutter_temp_list)/len(shutter_temp_list)\n    colocation_avg = sum(colo_temp_list)/len(colo_temp_list)\n    del shutter_temp_list\n    del colo_temp_list\n\n    pause_period = ((colocation_avg ) + ((shutter_avg + (colocation_avg * 2)/3) * 3))/4\n    xaxis = xaxis + (i,)\n    #print (pause_period/np.mean(execution_time_sec_shutter[j][i]))*10\n    yaxis = yaxis + ( (pause_period/np.mean(execution_time_sec_shutter[j][i]))*7.5  ,)\n    yaxis2 = yaxis2 + ( abs(((np.mean(execution_time_sec_shutter2[j][i])/np.mean(execution_time_sec_shutter[j][i])) - 1)*100), )\n    #print \'---------------------\'\n\n#print yaxis2\n#print np.mean(yaxis)\n\nwidth = 0.25\nx = np.arange(len(yaxis))\nfig = plt.figure(figsize=(25, 5))\nax = fig.add_subplot(1,1,1)\nbar2 = plt.bar( x, yaxis2, width, color="r", label=\'Shuttering  (avg = %.2f)\' %(np.mean(yaxis2)))\nbar1 = plt.bar( x+width, yaxis, width, color="y", label=\'Snapshot(avg = %.2f)\' %(np.mean(yaxis) ))\nly = len(yaxis2)\nadd_line(ax, 0 * 1, -.1)\nadd_line(ax, 1 * 1.0, -.1)\nadd_line(ax, 1 * 0.175, -.1)\nadd_line(ax, 1 * 0.335, -.1)\n#bar3 = plt.bar( x+width+width, yaxis3, width, color="g", label=\' colocating with sphinx3 (avg = %.1f)\' %(np.mean(yaxis3)))\n##bar3 = plt.bar( x+width+width, yaxis3, width, color="g", label=\'4 corunners (avg is %.1f)\' %(np.mean(yaxis3) ))\n##autolabel2(bar1)\n##autolabel(bar2)\n##autolabel2(bar3)\nplt.ylabel( \'Execution time \\n overhead(%)\', fontsize=\'19\' )\n#plt.title(\'Overhead due to Prediction of degradation while co-running with LIBQUANTUM\')\nplt.xticks(x + width/2.0, xaxis, rotation=\'90\', size=\'18\', ha=\'center\')\nplt.ylim(0,50)\nplt.xlim(-1,37)\nplt.yticks(np.arange(0,55,10),size=\'20\')\nplt.grid()\nplt.legend(loc=1, ncol=2, prop={\'size\':18})\nplt.tight_layout()\n#plt.savefig(\'overheadlibquantum.pdf\', dpi=125)\nax.text(24, -25, r\'SPEC 2006\', fontsize=20)\nax.text(1, -25, r\'Sirius Suite\', fontsize=20)\nax.text(7, -25, r\'DjiNN & Tonic\', fontsize=20)\n'
p0
.I0
.S'Analysis of phase level behavior'
p0
.S'$s: Analysis of Phase Level Behaviors'
p0
.I1
.S'Snapshot'
p0
.S'$p:\nIn the earlier section, we saw the effectiveness and efficiency of our snapshot technique. In this section, we look into how the technique can achieve high accuracy as well as low overhead by analyzing the phase level behavior for a selected set of applications. We select two applications, \\texttt{mcf} and \\texttt{milc} to analyze the execution behaviors. These applications possess a significant amount of phase changes among SPEC. As co-runners, we use \\texttt{libquantum} and \\texttt{mcf} respectively. Figure~\\ref{fig:mcfsnapshotlib} and~\\ref{fig:mcfsnapshotmcf} show the execution behavior of \\texttt{mcf} as with respect to time. In each graph, the yellow line depicts the phase of CPI when running without any co-runner and the red line shows how the snapshot technique identifies the phase of CPI when running with 3 instances of \\texttt{libquantum} and \\texttt{mcf}, respectively. We can see that our snapshot can effectively trace the phase changes even if we change co-runners. The closer the red line is to the yellow line, the lesser the error. The error in predicting performance degradation is 0.51\\% and 3.41\\%, respectively. For \\texttt{milc}, Figure~\\ref{fig:milcsnapshotlib} and ~\\ref{fig:milcsnapshotmcf} present that our technique can effectively trace all of its phase changes on both cases when running with \\texttt{libquantum} and \\texttt{mcf}. The error while predicting performance degradation is 1.23\\% and 2.52\\%, respectively. \n'
p0
.I0
.S'Scalability'
p0
.S'$s: Scalability\t Study'
p0
.I1
.S'4VMs vs. 16VMs'
p0
.S'$p:\nTo see the effectiveness of our technique in terms of scalability, we evaluate the accuracy and overhead by increasing the number of co-runners. Figure~\\ref{fig:accuracy-4-16VMs} and ~\\ref{fig:overhead-4-16VMs} show the trend of accuracy and overhead when increasing the number of VMs from 4 to 16. Left bar indicates four virtual machines running on Intel Xeon E5-2407 v2 (4-cores)and right bar means sixteen virtual machines running on Intel Xeon E5-2530 v3(16-cores). Like Figure~\\ref{fig:scaleup}, the accuracy and overhead are not significantly increased as we increase the number of co-locating VMs up to 16. The reason behind this is the fact that our snapshot technique spends enough time (75ms in our experiments) during each phase to accurately estimate solo execution performance. As we built a robust phase detection mechanism, our technique is not affected in terms of accuracy as the number of co-runners increase. On the other hand, we perform up to 6x better than the state of the art prior work with respect to overhead and provide a solution which is scalable up to the number of hardware contexts present in modern day servers.\n\n%To see the effectiveness of our technique in terms of scalability, we evaluate the accuracy and overhead by increasing the number of co-runners to 16VMs. Figure~\\ref{fig:scaleup-accuracy} and ~\\ref{fig:scaleup-overhead} show the accuracy and overhead for a set of applications, respectively. We use \\texttt{libquantum} as co-runners. '
p0
.I0
.S'Compared to prior work'
p0
.S'$s:Comparison of Prior Work and Snapshot'
p0
.I3
.S'Scalability graphs'
p0
.S''
p0
.I0
.S'description'
p0
.S'$p:\nIn this section, we compare our snapshot with the most recent prior technique called Precise Shuttering~\\cite{fairpricing}. Figure \\ref{fig:comparison} shows the accuracy and overhead of shuttering and \\textit{snapshot} techniques when running with fifteen instances of \\texttt{libquantum} co-runners. The x-axis shows the benchmarks and the y-axis present the error in estimating performance degradation. \nThrough these experiments, we can see that the estimation error is much lower for \\textit{snapshot} technique than shuttering. \nThe mean error of shuttering is 12.8\\%. On the other hand, our \\textit{snapshot} technique shows much lower error rates averaging around 3.95\\%.\nWith respect to overhead, the average is around 9.23\\% for the shuttering technique, but our technique shows only 1.73\\%. The reason why our technique shows high accuracy and low overhead is that our technique does not have to periodically measure the performance interference as compared to the shuttering technique. Instead, our snapshot is only triggered when a phase change occurs. \n\nTo compare scalability between shuttering and snapshot, we evaluate the accuracy and overhead for a set of applications by increasing the number of co-runners from 2 to 16VMs. Figure~\\ref{fig:scaleup-accuracy} and ~\\ref{fig:scaleup-overhead} show the accuracy and overhead for a set of applications, respectively. By consolidating more virtual machines on a single server, the number of phase changes increases dynamically. Nevertheless, our snapshot technique shows scalable performance in terms of overhead as well as accuracy compare to the shuttering technique. '
p0
.I0
.S'phase level'
p0
.S''
p0
.I0
.S'Conclusion'
p0
.S'$s: Conclusion '
p0
.I2
.S'conclusion'
p0
.S'$p:\nIn public clouds, the application performance of users can be easily affected by other applications belonging to different users. \nNevertheless, public cloud providers do not control the unintended performance degradation. It leads to a biased pricing scenario. \nThis work presented Fair Pricing Runtime, a novel approach to estimate performance degradation of each application in co-located environments and then we reflect the amount of unintended performance degradation on their price. \nFair Pricing Runtime has negligible performance overhead and operates without any special hardware or programmer supports. Using this mechanism, we could estimate performance degradation with 4\\% mean absolute error with a very low overhead of around 1\\%. \n'
p0
.I0
.S'Bare text'
p0
.S'To precisely measure the amount of performance degradation caused by co-running applications, the prior studies propose a technique called \\textit{shuttering} which pauses all the running VMs for a very short time except for one VM repeatedly at fixed time intervals ~\\cite{fairpricing, 6844481}. During the pausing time, a VM can monopolize computing resources on a system and they can easily extract the solo performance of applications.  Figure~\\ref{fig:precise_shuttering} shows how the prior technique works to estimate solo performance of an application running in a VM. \n\n\nAlthough this is a very simple and straightforward technique, it suffers from low accuracy in estimating the solo performance of applications. The top part of Figure~\\ref{fig:overheads_precise_shuttering} shows the error of estimating solo performance of applications. The baseline is CPI of each application without any co-runners. Each bar is normalized to the baseline when using the shuttering technique. \n%\\yellowcomment{Change with new values}\n\n\nThe error estimated by this technique is very high. The main reason is that the pausing time (3.2ms) used in prior work is not be enough to capture solo performance of an application. This is because the shared cache would not be warmed up to be containing the entire working set of the application which is to be measured. As a result, the measured application would spend most of its pausing time filling in the shared cache, giving much less time to observe how the application performs when it monopolizes computing resources. While increasing the pausing time can alleviate this problem, it is clear that this has a direct effect on the overhead of the runtime system. Moreover, as the number of co-runners increases, the shared cache becomes much more polluted due to the contention among the multiple co-runners. The effective time of precisely estimating solo performance of applications becomes much lower. \n\nA straightforward solution to this problem without sacrificing overhead could be by increase the pausing time while pausing less frequently.  Though doing this can improve the accuracy of prediction for some applications, it decreases the accuracy of many applications which have distinct phase changes. Figure~\\ref{fig:astarpovray}, ~\\ref{fig:bzip2povray}, ~\\ref{fig:mcfpovray} shows the estimated phase of the applications astar, bzip2 and mcf when it is colocating with povray. From the figures, we can clearly see that the prior technique misses complete phases for these applications due to pausing less frequently and this results in huge errors while estimating the performance degradation. A thorough study has been done by the prior work \\cite{fairpricing},\\cite{6844481} to tune the parameters that are present in shuttering and we use the best parameters as claimed by them in the rest of our experiments while comparing our work with them. \n\nIn addition, the bottom of Figure~\\ref{fig:overheads_precise_shuttering} shows the increased execution time for estimation of performance degradation as the number of co-runners increases. The source of the increased overhead is that the cache blocks belonging to the paused VMs would be eventually evicted at the end of the pausing time. As a result, when the paused VMs are resumed, they would pay an additional cost to warm up the cache. Moreover, as the number of co-running VMs increases, the overhead effects due to the prior is technique aggravated. \\\\\n\n\n%The overheads consist of two parts. Firstly, the direct cost occurs due to the pausing time. This increases the overall execution time of the VMs. Secondly, the indirect cost occurs due to the contention of architectural shared resources. When we resume the execution of the paused VMs, each VM would pay an additional cost to warm up the cache because the data belonging to the paused VMs would have been evicted during their pausing time.\n\n%In addition to this, as the number of co-runners increases, the number of pausing VMs is also increasing because precise shuttering needs to measure performance for each VM when running alone. As a result, it will cause performance overheads which increase the execution time of the applications. This overheads consist of two parts. Firstly, the direct cost occurs due to the pausing time. This increases the overall execution time of the VMs. Secondly, the indirect cost occurs due to the contention of architectural shared resources. When we resume the execution of the paused VMs, each VM would pay an additional cost to warm up the cache because the data belonging to the paused VMs would have been evicted during their pausing time. To figure out the overheads, we measured how the execution time of each application would increase as we increase the number of co-runners. \n\n%Moreover, since we take a snapshot only at phase changes, it enables us to snapshot for a longer time so as to accurately measure performance degradation of applications. If the measurement time is long enough to evict the cache blocks belonging to the co-running VMs and to bring the working set of the VM (which is to be measured) in the cache, we could achieve high accuracy. In addition, even if the number of co-runners increases, our \\textit{snapshot} technique is less susceptible to overhead issues as phase changes rarely occur.'
p0
.I0
.S'Bibliography'
p0
.S''
p0
.I48
.S'Q-clouds'
p0
.S"$bib:\n@inproceedings{Nathuji:2010:QMP:1755913.1755938,\n author = {Nathuji, Ripal and Kansal, Aman and Ghaffarkhah, Alireza},\n title = {Q-clouds: Managing Performance Interference Effects for QoS-aware Clouds},\n booktitle = {Proceedings of the 5th European Conference on Computer Systems},\n series = {EuroSys '10},\n year = {2010},\n isbn = {978-1-60558-577-2},\n location = {Paris, France},\n pages = {237--250},\n numpages = {14},\n url = {http://doi.acm.org/10.1145/1755913.1755938},\n doi = {10.1145/1755913.1755938},\n acmid = {1755938},\n publisher = {ACM},\n address = {New York, NY, USA},\n keywords = {cloud computing, resource management, virtualization},\n} "
p0
.I0
.S'Cuanta'
p0
.S"$bib:\n@inproceedings{Govindan:2011:CQE:2038916.2038938,\n author = {Govindan, Sriram and Liu, Jie and Kansal, Aman and Sivasubramaniam, Anand},\n title = {Cuanta: Quantifying Effects of Shared On-chip Resource Interference for Consolidated Virtual Machines},\n booktitle = {Proceedings of the 2Nd ACM Symposium on Cloud Computing},\n series = {SOCC '11},\n year = {2011},\n isbn = {978-1-4503-0976-9},\n location = {Cascais, Portugal},\n pages = {22:1--22:14},\n articleno = {22},\n numpages = {14},\n url = {http://doi.acm.org/10.1145/2038916.2038938},\n doi = {10.1145/2038916.2038938},\n acmid = {2038938},\n publisher = {ACM},\n address = {New York, NY, USA},\n keywords = {cache pressure clone, last-level cache, memory subsystem interference, performance estimation, resource contention, workload consolidation},\n} "
p0
.I0
.S'Bubble-up'
p0
.S'$bib:\n@inproceedings{bubbleup,\nauthor = {Mars, Jason and Tang, Lingjia and Hundt, Robert and Skadron, Kevin and Soffa, Mary Lou},\ntitle = {Bubble-Up: Increasing Utilization in Modern Warehouse Scale Computers via Sensible Co-locations},\nbooktitle = {Proceedings of the 44th Annual IEEE/ACM International Symposium on Microarchitecture (MICRO)},\nseries = {MICRO-44},\nyear = {2011},\nisbn = {978-1-4503-1053-6},\nlocation = {Porto Alegre, Brazil},\npages = {248--259},\nnumpages = {12},\nurl = {http://doi.acm.org/10.1145/2155620.2155650},\ndoi = {10.1145/2155620.2155650},\nacmid = {2155650},\npublisher = {ACM},\naddress = {New York, NY, USA},\nnote = {Acceptance Rate: 21% - Selected for IEEE MICRO TOP PICKS},\n}\n'
p0
.I0
.S'STM'
p0
.S'$bib:\n@inproceedings{stfm,\n author = {Mutlu, Onur and Moscibroda, Thomas},\n title = {Stall-Time Fair Memory Access Scheduling for Chip Multiprocessors},\n booktitle = {Proceedings of the 40th Annual IEEE/ACM International Symposium on Microarchitecture},\n series = {MICRO 40},\n year = {2007},\n isbn = {0-7695-3047-8},\n pages = {146--160},\n numpages = {15},\n url = {http://dx.doi.org/10.1109/MICRO.2007.40},\n doi = {10.1109/MICRO.2007.40},\n acmid = {1331715},\n publisher = {IEEE Computer Society},\n address = {Washington, DC, USA},\n} \n\n@INPROCEEDINGS{6522356, \nauthor={Subramanian, L. and Seshadri, V. and Yoongu Kim and Jaiyen, B. and Mutlu, O.}, \nbooktitle={High Performance Computer Architecture (HPCA2013), 2013 IEEE 19th International Symposium on}, \ntitle={MISE: Providing performance predictability and improving fairness in shared main memory systems}, \nyear={2013}, \nmonth={Feb}, \npages={639-650}, \nkeywords={performance evaluation;scheduling;shared memory systems;MISE model;application request;fairness improvement;inter-application interference;memory request;memory scheduling scheme;memory-bound application;memory-interference-induced slowdown estimation model;multicore system;performance degradation mitigation;performance predictability;quality-of-service;request-service-rate;shared main memory system;Abstracts;Organizations;Quality of service}, \ndoi={10.1109/HPCA.2013.6522356}, \nISSN={1530-0897},}'
p0
.I0
.S'FST'
p0
.S'$bib:\n@inproceedings{fst,\n author = {Ebrahimi, Eiman and Lee, Chang Joo and Mutlu, Onur and Patt, Yale N.},\n title = {Fairness via Source Throttling: A Configurable and High-performance Fairness Substrate for Multi-core Memory Systems},\n booktitle = {Proceedings of the Fifteenth Edition of ASPLOS on Architectural Support for Programming Languages and Operating Systems},\n series = {ASPLOS XV},\n year = {2010},\n isbn = {978-1-60558-839-1},\n location = {Pittsburgh, Pennsylvania, USA},\n pages = {335--346},\n numpages = {12},\n url = {http://doi.acm.org/10.1145/1736020.1736058},\n doi = {10.1145/1736020.1736058},\n acmid = {1736058},\n publisher = {ACM},\n address = {New York, NY, USA},\n keywords = {fairness, multi-core systems, shared memory systems, system performance},\n} '
p0
.I0
.S'QualityTime'
p0
.S'$bib:\n@INPROCEEDINGS{6844481, \nauthor={Gupta, A. and Sampson, J. and Taylor, M.B.}, \nbooktitle={Performance Analysis of Systems and Software (ISPASS), 2014 IEEE International Symposium on}, \ntitle={Quality Time: A simple online technique for quantifying multicore execution efficiency}, \nyear={2014}, \nmonth={March}, \npages={169-179}, \nkeywords={multiprocessing systems;performance evaluation;quality of service;shared memory systems;CPU time;QoS;Qplacer;Qtime;Qtop;memory interference;memory resources;multicore execution efficiency;multicore processors;online technique;quality time;user-space tools;Hardware;Instruction sets;Interference;Libraries;Multicore processing;Radiation detectors;Time measurement}, \ndoi={10.1109/ISPASS.2014.6844481},}'
p0
.I0
.S'Zhuravlev:2010:ASR'
p0
.S'$bib:\n@inproceedings{Zhuravlev:2010:ASR:1736020.1736036,\n author = {Zhuravlev, Sergey and Blagodurov, Sergey and Fedorova, Alexandra},\n title = {Addressing Shared Resource Contention in Multicore Processors via Scheduling},\n booktitle = {Proceedings of the Fifteenth Edition of ASPLOS on Architectural Support for Programming Languages and Operating Systems},\n series = {ASPLOS XV},\n year = {2010},\n isbn = {978-1-60558-839-1},\n location = {Pittsburgh, Pennsylvania, USA},\n pages = {129--142},\n numpages = {14},\n url = {http://doi.acm.org/10.1145/1736020.1736036},\n doi = {10.1145/1736020.1736036},\n acmid = {1736036},\n publisher = {ACM},\n address = {New York, NY, USA},\n keywords = {multicore processors, scheduling, shared resource contention},\n} '
p0
.I0
.S'fairpricing'
p0
.S'$bib:\n@article{fairpricing,\nauthor = {Alex D. Breslow and\nAnanta Tiwari and\nMartin Schulz and\nLaura Carrington and\nLingjia Tang and\nJason Mars},\ntitle = {Enabling fair pricing on high performance computer systems with node sharing},\njournal = {Scientific Programming},\nyear = {2014},\nvolume = {22},\nnumber = {2},\npages = {59--74},\nurl = {http://dx.doi.org/10.3233/SPR-140387},\ndoi = {10.3233/SPR-140387},\ntimestamp = {Fri, 05 Sep 2014 13:19:44 +0200},\nbiburl = {http://dblp.uni-trier.de/rec/bib/journals/sp/BreslowTSCTM14},\nbibsource = {dblp computer science bibliography, http://dblp.org}\n}'
p0
.I0
.S'Pollute Buffer'
p0
.S'$bib:\n@inproceedings{Soares:2008:RHE:1521747.1521800,\n author = {Soares, Livio and Tam, David and Stumm, Michael},\n title = {Reducing the Harmful Effects of Last-level Cache Polluters with an OS-level, Software-only Pollute Buffer},\n booktitle = {Proceedings of the 41st Annual IEEE/ACM International Symposium on Microarchitecture},\n series = {MICRO 41},\n year = {2008},\n isbn = {978-1-4244-2836-6},\n pages = {258--269},\n numpages = {12},\n url = {http://dx.doi.org/10.1109/MICRO.2008.4771796},\n doi = {10.1109/MICRO.2008.4771796},\n acmid = {1521800},\n publisher = {IEEE Computer Society},\n address = {Washington, DC, USA},\n} \n'
p0
.I0
.S'NUMA-aware contention'
p0
.S"$bib:\n@inproceedings{Blagodurov:2011:CNC:2002181.2002182,\n author = {Blagodurov, Sergey and Zhuravlev, Sergey and Dashti, Mohammad and Fedorova, Alexandra},\n title = {A Case for NUMA-aware Contention Management on Multicore Systems},\n booktitle = {Proceedings of the 2011 USENIX Conference on USENIX Annual Technical Conference},\n series = {USENIXATC'11},\n year = {2011},\n location = {Portland, OR},\n pages = {1--1},\n numpages = {1},\n url = {http://dl.acm.org/citation.cfm?id=2002181.2002182},\n acmid = {2002182},\n publisher = {USENIX Association},\n address = {Berkeley, CA, USA},\n} \n"
p0
.I0
.S'cache-partitioning'
p0
.S"$bib:\n@inproceedings{Suh:2002:NMM:874076.876484,\n author = {Suh, G. Edward and Devadas, Srinivas and Rudolph, Larry},\n title = {A New Memory Monitoring Scheme for Memory-Aware Scheduling and Partitioning},\n booktitle = {Proceedings of the 8th International Symposium on High-Performance Computer Architecture},\n series = {HPCA '02},\n year = {2002},\n pages = {117--},\n url = {http://dl.acm.org/citation.cfm?id=874076.876484},\n acmid = {876484},\n publisher = {IEEE Computer Society},\n address = {Washington, DC, USA},\n} \n"
p0
.I0
.S'overhead google'
p0
.S'$bib:\n@article{overheadgoogle,\n  title={Google-wide profiling: A continuous profiling infrastructure for data centers},\n  author={Ren, Gang and Tune, Eric and Moseley, Tipp and Shi, Yixin and Rus, Silvius and Hundt, Robert},\n  journal={IEEE micro},\n  number={4},\n  pages={65--79},\n  year={2010},\n  publisher={IEEE}\n}'
p0
.I0
.S'utility-partitioning'
p0
.S'$bib:\n@inproceedings{Qureshi:2006:UCP:1194816.1194855,\n author = {Qureshi, Moinuddin K. and Patt, Yale N.},\n title = {Utility-Based Cache Partitioning: A Low-Overhead, High-Performance, Runtime Mechanism to Partition Shared Caches},\n booktitle = {Proceedings of the 39th Annual IEEE/ACM International Symposium on Microarchitecture},\n series = {MICRO 39},\n year = {2006},\n isbn = {0-7695-2732-9},\n pages = {423--432},\n numpages = {10},\n url = {http://dx.doi.org/10.1109/MICRO.2006.49},\n doi = {10.1109/MICRO.2006.49},\n acmid = {1194855},\n publisher = {IEEE Computer Society},\n address = {Washington, DC, USA},\n} '
p0
.I0
.S'Rafique et al'
p0
.S"$bib:\n@inproceedings{Rafique:2006:ASO:1152154.1152160,\n author = {Rafique, Nauman and Lim, Won-Taek and Thottethodi, Mithuna},\n title = {Architectural Support for Operating System-driven CMP Cache Management},\n booktitle = {Proceedings of the 15th International Conference on Parallel Architectures and Compilation Techniques},\n series = {PACT '06},\n year = {2006},\n isbn = {1-59593-264-X},\n location = {Seattle, Washington, USA},\n pages = {2--12},\n numpages = {11},\n url = {http://doi.acm.org/10.1145/1152154.1152160},\n doi = {10.1145/1152154.1152160},\n acmid = {1152160},\n publisher = {ACM},\n address = {New York, NY, USA},\n keywords = {CMP, OS, QoS, SLAs, cache, fairness, interface, quotas},\n} \n\n@inproceedings{Rafique:2007:EMD:1299042.1299052,\n author = {Rafique, Nauman and Lim, Won-Taek and Thottethodi, Mithuna},\n title = {Effective Management of DRAM Bandwidth in Multicore Processors},\n booktitle = {Proceedings of the 16th International Conference on Parallel Architecture and Compilation Techniques},\n series = {PACT '07},\n year = {2007},\n isbn = {0-7695-2944-5},\n pages = {245--258},\n numpages = {14},\n url = {http://dx.doi.org/10.1109/PACT.2007.29},\n doi = {10.1109/PACT.2007.29},\n acmid = {1299052},\n publisher = {IEEE Computer Society},\n address = {Washington, DC, USA},\n} \n"
p0
.I0
.S'Srikantaiah et al'
p0
.S"$bib:\n@inproceedings{Srikantaiah:2008:ASP:1346281.1346299,\n author = {Srikantaiah, Shekhar and Kandemir, Mahmut and Irwin, Mary Jane},\n title = {Adaptive Set Pinning: Managing Shared Caches in Chip Multiprocessors},\n booktitle = {Proceedings of the 13th International Conference on Architectural Support for Programming Languages and Operating Systems},\n series = {ASPLOS XIII},\n year = {2008},\n isbn = {978-1-59593-958-6},\n location = {Seattle, WA, USA},\n pages = {135--144},\n numpages = {10},\n url = {http://doi.acm.org/10.1145/1346281.1346299},\n doi = {10.1145/1346281.1346299},\n acmid = {1346299},\n publisher = {ACM},\n address = {New York, NY, USA},\n keywords = {CMP, inter-processor, intra-processor, set pinning, shared cache},\n} \n\n@inproceedings{Srikantaiah:2009:CIP:1654059.1654066,\n author = {Srikantaiah, Shekhar and Das, Reetuparna and Mishra, Asit K. and Das, Chita R. and Kandemir, Mahmut},\n title = {A Case for Integrated Processor-cache Partitioning in Chip Multiprocessors},\n booktitle = {Proceedings of the Conference on High Performance Computing Networking, Storage and Analysis},\n series = {SC '09},\n year = {2009},\n isbn = {978-1-60558-744-8},\n location = {Portland, Oregon},\n pages = {6:1--6:12},\n articleno = {6},\n numpages = {12},\n url = {http://doi.acm.org/10.1145/1654059.1654066},\n doi = {10.1145/1654059.1654066},\n acmid = {1654066},\n publisher = {ACM},\n address = {New York, NY, USA},\n} "
p0
.I0
.S'VM-contention'
p0
.S"$bib:\n@inproceedings{Ahn:2012:DVM:2342763.2342782,\n author = {Ahn, Jeongseob and Kim, Changdae and Han, Jaeung and Choi, Young-Ri and Huh, Jaehyuk},\n title = {Dynamic Virtual Machine Scheduling in Clouds for Architectural Shared Resources},\n booktitle = {Proceedings of the 4th USENIX Conference on Hot Topics in Cloud Ccomputing},\n series = {HotCloud'12},\n year = {2012},\n location = {Boston, MA},\n pages = {19--19},\n numpages = {1},\n url = {http://dl.acm.org/citation.cfm?id=2342763.2342782},\n acmid = {2342782},\n publisher = {USENIX Association},\n address = {Berkeley, CA, USA},\n} "
p0
.I0
.S'Bubble flux'
p0
.S"$bib:\n@inproceedings{bubbleflux,\n author = {Yang, Hailong and Breslow, Alex and Mars, Jason and Tang, Lingjia},\n title = {Bubble-flux: Precise Online QoS Management for Increased Utilization in Warehouse Scale Computers},\n booktitle = {Proceedings of the 40th Annual International Symposium on Computer Architecture},\n series = {ISCA '13},\n year = {2013},\n isbn = {978-1-4503-2079-5},\n location = {Tel-Aviv, Israel},\n pages = {607--618},\n numpages = {12},\n url = {http://doi.acm.org/10.1145/2485922.2485974},\n doi = {10.1145/2485922.2485974},\n acmid = {2485974},\n publisher = {ACM},\n address = {New York, NY, USA},\n} \n"
p0
.I0
.S'paragon'
p0
.S"$bib:\n@inproceedings{Delimitrou:2013:PQS:2451116.2451125,\n author = {Delimitrou, Christina and Kozyrakis, Christos},\n title = {Paragon: QoS-aware Scheduling for Heterogeneous Datacenters},\n booktitle = {Proceedings of the Eighteenth International Conference on Architectural Support for Programming Languages and Operating Systems},\n series = {ASPLOS '13},\n year = {2013},\n isbn = {978-1-4503-1870-9},\n location = {Houston, Texas, USA},\n pages = {77--88},\n numpages = {12},\n url = {http://doi.acm.org/10.1145/2451116.2451125},\n doi = {10.1145/2451116.2451125},\n acmid = {2451125},\n publisher = {ACM},\n address = {New York, NY, USA},\n keywords = {cloud computing, datacenter, heterogeneity, interference, qos, scheduling},\n} \n"
p0
.I0
.S'FairQueuing'
p0
.S'$bib:\n@inproceedings{Nesbit:2006:FQM,\n author = {Nesbit, Kyle J. and Aggarwal, Nidhi and Laudon, James and Smith, James E.},\n title = {Fair Queuing Memory Systems},\n booktitle = {Proceedings of the 39th Annual IEEE/ACM International Symposium on Microarchitecture},\n series = {MICRO 39},\n year = {2006},\n isbn = {0-7695-2732-9},\n pages = {208--222},\n numpages = {15},\n url = {http://dx.doi.org/10.1109/MICRO.2006.24},\n doi = {10.1109/MICRO.2006.24},\n acmid = {1194839},\n publisher = {IEEE Computer Society},\n address = {Washington, DC, USA},\n} \n'
p0
.I0
.S'DeepDive'
p0
.S"$bib:\n@inproceedings{Novakovic:2013:DTI:2535461.2535489,\n author = {Novakovi\\'{c}, Dejan and Vasi\\'{c}, Nedeljko and Novakovi\\'{c}, Stanko and Kosti\\'{c}, Dejan and Bianchini, Ricardo},\n title = {DeepDive: Transparently Identifying and Managing Performance Interference in Virtualized Environments},\n booktitle = {Proceedings of the 2013 USENIX Conference on Annual Technical Conference},\n series = {USENIX ATC'13},\n year = {2013},\n location = {San Jose, CA},\n pages = {219--230},\n numpages = {12},\n url = {http://dl.acm.org/citation.cfm?id=2535461.2535489},\n acmid = {2535489},\n publisher = {USENIX Association},\n address = {Berkeley, CA, USA},\n} "
p0
.I0
.S'Amazon'
p0
.S'$bib:\n@misc{amazon,\nannote = {$\\backslash$url\\{http://aws.amazon.com/ec2/purchasing-options/}},\nauthor = {{Amazon Inc.}},\npublisher = {Amazon},\ntitle = {{Amazon Elastic Compute Cloud(EC2)}}\n}'
p0
.I0
.S'PARD'
p0
.S"$bib:\n@inproceedings{Ma:2015:SDS:2694344.2694382,\n author = {Ma, Jiuyue and Sui, Xiufeng and Sun, Ninghui and Li, Yupeng and Yu, Zihao and Huang, Bowen and Xu, Tianni and Yao, Zhicheng and Chen, Yun and Wang, Haibin and Zhang, Lixin and Bao, Yungang},\n title = {Supporting Differentiated Services in Computers via Programmable Architecture for Resourcing-on-Demand (PARD)},\n booktitle = {Proceedings of the Twentieth International Conference on Architectural Support for Programming Languages and Operating Systems},\n series = {ASPLOS '15},\n year = {2015},\n isbn = {978-1-4503-2835-7},\n location = {Istanbul, Turkey},\n pages = {131--143},\n numpages = {13},\n url = {http://doi.acm.org/10.1145/2694344.2694382},\n doi = {10.1145/2694344.2694382},\n acmid = {2694382},\n publisher = {ACM},\n address = {New York, NY, USA},\n keywords = {QoS, data center, hardware/software interface},\n} \n"
p0
.I0
.S'RFA'
p0
.S"$bib:\n@inproceedings{Varadarajan:2012:RAI:2382196.2382228,\n author = {Varadarajan, Venkatanathan and Kooburat, Thawan and Farley, Benjamin and Ristenpart, Thomas and Swift, Michael M.},\n title = {Resource-freeing Attacks: Improve Your Cloud Performance (at Your Neighbor's Expense)},\n booktitle = {Proceedings of the 2012 ACM Conference on Computer and Communications Security},\n series = {CCS '12},\n year = {2012},\n isbn = {978-1-4503-1651-4},\n location = {Raleigh, North Carolina, USA},\n pages = {281--292},\n numpages = {12},\n url = {http://doi.acm.org/10.1145/2382196.2382228},\n doi = {10.1145/2382196.2382228},\n acmid = {2382228},\n publisher = {ACM},\n address = {New York, NY, USA},\n keywords = {cloud computing, resource-freeing attacks, scheduling, security, virtualization},\n} \n"
p0
.I0
.S'cache-vm'
p0
.S"$bib:\n@inproceedings{Ahn:2014:MVP:2742155.2742195,\n author = {Ahn, Jeongseob and Park, Chang Hyun and Huh, Jaehyuk},\n title = {Micro-Sliced Virtual Processors to Hide the Effect of Discontinuous CPU Availability for Consolidated Systems},\n booktitle = {Proceedings of the 47th Annual IEEE/ACM International Symposium on Microarchitecture},\n series = {MICRO-47},\n year = {2014},\n isbn = {978-1-4799-6998-2},\n location = {Cambridge, United Kingdom},\n pages = {394--405},\n numpages = {12},\n url = {http://dx.doi.org/10.1109/MICRO.2014.49},\n doi = {10.1109/MICRO.2014.49},\n acmid = {2742195},\n publisher = {IEEE Computer Society},\n address = {Washington, DC, USA},\n keywords = {context prefetch, context preservation, virtual time discontinuity, virtualization},\n} \n\n@INPROCEEDINGS{Daly, \n    author={Daly, D. and Cain, H.W.}, \n    booktitle={Proceedings of the 18th International Symposium on High Performance Computer Architecture (HPCA) }, \n    title={Cache restoration for highly partitioned virtualized systems}, \n    year={2012}, \n    keywords={cache storage;memory architecture;multiprogramming;scheduling;virtual machines;virtualisation;POWER7 system;cache restoration;cycle-accurate simulation;hardware-based prefetching mechanism;highly partitioned virtualized systems;microarchitectural state;multiple virtual machines;multiprogrammed virtualization;per-core L3 last-level cache;performance improvement;server consolidation;server-class systems;virtualization features;virtualization software;Bandwidth;Hardware;Operating systems;Prefetching;Registers;Servers;Switches}, \n    doi={10.1109/HPCA.2012.6169029}, \n    ISSN={1530-0897},\n}\n\n\n@INPROCEEDINGS{ReCap, \n    author={Zebchuk, J. and Cain, H.W. and Xin Tong and Srinivasan, V. and Moshovos, A.}, \n    booktitle={Proceedings of the 19th International Symposium on High Performance Computer Architecture (HPCA) }, \n    title={{RECAP}: A region-based cure for the common cold (cache)}, \n    year={2013}, \n    keywords={cache storage;data compression;multiprogramming;power aware computing;processor scheduling;supervisory programs;virtual machines;virtualisation;L2 cache;RECAP;bandwidth overhead reduction;block reuse-based filtering;cache blocks;coarse-grain memory regions;cold cache effect reduction;compression technique;energy-delay product reduction;fine-grain sharing;hypervisor;management overhead reduction;metadata reading;metadata writing;multiprogrammed virtualization;performance improvement;processor scheduling;region-based cache restoration prefetcher;single processor core time-share;spatial locality;virtual machines}, \n    doi={10.1109/HPCA.2013.6522309}, \n    ISSN={1530-0897},\n}\n\n@inproceedings{Liu:2014:OVM:2665671.2665720,\n author = {Liu, Ming and Li, Tao},\n title = {Optimizing Virtual Machine Consolidation Performance on NUMA Server Architecture for Cloud Workloads},\n booktitle = {Proceeding of the 41st Annual International Symposium on Computer Architecuture},\n series = {ISCA '14},\n year = {2014},\n isbn = {978-1-4799-4394-4},\n location = {Minneapolis, Minnesota, USA},\n pages = {325--336},\n numpages = {12},\n url = {http://dl.acm.org/citation.cfm?id=2665671.2665720},\n acmid = {2665720},\n publisher = {IEEE Press},\n address = {Piscataway, NJ, USA},\n} \n\n@INPROCEEDINGS{6522328,\nauthor={Jia Rao and Kun Wang and Xiaobo Zhou and Cheng-zhong Xu},\nbooktitle={High Performance Computer Architecture (HPCA2013), 2013 IEEE 19th International Symposium on},\ntitle={Optimizing virtual machine scheduling in NUMA multicore systems},\nyear={2013},\nmonth={Feb},\npages={306-317},\nkeywords={memory architecture;multiprocessing systems;performance evaluation;processor scheduling;virtual machines;BRM algorithm;Xen credit scheduler;Xen virtual machine monitor;bias random vCPU migration algorithm;complex interplay;cross-node data sharing overhead;data locality;machine hardware;memory subsystem;nonuniform memory access architecture;optimal program performance;predictable program performance;scalable memory performance;shared on-chip memory resources;system-level optimizations;system-wide uncore penalty;two-way Intel NUMA multicore system;virtual hardware;virtual machine scheduling optimization;Benchmark testing;Hardware;Instruction sets;Multicore processing;Sockets;Topology},\ndoi={10.1109/HPCA.2013.6522328},\nISSN={1530-0897},}\n"
p0
.I0
.S'Dejavu'
p0
.S"$bib:\n@article{Vasic:2012:DAR:2248487.2151021,\n author = {Vasi\\'{c}, Nedeljko and Novakovi\\'{c}, Dejan and Miu\\v{c}in, Svetozar and Kosti\\'{c}, Dejan and Bianchini, Ricardo},\n title = {DejaVu: Accelerating Resource Allocation in Virtualized Environments},\n journal = {SIGPLAN Not.},\n issue_date = {April 2012},\n volume = {47},\n number = {4},\n month = mar,\n year = {2012},\n issn = {0362-1340},\n pages = {423--436},\n numpages = {14},\n url = {http://doi.acm.org/10.1145/2248487.2151021},\n doi = {10.1145/2248487.2151021},\n acmid = {2151021},\n publisher = {ACM},\n address = {New York, NY, USA},\n keywords = {data center, resource management, virtualization},\n} \n"
p0
.I0
.S'ReQoS'
p0
.S"$bib:\n@inproceedings{Tang:2013:RRS:2451116.2451126,\n author = {Tang, Lingjia and Mars, Jason and Wang, Wei and Dey, Tanima and Soffa, Mary Lou},\n title = {ReQoS: Reactive Static/Dynamic Compilation for QoS in Warehouse Scale Computers},\n booktitle = {Proceedings of the Eighteenth International Conference on Architectural Support for Programming Languages and Operating Systems},\n series = {ASPLOS '13},\n year = {2013},\n isbn = {978-1-4503-1870-9},\n location = {Houston, Texas, USA},\n pages = {89--100},\n numpages = {12},\n url = {http://doi.acm.org/10.1145/2451116.2451126},\n doi = {10.1145/2451116.2451126},\n acmid = {2451126},\n publisher = {ACM},\n address = {New York, NY, USA},\n keywords = {compiler, contention, cross-core interference, datacenter, dynamic techniques, multicore, online adaptation, quality of service, runtime systems, warehouse scale computers},\n} \n\n"
p0
.I0
.S'Whare-map'
p0
.S'$bib:\n@inproceedings{Mars:2013:WHH:2485922.2485975,\n author = {Mars, Jason and Tang, Lingjia},\n title = {Whare-map: Heterogeneity in "Homogeneous" Warehouse-scale Computers},\n booktitle = {Proceedings of the 40th Annual International Symposium on Computer Architecture},\n series = {ISCA \'13},\n year = {2013},\n isbn = {978-1-4503-2079-5},\n location = {Tel-Aviv, Israel},\n pages = {619--630},\n numpages = {12},\n url = {http://doi.acm.org/10.1145/2485922.2485975},\n doi = {10.1145/2485922.2485975},\n acmid = {2485975},\n publisher = {ACM},\n address = {New York, NY, USA},\n} '
p0
.I0
.S'Bubble-Flux'
p0
.S"$bib:\n@inproceedings{Yang:2013:BPO:2485922.2485974,\n author = {Yang, Hailong and Breslow, Alex and Mars, Jason and Tang, Lingjia},\n title = {Bubble-flux: Precise Online QoS Management for Increased Utilization in Warehouse Scale Computers},\n booktitle = {Proceedings of the 40th Annual International Symposium on Computer Architecture},\n series = {ISCA '13},\n year = {2013},\n isbn = {978-1-4503-2079-5},\n location = {Tel-Aviv, Israel},\n pages = {607--618},\n numpages = {12},\n url = {http://doi.acm.org/10.1145/2485922.2485974},\n doi = {10.1145/2485922.2485974},\n acmid = {2485974},\n publisher = {ACM},\n address = {New York, NY, USA},\n} "
p0
.I0
.S'RCH'
p0
.S"$bib:\n@inproceedings{Park:2013:RCH:2451116.2451137,\n author = {Park, Heekwon and Baek, Seungjae and Choi, Jongmoo and Lee, Donghee and Noh, Sam H.},\n title = {Regularities Considered Harmful: Forcing Randomness to Memory Accesses to Reduce Row Buffer Conflicts for Multi-core, Multi-bank Systems},\n booktitle = {Proceedings of the Eighteenth International Conference on Architectural Support for Programming Languages and Operating Systems},\n series = {ASPLOS '13},\n year = {2013},\n isbn = {978-1-4503-1870-9},\n location = {Houston, Texas, USA},\n pages = {181--192},\n numpages = {12},\n url = {http://doi.acm.org/10.1145/2451116.2451137},\n doi = {10.1145/2451116.2451137},\n acmid = {2451137},\n publisher = {ACM},\n address = {New York, NY, USA},\n keywords = {analysis tool, memory container, memory management, randomized algorithm, row-buffer conflict},\n} "
p0
.I0
.S'GVM'
p0
.S"$bib:\n@inproceedings{Liu:2014:GVM:2665671.2665698,\n author = {Liu, Lei and Li, Yong and Cui, Zehan and Bao, Yungang and Chen, Mingyu and Wu, Chengyong},\n title = {Going Vertical in Memory Management: Handling Multiplicity by Multi-policy},\n booktitle = {Proceeding of the 41st Annual International Symposium on Computer Architecuture},\n series = {ISCA '14},\n year = {2014},\n isbn = {978-1-4799-4394-4},\n location = {Minneapolis, Minnesota, USA},\n pages = {169--180},\n numpages = {12},\n url = {http://dl.acm.org/citation.cfm?id=2665671.2665698},\n acmid = {2665698},\n publisher = {IEEE Press},\n address = {Piscataway, NJ, USA},\n} "
p0
.I0
.S'sirius'
p0
.S"$bib:\n@inproceedings{sirius,\n author = {Hauswald, Johann and Laurenzano, Michael A. and Zhang, Yunqi and Li, Cheng and Rovinski, Austin and Khurana, Arjun and Dreslinski, Ronald G. and Mudge, Trevor and Petrucci, Vinicius and Tang, Lingjia and Mars, Jason},\n title = {Sirius: An Open End-to-End Voice and Vision Personal Assistant and Its Implications for Future Warehouse Scale Computers},\n booktitle = {Proceedings of the Twentieth International Conference on Architectural Support for Programming Languages and Operating Systems},\n series = {ASPLOS '15},\n year = {2015},\n isbn = {978-1-4503-2835-7},\n location = {Istanbul, Turkey},\n pages = {223--238},\n numpages = {16},\n url = {http://doi.acm.org/10.1145/2694344.2694347},\n doi = {10.1145/2694344.2694347},\n acmid = {2694347},\n publisher = {ACM},\n address = {New York, NY, USA},\n keywords = {datacenters, emerging workloads, intelligent personal assistants, warehouse scale computers},\n} "
p0
.I0
.S'djinn'
p0
.S"$bib:\n@inproceedings{djinn,\n author = {Hauswald, Johann and Kang, Yiping and Laurenzano, Michael A. and Chen, Quan and Li, Cheng and Mudge, Trevor and Dreslinski, Ronald G. and Mars, Jason and Tang, Lingjia},\n title = {DjiNN and Tonic: DNN As a Service and Its Implications for Future Warehouse Scale Computers},\n booktitle = {Proceedings of the 42Nd Annual International Symposium on Computer Architecture},\n series = {ISCA '15},\n year = {2015},\n isbn = {978-1-4503-3402-0},\n location = {Portland, Oregon},\n pages = {27--40},\n numpages = {14},\n url = {http://doi.acm.org/10.1145/2749469.2749472},\n doi = {10.1145/2749469.2749472},\n acmid = {2749472},\n publisher = {ACM},\n address = {New York, NY, USA},\n} "
p0
.I0
.S'Aws case studies'
p0
.S'$bib:\n@misc{awscase,\n  author = {Amazon},\n  title = {{Amazon web services User Case Studies}},\n  howpublished = {\\url{https://aws.amazon.com/solutions/case-studies/}},\n  note = {Accessed: 2015-08-12}\n}\n\n@misc{pennamazon,\n  author = {Amazon},\n  title = {{AWS Case Study: Penn State}},\n  howpublished = {\\url{http://aws.amazon.com/solutions/case-studies/penn-state/}},\n  note = {Accessed: 2015-08-12}\n}\n\n@misc{pixnet,\n  author = {Amazon},\n  title = {{AWS Case Study: PIXNET}},\n  howpublished = {\\url{http://aws.amazon.com/solutions/case-studies/pixnet/}},\n  note = {Accessed: 2015-08-12}\n}\n\n@misc{docomo,\n  author = {Amazon},\n  title = {{AWS Case Study: NTT Docomo}},\n  howpublished = {\\url{http://aws.amazon.com/solutions/case-studies/ntt-docomo/}},\n  note = {Accessed: 2015-08-12}\n}'
p0
.I0
.S'Ersatz labs'
p0
.S'$bib:\n@electronic{ersatzlabs,\nurl = {$\\backslash$url\\{http://www.ersatzlabs.com/}},\nauthor = {{Ersatz Labs}},\ntitle = {Ersatz Labs}\n}'
p0
.I0
.S'Forbes'
p0
.S'$bib:\n@electronic{forbes,\nauthor = {{Forbes}},\ntitle = {http://www.forbes.com/sites/benkepes/2015/03/04/new-stats-from-the-state-of-cloud-report/}\n}'
p0
.I0
.S'HPC cloud'
p0
.S"@inproceedings{Sotomayor:2008:CBE:1383422.1383434,\n author = {Sotomayor, Borja and Keahey, Kate and Foster, Ian},\n title = {Combining Batch Execution and Leasing Using Virtual Machines},\n booktitle = {Proceedings of the 17th International Symposium on High Performance Distributed Computing},\n series = {HPDC '08},\n year = {2008},\n isbn = {978-1-59593-997-5},\n location = {Boston, MA, USA},\n pages = {87--96},\n numpages = {10},\n url = {http://doi.acm.org/10.1145/1383422.1383434},\n doi = {10.1145/1383422.1383434},\n acmid = {1383434},\n publisher = {ACM},\n address = {New York, NY, USA},\n keywords = {advance reservations, backfilling, batch processing, checkpoint/restart, resource leasing, resource management, virtual machine overhead, virtual machines, virtual workspaces},\n} "
p0
.I0
.S'gce'
p0
.S'$bib:\n@misc{gce,\n  author = {Wikipedia},\n  title = {{Google Compute Engine}},\n  howpublished = {\\url{https://en.wikipedia.org/wiki/Google_Compute_Engine}},\n  note = {Accessed: 2015-08-10}\n}\n\n@misc{aws,\n  author = {Wikipedia},\n  title = {{Amazon Elastic Compute Cloud}},\n  howpublished = {\\url{https://en.wikipedia.org/wiki/Amazon_Elastic_Compute_Cloud}},\n  note = {Accessed: 2015-08-10}\n}'
p0
.I0
.S'KVM'
p0
.S'$bib:\n@INPROCEEDINGS{Kivity2007,\n  author = {Avi Kivity and Yaniv Kamay and Dor Laor and Uri Lublin and Anthony\n\tLiguori},\n  title = {kvm: the Linux Virtual Machine Monitor},\n  booktitle = {Proceedings of the Linux Symposium},\n  year = {2007},\n  volume = {1},\n  pages = {225--230},\n  address = {Ottawa, Ontario, Canada},\n  month = JUN,\n  url = {http://linux-security.cn/ebooks/ols2007/OLS2007-Proceedings-V1.pdf}\n}'
p0
.I0
.S'pricing'
p0
.S'$bib:\n@misc{aws-pricing,\n  author = {Amazon AWS},\n  title = {{Amazon EC2 Pricing}},\n  howpublished = {\\url{https://aws.amazon.com/ec2/pricing/}},\n  note = {Accessed: 2015-08-12}\n}\n\n@misc{gce-pricing,\n  author = {Google Cloud Platform},\n  title = {{Google Compute Engine Pricing}},\n  howpublished = {\\url{https://cloud.google.com/compute/pricing}},\n  note = {Accessed: 2015-08-12}\n}'
p0
.I0
.S'Luque et al'
p0
.S"$bib:\n@article{Luque:2009:CAC:1591872.1591935,\n author = {Luque, Carlos and Moreto, Miquel and Cazorla, Francisco J. and Gioiosa, Roberto and Buyuktosunoglu, Alper and Valero, Mateo},\n title = {CPU Accounting in CMP Processors},\n journal = {IEEE Comput. Archit. Lett.},\n issue_date = {January 2009},\n volume = {8},\n number = {1},\n month = jan,\n year = {2009},\n issn = {1556-6056},\n pages = {17--20},\n numpages = {4},\n url = {http://dx.doi.org/10.1109/L-CA.2009.3},\n doi = {10.1109/L-CA.2009.3},\n acmid = {1591935},\n publisher = {IEEE Computer Society},\n address = {Washington, DC, USA},\n keywords = {General, Hardware, Hardware, Hardware/software interfaces, Multi-core/single-chip multiprocessors, General, Hardware/software interfaces, Multi-core/single-chip multiprocessors},\n} \n\n@inproceedings{Luque:2009:IIC:1636712.1637756,\n author = {Luque, Carlos and Moreto, Miquel and Cazorla, Francisco J. and Gioiosa, Roberto and Buyuktosunoglu, Alper and Valero, Mateo},\n title = {ITCA: Inter-task Conflict-Aware CPU Accounting for CMPs},\n booktitle = {Proceedings of the 2009 18th International Conference on Parallel Architectures and Compilation Techniques},\n series = {PACT '09},\n year = {2009},\n isbn = {978-0-7695-3771-9},\n pages = {203--213},\n numpages = {11},\n url = {http://dx.doi.org/10.1109/PACT.2009.33},\n doi = {10.1109/PACT.2009.33},\n acmid = {1637756},\n publisher = {IEEE Computer Society},\n address = {Washington, DC, USA},\n keywords = {Cycle Accounting, Chip-MultiProcessor, Cache Partitioning Algorithms, Fairness, ATD},\n} \n\n@ARTICLE{5989796, \nauthor={Luque, C. and Moreto, M. and Cazorla, F.J. and Gioiosa, R. and Buyuktosunoglu, A. and Valero, M.}, \njournal={Computers, IEEE Transactions on}, \ntitle={CPU Accounting for Multicore Processors}, \nyear={2012}, \nmonth={Feb}, \nvolume={61}, \nnumber={2}, \npages={251-264}, \nkeywords={computational complexity;computer centres;microprocessor chips;multiprocessing systems;operating systems (computers);processor scheduling;CMP hardware resources;CPU accounting mechanism;CPU utilization;OS time;chip multiprocessors;computational complexity;data centers;multicore processors;operating system time;single-threaded processor;symmetric multiprocessors;task scheduling;Accuracy;Central Processing Unit;Electronic mail;Estimation;Hardware;Program processors;Proposals;CPU accounting;cache partitioning algorithms.;chip-multiprocessor;shared last level of cache}, \ndoi={10.1109/TC.2011.152}, \nISSN={0018-9340},}\n\n@article{Luque:2013:FCT:2400682.2400709,\n author = {Luque, Carlos and Moreto, Miquel and Cazorla, Francisco J. and Valero, Mateo},\n title = {Fair CPU Time Accounting in CMP\\&Plus;SMT Processors},\n journal = {ACM Trans. Archit. Code Optim.},\n issue_date = {January 2013},\n volume = {9},\n number = {4},\n month = jan,\n year = {2013},\n issn = {1544-3566},\n pages = {50:1--50:25},\n articleno = {50},\n numpages = {25},\n url = {http://doi.acm.org/10.1145/2400682.2400709},\n doi = {10.1145/2400682.2400709},\n acmid = {2400709},\n publisher = {ACM},\n address = {New York, NY, USA},\n keywords = {CPU accounting, fairness, multicore/multithreaded processors, progress, slowdown},\n} \n"
p0
.I0
.S'Calder et al'
p0
.S"$bib:\n@inproceedings{Sherwood:2003:PTP:859618.859657,\n author = {Sherwood, Timothy and Sair, Suleyman and Calder, Brad},\n title = {Phase Tracking and Prediction},\n booktitle = {Proceedings of the 30th Annual International Symposium on Computer Architecture},\n series = {ISCA '03},\n year = {2003},\n isbn = {0-7695-1945-8},\n location = {San Diego, California},\n pages = {336--349},\n numpages = {14},\n url = {http://doi.acm.org/10.1145/859618.859657},\n doi = {10.1145/859618.859657},\n acmid = {859657},\n publisher = {ACM},\n address = {New York, NY, USA},\n} \n\n@inproceedings{Lau:2005:TPC:1042442.1043427,\n author = {Lau, Jeremy and Schoenmackers, Stefan and Calder, Brad},\n title = {Transition Phase Classification and Prediction},\n booktitle = {Proceedings of the 11th International Symposium on High-Performance Computer Architecture},\n series = {HPCA '05},\n year = {2005},\n isbn = {0-7695-2275-0},\n pages = {278--289},\n numpages = {12},\n url = {http://dx.doi.org/10.1109/HPCA.2005.39},\n doi = {10.1109/HPCA.2005.39},\n acmid = {1043427},\n publisher = {IEEE Computer Society},\n address = {Washington, DC, USA},\n} "
p0
.I0
.S'Eyerman et al'
p0
.S'$bib:\n@inproceedings{Eyerman:2009:PCA:1508244.1508260,\n author = {Eyerman, Stijn and Eeckhout, Lieven},\n title = {Per-thread Cycle Accounting in SMT Processors},\n booktitle = {Proceedings of the 14th International Conference on Architectural Support for Programming Languages and Operating Systems},\n series = {ASPLOS XIV},\n year = {2009},\n isbn = {978-1-60558-406-5},\n location = {Washington, DC, USA},\n pages = {133--144},\n numpages = {12},\n url = {http://doi.acm.org/10.1145/1508244.1508260},\n doi = {10.1145/1508244.1508260},\n acmid = {1508260},\n publisher = {ACM},\n address = {New York, NY, USA},\n keywords = {cycle accounting, simultaneous multithreading (smt), thread-progress aware fetch policy},\n} '
p0
.I0
.S'Dhodapkar et al'
p0
.S'$bib:\n@inproceedings{Dhodapkar:2003:CPP:956417.956539,\n author = {Dhodapkar, Ashutosh S. and Smith, James E.},\n title = {Comparing Program Phase Detection Techniques},\n booktitle = {Proceedings of the 36th Annual IEEE/ACM International Symposium on Microarchitecture},\n series = {MICRO 36},\n year = {2003},\n isbn = {0-7695-2043-X},\n pages = {217--},\n url = {http://dl.acm.org/citation.cfm?id=956417.956539},\n acmid = {956539},\n publisher = {IEEE Computer Society},\n address = {Washington, DC, USA},\n} \n'
p0
.I0
.S'latency cloud1'
p0
.S'$bib:\n@INPROCEEDINGS{6076756, \nauthor={Yilei Zhang and Zibin Zheng and Lyu, M.R.}, \nbooktitle={Reliable Distributed Systems (SRDS), 2011 30th IEEE Symposium on}, \ntitle={Exploring Latent Features for Memory-Based QoS Prediction in Cloud Computing}, \nyear={2011}, \npages={1-10}, \nkeywords={cloud computing;groupware;quality of service;storage management;CloudPred;cloud computing;collaborative quality prediction;distributed components;latent features;memory-based QoS prediction;neighborhood-based approach;personalized quality prediction;Accuracy;Cloud computing;Collaboration;Monitoring;Quality of service;Sparse matrices;Vectors;Cloud Computing;Prediction;QoS}, \ndoi={10.1109/SRDS.2011.10}, \nISSN={1060-9857}, \nmonth={Oct},}'
p0
.I0
.S'latency cloud 2'
p0
.S'$bib:\n@misc{privatepublic,\n  title = {Private VS Public clouds which one to choose},\n  howpublished = {\\url{http://www.logicworks.net/blog/2015/03/difference-private-public-hybrid-cloud-comparison/}},\n  note = {Accessed: 2015}\n}\n'
p0
.I0
.S'latency cloud 3'
p0
.S'$bib:\nBibTeX | EndNote | ACM Ref\n@article{Marston:2011:CCB:1943771.1943810,\n author = {Marston, Sean and Li, Zhi and Bandyopadhyay, Subhajyoti and Zhang, Juheng and Ghalsasi, Anand},\n title = {Cloud Computing - The Business Perspective},\n journal = {Decis. Support Syst.},\n issue_date = {April, 2011},\n volume = {51},\n number = {1},\n month = apr,\n year = {2011},\n issn = {0167-9236},\n pages = {176--189},\n numpages = {14},\n url = {http://dx.doi.org/10.1016/j.dss.2010.12.006},\n doi = {10.1016/j.dss.2010.12.006},\n acmid = {1943810},\n publisher = {Elsevier Science Publishers B. V.},\n address = {Amsterdam, The Netherlands, The Netherlands},\n keywords = {Cloud computing, Cloud computing regulation, Infrastructure as a service, On-demand computing, Platform as a service, Software as a service, Virtualization},\n} \n'
p0
.I0
.S'phase definition'
p0
.S'$bib:\n@article{DBLP:journals/jilp/HamerlyPLC05,\n  author    = {Greg Hamerly and\n               Erez Perelman and\n               Jeremy Lau and\n               Brad Calder},\n  title     = {SimPoint 3.0: Faster and More Flexible Program Phase Analysis},\n  journal   = {J. Instruction-Level Parallelism},\n  volume    = {7},\n  year      = {2005},\n  url       = {http://www.jilp.org/vol7/v7paper14.pdf},\n  timestamp = {Fri, 21 Dec 2012 16:32:24 +0100},\n  biburl    = {http://dblp.uni-trier.de/rec/bib/journals/jilp/HamerlyPLC05},\n  bibsource = {dblp computer science bibliography, http://dblp.org}\n}'
p0
.I0
.S'consen'
p0
.S"$bib:\n@inproceedings{Tang:2011:CVS:2000417.2000419,\n author = {Tang, Lingjia and Mars, Jason and Soffa, Mary Lou},\n title = {Contentiousness vs. Sensitivity: Improving Contention Aware Runtime Systems on Multicore Architectures},\n booktitle = {Proceedings of the 1st International Workshop on Adaptive Self-Tuning Computing Systems for the Exaflop Era},\n series = {EXADAPT '11},\n year = {2011},\n isbn = {978-1-4503-0708-6},\n location = {San Jose, California, USA},\n pages = {12--21},\n numpages = {10},\n url = {http://doi.acm.org/10.1145/2000417.2000419},\n doi = {10.1145/2000417.2000419},\n acmid = {2000419},\n publisher = {ACM},\n address = {New York, NY, USA},\n keywords = {contention aware runtimes, contentiousness vs sensitivity, memory subsystems, multicore processors, scheduling},\n} "
p0
.I0
.S'Latex config'
p0
.S''
p0
.I4
.S'Style'
p0
.S''
p0
.I4
.S'couriers'
p0
.S"$style_file: couriers\n%%\n%% This is file `couriers.sty',\n%%\n% This program may be distributed and/or modified under the\n% conditions of the LaTeX Project Public License, either version 1.2\n% of this license or (at your option) any later version.\n% The latest version of this license is in\n%   http://www.latex-project.org/lppl.txt\n% and version 1.2 or later is part of all distributions of LaTeX\n% version 1999/12/01 or later.\n\\ProvidesPackage{couriers}\n[2004/07/10 Scaled Courier\n(HS)\n]\n\\RequirePackage{keyval}\n\\define@key{Cou}{scaled}[0.95]{%\n  \\def\\Cr@scale{#1}}\n\\def\\ProcessOptionsWithKV#1{%\n  \\let\\@tempc\\relax\n  \\let\\Cr@tempa\\@empty\n  \\@for\\CurrentOption:=\\@classoptionslist\\do{%\n    \\@ifundefined{KV@#1@\\CurrentOption}%\n    {}%\n    {\\edef\\Cr@tempa{\\Cr@tempa,\\CurrentOption,}}%\n  }%\n  \\edef\\Cr@tempa{%\n    \\noexpand\\setkeys{#1}{%\n      \\Cr@tempa\\@ptionlist{\\@currname.\\@currext}%\n    }%\n  }%\n  \\Cr@tempa\n}\n\\ProcessOptionsWithKV{Cou}\n\\AtEndOfPackage{%\n  \\let\\@unprocessedoptions\\relax\n}\n\\renewcommand{\\ttdefault}{pcrs}\n\\endinput\n%%\n%% End of file `couriers.sty'.\n"
p0
.I0
.S'etoolbox'
p0
.S"$style_file: etoolbox\n% $Id: etoolbox.sty,v 2.1 2011/01/03 19:14:10 lehman stable $\n\n% Copyright (c) 2007-2011 Philipp Lehman.\n%\n% Permission is granted to copy, distribute and/or modify this\n% software under the terms of the LaTeX Project Public License\n% (LPPL), version 1.3.\n%\n% The LPPL maintenance status of this software is\n% 'author-maintained'.\n%\n% This software is provided 'as is', without warranty of any kind,\n% either expressed or implied, including, but not limited to, the\n% implied warranties of merchantability and fitness for a\n% particular purpose.\n\n\\def\\etb@rcsid$#1: #2 #3 #4 #5${#4 v#3}\n\n\\NeedsTeXFormat{LaTeX2e}\n\\ProvidesPackage{etoolbox}\n[\\etb@rcsid $Id: etoolbox.sty,v 2.1 2011/01/03 19:14:10 lehman stable $\n e-TeX tools for LaTeX]\n\n\\begingroup\n\\@ifundefined{eTeXversion}\n  {\\PackageError{etoolbox}\n     {Not running under e-TeX}\n     {This package requires e-TeX. Try compiling the document\n      with\\MessageBreak 'elatex' instead of 'latex'. When using\n      pdfTeX, try 'pdfelatex'\\MessageBreak instead of 'pdflatex'.\n      This is a fatal error. I'm aborting now.}%\n   \\aftergroup\\endinput}\n  {}\n\\endgroup\n\n\\RequirePackage{etex}\n\n\\def\\etb@catcodes{\\do\\&\\do\\|\\do\\:\\do\\-\\do\\=\\do\\<\\do\\>}\n\\def\\do#1{\\catcode\\number`#1=\\the\\catcode`#1\\relax}\n\\edef\\etb@catcodes{\\etb@catcodes}\n\\let\\do\\noexpand\n\\AtEndOfPackage{\\etb@catcodes\\undef\\etb@catcodes}\n\n\\catcode`\\&=3\n\\catcode`\\|=3\n\\@makeother\\:\n\\@makeother\\-\n\\@makeother\\=\n\\@makeother\\<\n\\@makeother\\>\n\n\\protected\\def\\etb@error{\\PackageError{etoolbox}}\n\\protected\\def\\etb@warning{\\PackageWarning{etoolbox}}\n\\protected\\def\\etb@info{\\PackageInfo{etoolbox}}\n\\newcount\\etb@tempcnta\n\n% {<cstoken>}[<arguments>][<optarg default>]{<definition>}\n\n\\newcommand*{\\newrobustcmd}{}\n\\protected\\def\\newrobustcmd{\\@star@or@long\\etb@new@command}\n\n\\def\\etb@new@command#1{\\@testopt{\\etb@newcommand#1}0}\n\n\\def\\etb@newcommand#1[#2]{%\n  \\@ifnextchar[%]\n    {\\etb@xargdef#1[#2]}\n    {\\ifx\\l@ngrel@x\\relax\n       \\let\\l@ngrel@x\\protected\n     \\else\n       \\protected\\def\\l@ngrel@x{\\protected\\long}%\n     \\fi\n     \\@argdef#1[#2]}}\n\n\\long\\def\\etb@xargdef#1[#2][#3]#4{%\n  \\@ifdefinable#1{%\n    \\expandafter\\protected\n    \\expandafter\\def\n    \\expandafter#1%\n    \\expandafter{%\n      \\expandafter\\@testopt\n      \\csname\\string#1\\endcsname{#3}}%\n    \\expandafter\\@yargdef\\csname\\string#1\\endcsname\\tw@{#2}{#4}}}\n\n% {<cstoken>}[<arguments>][<optarg default>]{<definition>}\n\n\\newrobustcmd*{\\renewrobustcmd}{\\@star@or@long\\etb@renew@command}\n\n\\def\\etb@renew@command#1{%\n  \\ifundef{#1}\n     {\\etb@error{\\string#1 undefined}\\@ehc}\n     {}%\n  \\let\\@ifdefinable\\@rc@ifdefinable\n  \\etb@new@command#1}\n\n% {<cstoken>}[<arguments>][<optarg default>]{<definition>}\n\n\\newrobustcmd*{\\providerobustcmd}{\\@star@or@long\\etb@provide@command}\n\n\\def\\etb@provide@command#1{%\n  \\ifundef{#1}\n    {\\def\\reserved@a{\\etb@new@command#1}}\n    {\\def\\reserved@a{\\etb@renew@command\\reserved@a}}%\n  \\reserved@a}\n\n% {<csname>}\n\n\\newrobustcmd*{\\csshow}[1]{%\n  \\begingroup\\expandafter\\endgroup\n  \\expandafter\\show\\csname#1\\endcsname}\n\n% {<cstoken>}{<true>}{<false>}\n\n\\newcommand{\\ifdef}[1]{%\n  \\ifdefined#1%\n    \\expandafter\\@firstoftwo\n  \\else\n    \\expandafter\\@secondoftwo\n  \\fi}\n\n% {<cstoken>}{<true>}{<false>}\n\n\\newcommand{\\ifundef}[1]{%\n  \\ifdefined#1%\n    \\ifx#1\\relax\n      \\expandafter\\expandafter\n      \\expandafter\\@firstoftwo\n    \\else\n      \\expandafter\\expandafter\n      \\expandafter\\@secondoftwo\n    \\fi\n  \\else\n    \\expandafter\\@firstoftwo\n  \\fi}\n\n% {<csname>}{<true>}{<false>}\n\n\\newcommand*{\\ifcsdef}[1]{%\n  \\ifcsname#1\\endcsname\n    \\expandafter\\@firstoftwo\n  \\else\n    \\expandafter\\@secondoftwo\n  \\fi}\n\n% {<csname>}{<true>}{<false>}\n\n\\newcommand*{\\ifcsundef}[1]{%\n  \\ifcsname#1\\endcsname\n    \\expandafter\\ifx\\csname#1\\endcsname\\relax\n      \\expandafter\\expandafter\n      \\expandafter\\@firstoftwo\n    \\else\n      \\expandafter\\expandafter\n      \\expandafter\\@secondoftwo\n    \\fi\n  \\else\n    \\expandafter\\@firstoftwo\n  \\fi}\n\n% {<cstoken>}{<true}{<false>}\n\n\\newcommand{\\ifdefmacro}{}\n\\long\\edef\\ifdefmacro#1{%\n  \\noexpand\\expandafter\\noexpand\\etb@ifdefmacro\n  \\noexpand\\meaning#1\\detokenize{macro}:&}\n\\edef\\etb@ifdefmacro{%\n  \\def\\noexpand\\etb@ifdefmacro##1\\detokenize{macro}:##2&}\n\\etb@ifdefmacro{\\notblank{#2}}\n\n% {<csname>}{<true>}{<false>}\n\n\\newcommand*{\\ifcsmacro}[1]{%\n  \\ifcsdef{#1}\n    {\\expandafter\\ifdefmacro\\csname#1\\endcsname}\n    {\\@secondoftwo}}\n\n% {<cstoken>}{<true}{<false>}\n\n\\newcommand{\\ifdefprefix}[1]{%\n  \\ifdefmacro{#1}\n    {\\etb@ifdefprefix{#1}}\n    {\\@secondoftwo}}\n\\long\\edef\\etb@ifdefprefix#1{%\n  \\noexpand\\expandafter\\noexpand\\etb@ifdefprefix@i\n  \\noexpand\\meaning#1\\detokenize{macro}:&}\n\\edef\\etb@ifdefprefix@i{%\n  \\def\\noexpand\\etb@ifdefprefix@i##1\\detokenize{macro}:##2&}\n\\etb@ifdefprefix@i{\\notblank{#1}}\n\n% {<csname>}{<true>}{<false>}\n\n\\newcommand*{\\ifcsprefix}[1]{%\n  \\ifcsdef{#1}\n    {\\expandafter\\ifdefprefix\\csname#1\\endcsname}\n    {\\@secondoftwo}}\n\n% {<cstoken>}{<true}{<false>}\n\n\\newcommand{\\ifdefparam}{}\n\\long\\edef\\ifdefparam#1{%\n  \\noexpand\\expandafter\\noexpand\\etb@ifdefparam\n  \\noexpand\\meaning#1\\detokenize{macro}:->&}\n\\edef\\etb@ifdefparam{%\n  \\def\\noexpand\\etb@ifdefparam##1\\detokenize{macro}:##2->##3&}\n\\etb@ifdefparam{\\notblank{#2}}\n\n% {<csname>}{<true>}{<false>}\n\n\\newcommand*{\\ifcsparam}[1]{%\n  \\ifcsdef{#1}\n    {\\expandafter\\ifdefparam\\csname#1\\endcsname}\n    {\\@secondoftwo}}\n\n% {<cstoken>}{<true}{<false>}\n\n\\newcommand{\\ifdefprotected}{}\n\\long\\edef\\ifdefprotected#1{%\n  \\noexpand\\expandafter\\noexpand\\etb@ifdefprotected\n  \\noexpand\\meaning#1\\string\\protected&}\n\\edef\\etb@ifdefprotected{%\n  \\def\\noexpand\\etb@ifdefprotected##1\\string\\protected##2&}\n\\etb@ifdefprotected{\\notblank{#2}}\n\n% {<csname>}{<true>}{<false>}\n\n\\newcommand*{\\ifcsprotected}[1]{%\n  \\ifcsdef{#1}\n    {\\expandafter\\ifdefprotected\\csname#1\\endcsname}\n    {\\@secondoftwo}}\n\n% {<cstoken>}{<true}{<false>}\n\n\\newrobustcmd{\\ifdefltxprotect}[1]{%\n  \\begingroup\n  \\edef\\etb@resrvda{%\n    \\noexpand\\protect\\expandafter\\noexpand\n    \\csname\\expandafter\\@gobble\\string#1 \\endcsname}%\n  \\expandafter\\endgroup\\ifx#1\\etb@resrvda\n    \\expandafter\\@firstoftwo\n  \\else\n    \\expandafter\\@secondoftwo\n  \\fi}\n\n% {<csname>}{<true>}{<false>}\n\n\\newrobustcmd*{\\ifcsltxprotect}[1]{%\n  \\ifcsdef{#1}\n    {\\expandafter\\ifdefltxprotect\\csname#1\\endcsname}\n    {\\@secondoftwo}}\n\n% {<cstoken>}{<true>}{<false>}\n\n\\newcommand{\\ifdefempty}[1]{%\n  \\ifundef{#1}\n    {\\@secondoftwo}\n    {\\ifdefmacro{#1}\n       {\\ifdefparam{#1}\n\t  {\\@secondoftwo}\n\t  {\\etb@ifdefempty{#1}}}\n       {\\@secondoftwo}}}\n\n\\def\\etb@ifdefempty#1{%\n  \\expandafter\\expandafter\n  \\expandafter\\ifblank\n  \\expandafter\\expandafter\n  \\expandafter{%\n  \\expandafter\\strip@prefix\\meaning#1}}\n\n% {<csname>}{<true>}{<false>}\n\n\\newcommand*{\\ifcsempty}[1]{%\n  \\ifcsundef{#1}\n    {\\@secondoftwo}\n    {\\expandafter\\ifdefparam\\csname#1\\endcsname\n       {\\@secondoftwo}\n       {\\expandafter\\etb@ifdefempty\\csname#1\\endcsname}}}\n\n% {<cstoken>}{<true>}{<false>}\n\n\\newcommand{\\ifdefvoid}[1]{%\n  \\ifundef{#1}\n    {\\@firstoftwo}\n    {\\ifdefmacro{#1}\n       {\\ifdefparam{#1}\n\t  {\\@secondoftwo}\n\t  {\\etb@ifdefempty{#1}}}\n       {\\@secondoftwo}}}\n\n% {<csname>}{<true>}{<false>}\n\n\\newcommand*{\\ifcsvoid}[1]{%\n  \\ifcsundef{#1}\n    {\\@firstoftwo}\n    {\\expandafter\\ifdefparam\\csname#1\\endcsname\n       {\\@secondoftwo}\n       {\\expandafter\\etb@ifdefempty\\csname#1\\endcsname}}}\n\n% {<cstoken1>}{<cstoken2>}{<true>}{<false>}\n\n\\newcommand{\\ifdefequal}[2]{%\n  \\ifundef{#1}\n    {\\@secondoftwo}\n    {\\ifundef{#2}\n       {\\@secondoftwo}\n       {\\ifx#1#2%\n          \\expandafter\\@firstoftwo\n        \\else\n          \\expandafter\\@secondoftwo\n        \\fi}}}\n\n% {<csname1>}{<csname2>}{<true>}{<false>}\n\n\\newcommand*{\\ifcsequal}[2]{%\n  \\ifcsundef{#1}\n    {\\@secondoftwo}\n    {\\ifcsundef{#2}\n       {\\@secondoftwo}\n       {\\expandafter\\ifx\n        \\csname#1\\expandafter\\endcsname\n        \\csname#2\\endcsname\n          \\expandafter\\@firstoftwo\n        \\else\n          \\expandafter\\@secondoftwo\n        \\fi}}}\n\n% {<cstoken1>}{<cstoken2>}{<true>}{<false>}\n\n\\newrobustcmd{\\ifdefstrequal}[2]{%\n  \\ifdefmacro{#1}\n    {\\ifdefmacro{#2}\n       {\\begingroup\n\t\\edef\\etb@tempa{\\expandafter\\strip@prefix\\meaning#1}%\n\t\\edef\\etb@tempb{\\expandafter\\strip@prefix\\meaning#2}%\n\t\\ifx\\etb@tempa\\etb@tempb\n\t  \\aftergroup\\@firstoftwo\n\t\\else\n\t  \\aftergroup\\@secondoftwo\n\t\\fi\n\t\\endgroup}\n       {\\@secondoftwo}}\n    {\\@secondoftwo}}\n\n% {<csname1>}{<csname2>}{<true>}{<false>}\n\n\\newcommand*{\\ifcsstrequal}[2]{%\n  \\ifcsundef{#1}\n    {\\@secondoftwo}\n    {\\ifcsundef{#2}\n       {\\@secondoftwo}\n       {\\expandafter\\ifdefstrequal\n        \\csname#1\\expandafter\\endcsname\n\t\\csname#2\\endcsname}}}\n\n% {<cstoken>}{<string>}{<true>}{<false>}\n\n\\newrobustcmd{\\ifdefstring}[2]{%\n  \\ifdefmacro{#1}\n    {\\begingroup\n     \\edef\\etb@tempa{\\expandafter\\strip@prefix\\meaning#1}%\n     \\edef\\etb@tempb{\\detokenize{#2}}%\n     \\ifx\\etb@tempa\\etb@tempb\n       \\aftergroup\\@firstoftwo\n     \\else\n       \\aftergroup\\@secondoftwo\n     \\fi\n     \\endgroup}\n    {\\@secondoftwo}}\n\n% {<csname>}{<string>}{<true>}{<false>}\n\n\\newrobustcmd{\\ifcsstring}[2]{%\n  \\ifcsundef{#1}\n    {\\@secondoftwo}\n    {\\expandafter\\ifdefstring\\csname#1\\endcsname{#2}}}\n\n% {<cstoken>}{<true}{<false>}\n\n\\newcommand{\\ifdefcounter}[1]{\\etb@ifcounter#1&}\n\\long\\def\\etb@ifcounter#1#2&{%\n  \\ifx\\count#1%\n    \\expandafter\\@secondoftwo\n  \\else\n    \\expandafter\\etb@ifcounter@i\\meaning#1:%\n  \\fi}\n\\edef\\etb@ifcounter@i#1:#2\\fi{\\noexpand\\fi\n  \\noexpand\\etb@ifcounter@ii#1\\string\\count&}\n\\edef\\etb@ifcounter@ii{%\n  \\def\\noexpand\\etb@ifcounter@ii##1\\string\\count##2&}\n\\etb@ifcounter@ii{\\ifblank{#1}}\n\n% {<csname>}{<true>}{<false>}\n\n\\newcommand*{\\ifcscounter}[1]{%\n  \\ifcsdef{#1}\n    {\\expandafter\\ifdefcounter\\csname#1\\endcsname}\n    {\\@secondoftwo}}\n\n% {<name>}{<true>}{<false>}\n\n\\newcommand*{\\ifltxcounter}[1]{%\n  \\ifcsdef{c@#1}\n    {\\expandafter\\ifdefcounter\\csname c@#1\\endcsname}\n    {\\@secondoftwo}}\n\n% {<cstoken>}{<true}{<false>}\n\n\\newcommand{\\ifdeflength}[1]{\\etb@iflength#1&}\n\\long\\def\\etb@iflength#1#2&{%\n  \\ifx\\skip#1%\n    \\expandafter\\@secondoftwo\n  \\else\n    \\expandafter\\etb@iflength@i\\meaning#1:%\n  \\fi}\n\\edef\\etb@iflength@i#1:#2\\fi{\\noexpand\\fi\n  \\noexpand\\etb@iflength@ii#1\\string\\skip&}\n\\edef\\etb@iflength@ii{%\n  \\def\\noexpand\\etb@iflength@ii##1\\string\\skip##2&}\n\\etb@iflength@ii{\\ifblank{#1}}\n\n% {<csname>}{<true>}{<false>}\n\n\\newcommand*{\\ifcslength}[1]{%\n  \\ifcsdef{#1}\n    {\\expandafter\\ifdeflength\\csname#1\\endcsname}\n    {\\@secondoftwo}}\n\n% {<cstoken>}{<true}{<false>}\n\n\\newcommand{\\ifdefdimen}[1]{\\etb@ifdimen#1&}\n\\long\\def\\etb@ifdimen#1#2&{%\n  \\ifx\\dimen#1%\n    \\expandafter\\@secondoftwo\n  \\else\n    \\expandafter\\etb@ifdimen@i\\meaning#1:%\n  \\fi}\n\\edef\\etb@ifdimen@i#1:#2\\fi{\\noexpand\\fi\n  \\noexpand\\etb@ifdimen@ii#1\\string\\dimen&}\n\\edef\\etb@ifdimen@ii{%\n  \\def\\noexpand\\etb@ifdimen@ii##1\\string\\dimen##2&}\n\\etb@ifdimen@ii{\\ifblank{#1}}\n\n% {<csname>}{<true>}{<false>}\n\n\\newcommand*{\\ifcsdimen}[1]{%\n  \\ifcsdef{#1}\n    {\\expandafter\\ifdefdimen\\csname#1\\endcsname}\n    {\\@secondoftwo}}\n\n% {<string1>}{<string2>}{<true>}{<false>}\n\n\\newrobustcmd{\\ifstrequal}[2]{%\n  \\begingroup\n  \\edef\\etb@tempa{\\detokenize{#1}}%\n  \\edef\\etb@tempb{\\detokenize{#2}}%\n  \\ifx\\etb@tempa\\etb@tempb\n    \\aftergroup\\@firstoftwo\n  \\else\n    \\aftergroup\\@secondoftwo\n  \\fi\n  \\endgroup}\n\n% {<string>}{<true>}{<false>}\n\n\\newcommand{\\ifstrempty}[1]{%\n  \\expandafter\\ifx\\expandafter&\\detokenize{#1}&%\n    \\expandafter\\@firstoftwo\n  \\else\n    \\expandafter\\@secondoftwo\n  \\fi}\n\n% {<string>}{<true>}{<false>}\n\n\\newcommand{\\ifblank}[1]{% from url.sty\n  \\etb@ifblank@i#1&&\\@secondoftwo\\@firstoftwo:}\n\\long\\def\\etb@ifblank@i#1#2&#3#4#5:{#4}\n\n\\newcommand{\\notblank}[1]{%\n  \\etb@ifblank@i#1&&\\@firstoftwo\\@secondoftwo:}\n\n% {<numexpr>}{<comp>}{<numexpr>}{<true>}{<false>}\n\n\\newcommand*{\\ifnumcomp}[3]{%\n  \\ifnum\\numexpr#1\\relax#2\\numexpr#3\\relax\n    \\expandafter\\@firstoftwo\n  \\else\n    \\expandafter\\@secondoftwo\n  \\fi}\n\n% {<numexpr>}{<numexpr>}{<true>}{<false>}\n\n\\newcommand*{\\ifnumequal}[1]{%\n  \\ifnumcomp{#1}=}\n\n\\newcommand*{\\ifnumgreater}[1]{%\n  \\ifnumcomp{#1}>}\n\n\\newcommand*{\\ifnumless}[1]{%\n  \\ifnumcomp{#1}<}\n\n% {<numexpr>}{<true>}{<false>}\n\n\\newcommand*{\\ifnumodd}[1]{%\n  \\ifodd\\numexpr#1\\relax\n    \\expandafter\\@firstoftwo\n  \\else\n    \\expandafter\\@secondoftwo\n  \\fi}\n\n% {<dimexpr>}{<comp>}{<dimexpr>}{<true>}{<false>}\n\n\\newcommand*{\\ifdimcomp}[3]{%\n  \\ifdim\\dimexpr#1\\relax#2\\dimexpr#3\\relax\n    \\expandafter\\@firstoftwo\n  \\else\n    \\expandafter\\@secondoftwo\n  \\fi}\n\n% {<dimexpr>}{<dimexpr>}{<true>}{<false>}\n\n\\newcommand*{\\ifdimequal}[1]{%\n  \\ifdimcomp{#1}=}\n\n\\newcommand*{\\ifdimgreater}[1]{%\n  \\ifdimcomp{#1}>}\n\n\\newcommand*{\\ifdimless}[1]{%\n  \\ifdimcomp{#1}<}\n\n% {<expr>}{<true>}{<false>}\n\n\\newcommand{\\ifboolexpe}[1]{%\n  \\etb@be@beg\\etb@be@bgroup#1(&\\etb@be@end}\n\n\\let\\etb@be@true\\@empty\n\\def\\etb@be@false{-\\@ne}\n\n\\def\\etb@be@beg{%\n  \\ifnum\\numexpr\\z@\\ifnum\\numexpr\\z@}\n\n\\def\\etb@be@end{%\n  <\\z@\n    \\expandafter\\etb@be@false\n  \\fi\n  <\\z@\n    \\expandafter\\@secondoftwo\n  \\else\n    \\expandafter\\@firstoftwo\n  \\fi}\n\n\\long\\def\\etb@be@bgroup#1(#2&{%\n  \\etb@be@egroup#1)&%\n  \\ifblank{#2}\n    {}\n    {\\etb@be@beg\n     \\etb@be@bgroup#2&}}\n\n\\long\\def\\etb@be@egroup#1)#2&{%\n  \\etb@be@and#1and&%\n  \\ifblank{#2}\n    {}\n    {\\etb@be@end\\etb@be@true\\etb@be@false\n     \\etb@be@egroup#2&}}\n\n\\long\\def\\etb@be@and#1and#2&{%\n  \\etb@be@or#1or&%\n  \\ifblank{#2}\n    {}\n    {<\\z@\n       \\expandafter\\@firstofone\n     \\else\n       \\expandafter\\@gobble\n     \\fi\n     {=\\z@\\fi\\ifnum\\numexpr\\m@ne}%\n     \\ifnum\\numexpr\\z@\n     \\etb@be@and#2&}}\n\n\\long\\def\\etb@be@or#1or#2&{%\n  \\etb@be@not#1not&%\n  \\ifblank{#2}\n    {}\n    {<\\z@\n       \\expandafter\\@secondoftwo\n     \\else\n       \\expandafter\\@firstoftwo\n     \\fi\n     {=\\z@\\fi\\ifnum\\numexpr\\z@\n      \\ifnum\\numexpr\\@ne}\n     {=\\z@\\fi\\ifnum\\numexpr\\z@\n      \\ifnum\\numexpr\\z@}%\n     \\etb@be@or#2&}}\n\n\\long\\def\\etb@be@not#1not#2&{%\n  \\etb@be@togl#1togl&%\n  \\ifblank{#2}\n    {}\n    {>\\z@\n       \\expandafter\\@firstoftwo\n     \\else\n       \\expandafter\\@secondoftwo\n     \\fi\n     {\\unless\\ifnum\\numexpr\\m@ne}\n     {\\unless\\ifnum\\numexpr\\z@}%\n     \\etb@be@not#2&}}\n\n\\long\\def\\etb@be@togl#1togl#2&{%\n  \\etb@be@bool#1bool&%\n  \\ifblank{#2}\n    {}\n    {\\etb@be@togl@i#2&}}\n\n\\long\\def\\etb@be@togl@i#1#2&{%\n  \\ifcsdef{etb@tgl@#1}\n    {\\csname etb@tgl@#1\\endcsname\\etb@be@true\\etb@be@false}\n    {\\etb@be@err{Toggle '#1' undefined}{}}%\n  \\etb@be@togl#2&}\n\n\\long\\def\\etb@be@bool#1bool#2&{%\n  \\etb@be@test#1test&%\n  \\ifblank{#2}\n    {}\n    {\\etb@be@bool@i#2&}}\n\n\\long\\def\\etb@be@bool@i#1#2&{%\n  \\ifcsundef{if#1}\n    {\\etb@be@err{Boolean '#1' undefined}{}}\n    {\\csname if#1\\endcsname\n     \\else\n       \\etb@be@false\n     \\fi}%\n  \\etb@be@bool#2&}\n\n\\long\\def\\etb@be@test#1test#2&{%\n  \\ifblank{#1}\n    {}\n    {\\etb@be@err{The invalid part is: '\\detokenize{#1}'}{}}%\n  \\ifblank{#2}\n    {}\n    {\\etb@be@test@i#2&}}\n\n\\long\\def\\etb@be@test@i#1#2&{%\n  #1\\etb@be@true\\etb@be@false\n  \\etb@be@test#2&}\n\n\\long\\def\\etb@be@err#1#2{%\n  \\expandafter\\ifnum\\the\\numexpr\n    \\expandafter\\ifnum\\the\\currentiftype=-3\n      \\expandafter\\thr@@\n    \\else\n      \\expandafter\\currentiftype\n    \\fi\n  =\\thr@@\n    \\expandafter\\@firstoftwo\n  \\else\n    \\expandafter\\@secondoftwo\n  \\fi\n  {=\\z@\\fi\n   \\etb@be@err{#1}{#2\\ifnum\\numexpr\\m@ne}}\n  {\\etb@err@expr{#1}#2}}\n\n% {<expr>}{<true>}{<false>}\n\n\\newrobustcmd{\\ifboolexpr}[1]{\\etb@boolexpr{#1}}\n\n\\long\\def\\etb@boolexpr#1{%\n  \\begingroup\n  \\let\\etb@br@neg\\@firstoftwo\n  \\etb@tempcnta\\z@\n  \\etb@br@beg\n  \\etb@br@bgroup#1(&%\n  \\etb@br@end\n  \\etb@br@eval}\n\n\\def\\etb@br@beg{%\n  \\begingroup\n  \\let\\etb@br@neg\\@firstoftwo\n  \\etb@tempcnta\\z@}\n\n\\def\\etb@br@end{%\n  \\etb@br@eval\\etb@br@true\\etb@br@false}\n\n\\def\\etb@br@eval{%\n  \\ifnum\\etb@tempcnta<\\z@\n    \\aftergroup\\@secondoftwo\n  \\else\n    \\aftergroup\\@firstoftwo\n  \\fi\n  \\endgroup}\n\n\\def\\etb@br@true{%\n  \\advance\\etb@tempcnta\\etb@br@neg\\z@\\m@ne\n  \\let\\etb@br@neg\\@firstoftwo}\n\n\\def\\etb@br@false{%\n  \\advance\\etb@tempcnta\\etb@br@neg\\m@ne\\z@\n  \\let\\etb@br@neg\\@firstoftwo}\n\n\\long\\def\\etb@br@bgroup#1(#2&{%\n  \\etb@br@egroup#1)&%\n  \\ifblank{#2}\n    {}\n    {\\etb@br@beg\n     \\etb@br@bgroup#2&}}\n\n\\long\\def\\etb@br@egroup#1)#2&{%\n  \\etb@br@and#1and&%\n  \\ifblank{#2}\n    {}\n    {\\etb@br@end\n     \\etb@br@egroup#2&}}\n\n\\long\\def\\etb@br@and#1and#2&{%\n  \\etb@br@or#1or&%\n  \\ifblank{#2}\n    {}\n    {\\ifnum\\etb@tempcnta<\\z@\n       \\etb@tempcnta\\m@ne\n     \\else\n       \\etb@tempcnta\\z@\n     \\fi\n     \\etb@br@and#2&}}\n\n\\long\\def\\etb@br@or#1or#2&{%\n  \\etb@br@not#1not&%\n  \\ifblank{#2}\n    {}\n    {\\ifnum\\etb@tempcnta<\\z@\n       \\etb@tempcnta\\z@\n     \\else\n       \\etb@tempcnta\\@ne\n     \\fi\n     \\etb@br@or#2&}}\n\n\\long\\def\\etb@br@not#1not#2&{%\n  \\etb@br@togl#1togl&%\n  \\ifblank{#2}\n    {}\n    {\\let\\etb@br@neg\\@secondoftwo\n     \\etb@br@not#2&}}\n\n\\long\\def\\etb@br@togl#1togl#2&{%\n  \\etb@br@bool#1bool&%\n  \\ifblank{#2}\n    {}\n    {\\etb@br@togl@i#2&}}\n\n\\long\\def\\etb@br@togl@i#1#2&{%\n  \\ifcsdef{etb@tgl@#1}\n    {\\csname etb@tgl@#1\\endcsname\\etb@br@true\\etb@br@false}\n    {\\etb@err@expr{Toggle '#1' undefined}\\etb@br@false}%\n  \\etb@br@togl#2&}\n\n\\long\\def\\etb@br@bool#1bool#2&{%\n  \\etb@br@test#1test&%\n  \\ifblank{#2}\n    {}\n    {\\etb@br@bool@i#2&}}\n\n\\long\\def\\etb@br@bool@i#1#2&{%\n  \\ifcsundef{if#1}\n    {\\etb@err@expr{Boolean '#1' undefined}\\etb@br@false}\n    {\\csname if#1\\endcsname\n       \\etb@br@true\n     \\else\n       \\etb@br@false\n     \\fi}%\n  \\etb@br@bool#2&}\n\n\\long\\def\\etb@br@test#1test#2&{%\n  \\ifblank{#1}\n    {}\n    {\\etb@err@expr{The invalid part is: '\\detokenize{#1}'}}%\n  \\ifblank{#2}\n    {}\n    {\\etb@br@test@i#2&}}\n\n\\long\\def\\etb@br@test@i#1#2&{%\n  \\ignorespaces#1\\etb@br@true\\etb@br@false\n  \\etb@br@test#2&}\n\n\\long\\def\\etb@err@expr#1{%\n  \\etb@error\n    {Invalid boolean expression}\n    {#1.}}\n\n% {<expr>}{<code>}\n\n\\newrobustcmd{\\whileboolexpr}[2]{%\n  \\etb@boolexpr{#1}{#2\\whileboolexpr{#1}{#2}}{}}\n\n% {<expr>}{<code>}\n\n\\newrobustcmd{\\unlessboolexpr}[2]{%\n  \\etb@boolexpr{#1}{}{#2\\unlessboolexpr{#1}{#2}}}\n\n% {<cstoken>}\n\n\\newcommand{\\expandonce}[1]{%\n  \\unexpanded\\expandafter{#1}}\n\n% {<csname>}\n\n\\newcommand*{\\csexpandonce}[1]{%\n  \\expandafter\\expandonce\\csname#1\\endcsname}\n\n% {<code>}\n\n\\newcommand*{\\protecting}{}\n\\def\\protecting#{%\n  \\ifx\\protect\\@typeset@protect\n    \\etb@protecting\\@firstofone\n  \\fi\n  \\ifx\\protect\\@unexpandable@protect\n    \\etb@protecting\\etb@unexpandable\n  \\fi\n  \\ifx\\protect\\noexpand\n    \\etb@protecting\\unexpanded\n  \\fi\n  \\ifx\\protect\\string\n    \\etb@protecting\\detokenize\n  \\fi\n  \\relax\\@firstofone}\n\n\\def\\etb@protecting#1#2\\relax\\@firstofone{\\fi#1}\n\\long\\def\\etb@unexpandable#1{\\unexpanded{\\protecting{#1}}}\n\n% {<csname>}\n\n\\newrobustcmd*{\\csdef}[1]{\\expandafter\\def\\csname#1\\endcsname}\n\\newrobustcmd*{\\csedef}[1]{\\expandafter\\edef\\csname#1\\endcsname}\n\\newrobustcmd*{\\csgdef}[1]{\\expandafter\\gdef\\csname#1\\endcsname}\n\\newrobustcmd*{\\csxdef}[1]{\\expandafter\\xdef\\csname#1\\endcsname}\n\\newrobustcmd*{\\protected@csedef}{\\etb@protected\\csedef}\n\\newrobustcmd*{\\protected@csxdef}{\\etb@protected\\csxdef}\n\n\\def\\etb@protected{%\n  \\let\\@@protect\\protect\n  \\let\\protect\\@unexpandable@protect\n  \\afterassignment\\restore@protect}\n\n% {<csname>}{<cstoken>}\n\n\\newrobustcmd{\\cslet}[2]{%\n  \\expandafter\\let\\csname#1\\endcsname#2}\n\n% {<cstoken>}{<csname>}\n\n\\newrobustcmd{\\letcs}[2]{%\n  \\ifcsdef{#2}\n    {\\expandafter\\let\\expandafter#1\\csname#2\\endcsname}\n    {\\undef#1}}\n\n% {<csname>}{<csname>}\n\n\\newrobustcmd*{\\csletcs}[2]{%\n  \\ifcsdef{#2}\n    {\\expandafter\\let\n     \\csname#1\\expandafter\\endcsname\n     \\csname#2\\endcsname}\n    {\\csundef{#1}}}\n\n% {<csname>}\n\n\\newcommand*{\\csuse}[1]{%\n  \\ifcsname#1\\endcsname\n    \\csname#1\\expandafter\\endcsname\n  \\fi}\n\n% {<cstoken>}\n\n\\newrobustcmd{\\undef}[1]{\\let#1\\etb@undefined}\n\n% {<csname>}\n\n\\newrobustcmd*{\\csundef}[1]{\\cslet{#1}\\etb@undefined}\n\n% {<cstoken>}{<code>}\n\n\\newrobustcmd{\\appto}[2]{%\n  \\ifundef{#1}\n    {\\edef#1{\\unexpanded{#2}}}\n    {\\edef#1{\\expandonce#1\\unexpanded{#2}}}}\n\\newrobustcmd{\\eappto}[2]{%\n  \\ifundef{#1}\n    {\\edef#1{#2}}\n    {\\edef#1{\\expandonce#1#2}}}\n\\newrobustcmd{\\gappto}[2]{%\n  \\ifundef{#1}\n    {\\xdef#1{\\unexpanded{#2}}}\n    {\\xdef#1{\\expandonce#1\\unexpanded{#2}}}}\n\\newrobustcmd{\\xappto}[2]{%\n  \\ifundef{#1}\n    {\\xdef#1{#2}}\n    {\\xdef#1{\\expandonce#1#2}}}\n\n\\newrobustcmd*{\\protected@eappto}{\\etb@protected\\eappto}\n\\newrobustcmd*{\\protected@xappto}{\\etb@protected\\xappto}\n\n% {<cstoken>}{<code>}\n\n\\newrobustcmd{\\preto}[2]{%\n  \\ifundef{#1}\n    {\\edef#1{\\unexpanded{#2}}}\n    {\\edef#1{\\unexpanded{#2}\\expandonce#1}}}\n\\newrobustcmd{\\epreto}[2]{%\n  \\ifundef{#1}\n    {\\edef#1{#2}}\n    {\\edef#1{#2\\expandonce#1}}}\n\\newrobustcmd{\\gpreto}[2]{%\n  \\ifundef{#1}\n    {\\xdef#1{\\unexpanded{#2}}}\n    {\\xdef#1{\\unexpanded{#2}\\expandonce#1}}}\n\\newrobustcmd{\\xpreto}[2]{%\n  \\ifundef{#1}\n    {\\xdef#1{#2}}\n    {\\xdef#1{#2\\expandonce#1}}}\n\n\\newrobustcmd*{\\protected@epreto}{\\etb@protected\\epreto}\n\\newrobustcmd*{\\protected@xpreto}{\\etb@protected\\xpreto}\n\n% {<csname>}{<code>}\n\n\\newrobustcmd*{\\csappto}[1]{\\expandafter\\appto\\csname#1\\endcsname}\n\\newrobustcmd*{\\cseappto}[1]{\\expandafter\\eappto\\csname#1\\endcsname}\n\\newrobustcmd*{\\csgappto}[1]{\\expandafter\\gappto\\csname#1\\endcsname}\n\\newrobustcmd*{\\csxappto}[1]{\\expandafter\\xappto\\csname#1\\endcsname}\n\\newrobustcmd*{\\protected@cseappto}{\\etb@protected\\cseappto}\n\\newrobustcmd*{\\protected@csxappto}{\\etb@protected\\csxappto}\n\n% {<csname>}{<code>}\n\n\\newrobustcmd*{\\cspreto}[1]{\\expandafter\\preto\\csname#1\\endcsname}\n\\newrobustcmd*{\\csepreto}[1]{\\expandafter\\epreto\\csname#1\\endcsname}\n\\newrobustcmd*{\\csgpreto}[1]{\\expandafter\\gpreto\\csname#1\\endcsname}\n\\newrobustcmd*{\\csxpreto}[1]{\\expandafter\\xpreto\\csname#1\\endcsname}\n\\newrobustcmd*{\\protected@csepreto}{\\etb@protected\\csepreto}\n\\newrobustcmd*{\\protected@csxpreto}{\\etb@protected\\csxpreto}\n\n% {<cstoken>}{<numexpr>}\n\n\\newrobustcmd*{\\numdef}[2]{%\n  \\ifundef#1{\\let#1\\z@}{}%\n  \\edef#1{\\the\\numexpr#2}}\n\\newrobustcmd*{\\numgdef}[2]{%\n  \\ifundef#1{\\let#1\\z@}{}%\n  \\xdef#1{\\the\\numexpr#2}}\n\n% {<csname>}{<numexpr>}\n\n\\newrobustcmd*{\\csnumdef}[1]{%\n  \\expandafter\\numdef\\csname#1\\endcsname}\n\\newrobustcmd*{\\csnumgdef}[1]{%\n  \\expandafter\\numgdef\\csname#1\\endcsname}\n\n% {<cstoken>}{<dimexpr>}\n\n\\newrobustcmd*{\\dimdef}[2]{%\n  \\ifundef#1{\\let#1\\z@}{}%\n  \\edef#1{\\the\\dimexpr#2}}\n\\newrobustcmd*{\\dimgdef}[2]{%\n  \\ifundef#1{\\let#1\\z@}{}%\n  \\xdef#1{\\the\\dimexpr#2}}\n\n% {<csname>}{<dimexpr>}\n\n\\newrobustcmd*{\\csdimdef}[1]{%\n  \\expandafter\\dimdef\\csname#1\\endcsname}\n\\newrobustcmd*{\\csdimgdef}[1]{%\n  \\expandafter\\dimgdef\\csname#1\\endcsname}\n\n% {<cstoken>}{<glueexpr>}\n\n\\newrobustcmd*{\\gluedef}[2]{%\n  \\ifundef#1{\\let#1\\z@skip}{}%\n  \\edef#1{\\the\\glueexpr#2}}\n\\newrobustcmd*{\\gluegdef}[2]{%\n  \\ifundef#1{\\let#1\\z@skip}{}%\n  \\xdef#1{\\the\\glueexpr#2}}\n\n% {<csname>}{<glueexpr>}\n\n\\newrobustcmd*{\\csgluedef}[1]{%\n  \\expandafter\\gluedef\\csname#1\\endcsname}\n\\newrobustcmd*{\\csgluegdef}[1]{%\n  \\expandafter\\gluegdef\\csname#1\\endcsname}\n\n% {<cstoken>}{<muexpr>}\n\n\\newrobustcmd*{\\mudef}[2]{%\n  \\ifundef#1{\\def#1{0mu}}{}%\n  \\edef#1{\\the\\muexpr#2}}\n\\newrobustcmd*{\\mugdef}[2]{%\n  \\ifundef#1{\\let#1\\z@}{}%\n  \\xdef#1{\\the\\muexpr#2}}\n\n% {<csname>}{<muexpr>}\n\n\\newrobustcmd*{\\csmudef}[1]{%\n  \\expandafter\\mudef\\csname#1\\endcsname}\n\\newrobustcmd*{\\csmugdef}[1]{%\n  \\expandafter\\mugdef\\csname#1\\endcsname}\n\n% {<counter>}{<numexpr>}\n\n\\newrobustcmd*{\\defcounter}[2]{%\n  \\ifcsundef{c@#1}\n    {\\etb@noglobal\\@nocounterr{#1}}%\n    {\\csname c@#1\\endcsname\\numexpr#2\\relax}}\n\n% {<length>}{<glueexpr>}\n\n\\newrobustcmd*{\\deflength}[2]{%\n  \\ifundef{#1}\n    {\\etb@noglobal\\etb@err@nolen{#1}}%\n    {#1\\glueexpr#2\\relax}}\n\n\\protected\\def\\etb@err@nolen#1{%\n  \\etb@error{Length '\\string#1' undefined}\\@eha}\n\n% {<name>}\n\n\\newrobustcmd*{\\newbool}[1]{%\n  \\expandafter\\@ifdefinable\\csname if#1\\endcsname{%\n    \\expandafter\\newif\\csname if#1\\endcsname}}\n\n% {<name>}\n\n\\newrobustcmd*{\\providebool}[1]{%\n  \\ifcsundef{if#1}\n    {\\expandafter\\newif\\csname if#1\\endcsname}\n    {\\begingroup\n     \\edef\\@tempa{\\expandafter\\meaning\\csname if#1\\endcsname}%\n     \\ifx\\@tempa\\etb@isfalse\n     \\else\n       \\ifx\\@tempa\\etb@istrue\n       \\else\n         \\etb@error{\\@backslashchar if#1 not a boolean}\\@eha\n       \\fi\n     \\fi\n     \\endgroup}}\n\n% {<name>}{<true>|<false>}\n\n\\newrobustcmd*{\\setbool}[2]{%\n  \\ifcsundef{if#1}\n    {\\etb@noglobal\\etb@err@nobool{#1}}\n    {\\ifcsundef{#1#2}\n       {\\etb@noglobal\\etb@err@boolval{#2}}\n       {\\csname#1#2\\endcsname}}}\n\n% {<name>}\n\n\\newrobustcmd*{\\booltrue}[1]{%\n  \\ifcsundef{if#1}\n    {\\etb@noglobal\\etb@err@nobool{#1}}\n    {\\csname#1true\\endcsname}}\n\n% {<name>}\n\n\\newrobustcmd*{\\boolfalse}[1]{%\n  \\ifcsundef{if#1}\n    {\\etb@noglobal\\etb@err@nobool{#1}}\n    {\\csname#1false\\endcsname}}\n\n\\edef\\etb@istrue{\\meaning\\iftrue}\n\\edef\\etb@isfalse{\\meaning\\iffalse}\n\\protected\\def\\etb@noglobal{\\let\\relax\\relax}\n\n% {<name>}{<true}{<false>}\n\n\\newcommand*{\\ifbool}[1]{%\n  \\ifcsundef{if#1}\n    {\\etb@err@nobool{#1}\\@gobbletwo}\n    {\\csname if#1\\endcsname\n       \\expandafter\\@firstoftwo\n     \\else\n       \\expandafter\\@secondoftwo\n     \\fi}}\n\n% {<name>}{<not true}{<not false>}\n\n\\newcommand*{\\notbool}[1]{%\n  \\ifcsundef{if#1}\n    {\\etb@err@nobool{#1}\\@gobbletwo}\n    {\\csname if#1\\endcsname\n       \\expandafter\\@secondoftwo\n     \\else\n       \\expandafter\\@firstoftwo\n     \\fi}}\n\n\\protected\\def\\etb@err@nobool#1{%\n  \\etb@error{Boolean '\\@backslashchar if#1' undefined}\\@eha}\n\n\\def\\etb@err@boolval#1{%\n  \\etb@error\n    {Invalid boolean value '#1'}\n    {Valid boolean values are 'true' and 'false'.}}\n\n% {<name>}\n\n\\newrobustcmd*{\\newtoggle}[1]{%\n  \\ifcsdef{etb@tgl@#1}\n    {\\etb@error{Toggle '#1' already defined}\\@eha}\n    {\\cslet{etb@tgl@#1}\\@secondoftwo}}\n\n% {<name>}\n\n\\newrobustcmd*{\\providetoggle}[1]{%\n  \\ifcsdef{etb@tgl@#1}\n    {}\n    {\\cslet{etb@tgl@#1}\\@secondoftwo}}\n\n% {<name>}{<true>|<false>}\n\n\\newrobustcmd*{\\settoggle}[2]{%\n  \\ifcsdef{etb@tgl@#1}\n    {\\ifcsdef{etb@toggle#2}\n       {\\csletcs{etb@tgl@#1}{etb@toggle#2}}\n       {\\etb@noglobal\\etb@err@boolval{#2}}}\n    {\\etb@noglobal\\etb@err@notoggle{#1}}}\n\n% {<name>}\n\n\\newrobustcmd*{\\toggletrue}[1]{%\n  \\ifcsdef{etb@tgl@#1}\n    {\\cslet{etb@tgl@#1}\\etb@toggletrue}\n    {\\etb@noglobal\\etb@err@notoggle{#1}}}\n\n% {<name>}\n\n\\newrobustcmd*{\\togglefalse}[1]{%\n  \\ifcsdef{etb@tgl@#1}\n    {\\cslet{etb@tgl@#1}\\etb@togglefalse}\n    {\\etb@noglobal\\etb@err@notoggle{#1}}}\n\n\\let\\etb@toggletrue\\@firstoftwo\n\\let\\etb@togglefalse\\@secondoftwo\n\n% {<name>}{<true}{<false>}\n\n\\newcommand*{\\iftoggle}[1]{%\n  \\ifcsdef{etb@tgl@#1}\n    {\\csname etb@tgl@#1\\endcsname}\n    {\\etb@err@notoggle{#1}\\@gobbletwo}}\n\n% {<name>}{<not true}{<not false>}\n\n\\newcommand*{\\nottoggle}[1]{%\n  \\ifcsdef{etb@tgl@#1}\n    {\\csname etb@tgl@#1\\endcsname\\@secondoftwo\\@firstoftwo}\n    {\\etb@err@notoggle{#1}\\@gobbletwo}}\n\n\\protected\\def\\etb@err@notoggle#1{%\n  \\etb@error{Toggle '#1' undefined}\\@eha}\n\n% {<cstoken>}{<true}{<false>}\n\n\\protected\\def\\etb@ifscanable#1{%\n  \\begingroup\n  \\edef\\etb@resrvda{%\n    \\def\\noexpand\\etb@resrvda####1\\detokenize{macro}:####2->####3&{%\n      ####1\\def\\string\\etb@resrvda####2{####3}}%\n    \\edef\\noexpand\\etb@resrvda{\\noexpand\\etb@resrvda\\meaning#1&}}%\n  \\etb@resrvda\n  \\makeatletter\n  \\scantokens\\expandafter{\\etb@resrvda}%\n  \\expandafter\\endgroup\\ifx#1\\etb@resrvda\n    \\expandafter\\@firstoftwo\n  \\else\n    \\expandafter\\@secondoftwo\n  \\fi}\n\n% {<cstoken>}{<search>}{<true}{<false>}\n\n\\protected\\long\\def\\etb@ifpattern#1#2{%\n  \\begingroup\n  \\edef\\etb@resrvda{%\n    \\def\\noexpand\\etb@resrvda####1\\detokenize{#2}####2&{%\n      \\endgroup\\noexpand\\noexpand\\noexpand\\ifblank{####2}}%\n    \\edef\\noexpand\\etb@resrvda{\\noexpand\\etb@resrvda\n      \\expandafter\\strip@prefix\\meaning#1\\detokenize{#2}&}%\n    \\noexpand\\etb@resrvda}\n  \\etb@resrvda\\@secondoftwo\\@firstoftwo}\n\n% {<string>}{<true}{<false>}\n\n\\protected\\long\\def\\etb@ifhashcheck#1{%\n  \\begingroup\n  \\edef\\etb@resrvda{\\detokenize{#1}}%\n  \\expandafter\\endgroup\n  \\expandafter\\etb@ifhashcheck@i\\meaning\\etb@resrvda&}\n\n\\edef\\etb@ifhashcheck@i#1&{%\n  \\noexpand\\expandafter\n  \\noexpand\\etb@ifhashcheck@ii\n  \\noexpand\\strip@prefix#1\\string#\\string#&}\n\n\\edef\\etb@ifhashcheck@ii{%\n  \\def\\noexpand\\etb@ifhashcheck@ii##1\\string#\\string###2&}\n\\etb@ifhashcheck@ii{\\ifblank{#2}}\n\n% {<cstoken>}\n\n\\newrobustcmd*{\\robustify}[1]{%\n  \\ifundef{#1}\n    {\\etb@error{\\string#1 undefined}\\@eha}\n    {\\ifdefmacro{#1}\n       {\\ifdefltxprotect{#1}\n          {\\letcs\\etb@resrvda{\\expandafter\\@gobble\\string#1 }%\n           \\@tempswatrue}\n          {\\let\\etb@resrvda#1%\n           \\@tempswafalse}%\n        \\ifdefparam\\etb@resrvda\n          {\\etb@ifscanable\\etb@resrvda\n             {\\etb@robustify\\etb@resrvda\n              \\let#1\\etb@resrvda}\n             {\\etb@error{Failed to robustify \\string#1}\n                {The command is special and cannot be\n                 handled by \\string\\robustify.}%\n              \\@tempswafalse}}\n          {\\protected\\edef#1{\\expandonce\\etb@resrvda}}\n        \\if@tempswa\n          \\ifcsdef{\\string#1 }\n            {}\n            {\\csundef{\\expandafter\\@gobble\\string#1 }}%\n        \\fi\n        \\undef\\etb@resrvda}\n       {\\etb@error{\\string#1 not a macro}\\@eha}}}\n\n\\def\\etb@robustify#1{%\n  \\begingroup\n  \\edef\\etb@resrvdb{%\n    \\def\\noexpand\\etb@resrvdb####1\\detokenize{macro}:####2->####3&{%\n      \\protected####1\\def\\string#1\\space####2{####3}}%\n    \\edef\\noexpand\\etb@resrvdb{%\n      \\noexpand\\etb@resrvdb\\meaning#1&}}%\n  \\etb@resrvdb\n  \\etb@patchcmd@scantoks\\etb@resrvdb}\n\n%  {<cstoken>}{<search>}{<true}{<false>}\n% *{<cstoken>}{<true}{<false>}\n\n\\newrobustcmd{\\ifpatchable}{%\n  \\etb@dbg@trce\\ifpatchable\n  \\begingroup\n  \\@makeother\\#%\n  \\@ifstar\\etb@ifpatchable@i\\etb@ifpatchable}\n\n\\long\\def\\etb@ifpatchable#1#2{%\n  \\endgroup\n  \\etb@dbg@init#1%\n  \\ifundef{#1}\n    {\\etb@dbg@fail{def}\\@secondoftwo}\n    {\\etb@dbg@info{def}%\n     \\ifdefmacro{#1}\n       {\\etb@dbg@info{mac}%\n        \\etb@ifscanable{#1}\n          {\\etb@ifhashcheck{#2}\n             {\\etb@dbg@info{tok}%\n              \\etb@ifpattern#1{#2}\n                 {\\etb@dbg@info{pat}%\n                  \\etb@dbg@info{pos}\\@firstoftwo}\n                 {\\etb@dbg@fail{pat}\\@secondoftwo}}\n             {\\etb@dbg@fail{hsh}\\@secondoftwo}}\n          {\\etb@dbg@fail{tok}\\@secondoftwo}}\n       {\\etb@dbg@fail{mac}\\@secondoftwo}}}\n\n\\long\\def\\etb@ifpatchable@i#1{%\n  \\endgroup\n  \\etb@dbg@init#1%\n  \\ifundef{#1}\n    {\\etb@dbg@fail{def}\\@secondoftwo}\n    {\\etb@dbg@info{def}%\n     \\ifdefmacro{#1}\n       {\\etb@dbg@info{mac}%\n        \\ifdefparam{#1}\n          {\\etb@dbg@info{prm}%\n           \\etb@ifscanable{#1}\n             {\\etb@dbg@info{tok}%\n              \\etb@dbg@info{pos}\\@firstoftwo}\n             {\\etb@dbg@fail{tok}\\@secondoftwo}}\n          {\\etb@dbg@info{prl}%\n           \\ifdefprotected{#1}\n             {\\etb@dbg@info{pro}}\n             {}%\n           \\etb@dbg@info{pos}\\@firstoftwo}}\n       {\\etb@dbg@fail{mac}\\@secondoftwo}}}\n\n% [<prefix>]{<cstoken>}{<search>}{<replace>}{<success>}{<failure>}\n\n\\newrobustcmd*{\\patchcmd}{%\n  \\etb@dbg@trce\\patchcmd\n  \\begingroup\n  \\@makeother\\#%\n  \\etb@patchcmd}\n\n\\newcommand{\\etb@patchcmd}[4][########1]{%\n  \\etb@ifpatchable#2{#3}\n    {\\etb@dbg@succ{ret}%\n     \\begingroup\n     \\edef\\etb@resrvda{%\n       \\def\\noexpand\\etb@resrvda####1\\detokenize{macro:}####2->####3&{%\n         #1\\def\\string\\etb@resrvda\\space####2{\\noexpand\\etb@resrvdb####3&}}%\n       \\def\\noexpand\\etb@resrvdb####1\\detokenize{#3}####2&{%\n         ####1\\detokenize{#4}####2}%\n       \\edef\\noexpand\\etb@resrvda{%\n         \\noexpand\\etb@resrvda\\meaning#2&}}%\n     \\etb@resrvda\n     \\etb@patchcmd@scantoks\\etb@resrvda\n     \\let#2\\etb@resrvda\n     \\undef\\etb@resrvda\n     \\@firstoftwo}\n    {\\@secondoftwo}}\n\n\\def\\etb@patchcmd@scantoks#1{%\n  \\edef\\etb@resrvda{\\endgroup\n    \\unexpanded{\\makeatletter\\scantokens}{#1}%\n    \\catcode\\number`\\@=\\the\\catcode`\\@\\relax}%\n  \\etb@resrvda}\n\n% {<cstoken>}{<code>}{<success>}{<failure>}\n\n\\newrobustcmd*{\\apptocmd}{%\n  \\etb@dbg@trce\\apptocmd\n  \\begingroup\n  \\@makeother\\#%\n  \\etb@hooktocmd\\etb@append}\n\n\\newrobustcmd*{\\pretocmd}{%\n  \\etb@dbg@trce\\pretocmd\n  \\begingroup\n  \\@makeother\\#%\n  \\etb@hooktocmd\\etb@prepend}\n\n\\long\\def\\etb@hooktocmd#1#2#3{%\n  \\endgroup\n  \\etb@dbg@init#2%\n  \\ifundef{#2}\n    {\\etb@dbg@fail{def}\\@secondoftwo}\n    {\\etb@dbg@info{def}%\n     \\ifdefmacro{#2}\n       {\\etb@dbg@info{mac}%\n        \\ifdefparam{#2}\n          {\\etb@dbg@info{prm}%\n           \\etb@ifscanable{#2}\n             {\\etb@ifhashcheck{#3}\n                {\\etb@dbg@info{tok}%\n                 \\etb@dbg@succ{ret}%\n                 \\etb@hooktocmd@i#1#2{#3}%\n                 \\@firstoftwo}\n                {\\etb@dbg@fail{hsh}\\@secondoftwo}}\n             {\\etb@dbg@fail{tok}\\@secondoftwo}}\n          {\\etb@dbg@info{prl}%\n           \\ifdefprotected{#2}\n             {\\etb@dbg@info{pro}%\n              \\etb@dbg@succ{red}%\n              \\protected}\n             {\\etb@dbg@succ{red}}%\n           \\edef#2{#1{\\expandonce#2}{\\unexpanded{#3}}}%\n           \\@firstoftwo}}\n       {\\etb@dbg@fail{mac}\\@secondoftwo}}}\n\n\\long\\def\\etb@hooktocmd@i#1#2#3{%\n  \\begingroup\n  \\edef\\etb@resrvda{%\n    \\def\\noexpand\\etb@resrvda####1\\detokenize{macro}:####2->####3&{%\n      ####1\\def\\string\\etb@resrvda\\space####2{#1{####3}{\\detokenize{#3}}}}%\n    \\edef\\noexpand\\etb@resrvda{%\n      \\noexpand\\etb@resrvda\\meaning#2&}}%\n  \\etb@resrvda\n  \\etb@patchcmd@scantoks\\etb@resrvda\n  \\let#2\\etb@resrvda\n  \\undef\\etb@resrvda}\n\n\\long\\def\\etb@append#1#2{#1#2}\n\\long\\def\\etb@prepend#1#2{#2#1}\n\n\\newrobustcmd*{\\tracingpatches}{%\n  \\etb@info{Enabling tracing}%\n  \\input{etoolbox.def}%\n  \\global\\let\\tracingpatches\\relax}\n\\@onlypreamble\\tracingpatches\n\n\\let\\etb@dbg@trce\\@gobble\n\\let\\etb@dbg@init\\@gobble\n\\let\\etb@dbg@info\\@gobble\n\\let\\etb@dbg@succ\\@gobble\n\\let\\etb@dbg@fail\\@gobble\n\n% {<numeral>}\n\n\\newcommand{\\rmntonum}[1]{%\n  \\ifblank{#1}\n    {}\n    {\\expandafter\\etb@rti@end\\number\\numexpr\n     \\expandafter\\etb@rti@prs\\detokenize{#1}&\\relax}}\n\n\\def\\etb@rti@prs#1#2{%\n  \\ifx&#1%\n    \\expandafter\\@firstoftwo\n  \\else\n    \\expandafter\\@secondoftwo\n  \\fi\n  {#1#2}\n  {\\ifx&#2%\n     \\expandafter\\@firstoftwo\n   \\else\n     \\expandafter\\@secondoftwo\n   \\fi\n   {\\etb@rti@chk#1+\\etb@rti@num#1#2}\n   {\\etb@rti@chk#1\\etb@rti@chk#2%\n    \\ifnum\\etb@rti@num#1<\\etb@rti@num#2 %\n      \\expandafter\\@firstoftwo\n    \\else\n      \\expandafter\\@secondoftwo\n    \\fi\n    {+\\etb@rti@num#2-\\etb@rti@num#1\\etb@rti@prs}\n    {+\\etb@rti@num#1\\etb@rti@prs#2}}}}\n\n\\def\\etb@rti@chk#1{%\n  \\ifcsname etb@rmn@#1\\endcsname\n  \\else\n    \\expandafter\\etb@rti@brk\n  \\fi}\n\n\\def\\etb@rti@brk#1&{+\\z@&-1}\n\\def\\etb@rti@end#1&#2\\relax{\\ifblank{#2}{#1}{#2}}\n\\def\\etb@rti@num#1{\\csname etb@rmn@#1\\endcsname}\n\n\\chardef\\etb@rmn@i=1\n\\chardef\\etb@rmn@I=1\n\\chardef\\etb@rmn@v=5\n\\chardef\\etb@rmn@V=5\n\\chardef\\etb@rmn@x=10\n\\chardef\\etb@rmn@X=10\n\\chardef\\etb@rmn@l=50\n\\chardef\\etb@rmn@L=50\n\\chardef\\etb@rmn@c=100\n\\chardef\\etb@rmn@C=100\n\\mathchardef\\etb@rmn@d=500\n\\mathchardef\\etb@rmn@D=500\n\\mathchardef\\etb@rmn@m=1000\n\\mathchardef\\etb@rmn@M=1000\n\n% {<numeral>}{<true>}{<false>}\n\n\\newcommand{\\ifrmnum}[1]{%\n  \\ifblank{#1}\n    {\\@secondoftwo}\n    {\\expandafter\\etb@ifr@prs\\detokenize{#1}\\relax}}\n\n\\def\\etb@ifr@prs#1{%\n  \\ifx\\relax#1%\n    \\expandafter\\@firstoftwo\n  \\else\n    \\ifcsname etb@rmn@#1\\endcsname\n      \\expandafter\\expandafter\n      \\expandafter\\etb@ifr@prs\n    \\else\n      \\expandafter\\expandafter\n      \\expandafter\\etb@ifr@brk\n    \\fi\n  \\fi}\n\n\\def\\etb@ifr@brk#1\\relax{\\@secondoftwo}\n\n% <*>{<command>}{<separator>}\n\n\\newrobustcmd*{\\DeclareListParser}{%\n  \\@ifstar\n    {\\etb@defparser\\etb@defparser@arg}\n    {\\etb@defparser\\etb@defparser@do}}\n\n\\def\\etb@defparser#1#2#3{%\n  \\@ifdefinable#2{#1{#2}{#3}}}\n\n\\def\\etb@defparser@do#1#2{%\n  \\begingroup\n  \\edef\\@tempa{\\endgroup\n    \\long\\def\\noexpand#1####1{%\n      \\expandafter\\noexpand\n      \\csname etb@lst@\\expandafter\\@gobble\\string#1\\endcsname\n      \\space####1\\noexpand#2&}%\n    \\long\\csdef{etb@lst@\\expandafter\\@gobble\\string#1}####1\\noexpand#2####2&{%\n      \\noexpand\\etb@listitem\\noexpand\\do{####1}%\n      \\noexpand\\ifblank{####2}\n        {\\noexpand\\listbreak}\n        {\\expandafter\\noexpand\n         \\csname etb@lst@\\expandafter\\@gobble\\string#1\\endcsname\n\t \\space####2}&}}%\n  \\@tempa}\n\n\\def\\etb@defparser@arg#1#2{%\n  \\begingroup\n  \\edef\\@tempa{\\endgroup\n    \\long\\def\\noexpand#1####1####2{%\n      \\expandafter\\noexpand\n      \\csname etb@lst@\\expandafter\\@gobble\\string#1\\endcsname\n      {####1}\\space####2\\noexpand#2&}%\n    \\long\\csdef{etb@lst@\\expandafter\\@gobble\\string#1}####1####2\\noexpand#2####3&{%\n      \\noexpand\\etb@listitem{####1}{####2}%\n      \\noexpand\\ifblank{####3}\n        {\\noexpand\\listbreak}\n        {\\expandafter\\noexpand\n         \\csname etb@lst@\\expandafter\\@gobble\\string#1\\endcsname\n\t {####1}\\space####3}&}}%\n  \\@tempa}\n\n\\long\\def\\etb@listitem#1#2{%\n  \\ifblank{#2}\n    {}\n    {\\expandafter\\etb@listitem@i\n     \\expandafter{\\@firstofone#2}{#1}}}\n\\long\\def\\etb@listitem@i#1#2{#2{#1}}\n\n\\newcommand*{\\listbreak}{}\n\\long\\def\\listbreak#1&{}\n\n% {<item1>,<item2>,...} => \\do{<item1>}\\do{<item2>}...\n\n\\DeclareListParser{\\docsvlist}{,}\n\n% {<handler>}{<item1>,<item2>,...} => <handler>{<item1>}<handler>{<item2>}...\n\n\\DeclareListParser*{\\forcsvlist}{,}\n\n% {<listmacro>}{<string>}\n\n\\newrobustcmd{\\listadd}[2]{%\n  \\ifblank{#2}{}{\\appto#1{#2|}}}\n\\newrobustcmd{\\listeadd}[2]{%\n  \\begingroup\n  \\edef\\etb@tempa{\\endgroup\\noexpand\\ifblank{#2}}%\n  \\etb@tempa{}{\\eappto#1{#2|}}}\n\\newrobustcmd{\\listgadd}[2]{%\n  \\ifblank{#2}{}{\\gappto#1{#2|}}}\n\\newrobustcmd{\\listxadd}[2]{%\n  \\begingroup\n  \\edef\\etb@tempa{\\endgroup\\noexpand\\ifblank{#2}}%\n  \\etb@tempa{}{\\xappto#1{#2|}}}\n\n% {<listcsname>}{<string>}\n\n\\newrobustcmd{\\listcsadd}[1]{%\n  \\expandafter\\listadd\\csname#1\\endcsname}\n\\newrobustcmd{\\listcseadd}[1]{%\n  \\expandafter\\listeadd\\csname#1\\endcsname}\n\\newrobustcmd{\\listcsgadd}[1]{%\n  \\expandafter\\listgadd\\csname#1\\endcsname}\n\\newrobustcmd{\\listcsxadd}[1]{%\n  \\expandafter\\listxadd\\csname#1\\endcsname}\n\n% {<string>}{<listmacro>}{<true>}{<false>}\n\n\\newrobustcmd{\\ifinlist}[2]{%\n  \\begingroup\n  \\def\\etb@tempa##1|#1|##2&{\\endgroup\n    \\ifblank{##2}\\@secondoftwo\\@firstoftwo}%\n  \\expandafter\\etb@tempa\\expandafter|#2|#1|&}\n\n\\newrobustcmd{\\xifinlist}[1]{%\n  \\begingroup\n  \\edef\\etb@tempa{\\endgroup\\ifinlist{#1}}%\n  \\etb@tempa}\n\n% {<string>}{<listcsname>}{<true>}{<false>}\n\n\\newrobustcmd{\\ifinlistcs}[2]{%\n  \\expandafter\\etb@ifinlistcs@i\\csname #2\\endcsname{#1}}\n\\long\\def\\etb@ifinlistcs@i#1#2{\\ifinlist{#2}{#1}}\n\n\\newrobustcmd{\\xifinlistcs}[1]{%\n  \\begingroup\n  \\edef\\etb@tempa{\\endgroup\\ifinlistcs{#1}}%\n  \\etb@tempa}\n\n% {<handler>}{<listmacro>} => <handler>{<item1>}<handler>{<item2>}...\n\n\\newcommand*{\\forlistloop}[2]{%\n  \\expandafter\\etb@forlistloop\\expandafter{#2}{#1}}\n\n\\long\\def\\etb@forlistloop#1#2{\\etb@forlistloop@i{#2}#1|&}\n\n\\long\\def\\etb@forlistloop@i#1#2|#3&{%\n  \\ifblank{#2}\n    {}\n    {#1{#2}}%\n  \\ifblank{#3}\n    {\\listbreak}\n    {\\etb@forlistloop@i{#1}#3}%\n  &}\n\n% {<handler>}{<listcsname>} => <handler>{<item1>}<handler>{<item2>}...\n\n\\newcommand*{\\forlistcsloop}[2]{%\n  \\expandafter\\expandafter\\expandafter\\etb@forlistloop\n  \\expandafter\\expandafter\\expandafter{\\csname#2\\endcsname}{#1}}\n\n% {<listmacro>} => \\do{<item1>}\\do{<item2>}...\n\n\\newcommand*{\\dolistloop}{\\forlistloop\\do}\n\n% {<listcsname>} => \\do{<item1>}\\do{<item2>}...\n\n\\newcommand*{\\dolistcsloop}{\\forlistcsloop\\do}\n\n% {<code>}\n\n\\newrobustcmd*{\\AtEndPreamble}{\\gappto\\@endpreamblehook}\n\\newcommand*{\\@endpreamblehook}{}\n\n\\preto\\document{%\n  \\endgroup\n  \\let\\AtEndPreamble\\@firstofone\n  \\@endpreamblehook\n  \\protected\\def\\AtEndPreamble{\\@notprerr\\@gobble}%\n  \\undef\\@endpreamblehook\n  \\begingroup}\n\n% {<code>}\n\n\\newrobustcmd*{\\AfterPreamble}{\\AtBeginDocument}\n\\AtEndPreamble{\\let\\AfterPreamble\\@firstofone}\n\n% {<code>}\n\n\\newrobustcmd*{\\AfterEndPreamble}{\\gappto\\@afterendpreamblehook}\n\\newcommand*{\\@afterendpreamblehook}{}\n\n\\appto\\document{%\n  \\let\\AfterEndPreamble\\@firstofone\n  \\@afterendpreamblehook\n  \\protected\\def\\AfterEndPreamble{\\@notprerr\\@gobble}%\n  \\undef\\@afterendpreamblehook\n  \\ignorespaces}\n\n\\AtEndDocument{\\let\\AfterEndPreamble\\@gobble}\n\n% {<code>}\n\n\\newrobustcmd*{\\AfterEndDocument}{\\gappto\\@afterenddocumenthook}\n\\newcommand*{\\@afterenddocumenthook}{}\n\n\\patchcmd\\enddocument\n  {\\deadcycles}\n  {\\let\\AfterEndDocument\\@firstofone\n   \\@afterenddocumenthook\n   \\deadcycles}\n  {}\n  {\\let\\etb@@end\\@@end\n   \\def\\@@end{%\n     \\let\\AfterEndDocument\\@firstofone\n     \\@afterenddocumenthook\n     \\etb@@end}}\n\n% {<environment>}{<code>}\n\n\\newrobustcmd{\\AtBeginEnvironment}[1]{%\n  \\csgappto{@begin@#1@hook}}\n\n\\patchcmd\\begin\n  {\\csname #1\\endcsname}\n  {\\csuse{@begin@#1@hook}%\n   \\csname #1\\endcsname}\n  {}\n  {\\etb@warning{%\n     Patching '\\string\\begin' failed!\\MessageBreak\n     '\\string\\AtBeginEnvironment' will not work\\@gobble}}\n\n% {<environment>}{<code>}\n\n\\newrobustcmd{\\AtEndEnvironment}[1]{%\n  \\csgappto{@end@#1@hook}}\n\n\\patchcmd\\end\n  {\\csname end#1\\endcsname}\n  {\\csuse{@end@#1@hook}%\n   \\csname end#1\\endcsname}\n  {}\n  {\\etb@warning{%\n     Patching '\\string\\end' failed!\\MessageBreak\n     '\\string\\AtEndEnvironment' will not work\\@gobble}}\n\n% {<environment>}{<code>}\n\n\\newrobustcmd{\\BeforeBeginEnvironment}[1]{%\n  \\csgappto{@beforebegin@#1@hook}}\n\n\\pretocmd\\begin\n  {\\csuse{@beforebegin@#1@hook}}\n  {}\n  {\\etb@warning{%\n     Patching '\\string\\begin' failed!\\MessageBreak\n     '\\string\\BeforeBeginEnvironment' will not work\\@gobble}}\n\n% {<environment>}{<code>}\n\n\\newrobustcmd{\\AfterEndEnvironment}[1]{%\n  \\csgappto{@afterend@#1@hook}}\n\n\\patchcmd\\end\n  {\\if@ignore}\n  {\\csuse{@afterend@#1@hook}%\n   \\if@ignore}\n  {}\n  {\\etb@warning{%\n     Patching '\\string\\end' failed!\\MessageBreak\n     '\\string\\AfterEndEnvironment' will not work\\@gobble}}\n\n\\endinput\n"
p0
.I0
.S'Slunits'
p0
.S'$style_file: Slunits\n%%\n%% This is file `SIunits.sty\',\n%% generated with the docstrip utility.\n%%\n%% The original source files were:\n%%\n%% SIunits.dtx  (with options: `package\')\n%% \n%% Copyright (c) 1998-2002 Marcel Heldoorn <m.heldoorn@webschool.nl>.\n%% \n%% This program may be distributed and/or modified under the conditions of the LaTeX Project\n%% Public License, either version 1.2 of this license or (at your option) any later version.\n%% The latest version of this license is in http://www.latex-project.org/lppl.txt and\n%% version 1.2 or later is part of all distributions of LaTeX version 1999/12/01 or later.\n%% \n%% For error reports in case of UNCHANGED versions see the readme.txt file.\n%% \n%% Please do not request updates from me directly. Distribution is done through the\n%% Comprehensive TeX Archive Network (CTAN).\n%% \n\\def\\SIunits@RCS$#1: #2 #3${#2}\n\\def\\filename{SIunits.dtx}%Source File Name\n\\xdef\\fileversion{\\SIunits@RCS$Revision: 1.1.1.1 $}%Revision generated by CS-RCS\n\\xdef\\filedate{\\SIunits@RCS$Date: 2003/02/26 03:15:34 $}%Date generated by CS-RCS\n\\let\\docversion=\\fileversion\n\\let\\docdate=\\filedate\n\\NeedsTeXFormat{LaTeX2e}[1997/12/01]\n\\ProvidesPackage{SIunits}\n  [\\filedate\\space v\\fileversion\\space\n     Support for the International System of units (MH)]\n \\def\\packagemessage{}\n\\typeout{\\packagemessage}\n\\newif\\if@redefsquare\\@redefsquarefalse\n\\newif\\if@defsquaren\\@defsquarenfalse\n\\newif\\if@redefGray\\@redefGrayfalse\n\\newif\\if@defGray\\@defGrayfalse\n\\newif\\if@textstyle\\@textstylefalse\n\\newif\\if@optionbinary\\@optionbinaryfalse\n\\newif\\if@optionNoAMS\\@optionNoAMSfalse\n\\newif\\if@inunitcommand\\@inunitcommandfalse\n\\newlength{\\@qskwidth}\n\\newif\\if@defitalian\\@defitalianfalse\n\\DeclareRobustCommand\\SI@fstyle[1]{\\mathrm{#1}}\n\\DeclareTextSymbolDefault{\\SImu}{TS1}\n\\DeclareTextSymbol{\\SImu}{TS1}{181} % micro sign\n\\DeclareFontEncoding{TS1}{}{}\n\\DeclareFontSubstitution{TS1}{cmr}{m}{n}\n\\DeclareFontFamily{OML}{eur}{\\skewchar\\font127} \\DeclareFontShape{OML}{eur}{m}{n}{<5> <6>\n                <7> <8> <9> gen * eurm <10><10.95><12><14.4><17.28><20.74><24.88>eurm10}{}\n\\DeclareSymbolFont{greek}{OML}{eur}{m}{n}\n\\DeclareMathSymbol{\\upmu}{\\mathord}{greek}{"16}\n\\newcommand*\\SIunits[1][thickspace,thickqspace]{\\@for\\SIunits@@:=#1%\n  \\do{\\SIunits@execopt\\SIunits@@}}\n\\newcommand*\\SIunits@execopt[1]{\\@ifundefined{SIunits@opt@#1}%\n  {\\PackageWarning{SIunits}{Requested option `#1\' not provided}}%\n  {\\@nameuse{SIunits@opt@#1}}}\n\\newcommand*\\SIunits@opt@thickspace{%\n  \\@thickspace{runtime option `thickspace\' provided!}}\n\\newcommand*\\SIunits@opt@mediumspace{%\n  \\@mediumspace{runtime option `mediumspace\' provided!}}\n\\newcommand*\\SIunits@opt@thinspace{%\n  \\@thinspace{runtime option `thinspace\' provided!}}\n\\newcommand*\\SIunits@opt@cdot{%\n  \\@cdot{runtime option `cdot\' provided!}}\n\\newcommand*\\SIunits@opt@thickqspace{%\n  \\@thickqspace{runtime option `thickqspace\' provided!}}\n\\newcommand*\\SIunits@opt@mediumqspace{%\n  \\@mediumqspace{runtime option `mediumqspace\' provided!}}\n\\newcommand*\\SIunits@opt@thinqspace{%\n  \\@thinqspace{runtime option `thinqspace\' provided!}}\n\\DeclareRobustCommand{\\@text}{%\n  \\ifmmode\\expandafter\\@text@\\else\\expandafter\\mbox\\fi}\n\\let\\nfss@text\\@text%\n\\def\\@text@#1{\\mathchoice%\n  {\\textdef@\\displaystyle\\f@size{#1}}%\n  {\\textdef@\\textstyle\\tf@size{\\firstchoice@false #1}}%\n  {\\textdef@\\textstyle\\sf@size{\\firstchoice@false #1}}%\n  {\\textdef@\\textstyle\\ssf@size{\\firstchoice@false #1}}%\n  \\check@mathfonts}%\n\\def\\textdef@#1#2#3{\\hbox{{%\n                    \\everymath{#1}%\n                    \\let\\f@size#2\\selectfont%\n                    #3}}}%\n\\newif\\iffirstchoice@%\n\\firstchoice@true%\n\\def\\stepcounter#1{%\n  \\iffirstchoice@%\n     \\addtocounter{#1}\\@ne%\n     \\begingroup \\let\\@elt\\@stpelt \\csname cl@#1\\endcsname \\endgroup\n  \\fi%\n}%\n\\DeclareRobustCommand*{\\meter}{\\metre}\n\\DeclareRobustCommand*{\\deka}{\\deca}\n\\DeclareRobustCommand*{\\dekad}{\\decad}\n\\DeclareRobustCommand*{\\NoAMS}{\\addprefix{\\micro}{\\mbox{\\SImu}}}\n\\DeclareRobustCommand{\\addunit}[2]{\\newcommand{#1}{\\ensuremath{\\SI@fstyle{#2}}}}\n\\DeclareRobustCommand{\\addprefix}[2]{\\newcommand{#1}{\\ensuremath{\\SI@fstyle{#2}}}}\n\\DeclareRobustCommand*{\\unitskip}[1]{\\renewcommand{\\usk}{\\ensuremath{#1}}}\n\\DeclareRobustCommand*{\\quantityskip}[1]{\\renewcommand{\\@qsk}{\\ensuremath{#1}}}\n\\DeclareRobustCommand*{\\per}{\\ensuremath{\\SI@fstyle{/}}}\n\\DeclareRobustCommand*{\\usk}{\\ensuremath{\\;}}\n\\DeclareRobustCommand*{\\@qsk}{\\ensuremath{\\;}}\n\\renewcommand{\\cdot}{\\,\\mbox{\\textperiodcentered}\\,}\n\\newcommand{\\@cdot}[1]{\\DeclareRobustCommand*{\\usk}{\\ensuremath{\\cdot}}\\typeout{#1}}\n\\newcommand{\\@thickspace}[1]{\\DeclareRobustCommand*{\\usk}{\\ensuremath{\\;}}\\typeout{#1}}\n\\newcommand{\\@mediumspace}[1]{\\DeclareRobustCommand*{\\usk}{\\ensuremath{\\:}}\\typeout{#1}}\n\\newcommand{\\@thinspace}[1]{\\DeclareRobustCommand*{\\usk}{\\ensuremath{\\,}}\\typeout{#1}}\n\\newcommand{\\@thickqspace}[1]{\\DeclareRobustCommand*{\\@qsk}{\\ensuremath{\\;}}\\typeout{#1}}\n\\newcommand{\\@mediumqspace}[1]{\\DeclareRobustCommand*{\\@qsk}{\\ensuremath{\\:}}\\typeout{#1}}\n\\newcommand{\\@thinqspace}[1]{\\DeclareRobustCommand*{\\@qsk}{\\ensuremath{\\,}}\\typeout{#1}}\n{\\catcode`\\.=13\\gdef.{\\usk}}\n\\newcommand{\\period@active}[1]{\\begingroup\\mathcode`\\.="8000\\ensuremath{#1}\\endgroup}\n\\DeclareRobustCommand{\\unit}[2]{\\@inunitcommandtrue%\n \\ensuremath{\\SI@fstyle{#1\\@qsk\\period@active{#2}}}%\n \\@inunitcommandfalse}\n\\DeclareRobustCommand{\\one}{\\settowidth{\\@qskwidth}{\\@qsk}\\hspace*{-\\@qskwidth}}\n\\DeclareRobustCommand{\\no@qsk}{%\n \\if@inunitcommand%\n  \\one%\n \\else%\n  \\relax%\n \\fi%\n}\n\\DeclareRobustCommand{\\power}[2]{\\ensuremath{\\SI@fstyle{#1}^{\\SI@fstyle{#2}}}}\n\\AtBeginDocument{%\n \\if@redefsquare\n  \\providecommand{\\square}[1]{\\power{#1}{2}}\n  \\renewcommand{\\square}[1]{\\power{#1}{2}}\n  \\typeout{Option `amssymb\' provided! ^^J\n  Command \\protect\\square\\space redefined by SIunits package!}\n  \\typeout{}\n \\else\n   \\if@defsquaren\n    \\providecommand{\\squaren}[1]{\\power{#1}{2}}\n    \\renewcommand{\\squaren}[1]{\\power{#1}{2}}\n    \\typeout{Option `squaren\' provided! ^^J\n    Command \\protect\\squaren\\space defined by SIunits package!}\n    \\typeout{}\n   \\else\n    \\@ifundefined{square}{%\n     \\newcommand*{\\square}[1]{\\power{#1}{2}}\n     }{%\n     \\PackageError{SIunits}{%\n     The command \\protect\\square\\space was already defined.\\MessageBreak\n     Possibly due to the amssymb package}%\n     {Hint: use option `amssymb\' or `squaren\' with SIunits package.\\MessageBreak\n     See SIunits.dvi or readme.txt section: Known problems and limitations.}\n    }  %\\ifundefined{square}\n   \\fi %\\if@defsquaren\n \\fi   %\\if@redefsquare\n \\if@defitalian\n \\PackageWarning{SIunits}{Option `italian\' provided.\\MessageBreak\n                          Command \\protect\\unit\\space defined by babel.\\MessageBreak\n                          Mind to use \\protect\\unita\\space instead.}%\n \\DeclareRobustCommand{\\unita}[2]{%\n           \\@inunitcommandtrue%\n           \\ensuremath{\\SI@fstyle{#1\\@qsk\\period@active{#2}}}%\n           \\@inunitcommandfalse%\n           }%\n \\fi%\\if@defitalian\n}     %\\AtBeginDocument\n\\DeclareRobustCommand{\\SI@square}[1]\n    {\\if@defsquaren%\n      \\squaren{#1}%\n        \\else\n      \\square{#1}%\n     \\fi %\\if@defsquaren\n    }\n\\DeclareRobustCommand*{\\squared}{\\ensuremath{^{\\mathrm{2}}}}\n\\DeclareRobustCommand*{\\cubic}[1]{\\power{#1}{3}}\n\\DeclareRobustCommand*{\\cubed}{\\ensuremath{^{\\mathrm{3}}}}\n\\DeclareRobustCommand*{\\fourth}[1]{\\power{#1}{4}}\n\\DeclareRobustCommand*{\\reciprocal}[1]{\\power{#1}{-1}}\n\\DeclareRobustCommand*{\\rp}{\\reciprocal}\n\\DeclareRobustCommand*{\\rpsquare}[1]{\\power{#1}{-2}}\n\\DeclareRobustCommand*{\\rpsquared}{\\ensuremath{^{\\mathrm{-2}}}}\n\\DeclareRobustCommand*{\\rpcubic}[1]{\\power{#1}{-3}}\n\\DeclareRobustCommand*{\\rpcubed}{\\ensuremath{^{\\mathrm{-3}}}}\n\\DeclareRobustCommand*{\\rpfourth}[1]{\\power{#1}{-4}}\n\\addprefix{\\yocto}{y}\n\\addprefix{\\zepto}{z}\n\\addprefix{\\atto}{a}\n\\addprefix{\\femto}{f}\n\\addprefix{\\pico}{p}\n\\addprefix{\\nano}{n}\n\\AtBeginDocument{%\n\\if@optionNoAMS%\n \\addprefix{\\micro}{\\mbox{\\SImu}}%\n\\else%\n  \\addprefix{\\micro}{\\upmu}%\n \\fi%\n\\if@textstyle%\n  \\DeclareRobustCommand{\\micro}{{\\ensuremath{\\@text{\\SImu}}}}%\n\\fi}\n\\addprefix{\\milli}{m}\n\\addprefix{\\centi}{c}\n\\addprefix{\\deci}{d}\n\\addprefix{\\deca}{da}\n\\addprefix{\\hecto}{h}\n\\addprefix{\\kilo}{k}\n\\addprefix{\\mega}{M}\n\\addprefix{\\giga}{G}\n\\addprefix{\\tera}{T}\n\\addprefix{\\peta}{P}\n\\addprefix{\\exa}{E}\n\\addprefix{\\zetta}{Z}\n\\addprefix{\\yotta}{Y}\n\\DeclareRobustCommand*{\\yoctod}{\\power{10}{-24}}\n\\DeclareRobustCommand*{\\zeptod}{\\power{10}{-21}}\n\\DeclareRobustCommand*{\\attod}{\\power{10}{-18}}\n\\DeclareRobustCommand*{\\femtod}{\\power{10}{-15}}\n\\DeclareRobustCommand*{\\picod}{\\power{10}{-12}}\n\\DeclareRobustCommand*{\\nanod}{\\power{10}{-9}}\n\\DeclareRobustCommand*{\\microd}{\\power{10}{-6}}\n\\DeclareRobustCommand*{\\millid}{\\power{10}{-3}}\n\\DeclareRobustCommand*{\\centid}{\\power{10}{-2}}\n\\DeclareRobustCommand*{\\decid}{\\power{10}{-1}}\n\\DeclareRobustCommand*{\\decad}{\\power{10}{1}}\n\\DeclareRobustCommand*{\\hectod}{\\power{10}{2}}\n\\DeclareRobustCommand*{\\kilod}{\\power{10}{3}}\n\\DeclareRobustCommand*{\\megad}{\\power{10}{6}}\n\\DeclareRobustCommand*{\\gigad}{\\power{10}{9}}\n\\DeclareRobustCommand*{\\terad}{\\power{10}{12}}\n\\DeclareRobustCommand*{\\petad}{\\power{10}{15}}\n\\DeclareRobustCommand*{\\exad}{\\power{10}{18}}\n\\DeclareRobustCommand*{\\zettad}{\\power{10}{21}}\n\\DeclareRobustCommand*{\\yottad}{\\power{10}{24}}\n\\addunit{\\gram}{g}\n\\addunit{\\metre}{m}\n\\addunit{\\kilogram}{\\kilo\\gram}\n\\addunit{\\second}{s}\n\\addunit{\\ampere}{A}\n\\addunit{\\kelvin}{K}\n\\addunit{\\mole}{mol}\n\\addunit{\\candela}{cd}\n\\addunit{\\radian}{rad}\n\\addunit{\\steradian}{sr}\n\\addunit{\\hertz}{Hz}\n\\addunit{\\newton}{N}\n\\addunit{\\pascal}{Pa}\n\\addunit{\\joule}{J}\n\\addunit{\\watt}{W}\n\\addunit{\\coulomb}{C}\n\\addunit{\\volt}{V}\n\\addunit{\\farad}{F}\n\\addunit{\\ohm}{\\ensuremath{\\Omega}}\n\\addunit{\\siemens}{S}\n\\addunit{\\weber}{Wb}\n\\addunit{\\tesla}{T}\n\\addunit{\\henry}{H}\n\\newcommand{\\degreecelsius}{\\protect\\@inunitcommandfalse\\ensuremath{\\SI@fstyle{\\degree\\Celsius}}}\n\\addunit{\\celsius}{\\degreecelsius}\n\\addunit{\\lumen}{lm}\n\\addunit{\\lux}{lx}\n\\addunit{\\becquerel}{Bq}\n\\AtBeginDocument{%\n\\if@redefGray\n  \\providecommand{\\gray}{\\ensuremath{\\SI@fstyle{Gy}}}\n  \\renewcommand{\\gray}{\\ensuremath{\\SI@fstyle{Gy}}}\n  \\typeout{Option `pstricks\' provided! ^^J\n           Command \\protect\\gray\\space redefined by SIunits package!}\n  \\typeout{}\n \\else\n   \\if@defGray\n    \\providecommand{\\Gray}{\\ensuremath{\\SI@fstyle{Gy}}}\n    \\renewcommand{\\Gray}{\\ensuremath{\\SI@fstyle{Gy}}}\n    \\typeout{Option `Gray\' provided! ^^J\n             Command \\protect\\Gray\\space defined by SIunits package!}\n    \\typeout{}\n   \\else\n    \\@ifundefined{gray}{%\n     \\newcommand*{\\gray}{\\ensuremath{\\SI@fstyle{Gy}}}\n     }{%\n     \\PackageWarningNoLine{SIunits}{%\n     The command \\protect\\gray\\space was already defined.\\MessageBreak\n     Possibly due to the pstricks package}\n     \\typeout{Hint: use option `pstricks\' or `Gray\' with SIunits package.}\n     \\typeout{See SIunits.dvi or readme.txt section: Known problems and limitations.}\n     \\typeout{}\n    }          %\\ifundefined{gray}\n   \\fi %\\if@defGray\n \\fi   %\\if@redefGray\n}      %\\AtBeginDocument\n\\addunit{\\sievert}{Sv}\n\\addunit{\\katal}{kat}\n\n\\newcommand*\\SIunits@opt@derivedinbase{%\n\\typeout{Option \'derivedinbase\' provided!^^J}\n\\addunit{\\radianbase}%\n        {\\metre\\usk\\reciprocal\\metre}\n\\addunit{\\steradianbase}%\n        {\\squaremetre\\usk\\rpsquare\\metre}\n\\addunit{\\hertzbase}%\n        {\\reciprocal\\second}\n\\addunit{\\newtonbase}%\n        {\\metre\\usk\\kilogram\\usk\\second\\rpsquared}\n\\addunit{\\pascalbase}%\n        {\\reciprocal\\metre\\usk\\kilogram\\usk\\second\\rpsquared}\n\\addunit{\\joulebase}%\n        {\\squaremetre\\usk\\kilogram\\usk\\second\\rpsquared}\n\\addunit{\\wattbase}%\n        {\\squaremetre\\usk\\kilogram\\usk\\rpcubic\\second}\n\\addunit{\\coulombbase}%\n        {\\ampere\\usk\\second}\n\\addunit{\\voltbase}%\n        {\\squaremetre\\usk\\kilogram\\usk\\rpcubic\\second\\usk\\reciprocal\\ampere}\n\\addunit{\\faradbase}%\n        {\\rpsquare\\metre\\usk\\reciprocal\\kilogram\\usk\\fourth\\second\\usk\\ampere\\squared}\n\\addunit{\\ohmbase}%\n        {\\squaremetre\\usk\\kilogram\\usk\\rpcubic\\second\\usk\\rpsquare\\ampere}\n\\addunit{\\siemensbase}%\n        {\\rpsquare\\metre\\usk\\reciprocal\\kilogram\\usk\\cubic\\second\\usk\\ampere\\squared}\n\\addunit{\\weberbase}%\n        {\\squaremetre\\usk\\kilogram\\usk\\second\\rpsquared\\usk\\reciprocal\\ampere}\n\\addunit{\\teslabase}%\n        {\\kilogram\\usk\\second\\rpsquared\\usk\\reciprocal\\ampere}\n\\addunit{\\henrybase}%\n        {\\squaremetre\\usk\\kilogram\\usk\\second\\rpsquared\\usk\\rpsquare\\ampere}\n\\addunit{\\celsiusbase}%\n        {\\kelvin}\n\\addunit{\\lumenbase}%\n        {\\candela\\usk\\squaremetre\\usk\\rpsquare\\metre}\n\\addunit{\\luxbase}%\n        {\\candela\\usk\\squaremetre\\usk\\rpfourth\\metre}\n\\addunit{\\becquerelbase}%\n        {\\hertzbase}\n\\addunit{\\graybase}%\n        {\\squaremetre\\usk\\second\\rpsquared}\n\\addunit{\\sievertbase}%\n        {\\graybase}\n\\addunit{\\katalbase}%\n        {\\rp\\second\\usk\\mole }\n}\n\\newcommand*\\SIunits@opt@derived{%\n\\addunit{\\derradian}%\n        {\\metre\\usk\\reciprocal\\metre}\n\\addunit{\\dersteradian}%\n        {\\squaremetre\\usk\\rpsquare\\metre}\n\\addunit{\\derhertz}%\n        {\\reciprocal\\second}\n\\addunit{\\dernewton}%\n        {\\metre\\usk\\kilogram\\usk\\second\\rpsquared}\n\\addunit{\\derpascal}%\n        {\\newton\\usk\\rpsquare\\metre}\n\\addunit{\\derjoule}%\n        {\\newton\\usk\\metre}\n\\addunit{\\derwatt}%\n        {\\joule\\usk\\reciprocal\\second}\n\\addunit{\\dercoulomb}%\n        {\\ampere\\usk\\second}\n\\addunit{\\dervolt}%\n        {\\watt\\usk\\reciprocal\\ampere}\n\\addunit{\\derfarad}%\n        {\\coulomb\\usk\\reciprocal\\volt}\n\\addunit{\\derohm}%\n        {\\volt\\usk\\reciprocal\\ampere}\n\\addunit{\\dersiemens}%\n        {\\ampere\\usk\\reciprocal\\volt}\n\\addunit{\\derweber}%\n        {\\squaremetre\\usk\\kilogram\\usk\\second\\rpsquared\\usk\\reciprocal\\ampere}\n\\addunit{\\dertesla}%\n        {\\weber\\usk\\rpsquare\\metre}\n\\addunit{\\derhenry}%\n        {\\weber\\usk\\reciprocal\\ampere}\n\\addunit{\\dercelsius}%\n        {\\kelvin}\n\\addunit{\\derlumen}%\n        {\\candela\\usk\\steradian}\n\\addunit{\\derlux}%\n        {\\lumen\\usk\\rpsquare\\metre}\n\\addunit{\\derbecquerel}%\n        {\\derhertz}\n\\addunit{\\dergray}%\n        {\\joule\\usk\\reciprocal\\kilogram}\n\\addunit{\\dersievert}%\n        {\\dergray}\n\\addunit{\\derkatal}%\n        {\\katalbase}\n     \\typeout{Option `derived\' provided!}}\n\\addunit{\\minute}{min}\n\\addunit{\\hour}{h}\n\\addunit{\\dday}{d}\n\\addunit{\\degree}{\\no@qsk\\ensuremath{^{\\circ}}}\n\\addunit{\\paminute}{\\no@qsk\\ensuremath{\'}}\n\\addunit{\\arcminute}{\\no@qsk\\ensuremath{\'}}\n\\addunit{\\pasecond}{\\no@qsk\\ensuremath{\'\'}}\n\\addunit{\\arcsecond}{\\no@qsk\\ensuremath{\'\'}}\n\\addunit{\\ton}{t}\n\\addunit{\\tonne}{t}\n\\addunit{\\liter}{L}\n\\addunit{\\litre}{l}\n\\addunit{\\neper}{Np}\n\\addunit{\\bel}{B}\n\\addunit{\\curie}{Ci}\n\\addunit{\\rad}{rad}\n\\addunit{\\arad}{rd}\n\\addunit{\\rem}{rem}\n\\addunit{\\roentgen}{R}\n\\addunit{\\electronvolt}{e\\volt}\n\\addunit{\\atomicmass}{u}\n\\addunit{\\are}{a}\n\\addunit{\\hectare}{\\hecto\\are}\n\\addunit{\\barn}{b}\n\\addunit{\\bbar}{bar}\n\\addunit{\\gal}{Gal}\n\\addunit{\\angstrom}{\\mbox{{\\AA}}}\n\\addunit{\\rperminute}{r\\per\\minute}\n\\addunit{\\rpersecond}{r\\per\\second}\n\\addunit{\\squaremetre}{\\SI@square\\metre}\n\\addunit{\\cubicmetre}{\\cubic\\metre}\n\\addunit{\\graypersecond}{\\gray\\per\\second}\n\\addunit{\\graypersecondnp}{\\gray\\usk\\reciprocal\\second}\n\\addunit{\\metrepersquaresecond}{\\metre\\per\\second\\squared}\n\\addunit{\\metrepersquaresecondnp}{\\metre\\usk\\second\\rpsquared}\n\\addunit{\\joulepermole}{\\joule\\per\\mole}\n\\addunit{\\joulepermolenp}{\\joule\\usk\\reciprocal\\mole}\n\\addunit{\\molepercubicmetre}{\\mole\\per\\cubic\\metre}\n\\addunit{\\molepercubicmetrenp}{\\mole\\usk\\rpcubic\\metre}\n\\addunit{\\radianpersquaresecond}{\\radian\\per\\second\\squared}\n\\addunit{\\radianpersquaresecondnp}{\\radian\\usk\\second\\rpsquared}\n\\addunit{\\kilogramsquaremetrepersecond}{\\kilogram\\usk\\squaremetre\\per\\second}\n\\addunit{\\kilogramsquaremetrepersecondnp}{\\kilogram\\usk\\squaremetre\\usk\\reciprocal\\second}\n\\addunit{\\radianpersecond}{\\radian\\per\\second}\n\\addunit{\\radianpersecondnp}{\\radian\\usk\\reciprocal\\second}\n\\addunit{\\squaremetrepercubicmetre}{\\squaremetre\\per\\cubic\\metre}\n\\addunit{\\squaremetrepercubicmetrenp}{\\squaremetre\\usk\\rpcubic\\metre}\n\\addunit{\\katalpercubicmetre}{\\katal\\per\\cubic\\metre}\n\\addunit{\\katalpercubicmetrenp}{\\katal\\usk\\rpcubic\\metre}\n\\addunit{\\coulombpermol}{\\coulomb\\per\\mole}\n\\addunit{\\coulombpermolnp}{\\coulomb\\usk\\reciprocal\\mole}\n\\addunit{\\amperepersquaremetre}{\\ampere\\per\\squaremetre}\n\\addunit{\\amperepersquaremetrenp}{\\ampere\\usk\\rpsquare\\metre}\n\\addunit{\\kilogrampercubicmetre}{\\kilogram\\per\\cubic\\metre}\n\\addunit{\\kilogrampercubicmetrenp}{\\kilogram\\usk\\rpcubic\\metre}\n\\addunit{\\squaremetrepernewtonsecond}{\\squaremetre\\per\\newton\\usk\\second}\n\\addunit{\\squaremetrepernewtonsecondnp}{\\squaremetre\\usk\\reciprocal\\newton\\usk\\reciprocal\\second}\n\\addunit{\\pascalsecond}{\\pascal\\usk\\second}\n\\addunit{\\coulombpercubicmetre}{\\coulomb\\per\\cubic\\metre}\n\\addunit{\\coulombpercubicmetrenp}{\\coulomb\\usk\\rpcubic\\metre}\n\\addunit{\\amperemetresecond}{\\ampere\\usk\\metre\\usk\\second}\n\\addunit{\\voltpermetre}{\\volt\\per\\metre}\n\\addunit{\\voltpermetrenp}{\\volt\\usk\\reciprocal\\metre}\n\\addunit{\\coulombpersquaremetre}{\\coulomb\\per\\squaremetre}\n\\addunit{\\coulombpersquaremetrenp}{\\coulomb\\usk\\rpsquare\\metre}\n\\addunit{\\faradpermetre}{\\farad\\per\\metre}\n\\addunit{\\faradpermetrenp}{\\farad\\usk\\reciprocal\\metre}\n\\addunit{\\ohmmetre}{\\ohm\\usk\\metre}\n\\addunit{\\kilowatthour}{\\kilo\\watt\\hour}\n\\addunit{\\wattpersquaremetre}{\\watt\\per\\squaremetre}\n\\addunit{\\wattpersquaremetrenp}{\\watt\\usk\\rpsquare\\metre}\n\\addunit{\\joulepersquaremetre}{\\joule\\per\\squaremetre}\n\\addunit{\\joulepersquaremetrenp}{\\joule\\usk\\rpsquare\\metre}\n\\addunit{\\newtonpercubicmetre}{\\newton\\per\\cubic\\metre}\n\\addunit{\\newtonpercubicmetrenp}{\\newton\\usk\\rpcubic\\metre}\n\\addunit{\\newtonperkilogram}{\\newton\\per\\kilogram}\n\\addunit{\\newtonperkilogramnp}{\\newton\\usk\\reciprocal\\kilogram}\n\\addunit{\\jouleperkelvin}{\\joule\\per\\kelvin}\n\\addunit{\\jouleperkelvinnp}{\\joule\\usk\\reciprocal\\kelvin}\n\\addunit{\\jouleperkilogram}{\\joule\\per\\kilogram}\n\\addunit{\\jouleperkilogramnp}{\\joule\\usk\\reciprocal\\kilogram}\n\\addunit{\\coulombperkilogram}{\\coulomb\\per\\kilogram}\n\\addunit{\\coulombperkilogramnp}{\\coulomb\\usk\\reciprocal\\kilogram}\n\\addunit{\\squaremetrepersecond}{\\squaremetre\\per\\second}\n\\addunit{\\squaremetrepersecondnp}{\\squaremetre\\usk\\reciprocal\\second}\n\\addunit{\\squaremetrepersquaresecond}{\\squaremetre\\per\\second\\squared}\n\\addunit{\\squaremetrepersquaresecondnp}{\\squaremetre\\usk\\second\\rpsquared}\n\\addunit{\\kilogrammetrepersecond}{\\kilogram\\usk\\metre\\per\\second}\n\\addunit{\\kilogrammetrepersecondnp}{\\kilogram\\usk\\metre\\usk\\reciprocal\\second}\n\\addunit{\\candelapersquaremetre}{\\candela\\per\\squaremetre}\n\\addunit{\\candelapersquaremetrenp}{\\candela\\usk\\rpsquare\\metre}\n\\addunit{\\amperepermetre}{\\ampere\\per\\metre}\n\\addunit{\\amperepermetrenp}{\\ampere\\usk\\reciprocal\\metre}\n\\addunit{\\joulepertesla}{\\joule\\per\\tesla}\n\\addunit{\\jouleperteslanp}{\\joule\\usk\\reciprocal\\tesla}\n\\addunit{\\henrypermetre}{\\henry\\per\\metre}\n\\addunit{\\henrypermetrenp}{\\henry\\usk\\reciprocal\\metre}\n\\addunit{\\kilogrampersecond}{\\kilogram\\per\\second}\n\\addunit{\\kilogrampersecondnp}{\\kilogram\\usk\\reciprocal\\second}\n\\addunit{\\kilogrampersquaremetresecond}{\\kilogram\\per\\squaremetre\\usk\\second}\n\\addunit{\\kilogrampersquaremetresecondnp}{\\kilogram\\usk\\rpsquare\\metre\\usk\\reciprocal\\second}\n\\addunit{\\kilogrampersquaremetre}{\\kilogram\\per\\squaremetre}\n\\addunit{\\kilogrampersquaremetrenp}{\\kilogram\\usk\\rpsquare\\metre}\n\\addunit{\\kilogrampermetre}{\\kilogram\\per\\metre}\n\\addunit{\\kilogrampermetrenp}{\\kilogram\\usk\\reciprocal\\metre}\n\\addunit{\\joulepermolekelvin}{\\joule\\per\\mole\\usk\\kelvin}\n\\addunit{\\joulepermolekelvinnp}{\\joule\\usk\\reciprocal\\mole\\usk\\reciprocal\\kelvin}\n\\addunit{\\kilogramperkilomole}{\\kilogram\\per\\kilo\\mole}\n\\addunit{\\kilogramperkilomolenp}{\\kilogram\\usk\\kilo\\reciprocal\\mole}\n\\addunit{\\kilogramsquaremetre}{\\kilogram\\usk\\squaremetre}\n\\addunit{\\kilogramsquaremetrenp}{\\kilogramsquaremetre}\n\\addunit{\\kilogrammetrepersquaresecond}{\\kilogram\\usk\\metre\\per\\second\\squared}\n\\addunit{\\kilogrammetrepersquaresecondnp}{\\kilogram\\usk\\metre\\usk\\second\\rpsquared}\n\\addunit{\\newtonpersquaremetre}{\\newton\\per\\squaremetre}\n\\addunit{\\newtonpersquaremetrenp}{\\newton\\usk\\rpsquare\\metre}\n\\addunit{\\persquaremetresecond}{1\\per\\squaremetre\\usk\\second}\n\\addunit{\\persquaremetresecondnp}{\\rpsquare\\metre\\usk\\reciprocal\\second}\n\\addunit{\\wattperkilogram}{\\watt\\per\\kilogram}\n\\addunit{\\wattperkilogramnp}{\\watt\\usk\\reciprocal\\kilogram}\n\\addunit{\\wattpercubicmetre}{\\watt\\per\\cubic\\metre}\n\\addunit{\\wattpercubicmetrenp}{\\watt\\usk\\rpcubic\\metre}\n\\addunit{\\wattpersquaremetresteradian}{\\watt\\per\\squaremetre\\usk\\steradian}\n\\addunit{\\wattpersquaremetresteradiannp}{\\watt\\usk\\rpsquare\\metre\\usk\\rp\\steradian}\n\\addunit{\\jouleperkilogramkelvin}{\\joule\\per\\kilogram\\usk\\kelvin}\n\\addunit{\\jouleperkilogramkelvinnp}{\\joule\\usk\\reciprocal\\kilogram\\usk\\reciprocal\\kelvin}\n\\addunit{\\squaremetreperkilogram}{\\squaremetre\\per\\kilogram}\n\\addunit{\\rpsquaremetreperkilogram}{\\squaremetre\\usk\\reciprocal\\kilogram}\n\\addunit{\\cubicmetreperkilogram}{\\cubic\\metre\\per\\kilogram}\n\\addunit{\\rpcubicmetreperkilogram}{\\cubic\\metre\\usk\\reciprocal\\kilogram}\n\\addunit{\\newtonpermetre}{\\newton\\per\\metre}\n\\addunit{\\newtonpermetrenp}{\\newton\\usk\\reciprocal\\metre}\n\\addunit{\\Celsius}{\\ensuremath{\\SI@fstyle{C}}}\n\\addunit{\\wattpermetrekelvin}{\\watt\\per\\metre\\usk\\kelvin}\n\\addunit{\\wattpermetrekelvinnp}{\\watt\\usk\\reciprocal\\metre\\usk\\reciprocal\\kelvin}\n\\addunit{\\newtonmetre}{\\newton\\usk\\metre} \\addunit{\\newtonmetrenp}{\\newtonmetre}\n\\addunit{\\squaremetrepercubicsecond}{\\squaremetre\\per\\cubic\\second}\n\\addunit{\\squaremetrepercubicsecondnp}{\\squaremetre\\usk\\rpcubic\\second}\n\\addunit{\\metrepersecond}{\\metre\\per\\second}\n\\addunit{\\metrepersecondnp}{\\metre\\usk\\reciprocal\\second}\n\\addunit{\\joulepercubicmetre}{\\joule\\per\\cubicmetre}\n\\addunit{\\joulepercubicmetrenp}{\\joule\\usk\\rpcubic\\metre}\n\\addunit{\\kilogrampercubicmetrecoulomb}{\\kilogram\\per\\cubic\\metre\\usk\\coulomb}\n\\addunit{\\kilogrampercubicmetrecoulombnp}{\\kilogram\\usk\\rpcubic\\metre\\usk\\reciprocal\\coulomb}\n\\addunit{\\cubicmetrepersecond}{\\cubicmetre\\per\\second}\n\\addunit{\\rpcubicmetrepersecond}{\\cubicmetre\\usk\\reciprocal\\second}\n\\addunit{\\kilogrampersecondcubicmetre}{\\kilogram\\per\\second\\usk\\cubicmetre}\n\\addunit{\\kilogrampersecondcubicmetrenp}{\\kilogram\\usk\\reciprocal\\second\\usk\\rpcubic\\metre}\n\\DeclareOption{cdot}{\\@cdot{Option `cdot\' provided!}}\n\\DeclareOption{thickspace}{\\@thickspace{Option `thickspace\' provided!}}\n\\DeclareOption{mediumspace}{\\@mediumspace{Option `mediumspace\' provided!}}\n\\DeclareOption{thinspace}{\\@thinspace{Option `thinspace\' provided!}}\n\\DeclareOption{thickqspace}{\\@thickqspace{Option `thickqspace\' provided!}}\n\\DeclareOption{mediumqspace}{\\@mediumqspace{Option `mediumqspace\' provided!}}\n\\DeclareOption{thinqspace}{\\@thinqspace{Option `thinqspace\' provided!}}\n\\DeclareOption{textstyle}{\\renewcommand\\SI@fstyle[1]{\\@text{\\protect#1}}%\n\\@textstyletrue%\n\\typeout{Option `textstyle\' provided!}}\n\\DeclareOption{amssymb}{\\@redefsquaretrue%\n\\typeout{Option `amssymb\' provided!}}\n\\DeclareOption{squaren}{\\@defsquarentrue%\n\\typeout{Option `squaren\' provided!}}\n\\DeclareOption{pstricks}{\\@redefGraytrue%\n\\typeout{Option `pstricks\' provided!}}\n\\DeclareOption{Gray}{\\@defGraytrue%\n\\typeout{Option `Gray\' provided!}}\n\\DeclareOption{italian}{\\@defitaliantrue%\n\\typeout{Option `italian\' provided!}}\n\\DeclareOption{binary}{\\@optionbinarytrue }\n\\AtEndOfPackage{\\if@optionbinary\\RequirePackage{binary}\\fi}\n\\DeclareOption{derivedinbase}{\\SIunits@opt@derivedinbase}\n\\DeclareOption{derived}{\\SIunits@opt@derived}\n\\DeclareOption{noams}{\\@optionNoAMStrue%\n\\typeout{Option `noams\' provided!}}\n\\DeclareOption*{\\PackageWarningNoLine{SIunits}{What is `\\CurrentOption\'?}}\n\\InputIfFileExists{SIunits.cfg}{}%\n{\\PackageWarningNoLine{SIunits}{You have no `SIunits.cfg\' file installed.\n\\MessageBreak I will assume you are using `thickspace\' and `thickqspace\'}\n\\ExecuteOptions{thickspace,thickqspace}}\n\\ProcessOptions\\relax\n%% \n%%  Source: $Id: SIunits.sty,v 1.1.1.1 2003/02/26 03:15:34 amb Exp $\n%%\n%% End of file `SIunits.sty\'.\n'
p0
.I0
.S'titling'
p0
.S'$style_file: titling\n%%\n%% This is file `titling.sty\',\n%% generated with the docstrip utility.\n%%\n%% The original source files were:\n%%\n%% titling.dtx  (with options: `usc\')\n%% \n%% -----------------------------------------------------------------\n%%   Author: Peter Wilson (Herries Press)\n%%   Maintainer: Will Robertson (will dot robertson at latex-project dot org)\n%%   Copyright 2000--2004 Peter R. Wilson\n%% \n%%   This work may be distributed and/or modified under the\n%%   conditions of the LaTeX Project Public License, either\n%%   version 1.3c of this license or (at your option) any\n%%   later version: <http://www.latex-project.org/lppl.txt>\n%% \n%%   This work has the LPPL maintenance status "maintained".\n%%   The Current Maintainer of this work is Will Robertson.\n%% \n%%   This work consists of the files listed in the README file.\n%% -----------------------------------------------------------------\n%% \n\\NeedsTeXFormat{LaTeX2e}\n\\ProvidesPackage{titling}[2009/09/04 v2.1d maketitle typesetting]\n\n\\newcommand{\\pretitle}[1]{\\def\\@bspretitle{#1}}\n\\newcommand{\\posttitle}[1]{\\def\\@bsposttitle{#1}}\n\\newcommand{\\preauthor}[1]{\\def\\@bspreauthor{#1}}\n\\newcommand{\\postauthor}[1]{\\def\\@bspostauthor{#1}}\n\\newcommand{\\predate}[1]{\\def\\@bspredate{#1}}\n\\newcommand{\\postdate}[1]{\\def\\@bspostdate{#1}}\n\n\\if@titlepage\n  \\pretitle{\\begin{center}\\LARGE}\n  \\posttitle{\\par\\end{center}\\vskip 2em}\n  \\preauthor{\\begin{center}\n    \\large \\lineskip .75em%\n    \\begin{tabular}[t]{c}}\n  \\postauthor{\\end{tabular}\\par\\end{center}}\n  \\predate{\\begin{center}\\large}\n  \\postdate{\\par\\end{center}}\n\\else\n  \\pretitle{\\begin{center}\\LARGE}\n  \\posttitle{\\par\\end{center}\\vskip 0.5em}\n  \\preauthor{\\begin{center}\n    \\large \\lineskip .5em%\n    \\begin{tabular}[t]{c}}\n  \\postauthor{\\end{tabular}\\par\\end{center}}\n  \\predate{\\begin{center}\\large}\n  \\postdate{\\par\\end{center}}\n\\fi\n\n\\newcommand{\\maketitlehooka}{}\n\\newcommand{\\maketitlehookb}{}\n\\newcommand{\\maketitlehookc}{}\n\\newcommand{\\maketitlehookd}{}\n\n\\newcommand{\\thanksmarkseries}[1]{%\n  \\def\\@bsmarkseries{\\renewcommand{\\thefootnote}{\\@nameuse{#1}{footnote}}}}\n\\newcommand{\\symbolthanksmark}{\\thanksmarkseries{\\fnsymbol}}\n\\newcommand{\\@bscontmark}{\\setcounter{footnote}{0}}\n\\newcommand{\\continuousmarks}{\\def\\@bscontmark{}}\n\\newcommand{\\thanksheadextra}[2]{%\n  \\def\\@bsthanksheadpre{#1}%\n  \\def\\@bsthanksheadpost{#2}}\n\\newcommand{\\thanksfootextra}[2]{%\n  \\def\\thanksfootpre{#1}%\n  \\def\\thanksfootpost{#2}}\n\n\\DeclareRobustCommand{\\thanksmark}[1]{\\footnotemark[#1]}\n\\newcommand{\\thanksgap}[1]{\\hspace{#1}}\n\\newcommand{\\tamark}{\\@thefnmark}\n\n\\newlength{\\thanksmarkwidth}\n\\newlength{\\thanksmargin}\n\\newcommand{\\thanksscript}[1]{\\textsuperscript{#1}}\n\\newcommand{\\makethanksmarkhook}{}\n\n\\newcommand{\\thanksfootmark}{%\n  \\hb@xt@\\thanksmarkwidth{\\hfil\\normalfont\\thanksscript{%\n    \\thanksfootpre \\tamark \\thanksfootpost}}}\n\n\\newcommand{\\makethanksmark}{%\n  \\leavevmode%\n  \\makethanksmarkhook\\relax\n  \\parindent 1em\\noindent\n  \\leftskip\\thanksmargin\\relax\n  \\advance\\leftskip \\thanksmarkwidth \\null\\nobreak\\hskip -\\leftskip\n  \\thanksfootmark\n}\n\n\\newcommand{\\usethanksrule}{\\let\\footnoterule\\thanksrule}\n\\newcommand{\\cancelthanksrule}{\\let\\footnoterule\\@bsfootnoterule}\n\n\\if@titlepage\n  \\thanksmarkseries{arabic}    % normal footnote numbers\n\\else\n  \\thanksmarkseries{fnsymbol}\n\\fi\n\\thanksheadextra{}{}\n\\thanksfootextra{}{}\n\\setlength{\\thanksmarkwidth}{1.8em}\n\\setlength{\\thanksmargin}{-\\thanksmarkwidth}\n\n\\AtBeginDocument{%\n  \\let\\thanksrule\\footnoterule\n  \\let\\@bsfootnoterule\\footnoterule\n}\n\n\\newlength{\\droptitle}\n\\setlength{\\droptitle}{0pt}\n\n\\providecommand{\\maketitle}{}\n\\if@titlepage\n  \\renewcommand{\\maketitle}{\\begin{titlepage}%\n    \\let\\footnotesize\\small\n    \\let\\footnoterule\\relax\n    \\let \\footnote \\thanks\n    \\@bsmarkseries\n      \\def\\@makefnmark{\\rlap{\\@textsuperscript{%\n         \\normalfont\\@bsthanksheadpre \\tamark \\@bsthanksheadpost}}}%\n      \\long\\def\\@makefntext##1{\\makethanksmark ##1}\n    \\null\\vfil\n    \\vskip 60\\p@\n    \\vspace*{\\droptitle}\n    \\maketitlehooka\n    {\\@bspretitle \\@title \\@bsposttitle}\n    \\maketitlehookb\n    {\\@bspreauthor \\@author \\@bspostauthor}\n    \\maketitlehookc\n    {\\@bspredate \\@date \\@bspostdate}\n    \\maketitlehookd\n    \\par\n    \\@thanks\n    \\vfil\\null\n    \\end{titlepage}%\n    \\@bscontmark  %  \\setcounter{footnote}{0}%\n%%%    \\@bsmtitlempty\n  } % end titlepage defs\n\\else\n  \\renewcommand{\\maketitle}{\\par\n    \\begingroup\n      \\@bsmarkseries\n      \\def\\@makefnmark{\\rlap{\\@textsuperscript{%\n         \\normalfont\\@bsthanksheadpre \\tamark \\@bsthanksheadpost}}}%\n      \\long\\def\\@makefntext##1{\\makethanksmark ##1}\n      \\if@twocolumn\n        \\ifnum \\col@number=\\@ne\n          \\@maketitle\n        \\else\n          \\twocolumn[\\@maketitle]%\n        \\fi\n      \\else\n        \\newpage\n        \\global\\@topnum\\z@\n        \\@maketitle\n      \\fi\n      \\thispagestyle{plain}\\@thanks\n    \\endgroup\n    \\@bscontmark  %  \\setcounter{footnote}{0}%\n%%%    \\@bsmtitlempty\n  } % end non-titlepage\n\n  \\def\\@maketitle{%\n    \\newpage\n    \\null\n    \\vskip 2em%\n          \\vspace*{\\droptitle}\n    \\maketitlehooka\n    {\\@bspretitle \\@title \\@bsposttitle}\n    \\maketitlehookb\n    {\\@bspreauthor \\@author \\@bspostauthor}\n    \\maketitlehookc\n    {\\@bspredate \\@date \\@bspostdate}\n    \\maketitlehookd\n    \\par\n    \\vskip 1.5em}\n\\fi\n\n\\newenvironment{titlingpage}%\n  {%\n   \\let\\footnoterule\\relax\n   \\let\\footnotesize\\small\n   \\if@twocolumn\n     \\@restonecoltrue\\onecolumn\n   \\else\n     \\@restonecolfalse\n   \\fi\n   \\thispagestyle{empty}\n   \\setcounter{page}\\@ne\n  }{%\n   \\thispagestyle{empty}\n   \\if@restonecol\\twocolumn \\else \\newpage \\fi\n   \\if@twoside\\else \\setcounter{page}\\@ne\\fi}\n\n\\newcommand{\\calccentering}[2]{\n  #1 = \\paperwidth\n  \\advance #1 by -\\textwidth\n  \\divide #1 by \\tw@\n  \\advance #1 by -#2\n  \\advance #1 by -\\hoffset\n  \\advance #1 by -1in\n}\n\n\\newcommand{\\emptythanks}{\\global\\let\\@thanks\\@empty}\n\n\\newcommand{\\@bsmtitlempty}{%\n  \\global\\let\\maketitle\\relax\n  \\global\\let\\@maketitle\\relax\n  \\global\\let\\title\\relax\n  \\global\\let\\author\\relax\n  \\global\\let\\date\\relax\n  \\global\\let\\thanksmarkseries\\relax\n  \\global\\let\\thanksheadextra\\relax\n  \\global\\let\\thanksfootextra\\relax\n  \\global\\let\\thanksmark\\relax\n  \\global\\let\\thanksgap\\relax\n}\n\n\\newcommand{\\keepthetitle}{%\n  \\@bsmtitlempty\n  \\global\\let\\thanks\\relax\n  \\global\\let\\and\\relax\n  \\global\\let\\@thanks\\@empty\n  \\global\\let\\@title\\@empty\n  \\global\\let\\@author\\@empty\n  \\global\\let\\@date\\@empty\n}\n\n\\providecommand{\\killtitle}{}\n\\renewcommand{\\killtitle}{%\n  \\keepthetitle\n  \\global\\let\\thetitle\\relax\n  \\global\\let\\theauthor\\relax\n  \\global\\let\\thedate\\relax\n}\n\n\\providecommand{\\appendiargdef}[2]{\\begingroup\n  \\toks@\\expandafter{#1{##1}#2}%\n  \\edef\\@bsx{\\endgroup \\def\\noexpand#1####1{\\the\\toks@}}%\n  \\@bsx}\n\n\\appendiargdef{\\title}{%\n  \\begingroup\n    \\renewcommand{\\thanks}[1]{}\n    \\renewcommand{\\thanksmark}[1]{}\n    \\renewcommand{\\thanksgap}[1]{}\n    \\protected@xdef\\thetitle{#1}\n  \\endgroup}\n\\appendiargdef{\\author}{%\n  \\begingroup\n    \\renewcommand{\\thanks}[1]{}\n    \\renewcommand{\\and}{\\unskip, }\n    \\renewcommand{\\thanksmark}[1]{}\n    \\renewcommand{\\thanksgap}[1]{}\n    \\protected@xdef\\theauthor{#1}\n  \\endgroup}\n\\appendiargdef{\\date}{%\n  \\begingroup\n    \\renewcommand{\\thanks}[1]{}\n    \\renewcommand{\\thanksmark}[1]{}\n    \\renewcommand{\\thanksgap}[1]{}\n    \\protected@xdef\\thedate{#1}\n  \\endgroup}\n\n\\endinput\n%%\n%% End of file `titling.sty\'.\n'
p0
.I0
.S'Classfile'
p0
.S'You can add your custom classfile here.'
p0
.I1
.S'sig-alternate'
p0
.S'$class: sig-alternate\n%rabi SIG-ALTERNATE.CLS - VERSION 2.5\n% "COMPATIBLE" WITH THE "ACM_PROC_ARTICLE-SP.CLS" V3.2SP\n% Gerald Murray - May 23rd 2012\n%\n% ---- Start of \'updates\'  ----\n% Changed $10 fee to $15 -- May 2012  --  Gerry\n% Changed $5 fee to $10 --  April 2009 -- Gerry\n% April 22nd. 2009 - Fixed \'Natbib\' incompatibility problem - Gerry\n% April 22nd. 2009 - Fixed \'Babel\' incompatibility problem - Gerry\n% April 22nd. 2009 - Inserted various bug-fixes and improvements - Gerry\n%\n% To produce Type 1 fonts in the document plus allow for \'normal LaTeX accenting\' in the critical areas;\n% title, author block, section-heads, confname, etc. etc. \n% i.e. the whole purpose of this version update is to NOT resort to \'inelegant accent patches\'.\n% After much research, three extra .sty packages were added to the the tail (ae, aecompl, aeguill) to solve,\n% in particular, the accenting problem(s). We _could_ ask authors (via instructions/sample file) to \'include\' these in\n% the source .tex file - in the preamble - but if everything is already provided (\'behind the scenes\' - embedded IN the .cls)\n% then this is less work for authors and also makes everything appear \'vanilla\'.\n% NOTE: all \'patchwork accenting" has been commented out (here) and is no longer \'used\' in the sample .tex file (either).\n% Gerry June 2007\n%\n% Patch for accenting in conference name/location. Gerry May 3rd. 2007\n% Rule widths changed to .5, author count (>6) fixed, roll-back for Type 3 problem. Gerry March 20th. 2007\n% Changes made to \'modernize\' the fontnames but esp. for MikTeX users V2.4/2.5 - Nov. 30th. 2006\n% Updated the \\email definition to allow for its use inside of \'shared affiliations\' - Nov. 30th. 2006\n% Fixed the \'section number depth value\' - Nov. 30th. 2006\n%\n% Footnotes inside table cells using \\minipage (Oct. 2002)\n% Georgia fixed bug in sub-sub-section numbering in paragraphs (July 29th. 2002)\n% JS/GM fix to vertical spacing before Proofs (July 30th. 2002)\n%\n% Made the Permission Statement / Conference Info / Copyright Info\n% \'user definable\' in the source .tex file OR automatic if\n% not specified.\n%\n% Allowance made to switch default fonts between those systems using\n% normal/modern font names and those using \'Type 1\' or \'Truetype\' fonts.\n% See LINE NUMBER 255 for details.\n% Also provided for enumerated/annotated Corollaries \'surrounded\' by\n% enumerated Theorems (line 848).\n% Gerry November 11th. 1999\n%\n% ---- End of \'updates\' ----\n%\n\\def\\fileversion{v2.5}          % for ACM\'s tracking purposes\n\\def\\filedate{May 23, 2012}    % Gerry Murray\'s tracking data\n\\def\\docdate {Wednesday 23rd. May 2012} % Gerry Murray (with deltas to doc}\n\\usepackage{epsfig}\n\\usepackage{amssymb}\n\\usepackage{amsmath}\n\\usepackage{amsfonts}\n% Need this for accents in Arial/Helvetica\n%\\usepackage[T1]{fontenc}  % Gerry March 12, 2007 - causes Type 3 problems (body text)\n%\\usepackage{textcomp}\n%\n% SIG-ALTERNATE DOCUMENT STYLE\n% G.K.M. Tobin August-October 1999\n%    adapted from ARTICLE document style by Ken Traub, Olin Shivers\n%    also using elements of esub2acm.cls\n% HEAVILY MODIFIED, SUBSEQUENTLY, BY GERRY MURRAY 2000\n% ARTICLE DOCUMENT STYLE -- Released 16 March 1988\n%    for LaTeX version 2.09\n% Copyright (C) 1988 by Leslie Lamport\n%\n%\n%%% sig-alternate.cls is an \'ALTERNATE\' document style for producing\n%%% two-column camera-ready pages for ACM conferences.\n%%% THIS FILE DOES NOT STRICTLY ADHERE TO THE SIGS (BOARD-ENDORSED)\n%%% PROCEEDINGS STYLE. It has been designed to produce a \'tighter\'\n%%% paper in response to concerns over page budgets.\n%%% The main features of this style are:\n%%%\n%%% 1)  Two columns.\n%%% 2)  Side and top margins of 4.5pc, bottom margin of 6pc, column gutter of\n%%%     2pc, hence columns are 20pc wide and 55.5pc tall.  (6pc =3D 1in, approx)\n%%% 3)  First page has title information, and an extra 6pc of space at the\n%%%     bottom of the first column for the ACM copyright notice.\n%%% 4)  Text is 9pt on 10pt baselines; titles (except main) are 9pt bold.\n%%%\n%%%\n%%% There are a few restrictions you must observe:\n%%%\n%%% 1)  You cannot change the font size; ACM wants you to use 9pt.\n%%% 3)  You must start your paper with the \\maketitle command.  Prior to the\n%%%     \\maketitle you must have \\title and \\author commands.  If you have a\n%%%     \\date command it will be ignored; no date appears on the paper, since\n%%%     the proceedings will have a date on the front cover.\n%%% 4)  Marginal paragraphs, tables of contents, lists of figures and tables,\n%%%     and page headings are all forbidden.\n%%% 5)  The `figure\' environment will produce a figure one column wide; if you\n%%%     want one that is two columns wide, use `figure*\'.\n%%%\n%\n%%% Copyright Space:\n%%% This style automatically reserves 1" blank space at the bottom of page 1/\n%%% column 1.  This space can optionally be filled with some text using the\n%%% \\toappear{...} command.  If used, this command must be BEFORE the \\maketitle\n%%% command.  If this command is defined AND [preprint] is on, then the\n%%% space is filled with the {...} text (at the bottom); otherwise, it is\n%%% blank.  If you use \\toappearbox{...} instead of \\toappear{...} then a\n%%% box will be drawn around the text (if [preprint] is on).\n%%%\n%%% A typical usage looks like this:\n%%%     \\toappear{To appear in the Ninth AES Conference on Medievil Lithuanian\n%%%               Embalming Technique, June 1991, Alfaretta, Georgia.}\n%%% This will be included in the preprint, and left out of the conference\n%%% version.\n%%%\n%%% WARNING:\n%%% Some dvi-ps converters heuristically allow chars to drift from their\n%%% true positions a few pixels. This may be noticeable with the 9pt sans-serif\n%%% bold font used for section headers.\n%%% You may turn this hackery off via the -e option:\n%%%     dvips -e 0 foo.dvi >foo.ps\n%%%\n\\typeout{Document Class \'sig-alternate\' <23rd. May \'12>.  Modified by G.K.M. Tobin/Gerry Murray}\n\\typeout{Based in part upon document Style `acmconf\' <22 May 89>. Hacked 4/91 by}\n\\typeout{shivers@cs.cmu.edu, 4/93 by theobald@cs.mcgill.ca}\n\\typeout{Excerpts were taken from (Journal Style) \'esub2acm.cls\'.}\n\\typeout{****** Bugs/comments/suggestions/technicalities to Gerry Murray -- murray@hq.acm.org ******}\n\\typeout{Questions on the style, SIGS policies, etc. to Adrienne Griscti griscti@acm.org}\n\\oddsidemargin 4.5pc\n\\evensidemargin 4.5pc\n\\advance\\oddsidemargin by -1in  % Correct for LaTeX gratuitousness\n\\advance\\evensidemargin by -1in % Correct for LaTeX gratuitousness\n\\marginparwidth 0pt             % Margin pars are not allowed.\n\\marginparsep 11pt              % Horizontal space between outer margin and\n                                % marginal note\n\n                                % Top of page:\n\\topmargin 4.5pc                % Nominal distance from top of page to top of\n                                % box containing running head.\n\\advance\\topmargin by -1in      % Correct for LaTeX gratuitousness\n\\headheight 0pt                 % Height of box containing running head.\n\\headsep 0pt                    % Space between running head and text.\n                                % Bottom of page:\n\\footskip 30pt                  % Distance from baseline of box containing foot\n                                % to baseline of last line of text.\n\\@ifundefined{footheight}{\\newdimen\\footheight}{}% this is for LaTeX2e\n\\footheight 12pt                % Height of box containing running foot.\n\n%% Must redefine the top margin so there\'s room for headers and\n%% page numbers if you are using the preprint option. Footers\n%% are OK as is. Olin.\n\\advance\\topmargin by -37pt     % Leave 37pt above text for headers\n\\headheight 12pt                % Height of box containing running head.\n\\headsep 25pt                   % Space between running head and text.\n\n\\textheight 666pt       % 9 1/4 column height\n\\textwidth 42pc         % Width of text line.\n                        % For two-column mode:\n\\columnsep 2pc          %    Space between columns\n\\columnseprule 0pt      %    Width of rule between columns.\n\\hfuzz 1pt              % Allow some variation in column width, otherwise it\'s\n                        % too hard to typeset in narrow columns.\n\n\\footnotesep 5.6pt      % Height of strut placed at the beginning of every\n                        % footnote =3D height of normal \\footnotesize strut,\n                        % so no extra space between footnotes.\n\n\\skip\\footins 8.1pt plus 4pt minus 2pt  % Space between last line of text and\n                                        % top of first footnote.\n\\floatsep 11pt plus 2pt minus 2pt       % Space between adjacent floats moved\n                                        % to top or bottom of text page.\n\\textfloatsep 18pt plus 2pt minus 4pt   % Space between main text and floats\n                                        % at top or bottom of page.\n\\intextsep 11pt plus 2pt minus 2pt      % Space between in-text figures and\n                                        % text.\n\\@ifundefined{@maxsep}{\\newdimen\\@maxsep}{}% this is for LaTeX2e\n\\@maxsep 18pt                           % The maximum of \\floatsep,\n                                        % \\textfloatsep and \\intextsep (minus\n                                        % the stretch and shrink).\n\\dblfloatsep 11pt plus 2pt minus 2pt    % Same as \\floatsep for double-column\n                                        % figures in two-column mode.\n\\dbltextfloatsep 18pt plus 2pt minus 4pt% \\textfloatsep for double-column\n                                        % floats.\n\\@ifundefined{@dblmaxsep}{\\newdimen\\@dblmaxsep}{}% this is for LaTeX2e\n\\@dblmaxsep 18pt                        % The maximum of \\dblfloatsep and\n                                        % \\dbltexfloatsep.\n\\@fptop 0pt plus 1fil    % Stretch at top of float page/column. (Must be\n                         % 0pt plus ...)\n\\@fpsep 8pt plus 2fil    % Space between floats on float page/column.\n\\@fpbot 0pt plus 1fil    % Stretch at bottom of float page/column. (Must be\n                         % 0pt plus ... )\n\\@dblfptop 0pt plus 1fil % Stretch at top of float page. (Must be 0pt plus ...)\n\\@dblfpsep 8pt plus 2fil % Space between floats on float page.\n\\@dblfpbot 0pt plus 1fil % Stretch at bottom of float page. (Must be\n                         % 0pt plus ... )\n\\marginparpush 5pt       % Minimum vertical separation between two marginal\n                         % notes.\n\n\\parskip 0pt plus 1pt            % Extra vertical space between paragraphs.\n\\parindent 10pt  % GM July 2000 / was 0pt - width of paragraph indentation.\n\\partopsep 2pt plus 1pt minus 1pt% Extra vertical space, in addition to\n                                 % \\parskip and \\topsep, added when user\n                                 % leaves blank line before environment.\n\n\\@lowpenalty   51       % Produced by \\nopagebreak[1] or \\nolinebreak[1]\n\\@medpenalty  151       % Produced by \\nopagebreak[2] or \\nolinebreak[2]\n\\@highpenalty 301       % Produced by \\nopagebreak[3] or \\nolinebreak[3]\n\n\\@beginparpenalty -\\@lowpenalty % Before a list or paragraph environment.\n\\@endparpenalty   -\\@lowpenalty % After a list or paragraph environment.\n\\@itempenalty     -\\@lowpenalty % Between list items.\n\n%\\@namedef{ds@10pt}{\\@latexerr{The `10pt\' option is not allowed in the `acmconf\'\n%\\@namedef{ds@10pt}{\\ClassError{The `10pt\' option is not allowed in the `acmconf\'\t% January 2008\n%  document style.}\\@eha}\n%\\@namedef{ds@11pt}{\\@latexerr{The `11pt\' option is not allowed in the `acmconf\'\n\\@namedef{ds@11pt}{\\ClassError{The `11pt\' option is not allowed in the `acmconf\'\t% January 2008\n  document style.}\\@eha}\n%\\@namedef{ds@12pt}{\\@latexerr{The `12pt\' option is not allowed in the `acmconf\'\n\\@namedef{ds@12pt}{\\ClassError{The `12pt\' option is not allowed in the `acmconf\'\t% January 2008\n  document style.}\\@eha}\n\n\\@options\n\n\\lineskip 2pt           % \\lineskip is 1pt for all font sizes.\n\\normallineskip 2pt\n\\def\\baselinestretch{1}\n\n\\abovedisplayskip 10pt plus2pt minus4.5pt%\n\\belowdisplayskip \\abovedisplayskip\n\\abovedisplayshortskip  \\z@ plus3pt%\n\\belowdisplayshortskip  5.4pt plus3pt minus3pt%\n\\let\\@listi\\@listI     % Setting of \\@listi added 9 Jun 87\n\n\\def\\small{\\@setsize\\small{9pt}\\viiipt\\@viiipt\n\\abovedisplayskip 7.6pt plus 3pt minus 4pt%\n\\belowdisplayskip \\abovedisplayskip\n\\abovedisplayshortskip \\z@ plus2pt%\n\\belowdisplayshortskip 3.6pt plus2pt minus 2pt\n\\def\\@listi{\\leftmargin\\leftmargini %% Added 22 Dec 87\n\\topsep 4pt plus 2pt minus 2pt\\parsep 2pt plus 1pt minus 1pt\n\\itemsep \\parsep}}\n\n\\def\\refsmall{\\@setsize\\small{8pt}\\viiipt\\@viiipt\n\\abovedisplayskip 7.6pt plus 3pt minus 4pt%\n\\belowdisplayskip \\abovedisplayskip\n\\abovedisplayshortskip \\z@ plus2pt%\n\\belowdisplayshortskip 3.6pt plus2pt minus 2pt\n\\def\\@listi{\\leftmargin\\leftmargini %% Added 22 Dec 87\n\\topsep 4pt plus 2pt minus 2pt\\parsep 2pt plus 1pt minus 1pt\n\\itemsep \\parsep}}\n\n\\def\\footnotesize{\\@setsize\\footnotesize{9pt}\\ixpt\\@ixpt\n\\abovedisplayskip 6.4pt plus 2pt minus 4pt%\n\\belowdisplayskip \\abovedisplayskip\n\\abovedisplayshortskip \\z@ plus 1pt%\n\\belowdisplayshortskip 2.7pt plus 1pt minus 2pt\n\\def\\@listi{\\leftmargin\\leftmargini %% Added 22 Dec 87\n\\topsep 3pt plus 1pt minus 1pt\\parsep 2pt plus 1pt minus 1pt\n\\itemsep \\parsep}}\n\n\\newcount\\aucount\n\\newcount\\originalaucount\n\\newdimen\\auwidth\n\\auwidth=\\textwidth\n\\newdimen\\auskip\n\\newcount\\auskipcount\n\\newdimen\\auskip\n\\global\\auskip=1pc\n\\newdimen\\allauboxes\n\\allauboxes=\\auwidth\n\\newtoks\\addauthors\n\\newcount\\addauflag\n\\global\\addauflag=0 %Haven\'t shown additional authors yet\n\n\\newtoks\\subtitletext\n\\gdef\\subtitle#1{\\subtitletext={#1}}\n\n\\gdef\\additionalauthors#1{\\addauthors={#1}}\n\n\\gdef\\numberofauthors#1{\\global\\aucount=#1\n\\ifnum\\aucount>3\\global\\originalaucount=\\aucount \\global\\aucount=3\\fi %g}  % 3 OK - Gerry March 2007\n\\global\\auskipcount=\\aucount\\global\\advance\\auskipcount by 1\n\\global\\multiply\\auskipcount by 2\n\\global\\multiply\\auskip by \\auskipcount\n\\global\\advance\\auwidth by -\\auskip\n\\global\\divide\\auwidth by \\aucount}\n\n% \\and was modified to count the number of authors.  GKMT 12 Aug 1999\n\\def\\alignauthor{%                  % \\begin{tabular}\n\\end{tabular}%\n  \\begin{tabular}[t]{p{\\auwidth}}\\centering}%\n\n%  *** NOTE *** NOTE *** NOTE *** NOTE ***\n%  If you have \'font problems\' then you may need\n%  to change these, e.g. \'arialb\' instead of "arialbd".\n%  Gerry Murray 11/11/1999\n%  *** OR ** comment out block A and activate block B or vice versa.\n% **********************************************\n%\n%  -- Start of block A -- (Type 1 or Truetype fonts)\n%\\newfont{\\secfnt}{timesbd at 12pt} % was timenrb originally - now is timesbd\n%\\newfont{\\secit}{timesbi at 12pt}   %13 Jan 00 gkmt\n%\\newfont{\\subsecfnt}{timesi at 11pt} % was timenrri originally - now is timesi\n%\\newfont{\\subsecit}{timesbi at 11pt} % 13 Jan 00 gkmt -- was times changed to timesbi gm 2/4/2000\n%                         % because "normal" is italic, "italic" is Roman\n%\\newfont{\\ttlfnt}{arialbd at 18pt} % was arialb originally - now is arialbd\n%\\newfont{\\ttlit}{arialbi at 18pt}    % 13 Jan 00 gkmt\n%\\newfont{\\subttlfnt}{arial at 14pt} % was arialr originally - now is arial\n%\\newfont{\\subttlit}{ariali at 14pt} % 13 Jan 00 gkmt\n%\\newfont{\\subttlbf}{arialbd at 14pt}  % 13 Jan 00 gkmt\n%\\newfont{\\aufnt}{arial at 12pt} % was arialr originally - now is arial\n%\\newfont{\\auit}{ariali at 12pt} % 13 Jan 00 gkmt\n%\\newfont{\\affaddr}{arial at 10pt} % was arialr originally - now is arial\n%\\newfont{\\affaddrit}{ariali at 10pt} %13 Jan 00 gkmt\n%\\newfont{\\eaddfnt}{arial at 12pt} % was arialr originally - now is arial\n%\\newfont{\\ixpt}{times at 9pt} % was timenrr originally - now is times\n%\\newfont{\\confname}{timesi at 8pt} % was timenrri - now is timesi\n%\\newfont{\\crnotice}{times at 8pt} % was timenrr originally - now is times\n%\\newfont{\\ninept}{times at 9pt} % was timenrr originally - now is times\n\n% *********************************************\n%  -- End of block A --\n%\n%\n% -- Start of block B -- UPDATED FONT NAMES\n% *********************************************\n% Gerry Murray 11/30/2006\n% *********************************************\n\\newfont{\\secfnt}{ptmb8t at 12pt}\n\\newfont{\\secit}{ptmbi8t at 12pt}    %13 Jan 00 gkmt\n\\newfont{\\subsecfnt}{ptmri8t at 11pt}\n\\newfont{\\subsecit}{ptmbi8t at 11pt}  % \n\\newfont{\\ttlfnt}{phvb8t at 18pt}\n\\newfont{\\ttlit}{phvbo8t at 18pt}    % GM 2/4/2000\n\\newfont{\\subttlfnt}{phvr8t at 14pt}\n\\newfont{\\subttlit}{phvro8t at 14pt} % GM 2/4/2000\n\\newfont{\\subttlbf}{phvb8t at 14pt}  % 13 Jan 00 gkmt\n\\newfont{\\aufnt}{phvr8t at 12pt}\n\\newfont{\\auit}{phvro8t at 12pt}     % GM 2/4/2000\n\\newfont{\\affaddr}{phvr8t at 10pt}\n\\newfont{\\affaddrit}{phvro8t at 10pt} % GM 2/4/2000\n\\newfont{\\eaddfnt}{phvr8t at 12pt}\n\\newfont{\\ixpt}{ptmr8t at 9pt}\n\\newfont{\\confname}{ptmri8t at 8pt}\n\\newfont{\\crnotice}{ptmr8t at 8pt}\n\\newfont{\\ninept}{ptmr8t at 9pt}\n% +++++++++++++++++++++++++++++++++++++++++++++\n% -- End of block B --\n\n%\\def\\email#1{{{\\eaddfnt{\\vskip 4pt#1}}}}\n% If we have an email, inside a "shared affiliation" then we need the following instead\n\\def\\email#1{{{\\eaddfnt{\\par #1}}}}       % revised  - GM - 11/30/2006\n\n\\def\\addauthorsection{\\ifnum\\originalaucount>6  % was 3 - Gerry March 2007\n    \\section{Additional Authors}\\the\\addauthors\n  \\fi}\n\n\\newcount\\savesection\n\\newcount\\sectioncntr\n\\global\\sectioncntr=1\n\n\\setcounter{secnumdepth}{3}\n\n\\def\\appendix{\\par\n\\section*{APPENDIX}\n\\setcounter{section}{0}\n \\setcounter{subsection}{0}\n \\def\\thesection{\\Alph{section}} }\n\n\\leftmargini 22.5pt\n\\leftmarginii 19.8pt    % > \\labelsep + width of \'(m)\'\n\\leftmarginiii 16.8pt   % > \\labelsep + width of \'vii.\'\n\\leftmarginiv 15.3pt    % > \\labelsep + width of \'M.\'\n\\leftmarginv 9pt\n\\leftmarginvi 9pt\n\n\\leftmargin\\leftmargini\n\\labelsep 4.5pt\n\\labelwidth\\leftmargini\\advance\\labelwidth-\\labelsep\n\n\\def\\@listI{\\leftmargin\\leftmargini \\parsep 3.6pt plus 2pt minus 1pt%\n\\topsep 7.2pt plus 2pt minus 4pt%\n\\itemsep 3.6pt plus 2pt minus 1pt}\n\n\\let\\@listi\\@listI\n\\@listi\n\n\\def\\@listii{\\leftmargin\\leftmarginii\n   \\labelwidth\\leftmarginii\\advance\\labelwidth-\\labelsep\n   \\topsep 3.6pt plus 2pt minus 1pt\n   \\parsep 1.8pt plus 0.9pt minus 0.9pt\n   \\itemsep \\parsep}\n\n\\def\\@listiii{\\leftmargin\\leftmarginiii\n    \\labelwidth\\leftmarginiii\\advance\\labelwidth-\\labelsep\n    \\topsep 1.8pt plus 0.9pt minus 0.9pt\n    \\parsep \\z@ \\partopsep 1pt plus 0pt minus 1pt\n    \\itemsep \\topsep}\n\n\\def\\@listiv{\\leftmargin\\leftmarginiv\n     \\labelwidth\\leftmarginiv\\advance\\labelwidth-\\labelsep}\n\n\\def\\@listv{\\leftmargin\\leftmarginv\n     \\labelwidth\\leftmarginv\\advance\\labelwidth-\\labelsep}\n\n\\def\\@listvi{\\leftmargin\\leftmarginvi\n     \\labelwidth\\leftmarginvi\\advance\\labelwidth-\\labelsep}\n\n\\def\\labelenumi{\\theenumi.}\n\\def\\theenumi{\\arabic{enumi}}\n\n\\def\\labelenumii{(\\theenumii)}\n\\def\\theenumii{\\alph{enumii}}\n\\def\\p@enumii{\\theenumi}\n\n\\def\\labelenumiii{\\theenumiii.}\n\\def\\theenumiii{\\roman{enumiii}}\n\\def\\p@enumiii{\\theenumi(\\theenumii)}\n\n\\def\\labelenumiv{\\theenumiv.}\n\\def\\theenumiv{\\Alph{enumiv}}\n\\def\\p@enumiv{\\p@enumiii\\theenumiii}\n\n\\def\\labelitemi{$\\bullet$}\n\\def\\labelitemii{\\bf --}\n\\def\\labelitemiii{$\\ast$}\n\\def\\labelitemiv{$\\cdot$}\n\n\\def\\verse{\\let\\\\=\\@centercr\n  \\list{}{\\itemsep\\z@ \\itemindent -1.5em\\listparindent \\itemindent\n          \\rightmargin\\leftmargin\\advance\\leftmargin 1.5em}\\item[]}\n\\let\\endverse\\endlist\n\n\\def\\quotation{\\list{}{\\listparindent 1.5em\n    \\itemindent\\listparindent\n    \\rightmargin\\leftmargin \\parsep 0pt plus 1pt}\\item[]}\n\\let\\endquotation=\\endlist\n\n\\def\\quote{\\list{}{\\rightmargin\\leftmargin}\\item[]}\n\\let\\endquote=\\endlist\n\n\\def\\descriptionlabel#1{\\hspace\\labelsep \\bf #1}\n\\def\\description{\\list{}{\\labelwidth\\z@ \\itemindent-\\leftmargin\n       \\let\\makelabel\\descriptionlabel}}\n\n\\let\\enddescription\\endlist\n\n\\def\\theequation{\\arabic{equation}}\n\n\\arraycolsep 4.5pt   % Half the space between columns in an array environment.\n\\tabcolsep 5.4pt    % Half the space between columns in a tabular environment.\n\\arrayrulewidth .5pt % Width of rules in array and tabular environment. % (was .4) updated Gerry March 20 2007\n\\doublerulesep 1.8pt % Space between adjacent rules in array or tabular env.\n\n\\tabbingsep \\labelsep   % Space used by the \\\' command.  (See LaTeX manual.)\n\n\\skip\\@mpfootins =\\skip\\footins\n\n\\fboxsep =2.7pt      % Space left between box and text by \\fbox and \\framebox.\n\\fboxrule =.5pt      % Width of rules in box made by \\fbox and \\framebox. % (was .4) updated Gerry March 20 2007\n\n\\def\\thepart{\\Roman{part}} % Roman numeral part numbers.\n\\def\\thesection       {\\arabic{section}}\n\\def\\thesubsection    {\\thesection.\\arabic{subsection}}\n%\\def\\thesubsubsection {\\thesubsection.\\arabic{subsubsection}} % GM 7/30/2002\n%\\def\\theparagraph     {\\thesubsubsection.\\arabic{paragraph}}  % GM 7/30/2002\n\\def\\thesubparagraph  {\\theparagraph.\\arabic{subparagraph}}\n\n\\def\\@pnumwidth{1.55em}\n\\def\\@tocrmarg {2.55em}\n\\def\\@dotsep{4.5}\n\\setcounter{tocdepth}{3}\n\n%\\def\\tableofcontents{\\@latexerr{\\tableofcontents: Tables of contents are not\n%  allowed in the `acmconf\' document style.}\\@eha}\n\n\\def\\tableofcontents{\\ClassError{%\n    \\string\\tableofcontents\\space is not allowed in the `acmconf\' document\t% January 2008\n    style}\\@eha}\n\n\\def\\l@part#1#2{\\addpenalty{\\@secpenalty}\n   \\addvspace{2.25em plus 1pt}  % space above part line\n   \\begingroup\n   \\@tempdima 3em       % width of box holding part number, used by\n     \\parindent \\z@ \\rightskip \\@pnumwidth      %% \\numberline\n     \\parfillskip -\\@pnumwidth\n     {\\large \\bf        % set line in \\large boldface\n     \\leavevmode        % TeX command to enter horizontal mode.\n     #1\\hfil \\hbox to\\@pnumwidth{\\hss #2}}\\par\n     \\nobreak           % Never break after part entry\n   \\endgroup}\n\n\\def\\l@section#1#2{\\addpenalty{\\@secpenalty} % good place for page break\n   \\addvspace{1.0em plus 1pt}   % space above toc entry\n   \\@tempdima 1.5em             % width of box holding section number\n   \\begingroup\n    \\parindent  \\z@ \\rightskip \\@pnumwidth\n     \\parfillskip -\\@pnumwidth\n     \\bf                        % Boldface.\n     \\leavevmode                % TeX command to enter horizontal mode.\n      \\advance\\leftskip\\@tempdima %% added 5 Feb 88 to conform to\n      \\hskip -\\leftskip           %% 25 Jan 88 change to \\numberline\n     #1\\nobreak\\hfil \\nobreak\\hbox to\\@pnumwidth{\\hss #2}\\par\n   \\endgroup}\n\n\n\\def\\l@subsection{\\@dottedtocline{2}{1.5em}{2.3em}}\n\\def\\l@subsubsection{\\@dottedtocline{3}{3.8em}{3.2em}}\n\\def\\l@paragraph{\\@dottedtocline{4}{7.0em}{4.1em}}\n\\def\\l@subparagraph{\\@dottedtocline{5}{10em}{5em}}\n\n%\\def\\listoffigures{\\@latexerr{\\listoffigures: Lists of figures are not\n%  allowed in the `acmconf\' document style.}\\@eha}\n\n\\def\\listoffigures{\\ClassError{%\n    \\string\\listoffigures\\space is not allowed in the `acmconf\' document\t% January 2008\n    style}\\@eha}\n\n\\def\\l@figure{\\@dottedtocline{1}{1.5em}{2.3em}}\n\n%\\def\\listoftables{\\@latexerr{\\listoftables: Lists of tables are not\n%  allowed in the `acmconf\' document style.}\\@eha}\n%\\let\\l@table\\l@figure\n\n\\def\\listoftables{\\ClassError{%\n    \\string\\listoftables\\space is not allowed in the `acmconf\' document\t\t% January 2008\n    style}\\@eha}\n \\let\\l@table\\l@figure\n\n\\def\\footnoterule{\\kern-3\\p@\n  \\hrule width .5\\columnwidth   % (was .4) updated Gerry March 20 2007\n  \\kern 2.6\\p@}                 % The \\hrule has default height of .4pt % (was .4) updated Gerry March 20 2007\n% ------\n\\long\\def\\@makefntext#1{\\noindent \n%\\hbox to .5em{\\hss$^{\\@thefnmark}$}#1}   % original\n\\hbox to .5em{\\hss\\textsuperscript{\\@thefnmark}}#1}  % C. Clifton / GM Oct. 2nd. 2002\n% -------\n\n\\long\\def\\@maketntext#1{\\noindent\n#1}\n\n\\long\\def\\@maketitlenotetext#1#2{\\noindent\n            \\hbox to 1.8em{\\hss$^{#1}$}#2}\n\n\\setcounter{topnumber}{2}\n\\def\\topfraction{.7}\n\\setcounter{bottomnumber}{1}\n\\def\\bottomfraction{.3}\n\\setcounter{totalnumber}{3}\n\\def\\textfraction{.2}\n\\def\\floatpagefraction{.5}\n\\setcounter{dbltopnumber}{2}\n\\def\\dbltopfraction{.7}\n\\def\\dblfloatpagefraction{.5}\n\n%\n\\long\\def\\@makecaption#1#2{\n   \\vskip \\baselineskip\n   \\setbox\\@tempboxa\\hbox{\\textbf{#1: #2}}\n   \\ifdim \\wd\\@tempboxa >\\hsize % IF longer than one line:\n       \\textbf{#1: #2}\\par               %   THEN set as ordinary paragraph.\n     \\else                      %   ELSE  center.\n       \\hbox to\\hsize{\\hfil\\box\\@tempboxa\\hfil}\\par\n   \\fi}\n\n%\n\n\\long\\def\\@makecaption#1#2{\n   \\vskip 10pt\n   \\setbox\\@tempboxa\\hbox{\\textbf{#1: #2}}\n   \\ifdim \\wd\\@tempboxa >\\hsize % IF longer than one line:\n       \\textbf{#1: #2}\\par                %   THEN set as ordinary paragraph.\n     \\else                      %   ELSE  center.\n       \\hbox to\\hsize{\\hfil\\box\\@tempboxa\\hfil}\n   \\fi}\n\n\\@ifundefined{figure}{\\newcounter {figure}} % this is for LaTeX2e\n\n\\def\\fps@figure{tbp}\n\\def\\ftype@figure{1}\n\\def\\ext@figure{lof}\n\\def\\fnum@figure{Figure \\thefigure}\n\\def\\figure{\\@float{figure}}\n%\\let\\endfigure\\end@float\n\\def\\endfigure{\\end@float} \t\t% Gerry January 2008\n\\@namedef{figure*}{\\@dblfloat{figure}}\n\\@namedef{endfigure*}{\\end@dblfloat}\n\n\\@ifundefined{table}{\\newcounter {table}} % this is for LaTeX2e\n\n\\def\\fps@table{tbp}\n\\def\\ftype@table{2}\n\\def\\ext@table{lot}\n\\def\\fnum@table{Table \\thetable}\n\\def\\table{\\@float{table}}\n%\\let\\endtable\\end@float\n\\def\\endtable{\\end@float}\t\t% Gerry January 2008\n\\@namedef{table*}{\\@dblfloat{table}}\n\\@namedef{endtable*}{\\end@dblfloat}\n\n\\newtoks\\titleboxnotes\n\\newcount\\titleboxnoteflag\n\n\\def\\maketitle{\\par\n \\begingroup\n   \\def\\thefootnote{\\fnsymbol{footnote}}\n   \\def\\@makefnmark{\\hbox\n       to 0pt{$^{\\@thefnmark}$\\hss}}\n     \\twocolumn[\\@maketitle]\n\\@thanks\n \\endgroup\n \\setcounter{footnote}{0}\n \\let\\maketitle\\relax\n \\let\\@maketitle\\relax\n \\gdef\\@thanks{}\\gdef\\@author{}\\gdef\\@title{}\\gdef\\@subtitle{}\\let\\thanks\\relax\n \\@copyrightspace}\n\n%% CHANGES ON NEXT LINES\n\\newif\\if@ll % to record which version of LaTeX is in use\n\n\\expandafter\\ifx\\csname LaTeXe\\endcsname\\relax % LaTeX2.09 is used\n\\else% LaTeX2e is used, so set ll to true\n\\global\\@lltrue\n\\fi\n\n\\if@ll\n  \\NeedsTeXFormat{LaTeX2e}\n  \\ProvidesClass{sig-alternate} [2012/05/23 - V2.5 - based on acmproc.cls V1.3 <Nov. 30 \'99>]\n  \\RequirePackage{latexsym}% QUERY: are these two really needed?\n  \\let\\dooptions\\ProcessOptions\n\\else\n  \\let\\dooptions\\@options\n\\fi\n%% END CHANGES\n\n\\def\\@height{height}\n\\def\\@width{width}\n\\def\\@minus{minus}\n\\def\\@plus{plus}\n\\def\\hb@xt@{\\hbox to}\n\\newif\\if@faircopy\n\\@faircopyfalse\n\\def\\ds@faircopy{\\@faircopytrue}\n\n\\def\\ds@preprint{\\@faircopyfalse}\n\n\\@twosidetrue\n\\@mparswitchtrue\n\\def\\ds@draft{\\overfullrule 5\\p@}\n%% CHANGE ON NEXT LINE\n\\dooptions\n\n\\lineskip \\p@\n\\normallineskip \\p@\n\\def\\baselinestretch{1}\n\\def\\@ptsize{0} %needed for amssymbols.sty\n\n%% CHANGES ON NEXT LINES\n\\if@ll% allow use of old-style font change commands in LaTeX2e\n\\@maxdepth\\maxdepth\n%\n\\DeclareOldFontCommand{\\rm}{\\ninept\\rmfamily}{\\mathrm}\n\\DeclareOldFontCommand{\\sf}{\\normalfont\\sffamily}{\\mathsf}\n\\DeclareOldFontCommand{\\tt}{\\normalfont\\ttfamily}{\\mathtt}\n\\DeclareOldFontCommand{\\bf}{\\normalfont\\bfseries}{\\mathbf}\n\\DeclareOldFontCommand{\\it}{\\normalfont\\itshape}{\\mathit}\n\\DeclareOldFontCommand{\\sl}{\\normalfont\\slshape}{\\@nomath\\sl}\n\\DeclareOldFontCommand{\\sc}{\\normalfont\\scshape}{\\@nomath\\sc}\n\\DeclareRobustCommand*{\\cal}{\\@fontswitch{\\relax}{\\mathcal}}\n\\DeclareRobustCommand*{\\mit}{\\@fontswitch{\\relax}{\\mathnormal}}\n\\fi\n%\n\\if@ll\n\\renewcommand{\\rmdefault}{cmr}  % was \'ttm\'\n% Note! I have also found \'mvr\' to work ESPECIALLY well.\n% Gerry - October 1999\n% You may need to change your LV1times.fd file so that sc is\n% mapped to cmcsc - -for smallcaps -- that is if you decide\n% to change {cmr} to {times} above. (Not recommended)\n  \\renewcommand{\\@ptsize}{}\n  \\renewcommand{\\normalsize}{%\n    %\\@setfontsize\\normalsize\\@ixpt{10.5\\p@}%\\ninept%\n    \\@setfontsize\\normalsize\\@xpt{11\\p@}%\\tenpt% %% Adjusted for 10pt\n    \\abovedisplayskip 6\\p@ \\@plus2\\p@ \\@minus\\p@\n    \\belowdisplayskip \\abovedisplayskip\n    \\abovedisplayshortskip 6\\p@ \\@minus 3\\p@\n    \\belowdisplayshortskip 6\\p@ \\@minus 3\\p@\n    \\let\\@listi\\@listI\n  }\n\\else\n  \\def\\@normalsize{%changed next to 9 from 10\n    \\@setsize\\normalsize{10\\p@}\\ixpt\\@ixpt\n   \\abovedisplayskip 6\\p@ \\@plus2\\p@ \\@minus\\p@\n    \\belowdisplayskip \\abovedisplayskip\n    \\abovedisplayshortskip 6\\p@ \\@minus 3\\p@\n    \\belowdisplayshortskip 6\\p@ \\@minus 3\\p@\n    \\let\\@listi\\@listI\n  }%\n\\fi\n\\if@ll\n  \\newcommand\\scriptsize{\\@setfontsize\\scriptsize\\@viipt{8\\p@}}\n  \\newcommand\\tiny{\\@setfontsize\\tiny\\@vpt{6\\p@}}\n  \\newcommand\\large{\\@setfontsize\\large\\@xiipt{14\\p@}}\n  \\newcommand\\Large{\\@setfontsize\\Large\\@xivpt{18\\p@}}\n  \\newcommand\\LARGE{\\@setfontsize\\LARGE\\@xviipt{20\\p@}}\n  \\newcommand\\huge{\\@setfontsize\\huge\\@xxpt{25\\p@}}\n  \\newcommand\\Huge{\\@setfontsize\\Huge\\@xxvpt{30\\p@}}\n\\else\n  \\def\\scriptsize{\\@setsize\\scriptsize{8\\p@}\\viipt\\@viipt}\n  \\def\\tiny{\\@setsize\\tiny{6\\p@}\\vpt\\@vpt}\n  \\def\\large{\\@setsize\\large{14\\p@}\\xiipt\\@xiipt}\n  \\def\\Large{\\@setsize\\Large{18\\p@}\\xivpt\\@xivpt}\n  \\def\\LARGE{\\@setsize\\LARGE{20\\p@}\\xviipt\\@xviipt}\n  \\def\\huge{\\@setsize\\huge{25\\p@}\\xxpt\\@xxpt}\n  \\def\\Huge{\\@setsize\\Huge{30\\p@}\\xxvpt\\@xxvpt}\n\\fi\n\\normalsize\n\n% make aubox hsize/number of authors up to 3, less gutter\n% then showbox gutter showbox gutter showbox -- GKMT Aug 99\n\\newbox\\@acmtitlebox\n\\def\\@maketitle{\\newpage\n \\null\n \\setbox\\@acmtitlebox\\vbox{%\n\\baselineskip 20pt\n\\vskip 3em                   % Vertical space above title.\n   \\begin{center}\n    {\\ttlfnt \\@title\\par}       % Title set in 18pt Helvetica (Arial) bold size.\n    \\vskip 4em                % Vertical space after title.\n%This should be the subtitle.\n{\\subttlfnt \\the\\subtitletext\\par}\\vskip 1.25em%\\fi\n    {\\baselineskip 16pt\\aufnt   % each author set in \\12 pt Arial, in a\n     \\lineskip .5em             % tabular environment\n     \\begin{tabular}[t]{c}\\@author\n     \\end{tabular}\\par}\n    \\vskip 1.5em               % Vertical space after author.\n   \\end{center}}\n \\dimen0=\\ht\\@acmtitlebox\n \\advance\\dimen0 by -12.75pc\\relax % Increased space for title box -- KBT\n \\unvbox\\@acmtitlebox\n \\ifdim\\dimen0<0.0pt\\relax\\vskip-\\dimen0\\fi}\n\n\n\\newcount\\titlenotecount\n\\global\\titlenotecount=0\n\\newtoks\\tntoks\n\\newtoks\\tntokstwo\n\\newtoks\\tntoksthree\n\\newtoks\\tntoksfour\n\\newtoks\\tntoksfive\n\n\\def\\abstract{\n\\ifnum\\titlenotecount>0 % was =1\n    \\insert\\footins{%\n    \\reset@font\\footnotesize\n        \\interlinepenalty\\interfootnotelinepenalty\n        \\splittopskip\\footnotesep\n        \\splitmaxdepth \\dp\\strutbox \\floatingpenalty \\@MM\n        \\hsize\\columnwidth \\@parboxrestore\n        \\protected@edef\\@currentlabel{%\n        }%\n        \\color@begingroup\n\\ifnum\\titlenotecount=1\n      \\@maketntext{%\n         \\raisebox{4pt}{$\\ast$}\\rule\\z@\\footnotesep\\ignorespaces\\the\\tntoks\\@finalstrut\\strutbox}%\n\\fi\n\\ifnum\\titlenotecount=2\n      \\@maketntext{%\n      \\raisebox{4pt}{$\\ast$}\\rule\\z@\\footnotesep\\ignorespaces\\the\\tntoks\\par\\@finalstrut\\strutbox}%\n\\@maketntext{%\n         \\raisebox{4pt}{$\\dagger$}\\rule\\z@\\footnotesep\\ignorespaces\\the\\tntokstwo\\@finalstrut\\strutbox}%\n\\fi\n\\ifnum\\titlenotecount=3\n      \\@maketntext{%\n         \\raisebox{4pt}{$\\ast$}\\rule\\z@\\footnotesep\\ignorespaces\\the\\tntoks\\par\\@finalstrut\\strutbox}%\n\\@maketntext{%\n         \\raisebox{4pt}{$\\dagger$}\\rule\\z@\\footnotesep\\ignorespaces\\the\\tntokstwo\\par\\@finalstrut\\strutbox}%\n\\@maketntext{%\n         \\raisebox{4pt}{$\\ddagger$}\\rule\\z@\\footnotesep\\ignorespaces\\the\\tntoksthree\\@finalstrut\\strutbox}%\n\\fi\n\\ifnum\\titlenotecount=4\n      \\@maketntext{%\n         \\raisebox{4pt}{$\\ast$}\\rule\\z@\\footnotesep\\ignorespaces\\the\\tntoks\\par\\@finalstrut\\strutbox}%\n\\@maketntext{%\n         \\raisebox{4pt}{$\\dagger$}\\rule\\z@\\footnotesep\\ignorespaces\\the\\tntokstwo\\par\\@finalstrut\\strutbox}%\n\\@maketntext{%\n         \\raisebox{4pt}{$\\ddagger$}\\rule\\z@\\footnotesep\\ignorespaces\\the\\tntoksthree\\par\\@finalstrut\\strutbox}%\n\\@maketntext{%\n         \\raisebox{4pt}{$\\S$}\\rule\\z@\\footnotesep\\ignorespaces\\the\\tntoksfour\\@finalstrut\\strutbox}%\n\\fi\n\\ifnum\\titlenotecount=5\n      \\@maketntext{%\n         \\raisebox{4pt}{$\\ast$}\\rule\\z@\\footnotesep\\ignorespaces\\the\\tntoks\\par\\@finalstrut\\strutbox}%\n\\@maketntext{%\n         \\raisebox{4pt}{$\\dagger$}\\rule\\z@\\footnotesep\\ignorespaces\\the\\tntokstwo\\par\\@finalstrut\\strutbox}%\n\\@maketntext{%\n         \\raisebox{4pt}{$\\ddagger$}\\rule\\z@\\footnotesep\\ignorespaces\\the\\tntoksthree\\par\\@finalstrut\\strutbox}%\n\\@maketntext{%\n         \\raisebox{4pt}{$\\S$}\\rule\\z@\\footnotesep\\ignorespaces\\the\\tntoksfour\\par\\@finalstrut\\strutbox}%\n\\@maketntext{%\n         \\raisebox{4pt}{$\\P$}\\rule\\z@\\footnotesep\\ignorespaces\\the\\tntoksfive\\@finalstrut\\strutbox}%\n\\fi\n   \\color@endgroup} %g}\n\\fi\n\\setcounter{footnote}{0}\n\\section*{ABSTRACT}\\normalsize%\\ninept\n}\n\n\\def\\endabstract{\\if@twocolumn\\else\\endquotation\\fi}\n\n\n% \\def\\keywords{\\if@twocolumn\n% \\section*{Keywords}\n% \\else \\small\n% \\quotation\n% \\fi}\n\n\n\\def\\terms{\\if@twocolumn\n\\section*{General Terms}\n\\else \\small\n\\quotation\n\\fi}\n\n% -- Classification needs to be a bit smart due to optionals - Gerry/Georgia November 2nd. 1999\n\\newcount\\catcount\n\\global\\catcount=1\n\n\\def\\category#1#2#3{%\n\\ifnum\\catcount=1\n\\section*{Categories and Subject Descriptors}\n\\advance\\catcount by 1\\else{\\unskip; }\\fi\n    \\@ifnextchar [{\\@category{#1}{#2}{#3}}{\\@category{#1}{#2}{#3}[]}%\n}\n\n\\def\\@category#1#2#3[#4]{%\n    \\begingroup\n        \\let\\and\\relax\n            #1 [\\textbf{#2}]%\n            \\if!#4!%\n                \\if!#3!\\else : #3\\fi\n            \\else\n                :\\space\n                \\if!#3!\\else #3\\kern\\z@---\\hskip\\z@\\fi\n                \\textit{#4}%\n            \\fi\n    \\endgroup\n}\n%\n\n%%% This section (written by KBT) handles the 1" box in the lower left\n%%% corner of the left column of the first page by creating a picture,\n%%% and inserting the predefined string at the bottom (with a negative\n%%% displacement to offset the space allocated for a non-existent\n%%% caption).\n%%%\n\\newtoks\\copyrightnotice\n\\def\\ftype@copyrightbox{8}\n\\def\\@copyrightspace{\n%\\@float{copyrightbox}[b]\n%\\begin{center}\n%\\setlength{\\unitlength}{1pc}\n%\\begin{picture}(20,6) %Space for copyright notice\n%\\put(0,-0.95){\\crnotice{\\@toappear}}\n%\\end{picture}\n%\\end{center}\n%\\end@float\n}\n\n%\\def\\@toappear{} % Default setting blank - commands below change this.\n%\\long\\def\\toappear#1{\\def\\@toappear{\\parbox[b]{20pc}{\\baselineskip 9pt%#1}}}\n%\\def\\toappearbox#1{\\def\\@toappear{\\raisebox{5pt}{\\framebox[20pc]{\\parb%ox[b]{19pc}{#1}}}}}\n\n%\\newtoks\\conf\n%\\newtoks\\confinfo\n%\\def\\conferenceinfo#1#2{\\global\\conf={#1}\\global\\confinfo{#2}}\n\n\n%\\def\\marginpar{\\@latexerr{The \\marginpar command is not allowed in the\n%  `acmconf\' document style.}\\@eha}\n\n\\def\\marginpar{\\ClassError{%\n    \\string\\marginpar\\space is not allowed in the `acmconf\' document\t\t% January 2008\n    style}\\@eha}\n\n\\mark{{}{}}     % Initializes TeX\'s marks\n\n\\def\\today{\\ifcase\\month\\or\n  January\\or February\\or March\\or April\\or May\\or June\\or\n  July\\or August\\or September\\or October\\or November\\or December\\fi\n  \\space\\number\\day, \\number\\year}\n\n\\def\\@begintheorem#1#2{%\n    \\parskip 0pt % GM July 2000 (for tighter spacing)\n    \\trivlist\n    \\item[%\n        \\hskip 10\\p@\n        \\hskip \\labelsep\n        {{\\sc #1}\\hskip 5\\p@\\relax#2.}%\n    ]\n    \\it\n}\n\\def\\@opargbegintheorem#1#2#3{%\n    \\parskip 0pt % GM July 2000 (for tighter spacing)\n    \\trivlist\n    \\item[%\n        \\hskip 10\\p@\n        \\hskip \\labelsep\n        {\\sc #1\\ #2\\             % This mod by Gerry to enumerate corollaries\n   \\setbox\\@tempboxa\\hbox{(#3)}  % and bracket the \'corollary title\'\n        \\ifdim \\wd\\@tempboxa>\\z@ % and retain the correct numbering of e.g. theorems\n            \\hskip 5\\p@\\relax    % if they occur \'around\' said corollaries.\n            \\box\\@tempboxa       % Gerry - Nov. 1999.\n        \\fi.}%\n    ]\n    \\it\n}\n\\newif\\if@qeded\n\\global\\@qededfalse\n\n% -- original\n%\\def\\proof{%\n%  \\vspace{-\\parskip} % GM July 2000 (for tighter spacing)\n%    \\global\\@qededfalse\n%    \\@ifnextchar[{\\@xproof}{\\@proof}%\n%}\n% -- end of original\n\n% (JSS) Fix for vertical spacing bug - Gerry Murray July 30th. 2002\n\\def\\proof{%\n\\vspace{-\\lastskip}\\vspace{-\\parsep}\\penalty-51%\n\\global\\@qededfalse\n\\@ifnextchar[{\\@xproof}{\\@proof}%\n}\n\n\\def\\endproof{%\n    \\if@qeded\\else\\qed\\fi\n    \\endtrivlist\n}\n\\def\\@proof{%\n    \\trivlist\n    \\item[%\n        \\hskip 10\\p@\n        \\hskip \\labelsep\n        {\\sc Proof.}%\n    ]\n    \\ignorespaces\n}\n\\def\\@xproof[#1]{%\n    \\trivlist\n    \\item[\\hskip 10\\p@\\hskip \\labelsep{\\sc Proof #1.}]%\n    \\ignorespaces\n}\n\\def\\qed{%\n    \\unskip\n    \\kern 10\\p@\n    \\begingroup\n        \\unitlength\\p@\n        \\linethickness{.4\\p@}%\n        \\framebox(6,6){}%\n    \\endgroup\n    \\global\\@qededtrue\n}\n\n\\def\\newdef#1#2{%\n    \\expandafter\\@ifdefinable\\csname #1\\endcsname\n        {\\@definecounter{#1}%\n         \\expandafter\\xdef\\csname the#1\\endcsname{\\@thmcounter{#1}}%\n         \\global\\@namedef{#1}{\\@defthm{#1}{#2}}%\n         \\global\\@namedef{end#1}{\\@endtheorem}%\n    }%\n}\n\\def\\@defthm#1#2{%\n    \\refstepcounter{#1}%\n    \\@ifnextchar[{\\@ydefthm{#1}{#2}}{\\@xdefthm{#1}{#2}}%\n}\n\\def\\@xdefthm#1#2{%\n    \\@begindef{#2}{\\csname the#1\\endcsname}%\n    \\ignorespaces\n}\n\\def\\@ydefthm#1#2[#3]{%\n    \\trivlist\n    \\item[%\n        \\hskip 10\\p@\n        \\hskip \\labelsep\n        {\\it #2%\n%         \\savebox\\@tempboxa{#3}%\n         \\saveb@x\\@tempboxa{#3}%\t\t% January 2008\n         \\ifdim \\wd\\@tempboxa>\\z@\n            \\ \\box\\@tempboxa\n         \\fi.%\n        }]%\n    \\ignorespaces\n}\n\\def\\@begindef#1#2{%\n    \\trivlist\n    \\item[%\n        \\hskip 10\\p@\n        \\hskip \\labelsep\n        {\\it #1\\ \\rm #2.}%\n    ]%\n}\n\\def\\theequation{\\arabic{equation}}\n\n\\newcounter{part}\n\\newcounter{section}\n\\newcounter{subsection}[section]\n\\newcounter{subsubsection}[subsection]\n\\newcounter{paragraph}[subsubsection]\n\\def\\thepart{\\Roman{part}}\n\\def\\thesection{\\arabic{section}}\n\\def\\thesubsection{\\thesection.\\arabic{subsection}}\n\\def\\thesubsubsection{\\thesubsection.\\arabic{subsubsection}} %removed \\subsecfnt 29 July 2002 gkmt\n\\def\\theparagraph{\\thesubsubsection.\\arabic{paragraph}} %removed \\subsecfnt 29 July 2002 gkmt\n\\newif\\if@uchead\n\\@ucheadfalse\n\n%% CHANGES: NEW NOTE\n%% NOTE: OK to use old-style font commands below, since they were\n%% suitably redefined for LaTeX2e\n%% END CHANGES\n\\setcounter{secnumdepth}{3}\n\\def\\part{%\n    \\@startsection{part}{9}{\\z@}{-10\\p@ \\@plus -4\\p@ \\@minus -2\\p@}\n        {4\\p@}{\\normalsize\\@ucheadtrue}%\n}\n\\def\\section{%\n    \\@startsection{section}{1}{\\z@}{-10\\p@ \\@plus -4\\p@ \\@minus -2\\p@}% GM\n    {4\\p@}{\\baselineskip 14pt\\secfnt\\@ucheadtrue}%\n}\n\n\\def\\subsection{%\n    \\@startsection{subsection}{2}{\\z@}{-8\\p@ \\@plus -2\\p@ \\@minus -\\p@}\n    {4\\p@}{\\secfnt}%\n}\n\\def\\subsubsection{%\n    \\@startsection{subsubsection}{3}{\\z@}{-8\\p@ \\@plus -2\\p@ \\@minus -\\p@}%\n    {4\\p@}{\\subsecfnt}%\n}\n%\\def\\paragraph{%\n%    \\vskip 12pt\\@startsection{paragraph}{3}{\\z@}{6\\p@ \\@plus \\p@}% original\n%    {-5\\p@}{\\subsecfnt}%\n%}\n%  If one wants sections, subsections and subsubsections numbered,\n%  but not paragraphs, one usually sets secnumepth to 3.\n%  For that, the "depth" of paragraphs must be given correctly\n%  in the definition (``4\'\' instead of ``3\'\' as second argument\n%  of @startsection):\n\\def\\paragraph{%\n    \\vskip 12pt\\@startsection{paragraph}{4}{\\z@}{6\\p@ \\@plus \\p@}%    % GM and Wolfgang May - 11/30/06\n    {-5\\p@}{\\subsecfnt}%\n}\n\\let\\@period=.\n\\def\\@startsection#1#2#3#4#5#6{%\n        \\if@noskipsec  %gkmt, 11 aug 99\n        \\global\\let\\@period\\@empty\n        \\leavevmode\n        \\global\\let\\@period.%\n    \\fi\n      \\par %\n    \\@tempskipa #4\\relax\n    \\@afterindenttrue\n    \\ifdim \\@tempskipa <\\z@\n        \\@tempskipa -\\@tempskipa\n        \\@afterindentfalse\n    \\fi\n    \\if@nobreak\n    \\everypar{}%\n    \\else\n        \\addpenalty\\@secpenalty\n        \\addvspace\\@tempskipa\n    \\fi\n\\parskip=0pt % GM July 2000 (non numbered) section heads\n    \\@ifstar\n        {\\@ssect{#3}{#4}{#5}{#6}}\n        {\\@dblarg{\\@sect{#1}{#2}{#3}{#4}{#5}{#6}}}%\n}\n\\def\\@sect#1#2#3#4#5#6[#7]#8{%\n    \\ifnum #2>\\c@secnumdepth\n        \\let\\@svsec\\@empty\n    \\else\n        \\refstepcounter{#1}%\n        \\edef\\@svsec{%\n            \\begingroup\n                %\\ifnum#2>2 \\noexpand\\rm \\fi % changed to next 29 July 2002 gkmt\n            \\ifnum#2>2 \\noexpand#6 \\fi\n                \\csname the#1\\endcsname\n            \\endgroup\n            \\ifnum #2=1\\relax .\\fi\n            \\hskip 1em\n        }%\n    \\fi\n    \\@tempskipa #5\\relax\n    \\ifdim \\@tempskipa>\\z@\n        \\begingroup\n            #6\\relax\n            \\@hangfrom{\\hskip #3\\relax\\@svsec}%\n            \\begingroup\n                \\interlinepenalty \\@M\n                \\if@uchead\n                    \\uppercase{#8}%\n                \\else\n                    #8%\n                \\fi\n                \\par\n            \\endgroup\n        \\endgroup\n        \\csname #1mark\\endcsname{#7}%\n        \\vskip -12pt  %gkmt, 11 aug 99 and GM July 2000 (was -14) - numbered section head spacing\n\\addcontentsline{toc}{#1}{%\n            \\ifnum #2>\\c@secnumdepth \\else\n                \\protect\\numberline{\\csname the#1\\endcsname}%\n            \\fi\n            #7%\n        }%\n    \\else\n        \\def\\@svsechd{%\n            #6%\n            \\hskip #3\\relax\n            \\@svsec\n            \\if@uchead\n                \\uppercase{#8}%\n            \\else\n                #8%\n            \\fi\n            \\csname #1mark\\endcsname{#7}%\n            \\addcontentsline{toc}{#1}{%\n                \\ifnum #2>\\c@secnumdepth \\else\n                    \\protect\\numberline{\\csname the#1\\endcsname}%\n                \\fi\n                #7%\n            }%\n        }%\n    \\fi\n    \\@xsect{#5}\\hskip 1pt\n    \\par\n}\n\\def\\@xsect#1{%\n    \\@tempskipa #1\\relax\n    \\ifdim \\@tempskipa>\\z@\n        \\par\n        \\nobreak\n        \\vskip \\@tempskipa\n        \\@afterheading\n    \\else\n        \\global\\@nobreakfalse\n        \\global\\@noskipsectrue\n        \\everypar{%\n            \\if@noskipsec\n                \\global\\@noskipsecfalse\n                \\clubpenalty\\@M\n                \\hskip -\\parindent\n                \\begingroup\n                    \\@svsechd\n                    \\@period\n                \\endgroup\n                \\unskip\n                \\@tempskipa #1\\relax\n                \\hskip -\\@tempskipa\n            \\else\n                \\clubpenalty \\@clubpenalty\n                \\everypar{}%\n            \\fi\n        }%\n    \\fi\n    \\ignorespaces\n}\n\\def\\@trivlist{%\n    \\@topsepadd\\topsep\n    \\if@noskipsec\n        \\global\\let\\@period\\@empty\n        \\leavevmode\n        \\global\\let\\@period.%\n    \\fi\n    \\ifvmode\n        \\advance\\@topsepadd\\partopsep\n    \\else\n        \\unskip\n        \\par\n    \\fi\n    \\if@inlabel\n        \\@noparitemtrue\n        \\@noparlisttrue\n    \\else\n        \\@noparlistfalse\n        \\@topsep\\@topsepadd\n    \\fi\n    \\advance\\@topsep \\parskip\n    \\leftskip\\z@skip\n    \\rightskip\\@rightskip\n    \\parfillskip\\@flushglue\n    \\@setpar{\\if@newlist\\else{\\@@par}\\fi}\n    \\global\\@newlisttrue\n    \\@outerparskip\\parskip\n}\n\n%%% Actually, \'abbrev\' works just fine as the default\n%%% Bibliography style.\n\n\\typeout{Using \'Abbrev\' bibliography style}\n\\newcommand\\bibyear[2]{%\n    \\unskip\\quad\\ignorespaces#1\\unskip\n    \\if#2..\\quad \\else \\quad#2 \\fi\n}\n\\newcommand{\\bibemph}[1]{{\\em#1}}\n\\newcommand{\\bibemphic}[1]{{\\em#1\\/}}\n\\newcommand{\\bibsc}[1]{{\\sc#1}}\n\\def\\@normalcite{%\n    \\def\\@cite##1##2{[##1\\if@tempswa , ##2\\fi]}%\n}\n\\def\\@citeNB{%\n    \\def\\@cite##1##2{##1\\if@tempswa , ##2\\fi}%\n}\n\\def\\@citeRB{%\n    \\def\\@cite##1##2{##1\\if@tempswa , ##2\\fi]}%\n}\n\\def\\start@cite#1#2{%\n    \\edef\\citeauthoryear##1##2##3{%\n        ###1%\n        \\ifnum#2=\\z@ \\else\\ ###2\\fi\n    }%\n    \\ifnum#1=\\thr@@\n        \\let\\@@cite\\@citeyear\n    \\else\n        \\let\\@@cite\\@citenormal\n    \\fi\n    \\@ifstar{\\@citeNB\\@@cite}{\\@normalcite\\@@cite}%\n}\n%\\def\\cite{\\start@cite23}\n\\DeclareRobustCommand\\cite{\\start@cite23}\t\t% January 2008\n\\def\\citeNP{\\cite*}\t\t\t\t\t% No Parentheses e.g. 5\n%\\def\\citeA{\\start@cite10}\n\\DeclareRobustCommand\\citeA{\\start@cite10}\t\t% January 2008\n\\def\\citeANP{\\citeA*}\n%\\def\\shortcite{\\start@cite23}\t\t\t\t\n\\DeclareRobustCommand\\shortcite{\\start@cite23}\t\t% January 2008\n\\def\\shortciteNP{\\shortcite*}\n%\\def\\shortciteA{\\start@cite20}\n\\DeclareRobustCommand\\shortciteA{\\start@cite20}\t\t% January 2008\n\\def\\shortciteANP{\\shortciteA*}\n%\\def\\citeyear{\\start@cite30}\n\\DeclareRobustCommand\\citeyear{\\start@cite30}\t\t% January 2008\n\\def\\citeyearNP{\\citeyear*}\n%\\def\\citeN{%\n\\DeclareRobustCommand\\citeN{%\t\t\t\t% January 2008\n    \\@citeRB\n    \\def\\citeauthoryear##1##2##3{##1\\ [##3%\n        \\def\\reserved@a{##1}%\n        \\def\\citeauthoryear####1####2####3{%\n            \\def\\reserved@b{####1}%\n            \\ifx\\reserved@a\\reserved@b\n                ####3%\n            \\else\n                \\errmessage{Package acmart Error: author mismatch\n                         in \\string\\citeN^^J^^J%\n                    See the acmart package documentation for explanation}%\n            \\fi\n        }%\n    }%\n    \\@ifstar\\@citeyear\\@citeyear\n}\n%\\def\\shortciteN{%\n\\DeclareRobustCommand\\shortciteN{%\t\t\t% January 2008\n    \\@citeRB\n    \\def\\citeauthoryear##1##2##3{##2\\ [##3%\n        \\def\\reserved@a{##2}%\n        \\def\\citeauthoryear####1####2####3{%\n            \\def\\reserved@b{####2}%\n            \\ifx\\reserved@a\\reserved@b\n                ####3%\n            \\else\n                \\errmessage{Package acmart Error: author mismatch\n                         in \\string\\shortciteN^^J^^J%\n                    See the acmart package documentation for explanation}%\n            \\fi\n        }%\n    }%\n    \\@ifstar\\@citeyear\\@citeyear  % GM July 2000\n}\n\n\\def\\@citenormal{%\n    \\@ifnextchar [{\\@tempswatrue\\@citex;}%\n% original                 {\\@tempswafalse\\@citex,[]}% was ; Gerry 2/24/00\n{\\@tempswafalse\\@citex[]}%  \t% GERRY FIX FOR BABEL 3/20/2009\n}\n\n\\def\\@citeyear{%\n    \\@ifnextchar [{\\@tempswatrue\\@citex,}%\n% original                  {\\@tempswafalse\\@citex,[]}%\n{\\@tempswafalse\\@citex[]}%\t%  GERRY FIX FOR BABEL 3/20/2009\n}\n\n\\def\\@citex#1[#2]#3{%\n    \\let\\@citea\\@empty\n    \\@cite{%\n        \\@for\\@citeb:=#3\\do{%\n            \\@citea\n% original            \\def\\@citea{#1 }%\n            \\def\\@citea{#1, }% \t% GERRY FIX FOR BABEL 3/20/2009 -- SO THAT YOU GET [1, 2] IN THE BODY TEXT\n            \\edef\\@citeb{\\expandafter\\@iden\\@citeb}%\n            \\if@filesw\n                \\immediate\\write\\@auxout{\\string\\citation{\\@citeb}}%\n            \\fi\n            \\@ifundefined{b@\\@citeb}{%\n                {\\bf ?}%\n                \\@warning{%\n                    Citation `\\@citeb\' on page \\thepage\\space undefined%\n                }%\n            }%\n            {\\csname b@\\@citeb\\endcsname}%\n        }%\n    }{#2}%\n}\n%\\let\\@biblabel\\@gobble   % Dec. 2008 - Gerry\n% ----\n\\def\\@biblabelnum#1{[#1]} % Gerry\'s solution #1 - for Natbib -- April 2009\n\\let\\@biblabel=\\@biblabelnum  % Gerry\'s solution #1 - for Natbib -- April 2009\n\\def\\newblock{\\relax} % Gerry Dec. 2008\n% ---\n\\newdimen\\bibindent\n\\setcounter{enumi}{1}\n\\bibindent=0em\n\\def\\thebibliography#1{% \n\\ifnum\\addauflag=0\\addauthorsection\\global\\addauflag=1\\fi\n     \\section[References]{%    <=== OPTIONAL ARGUMENT ADDED HERE\n        {References} % was uppercased but this affects pdf bookmarks (SP/GM October 2004)\n          {\\vskip -2pt plus 1pt} % GM Nov. 2006 / GM July 2000 (for somewhat tighter spacing) \n         \\@mkboth{{\\refname}}{{\\refname}}%\n     }%\n     \\refsmall\n     \\list{[\\arabic{enumi}]}{%\n         \\settowidth\\labelwidth{[#1]}%\n         \\leftmargin\\labelwidth\n         \\advance\\leftmargin\\labelsep\n         \\advance\\leftmargin\\bibindent\n         \\parsep=0pt\\itemsep=5pt % GM July 2000\n         \\itemindent -\\bibindent\n         \\listparindent \\itemindent\n         \\usecounter{enumi}\n     }%\n     \\let\\newblock\\@empty\n     \\raggedright % GM July 2000\n     \\sloppy\n     \\sfcode`\\.=1000\\relax\n}\n\n\n\\gdef\\balancecolumns\n{\\vfill\\eject\n\\global\\@colht=\\textheight\n\\global\\ht\\@cclv=\\textheight\n}\n\n\\newcount\\colcntr\n\\global\\colcntr=0\n%\\newbox\\savebox\n\\newbox\\saveb@x\t\t\t\t% January 2008\n\n\\gdef \\@makecol {%\n\\global\\advance\\colcntr by 1\n\\ifnum\\colcntr>2 \\global\\colcntr=1\\fi\n   \\ifvoid\\footins\n     \\setbox\\@outputbox \\box\\@cclv\n   \\else\n     \\setbox\\@outputbox \\vbox{%\n\\boxmaxdepth \\@maxdepth\n       \\@tempdima\\dp\\@cclv\n       \\unvbox \\@cclv\n       \\vskip-\\@tempdima\n       \\vskip \\skip\\footins\n       \\color@begingroup\n         \\normalcolor\n         \\footnoterule\n         \\unvbox \\footins\n       \\color@endgroup\n       }%\n   \\fi\n   \\xdef\\@freelist{\\@freelist\\@midlist}%\n   \\global \\let \\@midlist \\@empty\n   \\@combinefloats\n   \\ifvbox\\@kludgeins\n     \\@makespecialcolbox\n   \\else\n     \\setbox\\@outputbox \\vbox to\\@colht {%\n\\@texttop\n       \\dimen@ \\dp\\@outputbox\n       \\unvbox \\@outputbox\n   \\vskip -\\dimen@\n       \\@textbottom\n       }%\n   \\fi\n   \\global \\maxdepth \\@maxdepth\n}\n\\def\\titlenote{\\@ifnextchar[\\@xtitlenote{\\stepcounter\\@mpfn\n\\global\\advance\\titlenotecount by 1\n\\ifnum\\titlenotecount=1\n    \\raisebox{9pt}{$\\ast$}\n\\fi\n\\ifnum\\titlenotecount=2\n    \\raisebox{9pt}{$\\dagger$}\n\\fi\n\\ifnum\\titlenotecount=3\n    \\raisebox{9pt}{$\\ddagger$}\n\\fi\n\\ifnum\\titlenotecount=4\n\\raisebox{9pt}{$\\S$}\n\\fi\n\\ifnum\\titlenotecount=5\n\\raisebox{9pt}{$\\P$}\n\\fi\n         \\@titlenotetext\n}}\n\n\\long\\def\\@titlenotetext#1{\\insert\\footins{%\n\\ifnum\\titlenotecount=1\\global\\tntoks={#1}\\fi\n\\ifnum\\titlenotecount=2\\global\\tntokstwo={#1}\\fi\n\\ifnum\\titlenotecount=3\\global\\tntoksthree={#1}\\fi\n\\ifnum\\titlenotecount=4\\global\\tntoksfour={#1}\\fi\n\\ifnum\\titlenotecount=5\\global\\tntoksfive={#1}\\fi\n    \\reset@font\\footnotesize\n    \\interlinepenalty\\interfootnotelinepenalty\n    \\splittopskip\\footnotesep\n    \\splitmaxdepth \\dp\\strutbox \\floatingpenalty \\@MM\n    \\hsize\\columnwidth \\@parboxrestore\n    \\protected@edef\\@currentlabel{%\n    }%\n    \\color@begingroup\n   \\color@endgroup}}\n\n%%%%%%%%%%%%%%%%%%%%%%%%%\n\\ps@plain\n\\baselineskip=11pt\n\\let\\thepage\\relax % For NO page numbers - GM Nov. 30th. 1999 and July 2000\n\\def\\setpagenumber#1{\\global\\setcounter{page}{#1}}\n%\\pagenumbering{arabic}  % Arabic page numbers GM July 2000\n\\twocolumn             % Double column.\n\\flushbottom           % Even bottom -- alas, does not balance columns at end of document\n\\pagestyle{plain}\n\n% Need Copyright Year and Copyright Data to be user definable (in .tex file).\n% Gerry Nov. 30th. 1999\n\\newtoks\\copyrtyr\n\\newtoks\\acmcopyr\n\\newtoks\\boilerplate\n\\global\\acmcopyr={X-XXXXX-XX-X/XX/XX}  % Default - 5/11/2001 *** Gerry\n\\global\\copyrtyr={20XX}                % Default - 3/3/2003 *** Gerry\n\\def\\CopyrightYear#1{\\global\\copyrtyr{#1}}\n\\def\\crdata#1{\\global\\acmcopyr{#1}}\n\\def\\permission#1{\\global\\boilerplate{#1}}\n%\n\\global\\boilerplate={}\n\\newtoks\\copyrightetc\n\\global\\copyrightetc{} % Gerry changed to 15 May 2012\n%\\toappear{\\the\\boilerplate\\par\n%{\\confname{\\the\\conf}} \\the\\confinfo\\par \\the\\copyrightetc.}\n%\\DeclareFixedFont{\\altcrnotice}{OT1}{tmr}{m}{n}{8}  % << patch needed for accenting e.g. Montreal - Gerry, May 2007\n%\\DeclareFixedFont{\\altconfname}{OT1}{tmr}{m}{it}{8}  % << patch needed for accenting in italicized confname - Gerry, May 2007\n%\n%{\\altconfname{{\\the\\conf}}} {\\altcrnotice\\the\\confinfo\\par} \\the\\copyrightetc.}  % << Gerry, May 2007\n%\n% The following section (i.e. 3 .sty inclusions) was added in May 2007 so as to fix the problems that many\n% authors were having with accents. Sometimes accents would occur, but the letter-character would be of a different\n% font. Conversely the letter-character font would be correct but, e.g. a \'bar\' would appear superimposed on the\n% character instead of, say, an unlaut/diaresis. Sometimes the letter-character would NOT appear at all.\n% Using [T1]{fontenc} outright was not an option as this caused 99% of the authors to \'produce\' a Type-3 (bitmapped)\n% PDF file - useless for production. \n%\n% For proper (font) accenting we NEED these packages to be part of the .cls file i.e. \'ae\', \'aecompl\' and \'aeguil\' \n% ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n%% This is file `ae.sty\' \n\\def\\fileversion{1.3}\n\\def\\filedate{2001/02/12}\n\\NeedsTeXFormat{LaTeX2e}\n%\\ProvidesPackage{ae}[\\filedate\\space\\fileversion\\space  % GM\n% Almost European Computer Modern]                       % GM - keeping the log file clean(er)\n\\newif\\if@ae@slides \\@ae@slidesfalse\n\\DeclareOption{slides}{\\@ae@slidestrue}\n\\ProcessOptions\n\\fontfamily{aer}\n\\RequirePackage[T1]{fontenc}\n\\if@ae@slides\n    \\renewcommand{\\sfdefault}{laess}\n    \\renewcommand{\\rmdefault}{laess} % no roman\n    \\renewcommand{\\ttdefault}{laett}\n\\else\n    \\renewcommand{\\sfdefault}{aess}\n    \\renewcommand{\\rmdefault}{aer}\n    \\renewcommand{\\ttdefault}{aett}\n\\fi\n\\endinput\n%% \n%% End of file `ae.sty\'.\n%\n%\n\\def\\fileversion{0.9}\n\\def\\filedate{1998/07/23}\n\\NeedsTeXFormat{LaTeX2e}\n%\\ProvidesPackage{aecompl}[\\filedate\\space\\fileversion\\space   % GM\n%T1 Complements for AE fonts (D. Roegel)]                      % GM -- keeping the log file clean(er)\n \n \\def\\@ae@compl#1{{\\fontencoding{T1}\\fontfamily{cmr}\\selectfont\\symbol{#1}}}\n\\def\\guillemotleft{\\@ae@compl{19}}\n\\def\\guillemotright{\\@ae@compl{20}}\n\\def\\guilsinglleft{\\@ae@compl{14}}\n\\def\\guilsinglright{\\@ae@compl{15}}\n\\def\\TH{\\@ae@compl{222}}\n\\def\\NG{\\@ae@compl{141}}\n\\def\\ng{\\@ae@compl{173}}\n\\def\\th{\\@ae@compl{254}}\n\\def\\DJ{\\@ae@compl{208}}\n\\def\\dj{\\@ae@compl{158}}\n\\def\\DH{\\@ae@compl{208}}\n\\def\\dh{\\@ae@compl{240}}\n\\def\\@perthousandzero{\\@ae@compl{24}}\n\\def\\textperthousand{\\%\\@perthousandzero}\n\\def\\textpertenthousand{\\%\\@perthousandzero\\@perthousandzero}\n\\endinput\n%\n%\n%% This is file `aeguill.sty\' \n% This file gives french guillemets (and not guillemots!)\n% built with the Polish CMR fonts (default), WNCYR fonts, the LASY fonts \n% or with the EC fonts. \n% This is useful in conjunction with the ae package\n% (this package loads the ae package in case it has not been loaded)\n%  and with or without the french(le) package.\n%\n% In order to get the guillemets, it is necessary to either type\n% \\guillemotleft and \\guillemotright, or to use an 8 bit encoding\n% (such as ISO-Latin1) which selects these two commands, \n% or, if you use the french package (but not the frenchle package), \n% to type << or >>.\n%\n% By default, you get the Polish CMR guillemets; if this package is loaded\n% with the `cm\' option, you get the LASY guillemets; with `ec,\' you\n% get the EC guillemets, and with `cyr,\' you get the cyrillic guillemets.\n%\n% In verbatim mode, you always get the EC/TT guillemets.\n%\n% The default option is interesting in conjunction with PDF,\n% because there is a Type 1 version of the Polish CMR fonts\n% and these guillemets are very close in shape to the EC guillemets.\n% There are no free Type 1 versions of the EC fonts.\n%\n% Support for Polish CMR guillemets was kindly provided by \n% Rolf Niepraschk <niepraschk@ptb.de> in version 0.99 (2000/05/22).\n% Bernd Raichle provided extensive simplifications to the code\n% for version 1.00.\n%\n% This package is released under the LPPL.\n%\n% Changes:\n%   Date        version\n%   2001/04/12  1.01    the frenchle and french package are now distinguished.\n%\n\\def\\fileversion{1.01}\n\\def\\filedate{2001/04/12}\n\\NeedsTeXFormat{LaTeX2e}\n%\\ProvidesPackage{aeguill}[2001/04/12 1.01 %    % GM\n%AE fonts with french guillemets (D. Roegel)]   % GM - keeping the log file clean(er)\n%\\RequirePackage{ae}  % GM May 2007 - already embedded here\n\n\\newcommand{\\@ae@switch}[4]{#4}\n\\DeclareOption{ec}{\\renewcommand\\@ae@switch[4]{#1}}\n\\DeclareOption{cm}{\\renewcommand\\@ae@switch[4]{#2}}\n\\DeclareOption{cyr}{\\renewcommand\\@ae@switch[4]{#3}}\n\\DeclareOption{pl}{\\renewcommand\\@ae@switch[4]{#4}}\n\\ExecuteOptions{pl}\n\\ProcessOptions\n\n%\n% Load necessary packages\n%\n\\@ae@switch{% ec\n  % do nothing\n}{% cm\n  \\RequirePackage{latexsym}%  GM - May 2007 - already \'mentioned as required\' up above\n}{% cyr\n  \\RequirePackage[OT2,T1]{fontenc}%\n}{% pl\n  \\RequirePackage[OT4,T1]{fontenc}%\n}\n\n% The following command will be compared to \\frenchname,\n% as defined in french.sty and frenchle.sty.\n\\def\\aeguillfrenchdefault{french}%\n\n\\let\\guill@verbatim@font\\verbatim@font\n\\def\\verbatim@font{\\guill@verbatim@font\\ecguills{cmtt}%\n                   \\let\\guillemotleft\\@oguills\\let\\guillemotright\\@fguills}\n\n\\begingroup \\catcode`\\<=13 \\catcode`\\>=13\n\\def\\x{\\endgroup\n \\def\\ae@lfguill{<<}%\n \\def\\ae@rfguill{>>}%\n}\\x\n\n\\newcommand{\\ecguills}[1]{%\n  \\def\\selectguillfont{\\fontencoding{T1}\\fontfamily{#1}\\selectfont}%\n  \\def\\@oguills{{\\selectguillfont\\symbol{19}}}%\n  \\def\\@fguills{{\\selectguillfont\\symbol{20}}}%\n  } \n\n\\newcommand{\\aeguills}{%\n  \\ae@guills\n  % We redefine \\guillemotleft and \\guillemotright\n  % in order to catch them when they are used \n  % with \\DeclareInputText (in latin1.def for instance)\n  % We use \\auxWARNINGi as a safe indicator that french.sty is used.\n  \\gdef\\guillemotleft{\\ifx\\auxWARNINGi\\undefined\n                         \\@oguills % neither french.sty nor frenchle.sty\n                      \\else\n                         \\ifx\\aeguillfrenchdefault\\frenchname\n                           \\ae@lfguill  % french.sty\n                         \\else\n                           \\@oguills    % frenchle.sty\n                         \\fi\n                      \\fi}%\n  \\gdef\\guillemotright{\\ifx\\auxWARNINGi\\undefined\n                         \\@fguills % neither french.sty nor frenchle.sty\n                       \\else\n                         \\ifx\\aeguillfrenchdefault\\frenchname\n                           \\ae@rfguill  % french.sty\n                         \\else\n                           \\@fguills    % frenchle.sty\n                         \\fi\n                       \\fi}%\n  }\n\n%\n% Depending on the class option\n% define the internal command \\ae@guills\n\\@ae@switch{% ec\n  \\newcommand{\\ae@guills}{%\n    \\ecguills{cmr}}%\n}{% cm\n  \\newcommand{\\ae@guills}{%\n    \\def\\selectguillfont{\\fontencoding{U}\\fontfamily{lasy}%\n            \\fontseries{m}\\fontshape{n}\\selectfont}%\n    \\def\\@oguills{\\leavevmode\\nobreak\n                \\hbox{\\selectguillfont (\\kern-.20em(\\kern.20em}\\nobreak}%\n    \\def\\@fguills{\\leavevmode\\nobreak\n                \\hbox{\\selectguillfont \\kern.20em)\\kern-.2em)}%\n                \\ifdim\\fontdimen\\@ne\\font>\\z@\\/\\fi}}%\n}{% cyr\n  \\newcommand{\\ae@guills}{%\n    \\def\\selectguillfont{\\fontencoding{OT2}\\fontfamily{wncyr}\\selectfont}%\n    \\def\\@oguills{{\\selectguillfont\\symbol{60}}}%\n    \\def\\@fguills{{\\selectguillfont\\symbol{62}}}}\n}{% pl\n  \\newcommand{\\ae@guills}{%\n    \\def\\selectguillfont{\\fontencoding{OT4}\\fontfamily{cmr}\\selectfont}%\n    \\def\\@oguills{{\\selectguillfont\\symbol{174}}}%\n    \\def\\@fguills{{\\selectguillfont\\symbol{175}}}}\n}\n\n\n\\AtBeginDocument{%\n  \\ifx\\GOfrench\\undefined\n    \\aeguills\n  \\else\n    \\let\\aeguill@GOfrench\\GOfrench\n    \\gdef\\GOfrench{\\aeguill@GOfrench \\aeguills}%\n  \\fi\n  }\n\n\\endinput\n%'
p0
.I0
.S'Head'
p0
.S''
p0
.I6
.S'Doc class'
p0
.S'$head:\n\\documentclass{sig-alternate} \n\\usepackage{mathptmx} % This is Times font'
p0
.I0
.S'Prereqs'
p0
.S'$head:\n\\newcommand{\\ignore}[1]{}\n\\usepackage{fancyhdr}\n\\usepackage[normalem]{ulem}\n\\usepackage[hyphens]{url}\n\\usepackage{hyperref}\n\\usepackage{epsfig}\n\\usepackage{amsmath,environ}\n\\usepackage{color}\n\\usepackage{graphicx}\n\\usepackage{listings}\n\\usepackage{multirow}\n\\usepackage{pdfsync}\n\\usepackage{caption}\n\\usepackage{algorithm}\n\\usepackage{algpseudocode}\n\\usepackage{subcaption}\n\\usepackage{todonotes}\n\\newcommand{\\redcomment}[1]{\\todo[inline,color=red!40,size=\\small]{#1}}\n\\newcommand{\\greencomment}[1]{\\todo[inline,color=green!40,size=\\small]{#1}}\n\\newcommand{\\bluecomment}[1]{\\todo[inline,color=blue!40,size=\\small]{#1}}\n\\newcommand{\\yellowcomment}[1]{\\todo[inline,color=yellow!40,size=\\small]{#1}}\n\\lstset{language=C++, basicstyle=\\footnotesize}\n\\newcommand{\\hpcasubmissionnumber}{53}'
p0
.I0
.S'Recommended'
p0
.S'$head:\n\\usepackage{balance}\n\\usepackage{cite}'
p0
.I0
.S'Your stuff'
p0
.S'$head: \n\\linespread{.92}\n\\fancypagestyle{firstpage}{\n  \\fancyhf{}\n\\setlength{\\headheight}{50pt}\n\\renewcommand{\\headrulewidth}{0pt}\n  \\fancyhead[C]{\\normalsize{ISCA 2016 Submission\n      \\textbf{\\#\\hpcasubmissionnumber} \\\\ Confidential Draft: DO NOT DISTRIBUTE}} \n  \\pagenumbering{arabic}\n} \n\\title{SnapCharge: Enabling Fair Pricing in Infrastructure-as-a-Service Clouds} \n\n\\author{}'
p0
.I0
.S'Start doc'
p0
.S'$head: \\begin{document}\n\\maketitle\n\\thispagestyle{firstpage}\n\\pagestyle{plain}\n\n'
p0
.I0
.S'Authors'
p0
.S'\\author{\n}'
p0
.I0
.S'Tail'
p0
.S''
p0
.I1
.S'Standard Tail'
p0
.S'$tail: \\bibliographystyle{ieeetr}\n\\bibliography{bib}\n\\end{document}'
p0
.I0
.