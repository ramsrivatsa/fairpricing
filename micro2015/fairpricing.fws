S'Your Next Top Tier Paper'
p0
.S'$title: Fair Pricing in Infrastructure-as-a-Service \\\\ Clouds via Snapshots'
p0
.I2
.S'Main Sections'
p0
.S''
p0
.I8
.S'Abstract'
p0
.S''
p0
.I2
.S'Problem'
p0
.S'$absp: Infrastructure-as-a-Service (IaaS) cloud environments allow users to pay a flat hourly rate for running their applications on virtual machines (VMs). However, virtual machines belonging to different users co-located on a same physical machine may interfere with one another causing performance degradation of individual applications. The magnitude of this degradation is highly variable as it depends upon the nature of co-located applications. Since neither providers nor clients have control over the nature of co-running applications, performance degradation due to interference can lead to a biased pricing scenario where users can pay more when contentious VMs from other users are co-located on a same server.'
p0
.I0
.S'Solution'
p0
.S"$absp: In this work, we present \\textbf{snapshot}, a technique to precisely estimate unintended performance degradation of individual VMs to enable fair pricing. Estimating performance interference is challenging especially in IaaS where cloud providers do not have information on individual VM's content. Moreover, any estimation technique should not incur much overhead in production environments. Our snapshot technique uses phase-aware millisecond scale pauses of all corunner VMs. To enable our snapshot technique, we introduce a novel phase detection mechanism which examines the execution behavior for each VM in co-located environments. In this work, we show that we are able to accurately identify phase changes and estimate performance degradation within 4\\% mean absolute error on SPEC benchmarks with a very low overhead of around 1\\% when four VMs are running on a four core machine.\n"
p0
.I0
.S'Introduction'
p0
.S'$s:Introduction'
p0
.I7
.S'State of the art problem'
p0
.S'$p: Infrastructure-as-a-Service (IaaS) cloud computing enables users to take advantage of the computing infrastructures under the pay-as-you-go scheme. Cloud providers rely on virtualization to provide the isolated computing resources called instances (or VMs) to each customer. High resource utilization is achieved by consolidating virtual machines into a single server. However, consolidation of virtual machines belonging to different users may lead to performance interference with each other. Although public clouds provide a variety of instance types to satisfy different requirements from users such as the number of virtual CPUs, the amount of memory and disk, users cannot specify the requirements for shared architectural resources like last level cache, memory bandwidth and memory controller. The sharing of architectural resources can significantly affect the performance of each application~\\cite{Nathuji:2010:QMP:1755913.1755938,Govindan:2011:CQE:2038916.2038938,Ahn:2012:DVM:2342763.2342782,Varadarajan:2012:RAI:2382196.2382228,Vasic:2012:DAR:2248487.2151021,Novakovic:2013:DTI:2535461.2535489,Ma:2015:SDS:2694344.2694382,Liu:2014:OVM:2665671.2665720, 6522328}.\n'
p0
.I0
.S'Magnitude by which users are affect because of the issues'
p0
.S'$p: Figure~\\ref{fig:comparecorun} shows the execution time when mcf is co-locating with different applications running on another VM. Each bar is normalized to solo execution of mcf. In such a scenario, libquantum, lbm, and soplex highly affect the performance of mcf. Especially, when mcf is running with libquantum, it would take 2.1x more time to complete compared to the case when mcf is running alone. \nIn the perspective of users, this performance degradation is not acceptable because current IaaS cloud providers calculate the price based on the amount of time each user spends running applications. As a result, it causes biased pricing scenarios where a user might end up paying more when running with contentious co-runners due to increased execution time. '
p0
.I0
.S'$fig:comparecorun,1:'
p0
.S''
p0
.I0
.S'$graph:comparecorun:mcf with co-runners normalized to solo execution\\vspace{-0.1in}:1'
p0
.S'from collections import defaultdict\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ncolocationListBaseline = [ \'colocating with perlbench\', \'colocating with astar\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with bzip2\', \'colocating with libquantum\', \'colocating with lbm\', \'colocating with sphinx3\', \'colocating with soplex\' ]\nrunningList = [ \'mcf\', \'colocating with bzip2\', \'mcf\', \'colocating with astar\', \'mcf\', \'colocating with soplex\', \'mcf\', \'colocating with lbm\', \'mcf\', \'colocating with libquantum\' ]\nbenchListExperiments = [\'mcf\']\nlibquantum=1.09\ndef autolabel(rects):\n    # attach some text labels\n    for rect in rects:\n        height = rect.get_height()\n        plt.text(rect.get_x()+rect.get_width()/2., 1.08*height, \'%.2f\'%float(height), size=\'17\')\n\ndef autolabel2(rects):\n    # attach some text labels\n    for rect in rects:\n        height = rect.get_height()\n        plt.text(rect.get_x()+rect.get_width()/2., 1.05*height, \'%.2f x\'%float(height))\n\nfilename = \'shutter_cpi_5\'\nfList2 = [s.strip() for s in open(\'../../papergraphs/1.1intrograph/degradation/shutter_cpi_1000.txt\').readlines()]\n\ndictList_degradation_colocation = defaultdict(lambda  : defaultdict(list))\n\nfor (b,a) in enumerate(fList2):\n    if a in colocationListBaseline:\n        index = a\n    else:\n        if a in benchListExperiments:\n            dictList_degradation_colocation[index][a].append(float(fList2[b+1]))\n\nyaxis = ()\nxaxis = ()\nxaxis = xaxis + (\'mcf solo\',)\nyaxis = yaxis + (1,)\n#sorting the ground truth values\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    xaxis = xaxis + (\'mcf + \\n\' + j[16:],)\n    #yaxis = yaxis + (np.mean(dictList_degradation_colocation[j][i])/np.mean(dictList_degradation_colocation[\'colocating with bzip2\'][i]), )\n    yaxis = yaxis + (np.mean(dictList_degradation_colocation[j][i])/2.75, ) \n   #print j,i,dictList_degradation_colocation[j][i]\n\nwidth=0.5\nx = np.arange(len(yaxis))\nfig = plt.figure(figsize=(10, 5))\nbar1 = plt.bar( x, yaxis, width, color="g", label=\'mcf with co-runners in the x-axis\')\n#bar2 = plt.bar( x+width, yaxis2, width, color="b", label=\'colocating with mcf  (avg = %.2f)\' %(np.mean(yaxis_abs2)))\nautolabel(bar1)\n#autolabel(bar2)\nplt.ylabel( \'Execution time \\n normalized to mcf solo \',fontsize=20, multialignment=\'center\')\nplt.xticks(x + width/2.0, xaxis, rotation=\'30\',  ha=\'center\', size=\'18\')\n#x\tplt.ylim(-0.1,4)\nplt.yticks(np.arange(0,5),size=\'23\')\n\nplt.xlim(-0.5,6)\nplt.grid()\nplt.tight_layout()\n#plt.legend(prop={\'size\':20})\n#plt.savefig(\'comparecorun.png\', dpi=150)\n#plt.show()\n#plt.close()\n#plt.savefig(\'%s_error.png\' %(filename), dpi=125)'
p0
.I0
.S'Prior Work'
p0
.S'$p:One of the possible solutions to the biased pricing problem is to accurately determine performance degradation for each VM. The most relevant prior work proposes runtime techniques for estimating performance degradation in HPC clusters~\\cite{fairpricing, 6844481}. However, the approach is not suitable to virtualized environments. As the number of co-runners increases, both the accuracy and overhead for estimating performance degradation turn out to be ineffective.\n\n%However they fail to effectively estimate performance degradation in virtualized environments. As the number of co-runners scale up, their solution turns out to be ineffective. In addition to that, they suffer from low accuracy in many applications, which is essential for fair pricing, and possess high overheads which makes it difficult to deploy in production environments. '
p0
.I0
.S'Proposed Solution'
p0
.S'$p:\nOur goal is to achieve high accuracy, which is essential for fair pricing, and low overhead in estimating performance degradation on IaaS cloud environments. The key observation of our approach is that we do not need to periodically estimate the performance degradation for each VM because the execution behavior of applications does not drastically change within a steady phase. Also, the number of phase changes is not significant in many applications.  By exploiting the characteristics, our technique takes a \\textit{snapshot} only at phase changes for investigating performance degradation. We can reduce the overhead of frequently estimating performance degradation at fixed time intervals. In addition, it enables us to \\textit{snapshot} for a longer time to accurately measure solo performance of each VM. Our technique does not depend on the number of co-runners. Even if the number of co-running VMs increases, our technique is less susceptible to the accuracy and overhead problems. To enable \\textit{snapshot}, we propose a novel phase detection mechanism based on performance monitoring units (PMUs). Since each application has different execution behavior, we investigate the representative hardware events to detect phase changes across all SPEC applications used in our experiment. Through the selected performance monitoring units, we can effectively capture phase changes during runtime. Our Fair Pricing Runtime engine is based on our \\textit{snapshot} on top of this phase detection mechanism. The contributions of this paper are as follows.\n\n\\begin{itemize}\n\\item \\textbf{Fair Pricing Runtime:} We introduce a lightweight, scalable, and deployable runtime system that enables fair pricing in public clouds through the precisely estimated solo performance of applications when co-located. \n\n\\item \\textbf{Snapshot:} To efficiently estimate solo performance of applications in public clouds, we use \\textit{snapshot} technique, which pauses all other VMs except for one during a short time, on phase changes.\n\n\\item \\textbf{Phase Detection Mechanism:} We design phase detection mechanism to figure out the phase changes of applications during runtime. We also efficiently eliminate false positives as well as spikes by leveraging the multi-queue based binary classification technique.\n\n\\end{itemize}\n '
p0
.I0
.S'Results discussion'
p0
.S'$p: Using our runtime engine, we are able to precisely estimate the performance degradation in co-located environments with a mean absolute error of around 4\\% and negligible overheads of less than 1\\%. Comparing to the prior work, our technique shows 2x more accuracy and 5x less overhead. '
p0
.I0
.S'Background and Motivation'
p0
.S'$s:Background and Motivation'
p0
.I3
.S'Summary'
p0
.S'$p:In this section, we discuss the background of public IaaS clouds. Next, we investigate the prior technique in detail and discuss its accuracy and overheads issues in estimating performance degradation.'
p0
.I0
.S'Public Clouds for IaaS'
p0
.S'$s:Background: Public Clouds for IaaS\n'
p0
.I2
.S'Type of Instance'
p0
.S'$p: To build Infrastructure-as-a-Service(IaaS), public clouds have adopted the virtualization technology. Each customer is provided with one or more virtual machines commonly called instances. Each public cloud provides a variety of instance types to satisfy the various demands from users. These instance types can be broadly categorized as compute, memory, I/O, etc. In addition, customers choose suitable resource capabilities such as the number of virtual CPUs, the amount of memory and storage size based on their requirements. The pricing strategy differs based on the instance types and capabilities. To use the IaaS cloud services, you have to pay the fee under the pay-as-you-go scheme where the price is proportional to the execution time of the VM. '
p0
.I0
.S'Pricing and problem'
p0
.S"$p: Although the pay-as-you-go scheme is an attractive pricing model, it overlooks the fact that the computing resources can be shared between different customers. The application performance of users could be easily affected by other customers who extensively use shared computing resources. If a virtual machine undergoes performance degradation due to resource contention, the victim users end up paying more price due to their increased execution time. To complement the fairness problem, we could consider having strict quality of service (QoS) between service providers and customers. However, it is difficult to define QoS metrics in public clouds because we would not know the type of the running applications. Even if we are aware of its broader category such as web servers or batch applications, the same type of application could have different execution characteristics. For example, there can be two users running web servers on clouds, but each web server might be customized for their own purpose. Then, the QoS metrics like request per second (RPS) might be difficult to use.\n\nThe most accurate way of eliminating biased pricing schemes is by figuring out performance degradation that occurs due to co-running applications during runtime. However, it is challenging in co-located environments like public clouds. Especially, the architectural resources such as last level cache and memory bandwidth, which are shared among users, makes it difficult to estimate performance degradation for each user's VM in clouds. \nIn this paper, we focus on the batch applications which are highly affected by the architectural shared resources. There have been prior efforts to estimate the performance degradation in co-located environments. We will discuss the issues of the prior technique in the next section. \n"
p0
.I0
.S'Motivation'
p0
.S'$s:Motivation: Accuracy and Overheads'
p0
.I7
.S'Summary'
p0
.S'$p: To precisely measure the amount of performance degradation caused by co-running applications, the prior studies propose a technique called \\textit{shuttering} which pauses all the running VMs for a very short time except for one VM repeatedly at fixed time intervals ~\\cite{fairpricing, 6844481}.During the pausing time, a VM can monopolize computing resources on a system and they can easily extract the solo performance of applications.  Figure~\\ref{fig:precise_shuttering} shows how the prior technique works to estimate solo performance of an application running in a VM. \n\n'
p0
.I0
.S'$fig:precise_shuttering,1:!'
p0
.S''
p0
.I0
.S'$pdf_fig:precise_shuttering: Pausing all other VMs during fixed time intervals :1'
p0
.S''
p0
.I0
.S'$fig:overheads_precise_shuttering,1:!'
p0
.S''
p0
.I0
.S'$graph:overheads_precise_shuttering:Error rates and overheads in shuttering:1'
p0
.S'from collections import defaultdict\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nbenchListBaseline = [ \'perlbench\', \'astar\', \'sphinx3\', \'h264ref\', \'bzip2\', \'tonto\', \'xalancbmk\', \'omnetpp\' ]\n#benchListExperiments = [ \'perlbench\', \'astar\', \'soplex\', \'xalancbmk\', \'omnetpp\', \'bzip2\',\'povray\']\nbenchListExperiments = [ \'perlbench\', \'astar\', \'sphinx3\', \'h264ref\', \'bzip2\', \'tonto\', \'xalancbmk\', \'omnetpp\' ]\n#benchListExperiments = [ \'perlbench\', \'astar\', \'soplex\', \'xalancbmk\', \'omnetpp\']\ncolocationListBaseline = [ \'colocating with lbm\', \'colocating with povray\', \'colocating with astar\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with mcf\' ]\ncolocationListExperiments = [ \'colocating with lbm\', \'colocating with povray\', \'colocating with perlbench\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with mcf\' ]\nrunningList = [ \'perlbench\', \'colocating with libquantum\', \'astar\', \'colocating with libquantum\', \'sphinx3\', \'colocating with libquantum\', \'bzip2\', \'colocating with libquantum\', \'xalancbmk\', \'colocating with libquantum\', \'omnetpp\', \'colocating with libquantum\'  ]\ncolocationList = [ \'colocating with libquantum\', \'colocating with mcf\',  \'colocating with sphinx3\']\nbenchList = [  \'perlbench\', \'astar\', \'sphinx3\', \'h264ref\', \'bzip2\', \'tonto\', \'xalancbmk\', \'omnetpp\'  ]\n#benchList = [  \'astar\', \'omnetpp\'  ]\n#colocationListOracle = [ \'colocating with gcc\', \'colocating with colocating with mcf\', \'colocating with perlbench\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with bzip2\' ]\n\ndef autolabel(rects):\n    # attach some text labels\n    for rect in rects:\n        height = rect.get_height()\n        plt.text(rect.get_x()+rect.get_width()/2., 1.1*height, \'%.2f\'%float(height), fontsize=8, ha=\'center\', va= \'bottom\')\n\ndef autolabel2(rects):\n    # attach some text labels\n    for rect in rects:\n        height = rect.get_height()\n        plt.text(rect.get_x()+rect.get_width()/2., -1.1*height, \'%.1f\'%float(height), fontsize=8, ha=\'center\', va= \'top\')\n\nfilename = \'shutter_cpi_1000\'\nfilename2 = \'shutter_cpi_4\'\nfList = [s.strip() for s in open(\'../../papergraphs/1.2intrograph/singlevm_23/shutter_cpi_1000.txt\').readlines()]\nfList2 = [s.strip() for s in open(\'../../papergraphs/1.2intrograph/2_degradation/%s.txt\' % filename).readlines()]\nfList3 = [s.strip() for s in open(\'../../papergraphs/1.2intrograph/3_degradation/%s.txt\' % filename).readlines()]\nfList4 = [s.strip() for s in open(\'../../papergraphs/1.2intrograph/4_degradation/%s.txt\' % filename).readlines()]\nfList5 = [s.strip() for s in open(\'../../papergraphs/1.2intrograph/2_prior/%s.txt\' % filename2).readlines()]\nfList6 = [s.strip() for s in open(\'../../papergraphs/1.2intrograph/3_prior/%s.txt\' % filename2).readlines()]\nfList7 = [s.strip() for s in open(\'../../papergraphs/1.2intrograph/4_prior/%s.txt\' % filename2).readlines()]\n\nexecutionground = \'execution_time_1000\'\nexecutionprior = \'execution_time_4\'\nfList8 = [s.strip() for s in open(\'../../papergraphs/1.2intrograph/2_degradation/%s.txt\' % executionground).readlines()]  #degradation\nfList9 = [s.strip() for s in open(\'../../papergraphs/1.2intrograph/2_prior/%s.txt\' % executionprior).readlines()]  #degradation\nfList10 = [s.strip() for s in open(\'../../papergraphs/1.2intrograph/3_degradation/%s.txt\' % executionground).readlines()]  #degradation\nfList11 = [s.strip() for s in open(\'../../papergraphs/1.2intrograph/3_prior/%s.txt\' % executionprior).readlines()]  #degradation\nfList12 = [s.strip() for s in open(\'../../papergraphs/1.2intrograph/4_degradation/%s.txt\' % executionground).readlines()]  #degradation\nfList13 = [s.strip() for s in open(\'../../papergraphs/1.2intrograph/4_prior/%s.txt\' % executionprior).readlines()]  #degradation\n\ndictList_single_vm = defaultdict(list)\ndictList_single_vm_mean = defaultdict(float)\ndictList_degradation_colocation = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter2 = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter_prev = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter_prev2 = defaultdict(lambda  : defaultdict(list))\nfinal_degradation = defaultdict(lambda  : defaultdict(list))\nplot_degradation = defaultdict(dict)\nplot_degradation_error = defaultdict(dict)\n\nexecution_time_shutter = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter = defaultdict(lambda  : defaultdict(list))\nexecution_time_shutter2 = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter2 = defaultdict(lambda  : defaultdict(list))\n\nstd_execution_time = defaultdict(dict)\nglobal index\n\ndef print_elapsed_time_shutter(time_shutter):\n    for j in colocationList:\n        for i in benchList:\n            print \'%s ||||  %s\'%(j,i)\n            print time_shutter[j][i]\n\n\nsep = \'u\'\nfor (b,a) in enumerate(fList8):\n    #print a\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            execution_time_shutter[index][a].append((fList8[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_shutter[\'colocating with mcf\'][\'perlbench\']\n#print((s.split(start))[1].split(end)[0])\n\nfor j in colocationList:\n    for i in benchList:\n        for k in execution_time_shutter[j][i]:\n            m,s = [float (var) for var in k.split(\':\')]\n            temp = m*60 + s\n            execution_time_sec_shutter[j][i].append(temp)\n\nfor (b,a) in enumerate(fList9):\n    #print a\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            #print index\n            #print a\n            execution_time_shutter2[index][a].append((fList9[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\nfor j in colocationList:\n    for i in benchList:\n        for k in execution_time_shutter2[j][i]:\n            #print k\n            m,s = [float (var) for var in k.split(\':\')]\n            temp = m*60 + s\n            execution_time_sec_shutter2[j][i].append(temp)\n\noverhead2 = ()\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n\n    #print (pause_period/np.mean(execution_time_sec_shutter[j][i]))*10\n    overhead2 = overhead2 + ( abs(((np.mean(execution_time_sec_shutter2[j][i])/np.mean(execution_time_sec_shutter[j][i])) - 1)*100)*-1, )\n    #print np.mean(execution_time_sec_shutter2[j][i])\n    #print np.mean(execution_time_sec_shutter[j][i])\n\n#print overhead2\ndel execution_time_shutter\ndel execution_time_sec_shutter\ndel execution_time_shutter2\ndel execution_time_sec_shutter2\n\n## ------------------------------------------------------------------------------\n\nexecution_time_shutter = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter = defaultdict(lambda  : defaultdict(list))\nexecution_time_shutter2 = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter2 = defaultdict(lambda  : defaultdict(list))\n\nstd_execution_time = defaultdict(dict)\n\nsep = \'u\'\nfor (b,a) in enumerate(fList10):\n    #print a\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            execution_time_shutter[index][a].append((fList10[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_shutter[\'colocating with mcf\'][\'perlbench\']\n#print((s.split(start))[1].split(end)[0])\n\nfor j in colocationList:\n    for i in benchList:\n        #print i\n        for k in execution_time_shutter[j][i]:\n            try:\n                m,s = [float (var) for var in k.split(\':\')]\n                #print m,s\n                temp = m*60 + s\n            except:\n                h,m,s = [float (var) for var in k.split(\':\')]\n                #print h,m,s\n                temp = h*60*60 + m*60 + s\n            execution_time_sec_shutter[j][i].append(temp)\n\nfor (b,a) in enumerate(fList11):\n    #print a\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            #print index\n            #print a\n            execution_time_shutter2[index][a].append((fList11[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\nfor j in colocationList:\n    for i in benchList:\n        for k in execution_time_shutter2[j][i]:\n            try:\n                m,s = [float (var) for var in k.split(\':\')]\n                #print m,s\n                temp = m*60 + s\n            except:\n                h,m,s = [float (var) for var in k.split(\':\')]\n                #print h,m,s\n                temp = h*60*60 + m*60 + s\n            execution_time_sec_shutter2[j][i].append(temp)\n\noverhead3 = ()\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    #print i\n\n    #print (pause_period/np.mean(execution_time_sec_shutter[j][i]))*10\n    overhead3 = overhead3 + ( abs(((np.mean(execution_time_sec_shutter2[j][i])/np.mean(execution_time_sec_shutter[j][i])) - 1)*100)*-1, )\n    #print np.mean(execution_time_sec_shutter2[j][i])\n    #print np.mean(execution_time_sec_shutter[j][i])\n\n#rint overhead3\ndel execution_time_shutter\ndel execution_time_sec_shutter\ndel execution_time_shutter2\ndel execution_time_sec_shutter2\n\n\n## ------------------------------------------------------------------------------\n\nexecution_time_shutter = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter = defaultdict(lambda  : defaultdict(list))\nexecution_time_shutter2 = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter2 = defaultdict(lambda  : defaultdict(list))\n\nstd_execution_time = defaultdict(dict)\n\ndef print_elapsed_time_shutter(time_shutter):\n    for j in colocationList:\n        for i in benchList:\n            print \'%s ||||  %s\'%(j,i)\n            print time_shutter[j][i]\n\n\nsep = \'u\'\nfor (b,a) in enumerate(fList12):\n    #print a\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            execution_time_shutter[index][a].append((fList12[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_shutter[\'colocating with mcf\'][\'perlbench\']\n#print((s.split(start))[1].split(end)[0])\n\nfor j in colocationList:\n    for i in benchList:\n        #print i\n        for k in execution_time_shutter[j][i]:\n            try:\n                m,s = [float (var) for var in k.split(\':\')]\n                #print m,s\n                temp = m*60 + s\n            except:\n                h,m,s = [float (var) for var in k.split(\':\')]\n                #print h,m,s\n                temp = h*60*60 + m*60 + s\n            execution_time_sec_shutter[j][i].append(temp)\n\nfor (b,a) in enumerate(fList13):\n    #print a\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            #print index\n            #print a\n            execution_time_shutter2[index][a].append((fList13[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n            #execution_time_shutter2[index][a].append((fList13[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\nfor j in colocationList:\n    for i in benchList:\n        for k in execution_time_shutter2[j][i]:\n            try:\n                m,s = [float (var) for var in k.split(\':\')]\n                #print m,s\n                temp = m*60 + s\n            except:\n                h,m,s = [float (var) for var in k.split(\':\')]\n                #print h,m,s\n                temp = h*60*60 + m*60 + s\n            #print k\n            execution_time_sec_shutter2[j][i].append(temp)\n\noverhead4 = ()\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    #print i\n\n    #print (pause_period/np.mean(execution_time_sec_shutter[j][i]))*10\n    overhead4 = overhead4 + ( (((np.mean(execution_time_sec_shutter2[j][i])/np.mean(execution_time_sec_shutter[j][i])) - 1)*100)*-1, )\n    #print np.mean(execution_time_sec_shutter2[j][i])\n    #print np.mean(execution_time_sec_shutter[j][i])\n\n#print overhead4\ndel execution_time_shutter\ndel execution_time_sec_shutter\ndel execution_time_shutter2\ndel execution_time_sec_shutter2\n\n##--------------------------------------------------------------------------\n\n\nfor (b,a) in enumerate(fList):\n    if a in benchListBaseline:\n        dictList_single_vm[a].append(fList[b+1])\n\n#SORTING LIST CONTAING VALUES OF SINGLE SPEC RUNS INSIDE VMs\nfor i in benchListBaseline:\n    dictList_single_vm[i].sort()\n    dictList_single_vm_mean[i] = sum(float(item) for item in dictList_single_vm[i])/len(dictList_single_vm[i])\n#    numerator1 = sum(float(n) for (m,n) in enumerate(dictList_degradation_colocation[j][i]))/(len(dictList_degradation_colocation[j][i]))\n    #print i,dictList_single_vm_mean[i]\n\n    #print i,dictList_single_vm[i]\n\nfor (b,a) in enumerate(fList2):\n    #print a\n    if a in colocationListBaseline:\n       #print a\n       index = a\n    else:\n        if a in benchListExperiments:\n            #print a\n            dictList_degradation_colocation[index][a].append(fList2[b+1])\n#sorting the ground truth values\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    #dictList_degradation_colocation[j][i].sort()\n    #print j,i,dictList_degradation_colocation[j][i]\n\n#APPENDING DEGRADATION SHUTTER\nfor (b,a) in enumerate(fList3):\n    if a in colocationListExperiments:\n        index = a\n    else:\n        if a in benchListExperiments:\n            dictList_degradation_shutter[index][a].append(fList3[b+1])\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    #dictList_degradation_colocation[j][i].sort()\n    #print j,i,dictList_degradation_shutter[j][i]\n\nfor (b,a) in enumerate(fList4):\n    if a in colocationListExperiments:\n        index = a\n    else:\n        if a in benchListExperiments:\n            dictList_degradation_shutter2[index][a].append(fList4[b+1])\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    #dictList_degradation_colocation[j][i].sort()\n    #print j,i,dictList_degradation_shutter2[j][i]\n\n\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    #dictList_degradation_colocation[j][i].sort()\n    #print j,i,dictList_degradation_shutter2[j][i]\n    sum_of = []\n    for n in dictList_degradation_colocation[j][i]:\n        sum_of.append(float(n))\n    #print np.mean(sum_of)\n    final_degradation[j][i].append(np.mean(sum_of))\n    del sum_of\n\n    sum_of = []\n    for n in dictList_degradation_shutter[j][i]:\n        sum_of.append(float(n))\n    #print np.mean(sum_of)\n    final_degradation[j][i].append(np.mean(sum_of))\n    del sum_of\n\n    sum_of = []\n    for n in dictList_degradation_shutter2[j][i]:\n        sum_of.append(float(n))\n    #print np.mean(sum_of)\n    final_degradation[j][i].append(np.mean(sum_of))\n    del sum_of\n\nxaxis = ()\nvm2 = ()\nvm3 = ()\nvm4 = ()\n#fig, ax = plt.subplots()\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    plot_list = []\n    xaxis = xaxis + (i,)\n    for (count,item) in enumerate(final_degradation[j][i]):\n        #print count\n        if count == 0:\n            vm2 = vm2 + (final_degradation[j][i][0]/dictList_single_vm_mean[i] ,)\n        if count == 1:\n            vm3 = vm3 + (final_degradation[j][i][1]/dictList_single_vm_mean[i], )\n        if count == 2:\n            vm4 = vm4 + (final_degradation[j][i][2]/dictList_single_vm_mean[i], )\n\n#print vm2\n#print vm3\n#print vm4\n\n\nshutter_vm2 = ()\nshutter_vm3 = ()\nshutter_vm4 = ()\n\n\nfor (b,a) in enumerate(fList5):\n    if a in colocationListExperiments:\n        index = a\n    else:\n        if a in benchListExperiments:\n            dictList_degradation_shutter_prev[index][a].append(fList5[b+1])\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    for elem in dictList_degradation_shutter_prev[j][i]:\n        dictList_degradation_shutter_prev2[j][i].extend(elem.strip().split(\'\\t\'))\n    #print dictList_degradation_shutter_prev2[j][i]\n\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    #print i\n    denominator1 = sum(float(n) for (m,n) in enumerate(dictList_single_vm[i]))/(len(dictList_single_vm[i]))\n    numerator1 = sum(float(n) for (m,n) in enumerate(dictList_degradation_colocation[j][i]))/(len(dictList_degradation_colocation[j][i]))\n    shutter_temp_list = []\n    colo_temp_list = []\n    degradation_temp_list = []\n    error_temp_list = []\n    #print numerator1\n    #print denominator1\n    for (count,item) in enumerate(dictList_degradation_shutter_prev2[j][i]):\n        #print item\n        if count%2==0:\n            colo_temp_list.append(item)\n        if count%2==1:\n            shutter_temp_list.append(item)\n\n    for (count,item) in enumerate(shutter_temp_list):\n        degradation_temp_list.append(abs((((float(shutter_temp_list[count])/float(colo_temp_list[count]))-(numerator1/denominator1))/(float(shutter_temp_list[count])/float(colo_temp_list[count])))*100))\n\n    shutter_temp_list.sort()\n    colo_temp_list.sort()\n    #print shutter_temp_list\n    #print colo_temp_list\n    #print dictList_degradation_shutter2[j][i]\n    denominator2 = sum(float(n) for (m,n) in enumerate(shutter_temp_list))/len(shutter_temp_list)\n    #print len(colo_temp_list)\n    #print len(shutter_temp_list)\n    numerator2 = sum(float(n) for (m,n) in enumerate(colo_temp_list))/len(colo_temp_list)\n    for (m,n) in enumerate(shutter_temp_list):\n        ratio=float(n)/float(colo_temp_list[m])\n        error_temp_list.append(abs((((ratio)-(numerator1/denominator1))/(numerator1/denominator1))*100))\n    plot_degradation_error[j][i]=np.std(error_temp_list)\n\n    #print numerator2\n    #print denominator2\n    del shutter_temp_list\n    del colo_temp_list\n    del degradation_temp_list\n    #plot_degradation[j][i] = abs((((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100)\n    plot_degradation[j][i] = abs(((denominator2/denominator1)-1)*100)\n    shutter_vm2 = shutter_vm2 + (plot_degradation[j][i],)\n    #print denominator2/numerator2\n    #print j,i,plot_degradation[j][i]\n            #print (((numerator2/denominator2)-(numerator1/denominator1))/(numerator2/denominator2))*100\n\n#print shutter_vm2\n\n\ndel dictList_degradation_shutter_prev\ndel dictList_degradation_shutter_prev2\ndel plot_degradation\ndel plot_degradation_error\n\ndictList_degradation_shutter_prev = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter_prev2 = defaultdict(lambda  : defaultdict(list))\nplot_degradation = defaultdict(dict)\nplot_degradation_error = defaultdict(dict)\n\n\nfor (b,a) in enumerate(fList6):\n    if a in colocationListExperiments:\n        index = a\n    else:\n        if a in benchListExperiments:\n            dictList_degradation_shutter_prev[index][a].append(fList6[b+1])\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    for elem in dictList_degradation_shutter_prev[j][i]:\n        dictList_degradation_shutter_prev2[j][i].extend(elem.strip().split(\'\\t\'))\n    #print dictList_degradation_shutter_prev2[j][i]\n\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    #print i\n    denominator1 = sum(float(n) for (m,n) in enumerate(dictList_single_vm[i]))/(len(dictList_single_vm[i]))\n    numerator1 = sum(float(n) for (m,n) in enumerate(dictList_degradation_shutter[j][i]))/(len(dictList_degradation_shutter[j][i]))\n    shutter_temp_list = []\n    colo_temp_list = []\n    degradation_temp_list = []\n    error_temp_list = []\n    #print numerator1\n    #print denominator1\n    for (count,item) in enumerate(dictList_degradation_shutter_prev2[j][i]):\n        #print item\n        if count%2==0:\n            colo_temp_list.append(item)\n        if count%2==1:\n            shutter_temp_list.append(item)\n\n    for (count,item) in enumerate(shutter_temp_list):\n        degradation_temp_list.append(abs((((float(shutter_temp_list[count])/float(colo_temp_list[count]))-(numerator1/denominator1))/(float(shutter_temp_list[count])/float(colo_temp_list[count])))*100))\n\n    shutter_temp_list.sort()\n    colo_temp_list.sort()\n    #print shutter_temp_list\n    #print colo_temp_list\n    #print dictList_degradation_shutter2[j][i]\n    denominator2 = sum(float(n) for (m,n) in enumerate(shutter_temp_list))/len(shutter_temp_list)\n    #print len(colo_temp_list)\n    #print len(shutter_temp_list)\n    numerator2 = sum(float(n) for (m,n) in enumerate(colo_temp_list))/len(colo_temp_list)\n    for (m,n) in enumerate(shutter_temp_list):\n        ratio=float(n)/float(colo_temp_list[m])\n        error_temp_list.append(abs((((ratio)-(numerator1/denominator1))/(numerator1/denominator1))*100))\n    plot_degradation_error[j][i]=np.std(error_temp_list)\n\n    #print numerator2\n    #print denominator2\n    del shutter_temp_list\n    del colo_temp_list\n    del degradation_temp_list\n    #plot_degradation[j][i] = abs((((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100)\n    plot_degradation[j][i] = abs(((denominator2/denominator1)-1)*100)\n    shutter_vm3 = shutter_vm3 + (plot_degradation[j][i],)\n    #print denominator2/numerator2\n    #print j,i,plot_degradation[j][i]\n            #print (((numerator2/denominator2)-(numerator1/denominator1))/(numerator2/denominator2))*100\n\n#print shutter_vm3\n\n\nfor (b,a) in enumerate(fList7):\n    if a in colocationListExperiments:\n        index = a\n    else:\n        if a in benchListExperiments:\n            dictList_degradation_shutter_prev[index][a].append(fList7[b+1])\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    for elem in dictList_degradation_shutter_prev[j][i]:\n        dictList_degradation_shutter_prev2[j][i].extend(elem.strip().split(\'\\t\'))\n    #print dictList_degradation_shutter_prev2[j][i]\n\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    #print i\n    denominator1 = sum(float(n) for (m,n) in enumerate(dictList_single_vm[i]))/(len(dictList_single_vm[i]))\n    numerator1 = sum(float(n) for (m,n) in enumerate(dictList_degradation_shutter2[j][i]))/(len(dictList_degradation_shutter2[j][i]))\n    shutter_temp_list = []\n    colo_temp_list = []\n    degradation_temp_list = []\n    error_temp_list = []\n    #print numerator1\n    #print denominator1\n    for (count,item) in enumerate(dictList_degradation_shutter_prev2[j][i]):\n        #print item\n        if count%2==0:\n            colo_temp_list.append(item)\n        if count%2==1:\n            shutter_temp_list.append(item)\n\n    for (count,item) in enumerate(shutter_temp_list):\n        degradation_temp_list.append(abs((((float(shutter_temp_list[count])/float(colo_temp_list[count]))-(numerator1/denominator1))/(float(shutter_temp_list[count])/float(colo_temp_list[count])))*100))\n\n    shutter_temp_list.sort()\n    colo_temp_list.sort()\n    #print shutter_temp_list\n    #print colo_temp_list\n    #print dictList_degradation_shutter2[j][i]\n    denominator2 = sum(float(n) for (m,n) in enumerate(shutter_temp_list))/len(shutter_temp_list)\n    #print len(colo_temp_list)\n    #print len(shutter_temp_list)\n    numerator2 = sum(float(n) for (m,n) in enumerate(colo_temp_list))/len(colo_temp_list)\n    for (m,n) in enumerate(shutter_temp_list):\n        ratio=float(n)/float(colo_temp_list[m])\n        error_temp_list.append(abs((((ratio)-(numerator1/denominator1))/(numerator1/denominator1))*100))\n    plot_degradation_error[j][i]=np.std(error_temp_list)\n\n    #print numerator2\n    #print denominator2\n    del shutter_temp_list\n    del colo_temp_list\n    del degradation_temp_list\n    #plot_degradation[j][i] = abs((((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100)\n    plot_degradation[j][i] = abs(((denominator2/denominator1)-1)*100)\n    shutter_vm4 = shutter_vm4 + (plot_degradation[j][i],)\n    #print denominator2/numerator2\n    #print j,i,plot_degradation[j][i]\n            #print (((numerator2/denominator2)-(numerator1/denominator1))/(numerator2/denominator2))*100\n#print shutter_vm4\n\ndel dictList_degradation_shutter_prev\ndel dictList_degradation_shutter_prev2\ndel plot_degradation\ndel plot_degradation_error\n\ndictList_degradation_shutter_prev = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter_prev2 = defaultdict(lambda  : defaultdict(list))\nplot_degradation = defaultdict(dict)\nplot_degradation_error = defaultdict(dict)\n\n\nwidth=0.2\nx = np.arange(len(vm2))\nplt.figure(figsize=(6, 4))\nplt.subplot(2, 1, 1)\nplt.bar( x, shutter_vm2, width, color="r", label=\'w/ 1 libquantum\' )\n#plt.text(0.5, 0.5, ha=\'center\', va=\'center\', size=24, alpha=.5)\nplt.bar( x+width, shutter_vm3, width, color="b", label=\'w/ 2 libquantum\' )\nplt.bar( x+width+width, shutter_vm4, width, color="g", label=\'w/ 3 libquantum\')\nplt.ylim(0,60)\nplt.ylabel( \'Estimation \\n error (%)\' , multialignment=\'center\')\nplt.yticks(np.arange(0, 60, 10))\n\nplt.xticks(())\nplt.legend(prop={\'size\':9}, loc=2)\n#plt.xticks(x + width, xaxis, rotation=\'30\', size=\'8\')\n\nplt.subplot(2, 1, 2)\nbar4 = plt.bar( x, overhead2, width, color="r", label=\'2 corunners running libquantum\' )\nbar5 = plt.bar( x+width, overhead3, width, color="b", label=\'3 corunners running libquantum \' )\nbar6 = plt.bar( x+width+width, overhead4, width, color="g", label=\'4 corunners running libquantum \')\n#bar4.tick_params(axis=\'x\', labelsize=28)\nplt.yticks(())\n#plt.text(0.5, 0.5, \'subplot(2,1,2)\', ha=\'center\', va=\'center\',\n #       size=24, alpha=.5)\n\nplt.tight_layout()\nplt.ylabel( \'Shuttering \\n overhead (%)\', fontsize=12, multialignment=\'center\')\nplt.xticks(x + width, xaxis, rotation=\'30\', size=\'12\')\n#plt.ylim(-15,0)\nplt.yticks(np.arange(-15,0,5), (\'15\',\'10\',\'5\'))\n#labels = np.arange(-15,0,5)\n#plt.yticks(labels)\n#labels[1] = \'testing\'\nplt.tight_layout()\n#plt.tight_layout()\n## default scale is 1 in your original case, scales with other cases:\n##plt.show()'
p0
.I0
.S'Problem1'
p0
.S'$p:Although this is a very simple and straightforward technique, it suffers from low accuracy in estimating the solo performance of applications. The top part of Figure~\\ref{fig:overheads_precise_shuttering} shows the error of estimating solo performance of applications. The baseline is CPI of each application without any co-runners. Each bar is normalized to the baseline when using the shuttering technique. The error rate is not negligible and increases to around 40\\% in \\texttt{bzip2} and \\texttt{xalancbmk}. The main reason is that the pausing time (3.2ms) used in prior work is not be enough to capture solo performance of an application. This is because the shared cache would not be warmed up to be containing the entire working set of the application which is to be measured. As a result, the measured application would spend most of its pausing time filling in the shared cache, giving much less time to observe how the application performs when it monopolizes computing resources. Moreover, as the number of co-runners increases, the shared cache becomes much more polluted due to the contention among the multiple co-runners. The effective time of precisely estimating solo performance of applications becomes much lower. \n\n'
p0
.I0
.S'Problem2'
p0
.S'$p:\nIn addition, the bottom of Figure~\\ref{fig:overheads_precise_shuttering} shows the increased execution time for estimation of performance degradation as the number of co-runners increases. The source of the increased overhead is that the cache blocks belonging to the paused VMs would be eventually evicted at the end of the pausing time. As a result, when the paused VMs are resumed, they would pay an additional cost to warm up the cache. Moreover, as the number of co-running VMs increases, the overhead effects due to the prior is technique aggravated. \\\\\n\n\n%The overheads consist of two parts. Firstly, the direct cost occurs due to the pausing time. This increases the overall execution time of the VMs. Secondly, the indirect cost occurs due to the contention of architectural shared resources. When we resume the execution of the paused VMs, each VM would pay an additional cost to warm up the cache because the data belonging to the paused VMs would have been evicted during their pausing time.\n\n%In addition to this, as the number of co-runners increases, the number of pausing VMs is also increasing because precise shuttering needs to measure performance for each VM when running alone. As a result, it will cause performance overheads which increase the execution time of the applications. This overheads consist of two parts. Firstly, the direct cost occurs due to the pausing time. This increases the overall execution time of the VMs. Secondly, the indirect cost occurs due to the contention of architectural shared resources. When we resume the execution of the paused VMs, each VM would pay an additional cost to warm up the cache because the data belonging to the paused VMs would have been evicted during their pausing time. To figure out the overheads, we measured how the execution time of each application would increase as we increase the number of co-runners. '
p0
.I0
.S'Fair Pricing Runtime Engine'
p0
.S'$s: Fair Pricing Runtime Engine'
p0
.I4
.S'Overview'
p0
.S'$p:\nIn this section, we introduce an efficient and scalable technique, called \\textit{snapshot}, to precisely identify unintended performance degradation in public clouds. To enable \\textit{snapshot}, we propose a phase detection mechanism based on selected performance monitoring units (PMUs). Our Fair Pricing Runtime Engine is based on \\textit{snapshot} technique on top of the phase detection mechanism.'
p0
.I0
.S'Snapshot Shuttering'
p0
.S'$s: Snapshot Technique'
p0
.I12
.S'$fig:snapshot_shuttering,1:!'
p0
.S''
p0
.I0
.S'$pdf_fig:snapshot_shuttering:Snapshot technique:1'
p0
.S''
p0
.I0
.S'$sub_fig*:PMUtypephase:Detecting phase changes when running with 3 instances of \\texttt{astar}:mcfl1dastar,1:milcl1dastar,1:nl:mcfllcastar,1:milcllcastar,1:!'
p0
.S''
p0
.I0
.S'$graph_fig:mcfl1dastar:mcf with L1-d cache load misses:0.9'
p0
.S"import matplotlib.pyplot as plt\nimport numpy as np\nfrom collections import defaultdict\n\nfilename = '5'\nf1 = [s.strip() for s in open('../../papergraphs/phases/pmutypes/single.txt').readlines()]\nf2 = [s.strip() for s in open('../../papergraphs/phases/pmutypes/degradation.txt').readlines()]\n#f3 = [s.strip() for s in open('../../papergraphs/phases/shutter_phase_%s.txt' % filename).readlines()]\n\nbenchListBaseline = [ 'gcc', 'perlbench', 'mcf', 'leslie3d', 'povray', 'libquantum', 'astar', 'bzip2', 'milc', 'namd', 'calculix', 'h264ref', 'zeusmp', 'gobmk', 'hmmer', 'tonto', 'sphinx3', 'bwaves', 'gromacs', 'dealII', 'sjeng', 'lbm', 'xalancbmk', 'gamess', 'cactusADM', 'soplex', 'GemsFDTD', 'omnetpp' ]\nbenchListExperiments = [ 'gcc', 'perlbench', 'mcf', 'leslie3d', 'povray', 'libquantum', 'astar', 'bzip2', 'milc', 'namd', 'calculix', 'h264ref', 'zeusmp', 'gobmk', 'hmmer', 'tonto', 'sphinx3', 'bwaves', 'gromacs', 'dealII', 'sjeng', 'lbm', 'xalancbmk', 'gamess', 'cactusADM', 'soplex', 'GemsFDTD', 'omnetpp' ]\ncolocationListBaseline = [ 'colocating with mcf', 'colocating with povray', 'colocating with astar', 'colocating with astar', 'colocating with libquantum', 'colocating with povray', 'colocating with omnetpp', 'colocating with bzip2' ]\ncolocationListExperiments = [ 'colocating with mcf', 'colocating with povray', 'colocating with perlbench', 'colocating with astar', 'colocating with libquantum', 'colocating with povray', 'colocating with omnetpp', 'colocating with bzip2' ]\nrunningList = [ 'mcf' ,'colocating with astar']\n\nphaseList_single = defaultdict(list)\nphaseList_degradation = defaultdict(lambda  : defaultdict(list))\nphaseList_shutter = defaultdict(lambda  : defaultdict(list))\nphaseList_colocation = defaultdict(lambda  : defaultdict(list))\n\n\nllc_miss_phaseList_single = defaultdict(list)\nllc_miss_phaseList_degradation = defaultdict(lambda  : defaultdict(list))\nllc_miss_phaseList_shutter = defaultdict(lambda  : defaultdict(list))\nllc_miss_phaseList_colocation = defaultdict(lambda  : defaultdict(list))\n\ndef setAxLinesBW(ax):\n    MARKERSIZE = 3\n    COLORMAP = {\n        'g': {'marker': None, 'dash': (None,None)},\n        'k': {'marker': None, 'dash': [5,5]},\n        'r': {'marker': None, 'dash': [5,3,1,3]},\n        'c': {'marker': None, 'dash': [1,3]},\n        'm': {'marker': None, 'dash': [5,2,5,2,5,10]},\n        'y': {'marker': None, 'dash': [5,3,1,2,1,10]},\n        'b': {'marker': '+', 'dash': (None,None)} #[1,2,1,10]}\n        }\n\n    for line in ax.get_lines() + ax.get_legend().get_lines():\n        origColor = line.get_color()\n        line.set_color('black')\n        line.set_dashes(COLORMAP[origColor]['dash'])\n        line.set_marker(COLORMAP[origColor]['marker'])\n        line.set_markersize(MARKERSIZE)\n\ndef setFigLinesBW(fig):\n    for ax in fig.get_axes():\n        setAxLinesBW(ax)\n\nfirstList1 = []\nsecondList1 = []\nthirdList1 = []\nfourthList1 = []\nfifthList1 = []\nsixthList1 = []\nseventhList1 = []\neighthList1 = []\n\nfor line in f1:\n    firstList1.append(line)\n\nfor line in f2:\n    secondList1.append(line)\n\n#for line in f3:\n#    thirdList1.append(line)\n\nglobal index\nglobal index2\n\nfor (j,i) in enumerate(firstList1):\n    #print i\n    if i in benchListBaseline:\n        index = i\n    else:\n        phaseList_single[index].append(i.split())\n\n\n\nfor (j,i) in enumerate(secondList1):\n    if i in colocationListExperiments:\n        index2=i\n    elif i in benchListExperiments:\n        index=i\n    else:\n        phaseList_degradation[index2][index].append(i.split())\n\n\n\nfor (j,i) in enumerate(thirdList1):\n    if i in colocationListExperiments:\n        index2=i\n    elif i in benchListExperiments:\n        index=i\n    else:\n        phaseList_shutter[index2][index].append(i.split())\n\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    print i\n    instruction_list1=[]\n    cpi_list1=[]\n    instruction_list2=[]\n    cpi_list2=[]\n    instruction_list3=[]\n    cpi_list3=[]\n    for (b,a) in enumerate(phaseList_shutter[j][i]):\n        if a[0][0] == '-':\n            break\n        else:\n            instruction_list1.append(float(a[1]))\n            cpi_list1.append(a[2])\n\n    for (b,a) in enumerate(phaseList_single[i]):\n        if a[0][0] == '-':\n            break\n        else:\n            instruction_list2.append(float(a[1]))\n            cpi_list2.append(a[2])\n\n    for (b,a) in enumerate(phaseList_degradation[j][i]):\n        if a[0][0] == '-':\n            break\n        else:\n            instruction_list3.append(float(a[1]))\n            cpi_list3.append(float(a[7])/1)\n\n    #print instruction_list\n    #print cpi_list\n\n    f, ax1 = plt.subplots(figsize=(12,5))\n    ax1.set_xlabel('Executed instructions', fontsize=23)\n    ax1.set_ylabel('CPI',fontsize=23)\n    ax1.plot(instruction_list2,cpi_list2, color='g',  label= 'CPI solo')\n    ax1.legend(loc=2,prop={'size':23})\n    ax2 = ax1.twinx()\n    ax2.plot(instruction_list3,cpi_list3, color='b',  label= 'L1-d load misses \\nw/ %s' %(j[16:]))\n    #ax2.plot(instruction_list3,cpi_list3, color='b',  label= 'co-run: %s with %s' %(i,j[16:]))\n    ax2.set_ylabel('L1-d load misses',fontsize=23)\n    ax1.set_ylim(-0.5,25)\n    ax2.set_ylim(-0.5,25)\n    ax2.legend(loc=1,prop={'size':23})\n    del instruction_list1\n    del cpi_list1\n\n    #setFigLinesBW(f)\n    #f.savefig('%s_and_libquantum2.pdf'%(i),bbox_inches='tight' ,dpi=200)"
p0
.I0
.S'$graph_fig:milcl1dastar:milc with L1-d cache load misses:0.9'
p0
.S"import matplotlib.pyplot as plt\nimport numpy as np\nfrom collections import defaultdict\n\nfilename = '5'\nf1 = [s.strip() for s in open('../../papergraphs/phases/pmutypes/single.txt').readlines()]\nf2 = [s.strip() for s in open('../../papergraphs/phases/pmutypes/degradation.txt').readlines()]\n#f3 = [s.strip() for s in open('../../papergraphs/phases/shutter_phase_%s.txt' % filename).readlines()]\n\nbenchListBaseline = [ 'gcc', 'perlbench', 'mcf', 'leslie3d', 'povray', 'libquantum', 'astar', 'bzip2', 'milc', 'namd', 'calculix', 'h264ref', 'zeusmp', 'gobmk', 'hmmer', 'tonto', 'sphinx3', 'bwaves', 'gromacs', 'dealII', 'sjeng', 'lbm', 'xalancbmk', 'gamess', 'cactusADM', 'soplex', 'GemsFDTD', 'omnetpp' ]\nbenchListExperiments = [ 'gcc', 'perlbench', 'mcf', 'leslie3d', 'povray', 'libquantum', 'astar', 'bzip2', 'milc', 'namd', 'calculix', 'h264ref', 'zeusmp', 'gobmk', 'hmmer', 'tonto', 'sphinx3', 'bwaves', 'gromacs', 'dealII', 'sjeng', 'lbm', 'xalancbmk', 'gamess', 'cactusADM', 'soplex', 'GemsFDTD', 'omnetpp' ]\ncolocationListBaseline = [ 'colocating with mcf', 'colocating with povray', 'colocating with astar', 'colocating with astar', 'colocating with libquantum', 'colocating with povray', 'colocating with omnetpp', 'colocating with bzip2' ]\ncolocationListExperiments = [ 'colocating with mcf', 'colocating with povray', 'colocating with perlbench', 'colocating with astar', 'colocating with libquantum', 'colocating with povray', 'colocating with omnetpp', 'colocating with bzip2' ]\nrunningList = [ 'milc' ,'colocating with astar']\n\nphaseList_single = defaultdict(list)\nphaseList_degradation = defaultdict(lambda  : defaultdict(list))\nphaseList_shutter = defaultdict(lambda  : defaultdict(list))\nphaseList_colocation = defaultdict(lambda  : defaultdict(list))\n\n\nllc_miss_phaseList_single = defaultdict(list)\nllc_miss_phaseList_degradation = defaultdict(lambda  : defaultdict(list))\nllc_miss_phaseList_shutter = defaultdict(lambda  : defaultdict(list))\nllc_miss_phaseList_colocation = defaultdict(lambda  : defaultdict(list))\n\ndef setAxLinesBW(ax):\n    MARKERSIZE = 3\n    COLORMAP = {\n        'g': {'marker': None, 'dash': (None,None)},\n        'k': {'marker': None, 'dash': [5,5]},\n        'r': {'marker': None, 'dash': [5,3,1,3]},\n        'c': {'marker': None, 'dash': [1,3]},\n        'm': {'marker': None, 'dash': [5,2,5,2,5,10]},\n        'y': {'marker': None, 'dash': [5,3,1,2,1,10]},\n        'b': {'marker': '+', 'dash': (None,None)} #[1,2,1,10]}\n        }\n\n    for line in ax.get_lines() + ax.get_legend().get_lines():\n        origColor = line.get_color()\n        line.set_color('black')\n        line.set_dashes(COLORMAP[origColor]['dash'])\n        line.set_marker(COLORMAP[origColor]['marker'])\n        line.set_markersize(MARKERSIZE)\n\ndef setFigLinesBW(fig):\n    for ax in fig.get_axes():\n        setAxLinesBW(ax)\n\nfirstList1 = []\nsecondList1 = []\nthirdList1 = []\nfourthList1 = []\nfifthList1 = []\nsixthList1 = []\nseventhList1 = []\neighthList1 = []\n\nfor line in f1:\n    firstList1.append(line)\n\nfor line in f2:\n    secondList1.append(line)\n\n#for line in f3:\n#    thirdList1.append(line)\n\nglobal index\nglobal index2\n\nfor (j,i) in enumerate(firstList1):\n    #print i\n    if i in benchListBaseline:\n        index = i\n    else:\n        phaseList_single[index].append(i.split())\n\n\n\nfor (j,i) in enumerate(secondList1):\n    if i in colocationListExperiments:\n        index2=i\n    elif i in benchListExperiments:\n        index=i\n    else:\n        phaseList_degradation[index2][index].append(i.split())\n\n\n\nfor (j,i) in enumerate(thirdList1):\n    if i in colocationListExperiments:\n        index2=i\n    elif i in benchListExperiments:\n        index=i\n    else:\n        phaseList_shutter[index2][index].append(i.split())\n\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    print i\n    instruction_list1=[]\n    cpi_list1=[]\n    instruction_list2=[]\n    cpi_list2=[]\n    instruction_list3=[]\n    cpi_list3=[]\n    for (b,a) in enumerate(phaseList_shutter[j][i]):\n        if a[0][0] == '-':\n            break\n        else:\n            instruction_list1.append(float(a[1]))\n            cpi_list1.append(a[2])\n\n    for (b,a) in enumerate(phaseList_single[i]):\n        if a[0][0] == '-':\n            break\n        else:\n            instruction_list2.append(float(a[1]))\n            cpi_list2.append(a[2])\n\n    for (b,a) in enumerate(phaseList_degradation[j][i]):\n        if a[0][0] == '-':\n            break\n        else:\n            instruction_list3.append(float(a[1]))\n            cpi_list3.append(float(a[7])/10)\n\n    #print instruction_list\n    #print cpi_list\n\n    f, ax1 = plt.subplots(figsize=(12,5))\n    ax1.set_xlabel('Executed instructions', fontsize=23)\n    ax1.set_ylabel('CPI',fontsize=23)\n    ax1.plot(instruction_list2,cpi_list2, color='g',  label= 'CPI solo')\n    ax1.legend(loc=2,prop={'size':23})\n    ax2 = ax1.twinx()\n    ax2.plot(instruction_list3,cpi_list3, color='b',  label= 'L1-d load misses \\nw/ %s' %(j[16:]))\n    #ax2.plot(instruction_list3,cpi_list3, color='b',  label= 'co-run: %s with %s' %(i,j[16:]))\n    ax2.set_ylabel('L1-d load misses',fontsize=23)\n    ax1.set_ylim(-0.5,3)\n    ax2.set_ylim(-0.5,3)\n    ax2.legend(loc=1,prop={'size':23})\n    del instruction_list1\n    del cpi_list1\n\n    #setFigLinesBW(f)\n    #f.savefig('%s_and_libquantum2.pdf'%(i),bbox_inches='tight' ,dpi=200)"
p0
.I0
.S'$graph_fig:mcfllcastar:mcf with LLC store misses:0.9'
p0
.S"import matplotlib.pyplot as plt\nimport numpy as np\nfrom collections import defaultdict\n\nfilename = '5'\nf1 = [s.strip() for s in open('../../papergraphs/phases/pmutypes/single.txt').readlines()]\nf2 = [s.strip() for s in open('../../papergraphs/phases/pmutypes/degradation.txt').readlines()]\n#f3 = [s.strip() for s in open('../../papergraphs/phases/shutter_phase_%s.txt' % filename).readlines()]\n\nbenchListBaseline = [ 'gcc', 'perlbench', 'mcf', 'leslie3d', 'povray', 'libquantum', 'astar', 'bzip2', 'milc', 'namd', 'calculix', 'h264ref', 'zeusmp', 'gobmk', 'hmmer', 'tonto', 'sphinx3', 'bwaves', 'gromacs', 'dealII', 'sjeng', 'lbm', 'xalancbmk', 'gamess', 'cactusADM', 'soplex', 'GemsFDTD', 'omnetpp' ]\nbenchListExperiments = [ 'gcc', 'perlbench', 'mcf', 'leslie3d', 'povray', 'libquantum', 'astar', 'bzip2', 'milc', 'namd', 'calculix', 'h264ref', 'zeusmp', 'gobmk', 'hmmer', 'tonto', 'sphinx3', 'bwaves', 'gromacs', 'dealII', 'sjeng', 'lbm', 'xalancbmk', 'gamess', 'cactusADM', 'soplex', 'GemsFDTD', 'omnetpp' ]\ncolocationListBaseline = [ 'colocating with mcf', 'colocating with povray', 'colocating with astar', 'colocating with astar', 'colocating with libquantum', 'colocating with povray', 'colocating with omnetpp', 'colocating with bzip2' ]\ncolocationListExperiments = [ 'colocating with mcf', 'colocating with povray', 'colocating with perlbench', 'colocating with astar', 'colocating with libquantum', 'colocating with povray', 'colocating with omnetpp', 'colocating with bzip2' ]\nrunningList = [ 'mcf' ,'colocating with astar']\n\nphaseList_single = defaultdict(list)\nphaseList_degradation = defaultdict(lambda  : defaultdict(list))\nphaseList_shutter = defaultdict(lambda  : defaultdict(list))\nphaseList_colocation = defaultdict(lambda  : defaultdict(list))\n\n\nllc_miss_phaseList_single = defaultdict(list)\nllc_miss_phaseList_degradation = defaultdict(lambda  : defaultdict(list))\nllc_miss_phaseList_shutter = defaultdict(lambda  : defaultdict(list))\nllc_miss_phaseList_colocation = defaultdict(lambda  : defaultdict(list))\n\ndef setAxLinesBW(ax):\n    MARKERSIZE = 3\n    COLORMAP = {\n        'g': {'marker': None, 'dash': (None,None)},\n        'k': {'marker': None, 'dash': [5,5]},\n        'r': {'marker': None, 'dash': [5,3,1,3]},\n        'c': {'marker': None, 'dash': [1,3]},\n        'm': {'marker': None, 'dash': [5,2,5,2,5,10]},\n        'y': {'marker': None, 'dash': [5,3,1,2,1,10]},\n        'b': {'marker': '+', 'dash': (None,None)} #[1,2,1,10]}\n        }\n\n    for line in ax.get_lines() + ax.get_legend().get_lines():\n        origColor = line.get_color()\n        line.set_color('black')\n        line.set_dashes(COLORMAP[origColor]['dash'])\n        line.set_marker(COLORMAP[origColor]['marker'])\n        line.set_markersize(MARKERSIZE)\n\ndef setFigLinesBW(fig):\n    for ax in fig.get_axes():\n        setAxLinesBW(ax)\n\nfirstList1 = []\nsecondList1 = []\nthirdList1 = []\nfourthList1 = []\nfifthList1 = []\nsixthList1 = []\nseventhList1 = []\neighthList1 = []\n\nfor line in f1:\n    firstList1.append(line)\n\nfor line in f2:\n    secondList1.append(line)\n\n#for line in f3:\n#    thirdList1.append(line)\n\nglobal index\nglobal index2\n\nfor (j,i) in enumerate(firstList1):\n    #print i\n    if i in benchListBaseline:\n        index = i\n    else:\n        phaseList_single[index].append(i.split())\n\n\n\nfor (j,i) in enumerate(secondList1):\n    if i in colocationListExperiments:\n        index2=i\n    elif i in benchListExperiments:\n        index=i\n    else:\n        phaseList_degradation[index2][index].append(i.split())\n\n\n\nfor (j,i) in enumerate(thirdList1):\n    if i in colocationListExperiments:\n        index2=i\n    elif i in benchListExperiments:\n        index=i\n    else:\n        phaseList_shutter[index2][index].append(i.split())\n\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    print i\n    instruction_list1=[]\n    cpi_list1=[]\n    instruction_list2=[]\n    cpi_list2=[]\n    instruction_list3=[]\n    cpi_list3=[]\n    for (b,a) in enumerate(phaseList_shutter[j][i]):\n        if a[0][0] == '-':\n            break\n        else:\n            instruction_list1.append(float(a[1]))\n            cpi_list1.append(a[2])\n\n    for (b,a) in enumerate(phaseList_single[i]):\n        if a[0][0] == '-':\n            break\n        else:\n            instruction_list2.append(float(a[1]))\n            cpi_list2.append(a[2])\n\n    for (b,a) in enumerate(phaseList_degradation[j][i]):\n        if a[0][0] == '-':\n            break\n        else:\n            instruction_list3.append(float(a[1]))\n            cpi_list3.append(float(a[14])/10)\n\n    #print instruction_list\n    #print cpi_list\n\n    f, ax1 = plt.subplots(figsize=(12,5))\n    ax1.set_xlabel('Executed instructions', fontsize=23)\n    ax1.set_ylabel('CPI',fontsize=23)\n    ax1.plot(instruction_list2,cpi_list2, color='g',  label= 'CPI solo')\n    ax1.legend(loc=2,prop={'size':23})\n    ax2 = ax1.twinx()\n    ax2.plot(instruction_list3,cpi_list3, color='b',  label= 'LLC store misses \\nw/ %s' %(j[16:]))\n    #ax2.plot(instruction_list3,cpi_list3, color='b',  label= 'co-run: %s with %s' %(i,j[16:]))\n    ax2.set_ylabel('LLC store misses',fontsize=23)\n    ax1.set_ylim(-0.5,25)\n    ax2.set_ylim(-0.5,25)\n    ax2.legend(loc=1,prop={'size':23})\n    del instruction_list1\n    del cpi_list1\n\n    #setFigLinesBW(f)\n    #f.savefig('%s_and_libquantum2.pdf'%(i),bbox_inches='tight' ,dpi=200)"
p0
.I0
.S'$graph_fig:milcllcastar:milc with LLC store misses:0.9'
p0
.S"import matplotlib.pyplot as plt\nimport numpy as np\nfrom collections import defaultdict\n\nfilename = '5'\nf1 = [s.strip() for s in open('../../papergraphs/phases/pmutypes/single.txt').readlines()]\nf2 = [s.strip() for s in open('../../papergraphs/phases/pmutypes/degradation.txt').readlines()]\n#f3 = [s.strip() for s in open('../../papergraphs/phases/shutter_phase_%s.txt' % filename).readlines()]\n\nbenchListBaseline = [ 'gcc', 'perlbench', 'mcf', 'leslie3d', 'povray', 'libquantum', 'astar', 'bzip2', 'milc', 'namd', 'calculix', 'h264ref', 'zeusmp', 'gobmk', 'hmmer', 'tonto', 'sphinx3', 'bwaves', 'gromacs', 'dealII', 'sjeng', 'lbm', 'xalancbmk', 'gamess', 'cactusADM', 'soplex', 'GemsFDTD', 'omnetpp' ]\nbenchListExperiments = [ 'gcc', 'perlbench', 'mcf', 'leslie3d', 'povray', 'libquantum', 'astar', 'bzip2', 'milc', 'namd', 'calculix', 'h264ref', 'zeusmp', 'gobmk', 'hmmer', 'tonto', 'sphinx3', 'bwaves', 'gromacs', 'dealII', 'sjeng', 'lbm', 'xalancbmk', 'gamess', 'cactusADM', 'soplex', 'GemsFDTD', 'omnetpp' ]\ncolocationListBaseline = [ 'colocating with mcf', 'colocating with povray', 'colocating with astar', 'colocating with astar', 'colocating with libquantum', 'colocating with povray', 'colocating with omnetpp', 'colocating with bzip2' ]\ncolocationListExperiments = [ 'colocating with mcf', 'colocating with povray', 'colocating with perlbench', 'colocating with astar', 'colocating with libquantum', 'colocating with povray', 'colocating with omnetpp', 'colocating with bzip2' ]\nrunningList = [ 'milc' ,'colocating with astar']\n\nphaseList_single = defaultdict(list)\nphaseList_degradation = defaultdict(lambda  : defaultdict(list))\nphaseList_shutter = defaultdict(lambda  : defaultdict(list))\nphaseList_colocation = defaultdict(lambda  : defaultdict(list))\n\n\nllc_miss_phaseList_single = defaultdict(list)\nllc_miss_phaseList_degradation = defaultdict(lambda  : defaultdict(list))\nllc_miss_phaseList_shutter = defaultdict(lambda  : defaultdict(list))\nllc_miss_phaseList_colocation = defaultdict(lambda  : defaultdict(list))\n\ndef setAxLinesBW(ax):\n    MARKERSIZE = 3\n    COLORMAP = {\n        'g': {'marker': None, 'dash': (None,None)},\n        'k': {'marker': None, 'dash': [5,5]},\n        'r': {'marker': None, 'dash': [5,3,1,3]},\n        'c': {'marker': None, 'dash': [1,3]},\n        'm': {'marker': None, 'dash': [5,2,5,2,5,10]},\n        'y': {'marker': None, 'dash': [5,3,1,2,1,10]},\n        'b': {'marker': '+', 'dash': (None,None)} #[1,2,1,10]}\n        }\n\n    for line in ax.get_lines() + ax.get_legend().get_lines():\n        origColor = line.get_color()\n        line.set_color('black')\n        line.set_dashes(COLORMAP[origColor]['dash'])\n        line.set_marker(COLORMAP[origColor]['marker'])\n        line.set_markersize(MARKERSIZE)\n\ndef setFigLinesBW(fig):\n    for ax in fig.get_axes():\n        setAxLinesBW(ax)\n\nfirstList1 = []\nsecondList1 = []\nthirdList1 = []\nfourthList1 = []\nfifthList1 = []\nsixthList1 = []\nseventhList1 = []\neighthList1 = []\n\nfor line in f1:\n    firstList1.append(line)\n\nfor line in f2:\n    secondList1.append(line)\n\n#for line in f3:\n#    thirdList1.append(line)\n\nglobal index\nglobal index2\n\nfor (j,i) in enumerate(firstList1):\n    #print i\n    if i in benchListBaseline:\n        index = i\n    else:\n        phaseList_single[index].append(i.split())\n\n\n\nfor (j,i) in enumerate(secondList1):\n    if i in colocationListExperiments:\n        index2=i\n    elif i in benchListExperiments:\n        index=i\n    else:\n        phaseList_degradation[index2][index].append(i.split())\n\n\n\nfor (j,i) in enumerate(thirdList1):\n    if i in colocationListExperiments:\n        index2=i\n    elif i in benchListExperiments:\n        index=i\n    else:\n        phaseList_shutter[index2][index].append(i.split())\n\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    print i\n    instruction_list1=[]\n    cpi_list1=[]\n    instruction_list2=[]\n    cpi_list2=[]\n    instruction_list3=[]\n    cpi_list3=[]\n    for (b,a) in enumerate(phaseList_shutter[j][i]):\n        if a[0][0] == '-':\n            break\n        else:\n            instruction_list1.append(float(a[1]))\n            cpi_list1.append(a[2])\n\n    for (b,a) in enumerate(phaseList_single[i]):\n        if a[0][0] == '-':\n            break\n        else:\n            instruction_list2.append(float(a[1]))\n            cpi_list2.append(a[2])\n\n    for (b,a) in enumerate(phaseList_degradation[j][i]):\n        if a[0][0] == '-':\n            break\n        else:\n            instruction_list3.append(float(a[1]))\n            cpi_list3.append(float(a[14])/100)\n\n    #print instruction_list\n    #print cpi_list\n\n    f, ax1 = plt.subplots(figsize=(12,5))\n    ax1.set_xlabel('Executed instructions', fontsize=23)\n    ax1.set_ylabel('CPI',fontsize=23)\n    ax1.plot(instruction_list2,cpi_list2, color='g',  label= 'CPI solo')\n    ax1.legend(loc=2,prop={'size':23})\n    ax2 = ax1.twinx()\n    ax2.plot(instruction_list3,cpi_list3, color='b',  label= 'LLC store misses \\nw/ %s' %(j[16:]))\n    #ax2.plot(instruction_list3,cpi_list3, color='b',  label= 'co-run: %s with %s' %(i,j[16:]))\n    ax2.set_ylabel('LLC store misses',fontsize=23)\n    ax1.set_ylim(-0.5,3)\n    ax2.set_ylim(-0.5,3)\n    ax2.legend(loc=1,prop={'size':23})\n    del instruction_list1\n    del cpi_list1\n\n    #setFigLinesBW(f)\n    #f.savefig('%s_and_libquantum2.pdf'%(i),bbox_inches='tight' ,dpi=200)"
p0
.I0
.S'Mechanism description'
p0
.S'$p:Our goal is to achieve high accuracy with low overhead in estimating unintended performance degradation on public clouds. We exploit two key observations which lead to our \\textit{snapshot} technique.  Firstly, the execution behavior of applications does not drastically change within a steady phase. In other words, the CPI of a particular phase of the application remains fairly constant. Hence, we do not need to periodically estimate performance degradation during a steady phases. When a phase change occurs, we have to take a snapshot once to investigate performance degradation for that phase. Secondly, the number of phase changes is not significant in many applications. It gives us an opportunity to optimize our snapshot technique for common cases where applications have few phase changes. In addition, even if applications have irregular behavior during its runtime, our snapshot technique has an ability to trace the performance degradation more accurately than prior approach. Therefore, if we accurately detect phase changes under the contentious environments, we can significantly reduce the overhead and achieve high accuracy for estimating performance degradation.\n\nMoreover, since we take a snapshot only at phase changes, it enables us to snapshot for a longer time so as to accurately measure performance degradation of applications. If the measurement time is long enough to evict the cache blocks belonging to the co-running VMs and to bring the working set of the VM (which is to be measured) in the cache, we could achieve high accuracy. In addition, even if the number of co-runners increases, our \\textit{snapshot} technique is less susceptible to overhead issues as phase changes rarely occur.'
p0
.I0
.S'Figure Explanation'
p0
.S'$p:Figure \\ref{fig:snapshot_shuttering} shows how our \\textit{snapshot} technique estimates performance degradation by taking snapshot only when one of the applications undergoes phase changes. During the snapshot, we can easily estimate solo performance (CPI) of the application. By using this information, we will be able to estimate CPI of solo execution by using the following equation.\n\n\\begin{equation} \\label{solo_equation}\n\\small CPI_{(solo)} = \\dfrac{CPI_{(1)} \\times T_{(1)} + CPI_{(2)} \\times T_{(2)} + . . . . + CPI_{(n)} \\times T_{(n)}}{T_{1} + T_{2} . . . . + T_{n}}\n\\end{equation}\n\\begin{itemize}\n\\item $CPI_{(solo)}$ is estimated CPI of solo execution of an application.\n\\vspace{-0.1in}\n\\item $CPI_{(i)}$ is estimated CPI of solo execution of the application during phase $i$.\n\\vspace{-0.1in}\n\\item $T_{(i)}$ is time for which the application remains in phase $i$.\n\\vspace{-0.1in}\n\\item $n$ is total number of phase changes for the application.\n\\end{itemize}\n'
p0
.I0
.S'Calculating degradation'
p0
.S'$p: The $CPI_{(co-location)}$ is directly measured when the application is running with the co-runners.  From the values of $CPI_{(co-location)}$ and $CPI_{(solo)}$, we estimate the degradation using the the following equation. \n\\begin{equation} \\label{eq:degradation_equation}\nPerfDeg = \\dfrac{CPI_{(co-location)}}{CPI_{(solo)}}\n\\end{equation}'
p0
.I0
.S'Motivation for next section'
p0
.S'$p: Thus, accurately detecting phase changes is very important to make \\textit{snapshot} technique viable. We will discuss this in the next section.'
p0
.I0
.S'$omit!:Mechanism description'
p0
.S'$p:In order to overcome the issues present in the prior techniques, we propose \\textit{snapshot} technique to achieve high accuracy and to minimize the overhead when estimating unintended performance degradation in co-located environments. The novelty of this approach lies in applying the basic shuttering technique opportunistically only when VMs undergo phase changes. A phase change in an application can be defined as a drastic change of CPI (Cycles Per Instructions) as CPI represents its performance for a given time. The reason behind shuttering only at phase changes is that the execution behavior of applications does not change within a steady phase. It means that we do not need to measure the performance behavior of applications at fixed time intervals as being done by prior work. If we accurately detect phase changes in co-located environments, we can significantly reduce the frequency of pausing the VMs compared to the prior technique. Our observation is that the number of phase changes is not significant in many applications. Therefore, our technique can eliminate repeated shuttering within the steady state of a single phase. \n\nIn addition, since our \\textit{snapshot} technique pauses VMs only at phase changes, it enables us to increase the pausing time to achieve high accuracy. This increased pausing time makes it possible to evict the cache blocks belonging to the co-running VMs and to bring the working set of the VM, which is to be measured, in the cache.\nEven if the number of co-runners increases, it is less susceptible to the overhead of pausing all other VMs because it does not frequently take \\textit{snapshots} in many cases.'
p0
.I0
.S'Phase Detecting Mechansim'
p0
.S'$s: Phase Detecting Mechanism\n'
p0
.I5
.S'Intro'
p0
.S'$p: In this section, we introduce our phase detecting mechanism to enable \\textit{snapshot} technique in public clouds. \nIf there are no co-runners, we could easily detect phase changes by capturing CPI changes during solo execution of an application. However, public clouds, which allow the co-location of VMs on a single server, make it difficult to precisely estimate phase changes. This is due to the fact that CPI of an application could be highly affected by other applications running in co-located VMs. As a result, there is a possibility of falsely detecting phase changes due to the interference from co-runners. To make our \\textit{snapshot} technique more effective, we need to minimize the number of falsely detecting phases because if we frequently detect wrong phase changes due to the interference, the number of unnecessary shuttering would increase. As a result, it would increase the overhead of our \\textit{snapshot} technique. \n\nTo efficiently detect true phase changes, which are inherent phase changes of applications, while avoiding falsely detecting phases, we need additional information apart from CPI. For this purpose, we observed usage patterns of architectural resources over time. Our hypothesis is that true phase changes of applications can be clearly identified by observing architectural resource usages. We took advantage of performance monitoring units (PMUs) to observe various architectural events. PMUs are well known for its low overheads and easily deployable into real systems.'
p0
.I0
.S'Explain figures'
p0
.S'$p: Figure \\ref{fig:PMUtypephase} shows that each application requires different types of PMU to precisely detect phase changes for two applications. The x-axis indicates the cumulative number of instructions executed as time progresses. The left y-axis and green line show CPI of the applications when running alone and the right y-axis and the blue line show estimating phase changes by a selected performance counter for the application when running with three instances of \\texttt{astar} as co-runners. From Figure \\ref{fig:mcfl1dastar}, we find out that the performance counter, \\textit{L1-d cache load misses}, can effectively detect inherent phase changes of \\texttt{mcf} in co-located environments whereas Figure \\ref{fig:milcl1dastar} shows that the same type of PMU is unable to detect inherent phase changes of \\texttt{milc}. On the other hand, \\textit{LLC store misses} is able to detect inherent phase changes for the \\texttt{milc} as shown in Figure \\ref{fig:milcllcastar} whereas the same type of PMU is unable to detect inherent phase changes of \\texttt{mcf} as shown in Figure \\ref{fig:mcfllcastar}. These results motivate us to need multiple types of PMU to capture phase changes across applications.'
p0
.I0
.S'Characteristics of good PMU indicators'
p0
.S'$s:Finding Representative Types of PMU for Phase Detection'
p0
.I5
.S'Brief intro'
p0
.S'$p: To capture a wide range of execution behavior across applications, we monitor a set of 6 different types of PMU, \\textit{CPI, L1-D cache load miss, L1-D cache load access, LLC store misses, LLC store access}, and \\textit{branch instructions}. We select eight training SPEC 2006 applications which are known to have varying phase changes. We investigate which types of event can capture phase changes for those eight applications. In this experiment, we used a quad-core machine and 3 instances of \\texttt{astar} as co-runners.\n'
p0
.I0
.S'$omit!PMU subset ordering table'
p0
.S'$t:\n\\begin{table*}[!ht]\n\\begin{footnotesize}\n\\resizebox{\\linewidth}{!}{%\n\\begin{tabular}{|l|llllll|}\n\\hline\n\\textbf{Application} & \\multicolumn{6}{l|}{\\textbf{Best PMU type}}                            \\\\ \\hline\nastar                & cpi & branch & L1-d load miss & LLC store miss & LLC loads & L-d loads \\\\ \\hline\n\\end{tabular}\n}\n\\caption{PMU types ordered by their effectiveness in detecting phase changes. }\n\\label{table:pmctype}\n\\end{footnotesize}\n\\end{table*}'
p0
.I0
.S'$omit!Best PMU type'
p0
.S'$t:\n\\begin{table*}[!ht]\n\\begin{footnotesize}\n\\resizebox{\\linewidth}{!}{%\n\\begin{tabular}{|l|l|l|l|l|l|l|l|l|}\n\\hline\n\\textbf{Application}   & astar & bzip2            & cactusADM      & dealII & mcf            & milc             & xalancbmk        & tonto          \\\\ \\cline{1-1}\n\\textbf{Best PMU type} & cpi   & LLC store misses & L1-d load miss & cpi    & L1-d load miss & LLC store misses & LLC store misses & L1-d load miss \\\\ \\hline\n\\end{tabular}\n}\n\\caption{Best PMU type for each of the training set of applications. }\n\\label{table:bestpmctype}\n\\end{footnotesize}\n\\end{table*}'
p0
.I0
.S'PMU ordering table'
p0
.S'$t:\n\\begin{table}[bt!]\n\\begin{footnotesize}\n\\begin{tabular}{|l|lll|}\n\\hline\n\\multicolumn{1}{|l|}{App.} & \\multicolumn{3}{|c|}{PMC Types} \\\\ \\hline\nastar & \\textbf{CPI} & branch & L1-d load miss  \\\\\nbzip2 & \\textbf{LLC store miss} & CPI & L1-d load miss  \\\\\ncactus.& \\textbf{L1-d load miss} & L1-d load & CPI  \\\\\ndealII & \\textbf{CPI} & L1-d load & branch  \\\\\nmcf & \\textbf{L1-d load miss} & CPI & LLC load \\\\\nmilc & \\textbf{LLC store miss} & L1-d load & branch\\\\\nxalan. & \\textbf{LLC store miss} & LLC load & L1-d load \\\\\ntonto & \\textbf{L1-d load miss} & branch & CPI  \\\\ \\hline\n\\end{tabular}\n\\caption{PMU types ordered by their effectiveness in detecting phase changes. }\n\\label{table:pmctype}\n\\end{footnotesize}\n\\end{table}'
p0
.I0
.S'Table explanation 2'
p0
.S'$p: We first identify the best type of PMU for each application individually. This is identified based on two criteria. Firstly, the best type of PMU should detect all inherent phase changes present in solo execution of the application. Secondly, it should minimize falsely detecting phase changes due to the interference from co-runners. In other words, among the six types of PMU, which can detect all inherent phases present in solo execution of the application, the best type of PMU is the one which has the lowest number of falsely detected phase changes. The reason behind this is that minimizing the number of falsely detecting phase changes will reduce the overheads of pausing the VMs unnecessarily. Based on the best type of PMU obtained for the training applications, we can select a subset of PMU types to detect phase changes. \n\n\nTable \\ref{table:pmctype} shows the preferred types of PMU for eight applications ordered by the effectiveness in which they are able to detect phase changes. Due to the space limit, the table shows only three types of PMU among six types. Based on this order, we can choose a common subset of PMU types which can detect phase changes effectively across the training set of applications. Using this method, we obtain three types of PMU, \\textit{CPI, LLC store miss} and \\textit{L1-d cache load miss}, to capture phase changes for the eight training SPEC applications.'
p0
.I0
.S'Spike elimination'
p0
.S'$s:Eliminating Spikes to Avoid False Phase Detection'
p0
.I7
.S'What is spike'
p0
.S'$p: \nWhile observing phase changes of the training applications, we notice that there are spikes in the reported PMU measurements. These spikes occasionally occur during a short interval of time and show significant variations in the execution behavior. \nIn such a case, our phase detection methodology should not treat spikes as phase changes. '
p0
.I0
.S'$fig:noise_elimination,1:'
p0
.S''
p0
.I0
.S'$pdf_fig:noise_elimination:Differentiating spikes and phase changes:1'
p0
.S''
p0
.I0
.S'$fig*:detect_phases,2:'
p0
.S''
p0
.I0
.S'$pdf_fig:detect_phases: Process of detecting phases\\vspace{-0.1in}:1'
p0
.S''
p0
.I0
.S'Solution - data structure'
p0
.S'$p: To distinguish between spikes and true phase changes, we employ a binary classification technique. We maintain a queue per each type of event. Each queue contains $k$ latest values that have been measured by a type of PMU. The value of $k$ is empirically determined by repeating experiments with different $k$ values and optimizing for value which is enough to differentiate phase changes and spikes. We know that whenever there is a phase change associated with an application, subsequent PMU measurements fall under a different range which corresponds to a completely new phase. On the other hand, whenever there is a spike, the PMU measurements show drastic changes for one or two values and the rest falling under the same range. In order to eliminate such drastic changes due to spikes, we declare a phase change only when a significant number of the values present in the queue belongs to a new range. In this way, we are able to eliminate incorrectly detecting phase changes due to spikes. '
p0
.I0
.S'Figure Explanation'
p0
.S'$p: Figure~\\ref{fig:noise_elimination} shows an example differentiating spikes and phase changes. During $T_{1}$ in Figure~\\ref{fig:noise_elimination}, the range of a significant number of elements changes to 3.0 compared to a previous phase which is around 1.0. In such a case, we consider this as a phase change where we take a \\textit{snapshot} of the new phase by pausing all co-runners. On the other hand, during $T_{2}$, the CPI of every element in the queue is closely around 3 except for one which is around 6.5. This change is considered as a spike and is not classified as a new phase. \n%The pictorial phase diagram gives a visual difference distinguishing phase changes and spikes. '
p0
.I0
.S'Detecting Phase changes'
p0
.S'$s: Detecting Phase Changes'
p0
.I2
.S'Motivation'
p0
.S'$p: In the previous sections, we discussed how to select three types of event to detect phase changes and how to eliminate spikes while detecting phase changes. In this section, we introduce how we can incorporate these two techniques to identify unintended performance degradation in public clouds.'
p0
.I0
.S'Figure explanation'
p0
.S'$p:Figure \\ref{fig:detect_phases} describes the process of the phase detection taking place in the Fair Pricing Runtime engine. Our runtime engine collects three types of events every second as shown in Figure \\ref{fig:detect_phases}(a). It inspects whether there is a significant change in the range of the measured events by comparing it to the corresponding PMU measurements at the most recent phase change. In this process, it also discards spikes associated with PMU measurements as shown in Figure \\ref{fig:detect_phases}(b). To avoid missing true phase changes, we use a conservative approach to call for a phase change even if one of the PMU types out of the three detects a phase change. If we do not detect true phase changes, it will significantly reduce the accuracy in estimating CPI of solo execution. On the other hand, mispredicting phase changes causes only negligible overhead if the frequency of such events is low. Once a new phase is detected, the runtime engine then pauses co-running VMs so as to estimate solo performance of the applications. In the example as shown in Figure \\ref{fig:detect_phases}(c), CPI:co-run, L1D:co-run and LLC:co-run indicate the PMU measurements for CPI, L1 d-cache load misses and LLC-store misses, respectively. From this figure, we are able to see that \\texttt{LLC store misses} is able to detect the phase changes present in the application whereas CPI and L1 d-cache are unable to detect phase changes in runtime.  '
p0
.I0
.S'Pricing for Fairness'
p0
.S'$s: Pricing for Fairness'
p0
.I9
.S'Algorithm'
p0
.S'$t:\n\\begin{algorithm}[!t]\n\\caption{Fair Pricing Runtime }\n\\label{alg:fpalgo}\n\\begin{algorithmic}\n\\begin{small}\n\\State $perfScoreVM_{i}$ = <CPI, LLC, L1D >\\;\\Comment{A queue of performance counters per VM}\n\\State $perfDegVM_{i}$ = <$VM_{1}$, ...., $VM_{n}$> \n%\\State $ perfDeg_{List} = < VM_{1}, ..., VM_{n} > $\n\\Comment{Performance degradation for each VM}\n\\State\n\\State /* \\textbf{Step 1:} Obtaining PMU measurements for all VMs */\n\\For{each $VM_{i}$ in $1$ ... $n$ }\n\\State $perfScoreVM_{i}$[CPI] <= gather\\_CPI($VM_{i}$) \n\\State $perfScoreVM_{i}$[LLC] <= gather\\_LLC\\_store\\_miss($VM_{i}$)\n\\State $perfScoreVM_{i}$[L1D] <= gather\\_L1d\\_cache\\_miss($VM_{i}$)\n\\EndFor \n\\State\n\\State /* \\textbf{Step 2:} Detecting phase changes by PMU types */\n\\For{each $VM_{i}$ in $1$ ... $n$}\n\\For{each $PMUtype_{j}$ in $1$ ... $m$}\n\\If{check\\_phase\\_change ($VM_{i}$[j]) == true}\n\\State pausing all co-running VMs except for itself;\n\\State $perfDegVM_{i}$ <= difference(gather\\_CPI($VM_{i}$) - $perfScoreVM_{i}$[CPI])\n\\State resuming all paused VMs\n\\EndIf\n\\EndFor \n\\EndFor \n\\State\n\\State /* \\textbf{Step 3:} Calculating price based on estimated degradation */\n\\For{each $VM_{i}$ in $1$ ... $n$}\n\\If{check\\_perfDeg\\_vm($VM_{i}$) == true}\n\\State reflect the unintended performance degradation in its bill\n\\EndIf\n\\EndFor \n\\end{small}\n\\end{algorithmic}\n\\end{algorithm}\n\\vspace{-0.15in}'
p0
.I1
.S'Algorithm for Phase change'
p0
.S''
p0
.I0
.S'Overview'
p0
.S'$p:In this section, we will see how we use the proposed \\textit{snapshot} technique for enabling fair pricing in public clouds. Pricing in public clouds is based on an hourly basis which could create a biased scenario in co-located environments. We need a mechanism to charge each user based on how individual applications perform when they were running alone. \n%This method would not be influenced by the nature of co-runner. '
p0
.I0
.S'$omit!Old Pricing Equation'
p0
.S'$p: With the help of \\textit{snapshot shuttering}, we are able to accurately estimate the performance degradation in co-located environments with a very low overhead. This can in turn be used to price individual users based on the amount by which they have been degraded. From the estimated degradation, the price to be paid by each user can be calculated by the following equation:- \n\\vspace{-0.05in}\n\\begin{equation} \\label{price}\nP_{i} = BasePrice + [ \\bar PerfDeg - PerfDeg_{i} ] \\times BasePrice\n\\vspace{-0.05in}\n\\end{equation}\nwhere,\\\\\n$P_{i}$ - price paid by user $i$, \\\\\n$PerfDeg_{i}$ - degradation suffered by user $i$ from equation \\ref{eq:degradation_equation},\\\\\n$\\bar PerfDeg$ - mean degradation suffered by all the users \n\n\nThe $BasePrice$ in this equation is the share of price which each user would pay without taking into account the performance degradation due to co-running applications. The second part of the equation ([$\\bar PerfDeg - PerfDeg_{i} ] \\times BasePrice$) is the factor by which a particular user has been discounted. This is due to the amount of degradation that the application has been subjected to due to its co-runners. '
p0
.I0
.S'Pricing Equation'
p0
.S'$p: With the help of \\textit{snapshot}, we are able to accurately estimate the performance degradation in co-located environments with a very low overhead. This can in turn be used to price individual users based on the amount of time by which they have been degraded. From the estimated performance degradation, the price of each user can be calculated by the following equation. \n\\vspace{-0.05in}\n\\begin{equation} \\label{price}\nP_{i} = BasePrice/PerfDeg_{i}\n\\vspace{-0.05in}\n\\end{equation}\n\n\\begin{itemize}\n\\item $P_{i}$: price paid by user $i$.\n\\vspace{-0.08in}\n\\item $PerfDeg_{i}$: degradation suffered by user $i$ from equation \\ref{eq:degradation_equation}.\n\\end{itemize}\n\n\nThe $BasePrice$ in this equation is the share of price which each user would pay without taking into account the performance degradation due to co-running applications. The division of the base price with $PerfDeg_{i}$ charges each user $i$ with a price proportional to the performance degradation. This is due to the amount of degradation that the application has been subjected to due to its co-runners. '
p0
.I0
.S'$sub_fig*:Accuracy:Accuracy of snapshot VS. shuttering in estimating performance degradation :accuracylibquantum,2:nl:accuracymcf,2:accuracymilc,2:!'
p0
.S''
p0
.I0
.S'Algorithm Description'
p0
.S'$p: Algorithm \\ref{alg:fpalgo} summarizes each step incurred by our Fair Pricing Runtime engine. The runtime consists of three functions. In step 1, it measures three types of PMUs every second for each VM. Step 2 of the algorithm tries to detect phase changes based on the PMU measurements. If there is a phase change, then it pauses all other co-running VMs to measure CPI of solo execution for the application. Finally, we can calculate the price by reflecting the estimated performance degradation on the equation.'
p0
.I0
.S'$graph:accuracylibquantum:co-running with 3 instances of \\texttt{libquantum} :1'
p0
.S'from collections import defaultdict\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nbenchListBaseline = [ \'gcc\', \'perlbench\', \'leslie3d\', \'povray\', \'libquantum\', \'astar\', \'bzip2\', \'milc\', \'namd\', \'calculix\', \'h264ref\', \'sphinx3\', \'zeusmp\', \'gobmk\', \'hmmer\', \'tonto\', \'bwaves\', \'gromacs\', \'dealII\', \'sjeng\', \'lbm\', \'xalancbmk\', \'gamess\', \'cactusADM\', \'soplex\', \'GemsFDTD\', \'omnetpp\', \'mcf\' ]\nbenchListExperiments = [ \'gcc\', \'perlbench\', \'leslie3d\', \'povray\', \'libquantum\', \'astar\', \'bzip2\', \'milc\', \'namd\', \'calculix\', \'h264ref\', \'sphinx3\', \'zeusmp\', \'gobmk\', \'hmmer\', \'tonto\', \'bwaves\', \'gromacs\', \'dealII\', \'sjeng\', \'lbm\', \'xalancbmk\', \'gamess\', \'cactusADM\', \'soplex\', \'GemsFDTD\', \'omnetpp\', \'mcf\' ]\ncolocationListBaseline = [ \'colocating with lbm\', \'colocating with povray\', \'colocating with astar\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with mcf\' ]\ncolocationListExperiments = [ \'colocating with lbm\', \'colocating with povray\', \'colocating with perlbench\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with mcf\' ]\nrunningList2 = [  \'perlbench\', \'colocating with libquantum\', \'mcf\', \'colocating with libquantum\', \'leslie3d\', \'colocating with libquantum\', \'povray\', \'colocating with libquantum\', \'libquantum\', \'colocating with libquantum\', \'astar\', \'colocating with libquantum\', \'bzip2\', \'colocating with libquantum\', \'milc\', \'colocating with libquantum\', \'namd\', \'colocating with libquantum\', \'calculix\', \'colocating with libquantum\', \'h264ref\', \'colocating with libquantum\', \'gobmk\', \'colocating with libquantum\', \'hmmer\', \'colocating with libquantum\', \'tonto\', \'colocating with libquantum\', \'sphinx3\', \'colocating with libquantum\', \'bwaves\', \'colocating with libquantum\', \'gromacs\', \'colocating with libquantum\', \'dealII\', \'colocating with libquantum\', \'sjeng\', \'colocating with libquantum\', \'lbm\', \'colocating with libquantum\', \'xalancbmk\', \'colocating with libquantum\', \'gamess\', \'colocating with libquantum\', \'cactusADM\', \'colocating with libquantum\', \'soplex\', \'colocating with libquantum\', \'GemsFDTD\', \'colocating with libquantum\', \'omnetpp\', \'colocating with libquantum\' ]\n\n\ndef autolabel(rects):\n    # attach some text labels\n    for rect in rects:\n        height = rect.get_height()\n        plt.text(rect.get_x()+rect.get_width()/2., 1.05*height, \'%.2f\'%float(height))\n\ndef autolabel2(rects):\n    # attach some text labels\n    for rect in rects:\n        height = rect.get_height()\n        plt.text(rect.get_x()+rect.get_width()/2., 1.05*height, \'%.2f\'%float(height))\n\nfilename = \'shutter_cpi_10\'\n\nfList3= [s.strip() for s in open(\'../../papergraphs/accuracy/libquantumcorunner/priorwork/shutter_cpi_5.txt\').readlines()]\n\nfList4 = [s.strip() for s in open(\'../../papergraphs/accuracy/libquantumcorunner/singlevm/shutter_cpi_1000.txt\').readlines()]\nfList5 = [s.strip() for s in open(\'../../papergraphs/accuracy/libquantumcorunner/degradation/shutter_cpi_1000.txt\').readlines()]\nfList6 = [s.strip() for s in open(\'../../papergraphs/accuracy/libquantumcorunner/snapshot2/%s.txt\' % filename).readlines()]\nfList7 = [s.strip() for s in open(\'../../papergraphs/accuracy/libquantumcorunner/degradation3/shutter_cpi_1000.txt\').readlines()]\n\n\ndictList_single_vm = defaultdict(list)\ndictList_degradation_colocation = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_colocation2 = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter2 = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter3 = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter4 = defaultdict(lambda  : defaultdict(list))\nplot_degradation = defaultdict(dict)\nplot_degradation2 = defaultdict(dict)\nplot_degradation_error = defaultdict(dict)\nplot_degradation_error2 = defaultdict(dict)\nplot_degradation_abs = defaultdict(dict)\nplot_degradation_abs2 = defaultdict(dict)\n\nfor (b,a) in enumerate(fList4):\n    if a in benchListBaseline:\n        dictList_single_vm[a].append(fList4[b+1])\n\n#SORTING LIST CONTAING VALUES OF SINGLE SPEC RUNS INSIDE VMs\nfor i in benchListBaseline:\n    dictList_single_vm[i].sort()\n    #print i,dictList_single_vm[i]\n\nfor (b,a) in enumerate(fList5):\n    #print a\n    if a in colocationListBaseline:\n       #print a\n       index = a\n    else:\n        if a in benchListExperiments:\n            #print a\n            dictList_degradation_colocation[index][a].append(fList5[b+1])\n\n#sorting the ground truth values\nfor a in xrange(0,len(runningList2),2):\n    j = runningList2[a+1]\n    i = runningList2[a]\n    dictList_degradation_colocation[j][i].sort()\n    #print j,i,dictList_degradation_colocation[j][i]\n\nfor (b,a) in enumerate(fList7):\n    #print a\n    if a in colocationListBaseline:\n       #print a\n       index = a\n    else:\n        if a in benchListExperiments:\n            print a\n            dictList_degradation_colocation2[index][a].append(fList7[b+1])\n\n#APPENDING DEGRADATION SHUTTER\nfor (b,a) in enumerate(fList6):\n    if a in colocationListExperiments:\n        index = a\n    else:\n        if a in benchListExperiments:\n            dictList_degradation_shutter[index][a].append(fList6[b+1])\n\nfor (b,a) in enumerate(fList3):\n    if a in colocationListExperiments:\n        index = a\n    else:\n        if a in benchListExperiments:\n            dictList_degradation_shutter3[index][a].append(fList3[b+1])\n\nfor a in xrange(0,len(runningList2),2):\n    j = runningList2[a+1]\n    i = runningList2[a]\n    #print i,j,dictList_degradation_shutter[j][i]\n#APPENDING DEGRADATION SHUTTER2 as shutter and colocation values are tab separated\nfor a in xrange(0,len(runningList2),2):\n    j = runningList2[a+1]\n    i = runningList2[a]\n    for elem in dictList_degradation_shutter[j][i]:\n        dictList_degradation_shutter2[j][i].extend(elem.strip().split(\'\\t\'))\n\n    for elem in dictList_degradation_shutter3[j][i]:\n        dictList_degradation_shutter4[j][i].extend(elem.strip().split(\'\\t\'))\n    #print dictList_degradation_shutter2[j][i]\n\nyaxis2 = ()\nyaxis3 = ()\nyaxis_abs2 = ()\nyaxis_abs3 = ()\nerror2 = ()\nerror3 = ()\nxaxis2 = ()\nfor a in xrange(0,len(runningList2),2):\n    j = runningList2[a+1]\n    i = runningList2[a]\n    #print i,j\n    #print dictList_single_vm[i]\n    #print dictList_degradation_colocation[j][i]\n    #print dictList_degradation_shutter2[j][i]\n    denominator1 = sum(float(n) for (m,n) in enumerate(dictList_single_vm[i]) if m!=0 and m!=len(dictList_single_vm[i])-1)/(len(dictList_single_vm[i])-2)\n    numerator1 = sum(float(n) for (m,n) in enumerate(dictList_degradation_colocation[j][i]))/(len(dictList_degradation_colocation[j][i]))\n    numerator10 = sum(float(n) for (m,n) in enumerate(dictList_degradation_colocation2[j][i]))/(len(dictList_degradation_colocation2[j][i]))\n    shutter_temp_list = []\n    shutter_temp_list2 = []\n    colo_temp_list = []\n    colo_temp_list2 = []\n    degradation_temp_list = []\n    degradation_temp_list2 = []\n    error_temp_list = []\n    error_temp_list2 = []\n    #print numerator1\n    #print denominator1\n    for (count,item) in enumerate(dictList_degradation_shutter2[j][i]):\n        if count%2==0:\n            colo_temp_list.append(item)\n        if count%2==1:\n            shutter_temp_list.append(item)\n\n    for (count,item) in enumerate(dictList_degradation_shutter4[j][i]):\n        if count%2==0:\n            colo_temp_list2.append(item)\n        if count%2==1:\n            shutter_temp_list2.append(item)\n\n    for (count,item) in enumerate(shutter_temp_list):\n        degradation_temp_list.append(abs((((float(shutter_temp_list[count])/float(colo_temp_list[count]))-(numerator1/denominator1))/(float(shutter_temp_list[count])/float(colo_temp_list[count])))*100))\n\n    shutter_temp_list.sort()\n    shutter_temp_list2.sort()\n    colo_temp_list.sort()\n    colo_temp_list2.sort()\n    #print shutter_temp_list\n    #print colo_temp_list\n    #print dictList_degradation_shutter2[j][i]\n    denominator2 = sum(float(n) for (m,n) in enumerate(shutter_temp_list) if m!=0 and m!=len(shutter_temp_list)-1 )/len(shutter_temp_list)\n    numerator2 = sum(float(n) for (m,n) in enumerate(colo_temp_list) if m!=0 and m!=len(colo_temp_list)-1  )/len(colo_temp_list)\n    for (m,n) in enumerate(shutter_temp_list):\n        ratio=float(n)/float(colo_temp_list[m])\n        error_temp_list.append(abs((((ratio)-(numerator10/denominator1))/(numerator10/denominator1))*100))\n    plot_degradation_error[j][i]=np.std(error_temp_list)\n\n    denominator3 = sum(float(n) for (m,n) in enumerate(shutter_temp_list2))/(len(shutter_temp_list2))\n    numerator3 = sum(float(n) for (m,n) in enumerate(colo_temp_list2))/(len(colo_temp_list2))\n    for (m,n) in enumerate(shutter_temp_list2):\n        ratio=float(n)/float(colo_temp_list2[m])\n        error_temp_list2.append(abs((((ratio)-(numerator3/denominator3))/(numerator1/denominator1))*100))\n    plot_degradation_error2[j][i]=np.std(error_temp_list2)\n\n    #print numerator2\n    #print denominator2\n    del shutter_temp_list\n    del colo_temp_list\n    del degradation_temp_list\n    del shutter_temp_list2\n    del colo_temp_list2\n    del degradation_temp_list2\n    plot_degradation[j][i] = (((numerator2/denominator2)-(numerator10/denominator1))/(numerator10/denominator1))*100\n    plot_degradation_abs[j][i] = abs((((numerator2/denominator2)-(numerator10/denominator1))/(numerator10/denominator1))*100)\n    plot_degradation2[j][i] = (((numerator3/denominator3)-(numerator1/denominator1))/(numerator1/denominator1))*100\n    plot_degradation_abs2[j][i] = abs((((numerator3/denominator3)-(numerator1/denominator1))/(numerator1/denominator1))*100)\n    #print j,i,plot_degradation[j][i]\n    #print plot_degradation_error[j][i]\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    xaxis2 = xaxis2 + (i,)\n    yaxis2 = yaxis2 + (plot_degradation[j][i],)\n    yaxis3 = yaxis3 + (plot_degradation2[j][i],)\n    yaxis_abs2 = yaxis_abs2 + (plot_degradation_abs[j][i],)\n    yaxis_abs3 = yaxis_abs3 + (plot_degradation_abs2[j][i],)\n    error2 = error2 + (plot_degradation_error[j][i],)\n    error3 = error3 + (plot_degradation_error2[j][i],)\n    #print numerator2,denominator2,numerator2/denominator2\n    #print denominator2/numerator2\n    #print j,i,plot_degradation[j][i]\n            #print (((numerator2/denominator2)-(numerator1/denominator1))/(numerator2/denominator2))*100\n#print np.mean(yaxis2)\n\n\nwidth=0.25\nx = np.arange(len(yaxis2))\nfig = plt.figure(figsize=(28, 5))\n#bar1 = plt.bar( x, yaxis, width, color="r", label=\'colocating with libquatum (avg = %.2f)\' %(np.mean(yaxis_abs)))\nbar1 = plt.bar( x, yaxis_abs3, width, color="k", yerr=error3, label=\'Shuttering (mean: %.2f)\' %(np.mean(yaxis_abs3)))\nbar2 = plt.bar( x+width, yaxis_abs2, width, color="lightgrey", yerr=error2, label=\'Snapshot (mean: %.2f)\' %(np.mean(yaxis_abs2)))\n#bar3 = plt.bar( x+width+width, yaxis3, width, color="g", label=\'colocating with sphinx  (avg = %.2f)\' %(np.mean(yaxis_abs3)))\n#autolabel(bar1)\n#autolabel(bar2)\nplt.ylabel( \'Estimation error (%)\' ,fontsize=\'25\')\n#plt.title(\'Error in predicting degradation when co-locating with libquantum\')\nplt.xticks(x + width/2.0, xaxis2, rotation=\'30\', size=\'23\',  ha=\'center\', va=\'top\')\n#plt.yticks((-0.5,0,1,2,3,4),(\'\',\'0\',\'1\',\'2\',\'3\',\'4\'),size=\'23\')\nplt.yticks((0,10,20,30,40,50),(\'0\',\'10\',\'20\',\'30\',\'40\',\' \'),size=\'25\')\nplt.ylim(0,50)\nplt.xlim(-1,26)\nplt.grid()\nplt.tight_layout()\nplt.legend(loc=9, ncol=2, prop={\'size\':28})\n#plt.savefig(\'%s_maybefinal_error.png\' %(filename), dpi=125)\n'
p0
.I0
.S'$graph:accuracymcf:co-running with 3 instances of \\texttt{mcf}:1'
p0
.S'from collections import defaultdict\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nbenchListBaseline = [ \'gcc\', \'perlbench\', \'leslie3d\', \'povray\', \'libquantum\', \'astar\', \'bzip2\', \'milc\', \'namd\', \'calculix\', \'h264ref\', \'sphinx3\', \'zeusmp\', \'gobmk\', \'hmmer\', \'tonto\', \'bwaves\', \'gromacs\', \'dealII\', \'sjeng\', \'lbm\', \'xalancbmk\', \'gamess\', \'cactusADM\', \'soplex\', \'GemsFDTD\', \'omnetpp\', \'mcf\' ]\nbenchListExperiments = [ \'gcc\', \'perlbench\', \'leslie3d\', \'povray\', \'libquantum\', \'astar\', \'bzip2\', \'milc\', \'namd\', \'calculix\', \'h264ref\', \'sphinx3\', \'zeusmp\', \'gobmk\', \'hmmer\', \'tonto\', \'bwaves\', \'gromacs\', \'dealII\', \'sjeng\', \'lbm\', \'xalancbmk\', \'gamess\', \'cactusADM\', \'soplex\', \'GemsFDTD\', \'omnetpp\', \'mcf\' ]\ncolocationListBaseline = [ \'colocating with lbm\', \'colocating with povray\', \'colocating with astar\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with mcf\' ]\ncolocationListExperiments = [ \'colocating with lbm\', \'colocating with povray\', \'colocating with perlbench\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with mcf\' ]\n\nrunningList2 = [  \'perlbench\', \'colocating with mcf\', \'mcf\', \'colocating with mcf\', \'leslie3d\', \'colocating with mcf\', \'povray\', \'colocating with mcf\', \'libquantum\', \'colocating with mcf\', \'astar\', \'colocating with mcf\', \'bzip2\', \'colocating with mcf\', \'milc\', \'colocating with mcf\', \'namd\', \'colocating with mcf\', \'calculix\', \'colocating with mcf\', \'h264ref\', \'colocating with mcf\', \'gobmk\', \'colocating with mcf\', \'hmmer\', \'colocating with mcf\', \'tonto\', \'colocating with mcf\', \'sphinx3\', \'colocating with mcf\', \'zeusmp\', \'colocating with mcf\', \'bwaves\', \'colocating with mcf\', \'gromacs\', \'colocating with mcf\', \'dealII\', \'colocating with mcf\', \'sjeng\', \'colocating with mcf\', \'lbm\', \'colocating with mcf\', \'xalancbmk\', \'colocating with mcf\', \'gamess\', \'colocating with mcf\', \'cactusADM\', \'colocating with mcf\', \'soplex\', \'colocating with mcf\', \'GemsFDTD\', \'colocating with mcf\', \'omnetpp\', \'colocating with mcf\' ]\n\ndef autolabel(rects):\n    # attach some text labels\n    for rect in rects:\n        height = rect.get_height()\n        plt.text(rect.get_x()+rect.get_width()/2., 1.05*height, \'%.2f\'%float(height))\n\ndef autolabel2(rects):\n    # attach some text labels\n    for rect in rects:\n        height = rect.get_height()\n        plt.text(rect.get_x()+rect.get_width()/2., 1.05*height, \'%.2f\'%float(height))\n\nfilename = \'shutter_cpi_70\'\n\nfList3= [s.strip() for s in open(\'../../papergraphs/accuracy/mcfcorunner/priorwork/shutter_cpi_5.txt\').readlines()]\n\nfList4 = [s.strip() for s in open(\'../../papergraphs/accuracy/mcfcorunner/singlevm/shutter_cpi_1000.txt\').readlines()]\nfList5 = [s.strip() for s in open(\'../../papergraphs/accuracy/mcfcorunner/degradation/shutter_cpi_1000.txt\').readlines()]\nfList6 = [s.strip() for s in open(\'../../papergraphs/accuracy/mcfcorunner/snapshot/%s.txt\' % filename).readlines()]\n\n\ndictList_single_vm = defaultdict(list)\ndictList_degradation_colocation = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter2 = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter3 = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter4 = defaultdict(lambda  : defaultdict(list))\nplot_degradation = defaultdict(dict)\nplot_degradation2 = defaultdict(dict)\nplot_degradation_error = defaultdict(dict)\nplot_degradation_error2 = defaultdict(dict)\nplot_degradation_abs = defaultdict(dict)\nplot_degradation_abs2 = defaultdict(dict)\n\nfor (b,a) in enumerate(fList4):\n    if a in benchListBaseline:\n        dictList_single_vm[a].append(fList4[b+1])\n\n#SORTING LIST CONTAING VALUES OF SINGLE SPEC RUNS INSIDE VMs\nfor i in benchListBaseline:\n    dictList_single_vm[i].sort()\n    #print i,dictList_single_vm[i]\n\nfor (b,a) in enumerate(fList5):\n    #print a\n    if a in colocationListBaseline:\n       #print a\n       index = a\n    else:\n        if a in benchListExperiments:\n            #print a\n            dictList_degradation_colocation[index][a].append(fList5[b+1])\n\n#sorting the ground truth values\nfor a in xrange(0,len(runningList2),2):\n    j = runningList2[a+1]\n    i = runningList2[a]\n    dictList_degradation_colocation[j][i].sort()\n    #print j,i,dictList_degradation_colocation[j][i]\n\n\n#APPENDING DEGRADATION SHUTTER\nfor (b,a) in enumerate(fList6):\n    if a in colocationListExperiments:\n        index = a\n    else:\n        if a in benchListExperiments:\n            dictList_degradation_shutter[index][a].append(fList6[b+1])\n\nfor (b,a) in enumerate(fList3):\n    if a in colocationListExperiments:\n        index = a\n    else:\n        if a in benchListExperiments:\n            dictList_degradation_shutter3[index][a].append(fList3[b+1])\n\nfor a in xrange(0,len(runningList2),2):\n    j = runningList2[a+1]\n    i = runningList2[a]\n    #print i,j,dictList_degradation_shutter[j][i]\n#APPENDING DEGRADATION SHUTTER2 as shutter and colocation values are tab separated\nfor a in xrange(0,len(runningList2),2):\n    j = runningList2[a+1]\n    i = runningList2[a]\n    for elem in dictList_degradation_shutter[j][i]:\n        dictList_degradation_shutter2[j][i].extend(elem.strip().split(\'\\t\'))\n\n    for elem in dictList_degradation_shutter3[j][i]:\n        dictList_degradation_shutter4[j][i].extend(elem.strip().split(\'\\t\'))\n    #print dictList_degradation_shutter2[j][i]\n\nyaxis2 = ()\nyaxis3 = ()\nyaxis_abs2 = ()\nyaxis_abs3 = ()\nerror2 = ()\nerror3 = ()\nxaxis2 = ()\nfor a in xrange(0,len(runningList2),2):\n    j = runningList2[a+1]\n    i = runningList2[a]\n    #print i,j\n    #print dictList_single_vm[i]\n    #print dictList_degradation_colocation[j][i]\n    #print dictList_degradation_shutter2[j][i]\n    denominator1 = sum(float(n) for (m,n) in enumerate(dictList_single_vm[i]) if m!=0 and m!=len(dictList_single_vm[i])-1)/(len(dictList_single_vm[i])-2)\n    numerator1 = sum(float(n) for (m,n) in enumerate(dictList_degradation_colocation[j][i]))/(len(dictList_degradation_colocation[j][i]))\n    shutter_temp_list = []\n    shutter_temp_list2 = []\n    colo_temp_list = []\n    colo_temp_list2 = []\n    degradation_temp_list = []\n    degradation_temp_list2 = []\n    error_temp_list = []\n    error_temp_list2 = []\n    #print numerator1\n    #print denominator1\n    for (count,item) in enumerate(dictList_degradation_shutter2[j][i]):\n        if count%2==0:\n            colo_temp_list.append(item)\n        if count%2==1:\n            shutter_temp_list.append(item)\n\n    for (count,item) in enumerate(dictList_degradation_shutter4[j][i]):\n        if count%2==0:\n            colo_temp_list2.append(item)\n        if count%2==1:\n            shutter_temp_list2.append(item)\n\n    for (count,item) in enumerate(shutter_temp_list):\n        degradation_temp_list.append(abs((((float(shutter_temp_list[count])/float(colo_temp_list[count]))-(numerator1/denominator1))/(float(shutter_temp_list[count])/float(colo_temp_list[count])))*100))\n\n    shutter_temp_list.sort()\n    shutter_temp_list2.sort()\n    colo_temp_list.sort()\n    colo_temp_list2.sort()\n    #print shutter_temp_list\n    #print colo_temp_list\n    #print dictList_degradation_shutter2[j][i]\n    denominator2 = sum(float(n) for (m,n) in enumerate(shutter_temp_list) if m!=0 and m!=len(shutter_temp_list)-1)/(len(shutter_temp_list)-2)\n    numerator2 = sum(float(n) for (m,n) in enumerate(colo_temp_list) if m!=0 and m!=len(colo_temp_list)-1)/(len(colo_temp_list)-2)\n    #denominator2 = sum(float(n) for (m,n) in enumerate(shutter_temp_list))/len(shutter_temp_list)\n    #numerator2 = sum(float(n) for (m,n) in enumerate(colo_temp_list))/len(colo_temp_list)\n    for (m,n) in enumerate(shutter_temp_list):\n        ratio=float(n)/float(colo_temp_list[m])\n        error_temp_list.append(abs((((ratio)-(numerator1/denominator1))/(numerator1/denominator1))*100))\n    plot_degradation_error[j][i]=np.std(error_temp_list)\n\n    denominator3 = sum(float(n) for (m,n) in enumerate(shutter_temp_list2))/(len(shutter_temp_list2))\n    numerator3 = sum(float(n) for (m,n) in enumerate(colo_temp_list2))/(len(colo_temp_list2))\n    for (m,n) in enumerate(shutter_temp_list2):\n        ratio=float(n)/float(colo_temp_list2[m])\n        error_temp_list2.append(abs((((ratio)-(numerator3/denominator3))/(numerator1/denominator1))*100))\n    plot_degradation_error2[j][i]=np.std(error_temp_list2)\n\n    #print numerator2\n    #print denominator2\n    del shutter_temp_list\n    del colo_temp_list\n    del degradation_temp_list\n    del shutter_temp_list2\n    del colo_temp_list2\n    del degradation_temp_list2\n    plot_degradation[j][i] = (((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100\n    plot_degradation_abs[j][i] = abs((((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100)\n    plot_degradation2[j][i] = (((numerator3/denominator3)-(numerator1/denominator1))/(numerator1/denominator1))*100\n    plot_degradation_abs2[j][i] = abs((((numerator3/denominator3)-(numerator1/denominator1))/(numerator1/denominator1))*100)\n    #print j,i,plot_degradation[j][i]\n    #print plot_degradation_error[j][i]\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    xaxis2 = xaxis2 + (i,)\n    yaxis2 = yaxis2 + (plot_degradation[j][i],)\n    yaxis3 = yaxis3 + (plot_degradation2[j][i],)\n    yaxis_abs2 = yaxis_abs2 + (plot_degradation_abs[j][i],)\n    yaxis_abs3 = yaxis_abs3 + (plot_degradation_abs2[j][i],)\n    error2 = error2 + (plot_degradation_error[j][i],)\n    error3 = error3 + (plot_degradation_error2[j][i],)\n\n\nwidth=0.25\nx = np.arange(len(yaxis2))\nfig = plt.figure(figsize=(28, 5))\n#bar1 = plt.bar( x, yaxis, width, color="r", label=\'colocating with libquatum (avg = %.2f)\' %(np.mean(yaxis_abs)))\nbar1 = plt.bar( x, yaxis_abs3, width, color="k", yerr=error3, label=\'Shuttering (mean: %.2f)\' %(np.mean(yaxis_abs3)))\nbar2 = plt.bar( x+width, yaxis_abs2, width, color="lightgrey", yerr=error2, label=\'Snapshot (mean: %.2f)\' %(np.mean(yaxis_abs2)))\n#bar3 = plt.bar( x+width+width, yaxis3, width, color="g", label=\'colocating with sphinx  (avg = %.2f)\' %(np.mean(yaxis_abs3)))\n#autolabel(bar1)\n#autolabel(bar2)\nplt.ylabel( \'Estimation error(%)\' ,fontsize=\'25\')\n#plt.title(\'Error in predicting degradation when co-locating with mcf\')\nplt.xticks(x + width/2.0, xaxis2, rotation=\'30\', size=\'23\',  ha=\'center\', va=\'top\')\nplt.yticks(np.arange(0,50,10),size=\'25\')\nplt.ylim(0,40)\nplt.xlim(-1,27)\nplt.grid()\nplt.tight_layout()\nplt.legend(loc=9, ncol=2, prop={\'size\':28})\n#plt.savefig(\'%s_maybefinal_error.png\' %(filename), dpi=125)\n'
p0
.I0
.S'$graph:accuracymilc:co-running with 3 instances of \\texttt{milc}:1'
p0
.S'from collections import defaultdict\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nbenchListBaseline = [ \'gcc\', \'perlbench\', \'leslie3d\', \'povray\', \'libquantum\', \'astar\', \'bzip2\', \'milc\', \'namd\', \'calculix\', \'h264ref\', \'sphinx3\', \'zeusmp\', \'gobmk\', \'hmmer\', \'tonto\', \'bwaves\', \'gromacs\', \'dealII\', \'sjeng\', \'lbm\', \'xalancbmk\', \'gamess\', \'cactusADM\', \'soplex\', \'GemsFDTD\', \'omnetpp\', \'mcf\' ]\nbenchListExperiments = [ \'gcc\', \'perlbench\', \'leslie3d\', \'povray\', \'libquantum\', \'astar\', \'bzip2\', \'milc\', \'namd\', \'calculix\', \'h264ref\', \'sphinx3\', \'zeusmp\', \'gobmk\', \'hmmer\', \'tonto\', \'bwaves\', \'gromacs\', \'dealII\', \'sjeng\', \'lbm\', \'xalancbmk\', \'gamess\', \'cactusADM\', \'soplex\', \'GemsFDTD\', \'omnetpp\', \'mcf\' ]\ncolocationListBaseline = [ \'colocating with lbm\', \'colocating with povray\', \'colocating with milc\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with mcf\' ]\ncolocationListExperiments = [ \'colocating with lbm\', \'colocating with povray\', \'colocating with milc\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with mcf\' ]\n\nrunningList2 = [  \'perlbench\', \'colocating with milc\', \'mcf\', \'colocating with milc\', \'leslie3d\', \'colocating with milc\', \'povray\', \'colocating with milc\', \'libquantum\', \'colocating with milc\', \'astar\', \'colocating with milc\', \'bzip2\', \'colocating with milc\', \'milc\', \'colocating with milc\', \'namd\', \'colocating with milc\', \'calculix\', \'colocating with milc\', \'h264ref\', \'colocating with milc\', \'gobmk\', \'colocating with milc\', \'hmmer\', \'colocating with milc\', \'tonto\', \'colocating with milc\', \'sphinx3\', \'colocating with milc\', \'zeusmp\', \'colocating with milc\', \'bwaves\', \'colocating with milc\', \'gromacs\', \'colocating with milc\', \'dealII\', \'colocating with milc\', \'sjeng\', \'colocating with milc\', \'lbm\', \'colocating with milc\', \'xalancbmk\', \'colocating with milc\', \'gamess\', \'colocating with milc\', \'cactusADM\', \'colocating with milc\', \'soplex\', \'colocating with milc\', \'GemsFDTD\', \'colocating with milc\', \'omnetpp\', \'colocating with milc\' ]\n\n\n\ndef autolabel(rects):\n    # attach some text labels\n    for rect in rects:\n        height = rect.get_height()\n        plt.text(rect.get_x()+rect.get_width()/2., 1.05*height, \'%.2f\'%float(height))\n\ndef autolabel2(rects):\n    # attach some text labels\n    for rect in rects:\n        height = rect.get_height()\n        plt.text(rect.get_x()+rect.get_width()/2., 1.05*height, \'%.2f\'%float(height))\n\nfilename = \'shutter_cpi_70\'\n#fList = [s.strip() for s in open(\'../../papergraphs/2.fullspec/accuracy/libquantumcorunner/single_vm_ground_truth/shutter_cpi_1000.txt\').readlines()]\n#fList2 = [s.strip() for s in open(\'../../papergraphs/2.fullspec/accuracy/libquantumcorunner/degradation_ground_truth/shutter_cpi_1000.txt\').readlines()]\n#fList3 = [s.strip() for s in open(\'../../papergraphs/2.fullspec/accuracy/libquantumcorunner/experiment_1/%s.txt\' % filename).readlines()]\nfList3= [s.strip() for s in open(\'../../papergraphs/accuracy/milccorunner/priorwork/shutter_cpi_5.txt\').readlines()]\n\nfList4 = [s.strip() for s in open(\'../../papergraphs/accuracy/milccorunner/singlevm/shutter_cpi_1000.txt\').readlines()]\nfList5 = [s.strip() for s in open(\'../../papergraphs/accuracy/milccorunner/degradation/shutter_cpi_1000.txt\').readlines()]\nfList6 = [s.strip() for s in open(\'../../papergraphs/accuracy/milccorunner/snapshot/%s.txt\' % filename).readlines()]\n\n\n\ndictList_single_vm = defaultdict(list)\ndictList_degradation_colocation = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter2 = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter3 = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter4 = defaultdict(lambda  : defaultdict(list))\nplot_degradation = defaultdict(dict)\nplot_degradation2 = defaultdict(dict)\nplot_degradation_error = defaultdict(dict)\nplot_degradation_error2 = defaultdict(dict)\nplot_degradation_abs = defaultdict(dict)\nplot_degradation_abs2 = defaultdict(dict)\n\nfor (b,a) in enumerate(fList4):\n    if a in benchListBaseline:\n        dictList_single_vm[a].append(fList4[b+1])\n\n#SORTING LIST CONTAING VALUES OF SINGLE SPEC RUNS INSIDE VMs\nfor i in benchListBaseline:\n    dictList_single_vm[i].sort()\n    #print i,dictList_single_vm[i]\n\nfor (b,a) in enumerate(fList5):\n    #print a\n    if a in colocationListBaseline:\n       #print a\n       index = a\n    else:\n        if a in benchListExperiments:\n            #print a\n            dictList_degradation_colocation[index][a].append(fList5[b+1])\n\n#sorting the ground truth values\nfor a in xrange(0,len(runningList2),2):\n    j = runningList2[a+1]\n    i = runningList2[a]\n    dictList_degradation_colocation[j][i].sort()\n    #print j,i,dictList_degradation_colocation[j][i]\n\n\n\n#APPENDING DEGRADATION SHUTTER\nfor (b,a) in enumerate(fList6):\n    if a in colocationListExperiments:\n        index = a\n    else:\n        if a in benchListExperiments:\n            dictList_degradation_shutter[index][a].append(fList6[b+1])\n\nfor (b,a) in enumerate(fList3):\n    if a in colocationListExperiments:\n        index = a\n    else:\n        if a in benchListExperiments:\n            dictList_degradation_shutter3[index][a].append(fList3[b+1])\n\nfor a in xrange(0,len(runningList2),2):\n    j = runningList2[a+1]\n    i = runningList2[a]\n    #print i,j,dictList_degradation_shutter[j][i]\n#APPENDING DEGRADATION SHUTTER2 as shutter and colocation values are tab separated\nfor a in xrange(0,len(runningList2),2):\n    j = runningList2[a+1]\n    i = runningList2[a]\n    for elem in dictList_degradation_shutter[j][i]:\n        dictList_degradation_shutter2[j][i].extend(elem.strip().split(\'\\t\'))\n\n    for elem in dictList_degradation_shutter3[j][i]:\n        dictList_degradation_shutter4[j][i].extend(elem.strip().split(\'\\t\'))\n    #print dictList_degradation_shutter2[j][i]\n\nyaxis2 = ()\nyaxis3 = ()\nyaxis_abs2 = ()\nyaxis_abs3 = ()\nerror2 = ()\nerror3 = ()\nxaxis2 = ()\nfor a in xrange(0,len(runningList2),2):\n    j = runningList2[a+1]\n    i = runningList2[a]\n    #print i,j\n    #print dictList_single_vm[i]\n    #print dictList_degradation_colocation[j][i]\n    #print dictList_degradation_shutter2[j][i]\n    denominator1 = sum(float(n) for (m,n) in enumerate(dictList_single_vm[i]) if m!=0 and m!=len(dictList_single_vm[i])-1)/(len(dictList_single_vm[i])-2)\n    numerator1 = sum(float(n) for (m,n) in enumerate(dictList_degradation_colocation[j][i]))/(len(dictList_degradation_colocation[j][i]))\n    shutter_temp_list = []\n    shutter_temp_list2 = []\n    colo_temp_list = []\n    colo_temp_list2 = []\n    degradation_temp_list = []\n    degradation_temp_list2 = []\n    error_temp_list = []\n    error_temp_list2 = []\n    #print numerator1\n    #print denominator1\n    for (count,item) in enumerate(dictList_degradation_shutter2[j][i]):\n        if count%2==0:\n            colo_temp_list.append(item)\n        if count%2==1:\n            shutter_temp_list.append(item)\n\n    for (count,item) in enumerate(dictList_degradation_shutter4[j][i]):\n        if count%2==0:\n            colo_temp_list2.append(item)\n        if count%2==1:\n            shutter_temp_list2.append(item)\n\n    for (count,item) in enumerate(shutter_temp_list):\n        degradation_temp_list.append(abs((((float(shutter_temp_list[count])/float(colo_temp_list[count]))-(numerator1/denominator1))/(float(shutter_temp_list[count])/float(colo_temp_list[count])))*100))\n\n    shutter_temp_list.sort()\n    shutter_temp_list2.sort()\n    colo_temp_list.sort()\n    colo_temp_list2.sort()\n    #print shutter_temp_list\n    #print colo_temp_list\n    #print dictList_degradation_shutter2[j][i]\n    denominator2 = sum(float(n) for (m,n) in enumerate(shutter_temp_list) if m!=0 and m!=len(shutter_temp_list)-1)/(len(shutter_temp_list)-2)\n    numerator2 = sum(float(n) for (m,n) in enumerate(colo_temp_list) if m!=0 and m!=len(colo_temp_list)-1)/(len(colo_temp_list)-2)\n    for (m,n) in enumerate(shutter_temp_list):\n        ratio=float(n)/float(colo_temp_list[m])\n        error_temp_list.append(abs((((ratio)-(numerator1/denominator1))/(numerator1/denominator1))*100))\n    plot_degradation_error[j][i]=np.std(error_temp_list)\n\n    denominator3 = sum(float(n) for (m,n) in enumerate(shutter_temp_list2))/(len(shutter_temp_list2))\n    numerator3 = sum(float(n) for (m,n) in enumerate(colo_temp_list2))/(len(colo_temp_list2))\n    for (m,n) in enumerate(shutter_temp_list2):\n        ratio=float(n)/float(colo_temp_list2[m])\n        error_temp_list2.append(abs((((ratio)-(numerator3/denominator3))/(numerator1/denominator1))*100))\n    plot_degradation_error2[j][i]=np.std(error_temp_list2)\n\n    #print numerator2\n    #print denominator2\n    del shutter_temp_list\n    del colo_temp_list\n    del degradation_temp_list\n    del shutter_temp_list2\n    del colo_temp_list2\n    del degradation_temp_list2\n    plot_degradation[j][i] = (((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100\n    plot_degradation_abs[j][i] = abs((((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100)\n    plot_degradation2[j][i] = (((numerator3/denominator3)-(numerator1/denominator1))/(numerator1/denominator1))*100\n    plot_degradation_abs2[j][i] = abs((((numerator3/denominator3)-(numerator1/denominator1))/(numerator1/denominator1))*100)\n    print j,i,plot_degradation[j][i]\n    #print plot_degradation_error[j][i]\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    xaxis2 = xaxis2 + (i,)\n    yaxis2 = yaxis2 + (plot_degradation[j][i],)\n    yaxis3 = yaxis3 + (plot_degradation2[j][i],)\n    yaxis_abs2 = yaxis_abs2 + (plot_degradation_abs[j][i],)\n    yaxis_abs3 = yaxis_abs3 + (plot_degradation_abs2[j][i],)\n    error2 = error2 + (plot_degradation_error[j][i],)\n    error3 = error3 + (plot_degradation_error2[j][i],)\n\n\nwidth=0.25\nx = np.arange(len(yaxis2))\nfig = plt.figure(figsize=(28, 5))\n#bar1 = plt.bar( x, yaxis, width, color="r", label=\'colocating with libquatum (avg = %.2f)\' %(np.mean(yaxis_abs)))\nbar1 = plt.bar( x, yaxis_abs3, width, color="k", yerr=error3, label=\'Shuttering (mean: %.2f)\' %(np.mean(yaxis_abs3)))\nbar2 = plt.bar( x+width, yaxis_abs2, width, color="lightgrey", yerr=error2, label=\'Snapshot (mean: %.2f)\' %(np.mean(yaxis_abs2)))\n\nplt.ylabel( \'Estimation error (%)\',fontsize=\'25\' )\n#plt.title(\'Error in predicting degradation when co-locating with milc\')\nplt.xticks(x + width/2.0, xaxis2, rotation=\'30\', size=\'23\',  ha=\'center\', va=\'top\')\nplt.yticks(np.arange(0,50,10),size=\'25\')\nplt.ylim(0,50)\nplt.xlim(-1,27)\nplt.grid()\nplt.tight_layout()\nplt.legend(loc=9, ncol=2, prop={\'size\':28})\n#plt.savefig(\'milc_accuracy.pdf\', dpi=125)\n'
p0
.I0
.S'Evaluation'
p0
.S'$s: Evaluation'
p0
.I3
.S'Overview'
p0
.S'$p: In this section, we evaluate the effectiveness of our \\textit{snapshot} technique. Firstly, we look into how the \\textit{snapshot} technique can achieve the high accuracy to estimate performance degradation for each VM in co-located environments. In addition, we examine how our phase detection mechanism effectively works capturing phase changes at runtime.  Secondly, we show the runtime overheads increasing execution time. In the experiments, we also compare our technique with the prior work and show that we achieve a high accuracy in estimating performance degradation with less overhead in most cases. '
p0
.I0
.S'Experimental setup'
p0
.S'$s:Experimental Setup'
p0
.I2
.S'Brief Architecture'
p0
.S'$p: We evaluate our Fair Pricing Runtime engine on a Intel Xeon E5-2407 v2 (4-cores). We use \\textit{SPEC 2006} with \\texttt{ref} inputs. \nTo mimic IaaS public clouds, we take advantage of Linux KVM as the hypervisor and run applications on virtual machines~\\cite{Qumranet2007}. In this evaluation, we leverage the hardware assisted virtual machine. Each virtual machine has 1 virtual CPU, 4GB main memory, and 16GB disk. We use Ubuntu 12.04 as guest operating systems with Linux kernel 3.11.0. We use the \\texttt{perf} tool to measure hardware events~\\cite{denew}. \n\nTable \\ref{table:parameters} shows the experimental parameters that we have taken into consideration while building the runtime system. \n'
p0
.I0
.S'Experimental parameters table'
p0
.S'$t:\n\\begin{table}[!ht]\n\\resizebox{8cm}{!} {\n\\begin{tabular}{|l|l|l|}\n\\hline\n\\textbf{Parameter}                                                       & \\textbf{\\begin{tabular}[c]{@{}l@{}} Shuttering\\end{tabular}} & \\textbf{\\begin{tabular}[c]{@{}l@{}}Snapshot\\end{tabular}}                                       \\\\ \\hline\n\\textbf{\\begin{tabular}[c]{@{}l@{}}Mesurement \\\\ frequency\\end{tabular}} & 200ms                                                                 & \\begin{tabular}[c]{@{}l@{}}1s (Checking phase changes is also \\\\ performed at the same frequency.)\\end{tabular} \\\\ \\hline\n\\textbf{Pausing time}                                                  & 3.2ms                                                                  & \\begin{tabular}[c]{@{}l@{}}75ms (measurementtime) \\\\ + 5ms (cache warm up time)\\end{tabular}                    \\\\ \\hline\n\\end{tabular}\n}\n\\caption{Parameters for the runtime engine}\n\\label{table:parameters}\n\\end{table}'
p0
.I0
.S'Evaluation'
p0
.S'$s: Experimental Results'
p0
.I5
.S'Note'
p0
.S'$t: In this section, we evaluate the effectiveness of \\textit{snapshot} in terms of accuracy and overhead.'
p0
.I0
.S'Accuracy'
p0
.S'$s:Accuracy of Fair Pricing Runtime Engine'
p0
.I16
.S'$sub_fig*:astarcompare:Phase level behavior of snapshot and shuttering for \\texttt{astar}:astarsnapshotlib,1:astarpriorlib,1:!t'
p0
.S''
p0
.I0
.S'$graph_fig:astarsnapshotlib:Snapshot (error 1.31\\%):0.92'
p0
.S"import matplotlib.pyplot as plt\nimport numpy as np\nfrom collections import defaultdict\n\nfilename = '5'\nf1 = [s.strip() for s in open('../../papergraphs/phases/phasedetection/single.txt').readlines()]\nf3 = [s.strip() for s in open('../../papergraphs/phases/phasedetection/shutter_phase_%s.txt' % filename).readlines()]\n\n\nbenchListBaseline = [ 'gcc', 'perlbench', 'mcf', 'leslie3d', 'povray', 'libquantum', 'astar', 'bzip2', 'milc', 'namd', 'calculix', 'h264ref', 'zeusmp', 'gobmk', 'hmmer', 'tonto', 'sphinx3', 'bwaves', 'gromacs', 'dealII', 'sjeng', 'lbm', 'xalancbmk', 'gamess', 'cactusADM', 'soplex', 'GemsFDTD', 'omnetpp' ]\nbenchListExperiments = [ 'gcc', 'perlbench', 'mcf', 'leslie3d', 'povray', 'libquantum', 'astar', 'bzip2', 'milc', 'namd', 'calculix', 'h264ref', 'zeusmp', 'gobmk', 'hmmer', 'tonto', 'sphinx3', 'bwaves', 'gromacs', 'dealII', 'sjeng', 'lbm', 'xalancbmk', 'gamess', 'cactusADM', 'soplex', 'GemsFDTD', 'omnetpp' ]\n#benchListExperiments = [ 'perlbench', 'astar', 'soplex', 'xalancbmk', 'omnetpp', 'bzip2','povray']\n#benchListExperiments = [ 'gcc', 'perlbench', 'astar', 'soplex', 'xalancbmk', 'omnetpp']\ncolocationListBaseline = [ 'colocating with mcf', 'colocating with povray', 'colocating with astar', 'colocating with astar', 'colocating with libquantum', 'colocating with povray', 'colocating with omnetpp', 'colocating with bzip2' ]\ncolocationListExperiments = [ 'colocating with mcf', 'colocating with povray', 'colocating with perlbench', 'colocating with astar', 'colocating with libquantum', 'colocating with povray', 'colocating with omnetpp', 'colocating with bzip2' ]\n\nrunningList = [ 'astar' ,'colocating with libquantum']\n\n\nphaseList_single = defaultdict(list)\nphaseList_degradation = defaultdict(lambda  : defaultdict(list))\nphaseList_shutter = defaultdict(lambda  : defaultdict(list))\nphaseList_colocation = defaultdict(lambda  : defaultdict(list))\n\n\nllc_miss_phaseList_single = defaultdict(list)\nllc_miss_phaseList_degradation = defaultdict(lambda  : defaultdict(list))\nllc_miss_phaseList_shutter = defaultdict(lambda  : defaultdict(list))\nllc_miss_phaseList_colocation = defaultdict(lambda  : defaultdict(list))\n\nfirstList1 = []\nsecondList1 = []\nthirdList1 = []\nfourthList1 = []\nfifthList1 = []\nsixthList1 = []\nseventhList1 = []\neighthList1 = []\n\nfor line in f1:\n    firstList1.append(line)\n\n#for line in f2:\n #   secondList1.append(line)\n\nfor line in f3:\n    thirdList1.append(line)\n\n\n\n#print sixthList1\n#print firstList1\nglobal index\nglobal index2\n\nfor (j,i) in enumerate(firstList1):\n    #print i\n    if i in benchListBaseline:\n        index = i\n    else:\n        phaseList_single[index].append(i.split())\n\n\n#for (j,i) in enumerate(fifthList1):\n#    if i in benchListExperiments:\n#        index = i\n#    else:\n#        llc_miss_phaseList_single[index].append(i.split())\n\n#print len(phaseList_single['gcc'])\n#print len(llc_miss_phaseList_single['gcc'])\n\nfor (j,i) in enumerate(secondList1):\n    if i in colocationListExperiments:\n        index2=i\n    elif i in benchListExperiments:\n        index=i\n    else:\n        phaseList_degradation[index2][index].append(i.split())\n\n\n#for (j,i) in enumerate(sixthList1):\n#    if i in colocationListExperiments:\n#        index2=i\n#    elif i in benchListExperiments:\n#        index=i\n#    else:\n#        llc_miss_phaseList_degradation[index2][index].append(i.split())\n\n#print len(phaseList_degradation['colocating with libquantum']['gcc'])\n#print len(llc_miss_phaseList_degradation['colocating with libquantum']['gcc'])\n\nfor (j,i) in enumerate(thirdList1):\n    if i in colocationListExperiments:\n        index2=i\n    elif i in benchListExperiments:\n        index=i\n    else:\n        phaseList_shutter[index2][index].append(i.split())\n\n\n#for (j,i) in enumerate(seventhList1):\n#    if i in colocationListExperiments:\n#        index2=i\n#    elif i in benchListExperiments:\n#        index=i\n#    else:\n#        llc_miss_phaseList_shutter[index2][index].append(i.split())\n#print len(phaseList_shutter['colocating with libquantum']['gcc'])\n#print len(llc_miss_phaseList_shutter['colocating with libquantum']['gcc'])\n\n#for (j,i) in enumerate(fourthList1):\n#    if i in colocationListExperiments:\n#        index2=i\n#    elif i in benchListExperiments:\n#        index=i\n#    else:\n#        phaseList_colocation[index2][index].append(i.split())\n\n\n#for (j,i) in enumerate(eighthList1):\n#    if i in colocationListExperiments:\n#        index2=i\n#    elif i in benchListExperiments:\n#        index=i\n#    else:\n#        llc_miss_phaseList_colocation[index2][index].append(i.split())\n\n#print len(phaseList_colocation['colocating with libquantum']['gcc'])\n#print len(llc_miss_phaseList_colocation['colocating with libquantum']['gcc'])\n##############place to get the lists to plot #############\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    print i\n    instruction_list1=[]\n    cpi_list1=[]\n    instruction_list2=[]\n    cpi_list2=[]\n    instruction_list3=[]\n    cpi_list3=[]\n    for (b,a) in enumerate(phaseList_shutter[j][i]):\n        if a[0][0] == '-':\n            break\n        else:\n            instruction_list1.append(float(a[1]))\n            cpi_list1.append(a[2])\n\n    for (b,a) in enumerate(phaseList_single[i]):\n        if a[0][0] == '-':\n            break\n        else:\n            instruction_list2.append(float(a[1])*1.12)\n            cpi_list2.append(a[2])\n\n    for (b,a) in enumerate(phaseList_degradation[j][i]):\n        if a[0][0] == '-':\n            break\n        else:\n            instruction_list3.append(float(a[1]))\n            cpi_list3.append(float(a[14])/10)\n\n    #print instruction_list\n    #print cpi_list\n\n    f, ax = plt.subplots(figsize=(12,5))\n    #ax.plot(instruction_list1,miss_list1, color='b', label='ground truth degradation when %s is colocating with %s' %(i,j[16:]))\n    #ax.plot(instruction_list2,cpi_list2, color='g',  label='phase L3 cache miss rate (per thousand cycles) of %s during when 3 corunners (%s) are running ' %(i,j[16:]))\n    #ax.plot(instruction_list2,miss_list2, color='c', label='ground truth L3 cache miss rate (per thousand cycles) of %s when colocating with %s  ' %(i,j[16:]))\n\n\n\n    ax.plot(instruction_list1,cpi_list1, color='r', label='astar w/ libquantum')\n    ax.plot(instruction_list2,cpi_list2, color='g',  label= 'astar w/o libquantum')\n    #ax.plot(instruction_list2,miss_list2, color='c', label='ground truth L3 cache miss rate (per thousand cycles) of %s running alone' %(i))\n    #ax.set_title('Phase of lone execution of %s VS phase of %s running with %s'%(i,i,j))\n    ax.set_xlabel('Executed instructions', fontsize=23)\n    ax.set_ylabel('CPI', fontsize=23)\n    #ax.set_ylabel('LLC store misses')\n    #ax.set_ylabel('L1 Dcache load misses')\n    ax.set_ylim(0.1,6)\n    ax.legend(loc=1,prop={'size':20})\n    #plt.savefig('%s_and_libquantum.pdf'%(i),bbox_inches='tight' ,dpi=200)\n    del instruction_list1\n    del cpi_list1\n"
p0
.I0
.S'$graph_fig:astarpriorlib:Shuttering (error 15.06\\%):0.92'
p0
.S"import matplotlib.pyplot as plt\nimport numpy as np\nfrom collections import defaultdict\n\nfilename = '5'\nf1 = [s.strip() for s in open('../../papergraphs/phases/phasedetection/single.txt').readlines()]\nf3 = [s.strip() for s in open('../../papergraphs/phases/phasedetection/shutter_phase_%s_prior.txt' % filename).readlines()]\n\n\nbenchListBaseline = [ 'gcc', 'perlbench', 'mcf', 'leslie3d', 'povray', 'libquantum', 'astar', 'bzip2', 'milc', 'namd', 'calculix', 'h264ref', 'zeusmp', 'gobmk', 'hmmer', 'tonto', 'sphinx3', 'bwaves', 'gromacs', 'dealII', 'sjeng', 'lbm', 'xalancbmk', 'gamess', 'cactusADM', 'soplex', 'GemsFDTD', 'omnetpp' ]\nbenchListExperiments = [ 'gcc', 'perlbench', 'mcf', 'leslie3d', 'povray', 'libquantum', 'astar', 'bzip2', 'milc', 'namd', 'calculix', 'h264ref', 'zeusmp', 'gobmk', 'hmmer', 'tonto', 'sphinx3', 'bwaves', 'gromacs', 'dealII', 'sjeng', 'lbm', 'xalancbmk', 'gamess', 'cactusADM', 'soplex', 'GemsFDTD', 'omnetpp' ]\n#benchListExperiments = [ 'perlbench', 'astar', 'soplex', 'xalancbmk', 'omnetpp', 'bzip2','povray']\n#benchListExperiments = [ 'gcc', 'perlbench', 'astar', 'soplex', 'xalancbmk', 'omnetpp']\ncolocationListBaseline = [ 'colocating with mcf', 'colocating with povray', 'colocating with astar', 'colocating with astar', 'colocating with libquantum', 'colocating with povray', 'colocating with omnetpp', 'colocating with bzip2' ]\ncolocationListExperiments = [ 'colocating with mcf', 'colocating with povray', 'colocating with perlbench', 'colocating with astar', 'colocating with libquantum', 'colocating with povray', 'colocating with omnetpp', 'colocating with bzip2' ]\n\nrunningList = [ 'astar' ,'colocating with libquantum']\n\n\nphaseList_single = defaultdict(list)\nphaseList_degradation = defaultdict(lambda  : defaultdict(list))\nphaseList_shutter = defaultdict(lambda  : defaultdict(list))\nphaseList_colocation = defaultdict(lambda  : defaultdict(list))\n\n\nllc_miss_phaseList_single = defaultdict(list)\nllc_miss_phaseList_degradation = defaultdict(lambda  : defaultdict(list))\nllc_miss_phaseList_shutter = defaultdict(lambda  : defaultdict(list))\nllc_miss_phaseList_colocation = defaultdict(lambda  : defaultdict(list))\n\nfirstList1 = []\nsecondList1 = []\nthirdList1 = []\nfourthList1 = []\nfifthList1 = []\nsixthList1 = []\nseventhList1 = []\neighthList1 = []\n\nfor line in f1:\n    firstList1.append(line)\n\n#for line in f2:\n #   secondList1.append(line)\n\nfor line in f3:\n    thirdList1.append(line)\n\n\n\n#print sixthList1\n#print firstList1\nglobal index\nglobal index2\n\nfor (j,i) in enumerate(firstList1):\n    #print i\n    if i in benchListBaseline:\n        index = i\n    else:\n        phaseList_single[index].append(i.split())\n\n\n#for (j,i) in enumerate(fifthList1):\n#    if i in benchListExperiments:\n#        index = i\n#    else:\n#        llc_miss_phaseList_single[index].append(i.split())\n\n#print len(phaseList_single['gcc'])\n#print len(llc_miss_phaseList_single['gcc'])\n\nfor (j,i) in enumerate(secondList1):\n    if i in colocationListExperiments:\n        index2=i\n    elif i in benchListExperiments:\n        index=i\n    else:\n        phaseList_degradation[index2][index].append(i.split())\n\n\n#for (j,i) in enumerate(sixthList1):\n#    if i in colocationListExperiments:\n#        index2=i\n#    elif i in benchListExperiments:\n#        index=i\n#    else:\n#        llc_miss_phaseList_degradation[index2][index].append(i.split())\n\n#print len(phaseList_degradation['colocating with libquantum']['gcc'])\n#print len(llc_miss_phaseList_degradation['colocating with libquantum']['gcc'])\n\nfor (j,i) in enumerate(thirdList1):\n    if i in colocationListExperiments:\n        index2=i\n    elif i in benchListExperiments:\n        index=i\n    else:\n        phaseList_shutter[index2][index].append(i.split())\n\n\n#for (j,i) in enumerate(seventhList1):\n#    if i in colocationListExperiments:\n#        index2=i\n#    elif i in benchListExperiments:\n#        index=i\n#    else:\n#        llc_miss_phaseList_shutter[index2][index].append(i.split())\n#print len(phaseList_shutter['colocating with libquantum']['gcc'])\n#print len(llc_miss_phaseList_shutter['colocating with libquantum']['gcc'])\n\n#for (j,i) in enumerate(fourthList1):\n#    if i in colocationListExperiments:\n#        index2=i\n#    elif i in benchListExperiments:\n#        index=i\n#    else:\n#        phaseList_colocation[index2][index].append(i.split())\n\n\n#for (j,i) in enumerate(eighthList1):\n#    if i in colocationListExperiments:\n#        index2=i\n#    elif i in benchListExperiments:\n#        index=i\n#    else:\n#        llc_miss_phaseList_colocation[index2][index].append(i.split())\n\n#print len(phaseList_colocation['colocating with libquantum']['gcc'])\n#print len(llc_miss_phaseList_colocation['colocating with libquantum']['gcc'])\n##############place to get the lists to plot #############\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    print i\n    instruction_list1=[]\n    cpi_list1=[]\n    instruction_list2=[]\n    cpi_list2=[]\n    instruction_list3=[]\n    cpi_list3=[]\n    for (b,a) in enumerate(phaseList_shutter[j][i]):\n        if a[0][0] == '-':\n            break\n        else:\n            instruction_list1.append(float(a[1]))\n            cpi_list1.append(a[2])\n\n    for (b,a) in enumerate(phaseList_single[i]):\n        if a[0][0] == '-':\n            break\n        else:\n            instruction_list2.append(float(a[1])*1.2)\n            cpi_list2.append(a[2])\n\n    for (b,a) in enumerate(phaseList_degradation[j][i]):\n        if a[0][0] == '-':\n            break\n        else:\n            instruction_list3.append(float(a[1]))\n            cpi_list3.append(float(a[14])/10)\n\n    #print instruction_list\n    #print cpi_list\n\n    f, ax = plt.subplots(figsize=(12,5))\n    #ax.plot(instruction_list1,miss_list1, color='b', label='ground truth degradation when %s is colocating with %s' %(i,j[16:]))\n    #ax.plot(instruction_list2,cpi_list2, color='g',  label='phase L3 cache miss rate (per thousand cycles) of %s during when 3 corunners (%s) are running ' %(i,j[16:]))\n    #ax.plot(instruction_list2,miss_list2, color='c', label='ground truth L3 cache miss rate (per thousand cycles) of %s when colocating with %s  ' %(i,j[16:]))\n\n\n\n    ax.plot(instruction_list1,cpi_list1, color='r', label='astar w/ libquantum')\n    ax.plot(instruction_list2,cpi_list2, color='g',  label= 'astar w/o libquantum')\n    #ax.plot(instruction_list2,miss_list2, color='c', label='ground truth L3 cache miss rate (per thousand cycles) of %s running alone' %(i))\n    #ax.set_title('Phase of lone execution of %s VS phase of %s running with %s'%(i,i,j))\n    ax.set_xlabel('Executed instructions', fontsize=23)\n    ax.set_ylabel('CPI', fontsize=23)\n    #ax.set_ylabel('LLC store misses')\n    #ax.set_ylabel('L1 Dcache load misses')\n    ax.set_ylim(0.1,6)\n    ax.legend(loc=1,prop={'size':20})\n    #plt.savefig('%s_and_libquantum.pdf'%(i),bbox_inches='tight' ,dpi=200)\n    del instruction_list1\n    del cpi_list1\n"
p0
.I0
.S'$sub_fig*:mcfphase:Phase detection by snapshot for \\texttt{mcf} and \\texttt{milc} when running with 3 \\texttt{libquantum} co-runners  :mcfsnapshotlib,1:milcsnapshotlib,1:mcfsnapshotmcf,1:milcsnapshotmcf,1'
p0
.S''
p0
.I0
.S'$graph_fig:mcfsnapshotlib:\\texttt{mcf} (error 0.51\\%):0.92'
p0
.S"import matplotlib.pyplot as plt\nimport numpy as np\nfrom collections import defaultdict\n\nfilename = '5'\nf1 = [s.strip() for s in open('../../papergraphs/phases/phasedetection/single.txt').readlines()]\n#f2 = [s.strip() for s in open('degradation2/colocation_phase_5.txt').readlines()]\n#f2 = [s.strip() for s in open('../../papergraphs/phases/phasedetection/degradation.txt').readlines()]\nf3 = [s.strip() for s in open('../../papergraphs/phases/phasedetection/shutter_phase_%s.txt' % filename).readlines()]\n#f4 = [s.strip() for s in open('colocation_phase_%s.txt' % filename).readlines()]\n\n\nbenchListBaseline = [ 'gcc', 'perlbench', 'mcf', 'leslie3d', 'povray', 'libquantum', 'astar', 'bzip2', 'milc', 'namd', 'calculix', 'h264ref', 'zeusmp', 'gobmk', 'hmmer', 'tonto', 'sphinx3', 'bwaves', 'gromacs', 'dealII', 'sjeng', 'lbm', 'xalancbmk', 'gamess', 'cactusADM', 'soplex', 'GemsFDTD', 'omnetpp' ]\nbenchListExperiments = [ 'gcc', 'perlbench', 'mcf', 'leslie3d', 'povray', 'libquantum', 'astar', 'bzip2', 'milc', 'namd', 'calculix', 'h264ref', 'zeusmp', 'gobmk', 'hmmer', 'tonto', 'sphinx3', 'bwaves', 'gromacs', 'dealII', 'sjeng', 'lbm', 'xalancbmk', 'gamess', 'cactusADM', 'soplex', 'GemsFDTD', 'omnetpp' ]\n#benchListExperiments = [ 'perlbench', 'astar', 'soplex', 'xalancbmk', 'omnetpp', 'bzip2','povray']\n#benchListExperiments = [ 'gcc', 'perlbench', 'astar', 'soplex', 'xalancbmk', 'omnetpp']\ncolocationListBaseline = [ 'colocating with mcf', 'colocating with povray', 'colocating with astar', 'colocating with astar', 'colocating with libquantum', 'colocating with povray', 'colocating with omnetpp', 'colocating with bzip2' ]\ncolocationListExperiments = [ 'colocating with mcf', 'colocating with povray', 'colocating with perlbench', 'colocating with astar', 'colocating with libquantum', 'colocating with povray', 'colocating with omnetpp', 'colocating with bzip2' ]\n\nrunningList = [ 'mcf' ,'colocating with libquantum']\n\n\nphaseList_single = defaultdict(list)\nphaseList_degradation = defaultdict(lambda  : defaultdict(list))\nphaseList_shutter = defaultdict(lambda  : defaultdict(list))\nphaseList_colocation = defaultdict(lambda  : defaultdict(list))\n\n\nllc_miss_phaseList_single = defaultdict(list)\nllc_miss_phaseList_degradation = defaultdict(lambda  : defaultdict(list))\nllc_miss_phaseList_shutter = defaultdict(lambda  : defaultdict(list))\nllc_miss_phaseList_colocation = defaultdict(lambda  : defaultdict(list))\n\nfirstList1 = []\nsecondList1 = []\nthirdList1 = []\nfourthList1 = []\nfifthList1 = []\nsixthList1 = []\nseventhList1 = []\neighthList1 = []\n\nfor line in f1:\n    firstList1.append(line)\n\n#for line in f2:\n #   secondList1.append(line)\n\nfor line in f3:\n    thirdList1.append(line)\n\n\n\n#print sixthList1\n#print firstList1\nglobal index\nglobal index2\n\nfor (j,i) in enumerate(firstList1):\n    #print i\n    if i in benchListBaseline:\n        index = i\n    else:\n        phaseList_single[index].append(i.split())\n\n\nfor (j,i) in enumerate(secondList1):\n    if i in colocationListExperiments:\n        index2=i\n    elif i in benchListExperiments:\n        index=i\n    else:\n        phaseList_degradation[index2][index].append(i.split())\n\n\n\n\nfor (j,i) in enumerate(thirdList1):\n    if i in colocationListExperiments:\n        index2=i\n    elif i in benchListExperiments:\n        index=i\n    else:\n        phaseList_shutter[index2][index].append(i.split())\n\n#print len(phaseList_colocation['colocating with libquantum']['gcc'])\n#print len(llc_miss_phaseList_colocation['colocating with libquantum']['gcc'])\n##############place to get the lists to plot #############\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    print i\n    instruction_list1=[]\n    cpi_list1=[]\n    instruction_list2=[]\n    cpi_list2=[]\n    instruction_list3=[]\n    cpi_list3=[]\n    for (b,a) in enumerate(phaseList_shutter[j][i]):\n        if a[0][0] == '-':\n            break\n        else:\n            instruction_list1.append(float(a[1]))\n            cpi_list1.append(a[2])\n\n    for (b,a) in enumerate(phaseList_single[i]):\n        if a[0][0] == '-':\n            break\n        else:\n            instruction_list2.append(float(a[1])*1.6)\n            cpi_list2.append(a[2])\n\n    for (b,a) in enumerate(phaseList_degradation[j][i]):\n        if a[0][0] == '-':\n            break\n        else:\n            instruction_list3.append(float(a[1]))\n            cpi_list3.append(float(a[14])/10)\n\n    #print instruction_list\n    #print cpi_list\n\n    f, ax = plt.subplots(figsize=(12,5))\n  \n    ax.plot(instruction_list1,cpi_list1, color='r', label='mcf w/ libquantum')\n    ax.plot(instruction_list2,cpi_list2, color='g',  label= 'mcf w/o libquantum')\n    #ax.plot(instruction_list2,miss_list2, color='c', label='ground truth L3 cache miss rate (per thousand cycles) of %s running alone' %(i))\n    #ax.set_title('Phase of lone execution of %s VS phase of %s running with %s'%(i,i,j))\n    ax.set_xlabel('Executed instructions', fontsize=23)\n    ax.set_ylabel('CPI', fontsize=23)\n    #ax.set_ylabel('LLC store misses')\n    #ax.set_ylabel('L1 Dcache load misses')\n    ax.set_ylim(0.5,6.5)\n    ax.legend(loc=1,prop={'size':20})\n    #plt.savefig('%s_and_libquantum.pdf'%(i),bbox_inches='tight' ,dpi=200)\n    del instruction_list1\n    del cpi_list1\n"
p0
.I0
.S'$graph_fig:milcsnapshotlib:\\texttt{milc} (error 1.23\\%):0.92'
p0
.S"import matplotlib.pyplot as plt\nimport numpy as np\nfrom collections import defaultdict\n\nfilename = '5'\nf1 = [s.strip() for s in open('../../papergraphs/phases/phasedetection/single.txt').readlines()]\n#f2 = [s.strip() for s in open('degradation2/colocation_phase_5.txt').readlines()]\n#f2 = [s.strip() for s in open('../../papergraphs/phases/phasedetection/degradation.txt').readlines()]\nf3 = [s.strip() for s in open('../../papergraphs/phases/phasedetection/shutter_phase_%s.txt' % filename).readlines()]\n#f4 = [s.strip() for s in open('colocation_phase_%s.txt' % filename).readlines()]\n\n\nbenchListBaseline = [ 'gcc', 'perlbench', 'mcf', 'leslie3d', 'povray', 'libquantum', 'astar', 'bzip2', 'milc', 'namd', 'calculix', 'h264ref', 'zeusmp', 'gobmk', 'hmmer', 'tonto', 'sphinx3', 'bwaves', 'gromacs', 'dealII', 'sjeng', 'lbm', 'xalancbmk', 'gamess', 'cactusADM', 'soplex', 'GemsFDTD', 'omnetpp' ]\nbenchListExperiments = [ 'gcc', 'perlbench', 'mcf', 'leslie3d', 'povray', 'libquantum', 'astar', 'bzip2', 'milc', 'namd', 'calculix', 'h264ref', 'zeusmp', 'gobmk', 'hmmer', 'tonto', 'sphinx3', 'bwaves', 'gromacs', 'dealII', 'sjeng', 'lbm', 'xalancbmk', 'gamess', 'cactusADM', 'soplex', 'GemsFDTD', 'omnetpp' ]\n#benchListExperiments = [ 'perlbench', 'astar', 'soplex', 'xalancbmk', 'omnetpp', 'bzip2','povray']\n#benchListExperiments = [ 'gcc', 'perlbench', 'astar', 'soplex', 'xalancbmk', 'omnetpp']\ncolocationListBaseline = [ 'colocating with mcf', 'colocating with povray', 'colocating with astar', 'colocating with astar', 'colocating with libquantum', 'colocating with povray', 'colocating with omnetpp', 'colocating with bzip2' ]\ncolocationListExperiments = [ 'colocating with mcf', 'colocating with povray', 'colocating with perlbench', 'colocating with astar', 'colocating with libquantum', 'colocating with povray', 'colocating with omnetpp', 'colocating with bzip2' ]\n\nrunningList = [ 'milc' ,'colocating with libquantum']\n\n\nphaseList_single = defaultdict(list)\nphaseList_degradation = defaultdict(lambda  : defaultdict(list))\nphaseList_shutter = defaultdict(lambda  : defaultdict(list))\nphaseList_colocation = defaultdict(lambda  : defaultdict(list))\n\n\nllc_miss_phaseList_single = defaultdict(list)\nllc_miss_phaseList_degradation = defaultdict(lambda  : defaultdict(list))\nllc_miss_phaseList_shutter = defaultdict(lambda  : defaultdict(list))\nllc_miss_phaseList_colocation = defaultdict(lambda  : defaultdict(list))\n\nfirstList1 = []\nsecondList1 = []\nthirdList1 = []\nfourthList1 = []\nfifthList1 = []\nsixthList1 = []\nseventhList1 = []\neighthList1 = []\n\nfor line in f1:\n    firstList1.append(line)\n\nfor line in f3:\n    thirdList1.append(line)\n\n\nglobal index\nglobal index2\n\nfor (j,i) in enumerate(firstList1):\n    #print i\n    if i in benchListBaseline:\n        index = i\n    else:\n        phaseList_single[index].append(i.split())\n\n\n\nfor (j,i) in enumerate(secondList1):\n    if i in colocationListExperiments:\n        index2=i\n    elif i in benchListExperiments:\n        index=i\n    else:\n        phaseList_degradation[index2][index].append(i.split())\n\n\n#for (j,i) in enumerate(sixthList1):\n#    if i in colocationListExperiments:\n#        index2=i\n#    elif i in benchListExperiments:\n#        index=i\n#    else:\n#        llc_miss_phaseList_degradation[index2][index].append(i.split())\n\n#print len(phaseList_degradation['colocating with libquantum']['gcc'])\n#print len(llc_miss_phaseList_degradation['colocating with libquantum']['gcc'])\n\nfor (j,i) in enumerate(thirdList1):\n    if i in colocationListExperiments:\n        index2=i\n    elif i in benchListExperiments:\n        index=i\n    else:\n        phaseList_shutter[index2][index].append(i.split())\n\n\n#for (j,i) in enumerate(seventhList1):\n#    if i in colocationListExperiments:\n#        index2=i\n#    elif i in benchListExperiments:\n#        index=i\n#    else:\n#        llc_miss_phaseList_shutter[index2][index].append(i.split())\n#print len(phaseList_shutter['colocating with libquantum']['gcc'])\n#print len(llc_miss_phaseList_shutter['colocating with libquantum']['gcc'])\n\n#for (j,i) in enumerate(fourthList1):\n#    if i in colocationListExperiments:\n#        index2=i\n#    elif i in benchListExperiments:\n#        index=i\n#    else:\n#        phaseList_colocation[index2][index].append(i.split())\n\n\n#for (j,i) in enumerate(eighthList1):\n#    if i in colocationListExperiments:\n#        index2=i\n#    elif i in benchListExperiments:\n#        index=i\n#    else:\n#        llc_miss_phaseList_colocation[index2][index].append(i.split())\n\n#print len(phaseList_colocation['colocating with libquantum']['gcc'])\n#print len(llc_miss_phaseList_colocation['colocating with libquantum']['gcc'])\n##############place to get the lists to plot #############\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    print i\n    instruction_list1=[]\n    cpi_list1=[]\n    instruction_list2=[]\n    cpi_list2=[]\n    instruction_list3=[]\n    cpi_list3=[]\n    for (b,a) in enumerate(phaseList_shutter[j][i]):\n        if a[0][0] == '-':\n            break\n        else:\n            instruction_list1.append(float(a[1]))\n            cpi_list1.append(a[2])\n\n    for (b,a) in enumerate(phaseList_single[i]):\n        if a[0][0] == '-':\n            break\n        else:\n            instruction_list2.append(float(a[1])*1.3)\n            cpi_list2.append(a[2])\n\n    for (b,a) in enumerate(phaseList_degradation[j][i]):\n        if a[0][0] == '-':\n            break\n        else:\n            instruction_list3.append(float(a[1]))\n            cpi_list3.append(float(a[14])/10)\n\n    #print instruction_list\n    #print cpi_list\n\n    f, ax = plt.subplots(figsize=(12,5))\n    #ax.plot(instruction_list1,miss_list1, color='b', label='ground truth degradation when %s is colocating with %s' %(i,j[16:]))\n    #ax.plot(instruction_list2,cpi_list2, color='g',  label='phase L3 cache miss rate (per thousand cycles) of %s during when 3 corunners (%s) are running ' %(i,j[16:]))\n    #ax.plot(instruction_list2,miss_list2, color='c', label='ground truth L3 cache miss rate (per thousand cycles) of %s when colocating with %s  ' %(i,j[16:]))\n\n\n\n    ax.plot(instruction_list1,cpi_list1, color='r', label='milc w/ libquantum')\n    ax.plot(instruction_list2,cpi_list2, color='g',  label= 'milc w/o libquantum')\n    #ax.plot(instruction_list2,miss_list2, color='c', label='ground truth L3 cache miss rate (per thousand cycles) of %s running alone' %(i))\n    #ax.set_title('Phase of lone execution of %s VS phase of %s running with %s'%(i,i,j))\n    ax.set_xlabel('Executed instructions', fontsize=23)\n    ax.set_ylabel('CPI', fontsize=23)\n    #ax.set_ylabel('LLC store misses')\n    #ax.set_ylabel('L1 Dcache load misses')\n    ax.set_ylim(0.3,3)\n    ax.legend(loc=1,prop={'size':20})\n    #plt.savefig('%s_and_libquantum.pdf'%(i),bbox_inches='tight' ,dpi=200)\n    del instruction_list1\n    del cpi_list1\n"
p0
.I0
.S'$graph_fig:mcfsnapshotmcf:mcf (error 3.41\\%):0.92'
p0
.S''
p0
.I0
.S'$graph_fig:milcsnapshotmcf:milc (error 2.52\\%):0.92'
p0
.S''
p0
.I0
.S'$sub_fig*:Overhead:Overheads of snapshot VS. shuttering while estimating performance degradation :overheadlibquantum,2:nl:overheadmcf,2:overheadmilc,2:!'
p0
.S''
p0
.I0
.S'$graph:overheadlibquantum:co-running with 3 instances of \\texttt{libquantum}:1'
p0
.S'from collections import defaultdict\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\n\nbenchList = [ \'gcc\', \'perlbench\', \'leslie3d\', \'povray\', \'libquantum\', \'astar\', \'bzip2\', \'milc\', \'namd\', \'calculix\', \'h264ref\', \'sphinx3\', \'zeusmp\', \'gobmk\', \'hmmer\', \'tonto\', \'bwaves\', \'gromacs\', \'dealII\', \'sjeng\', \'lbm\', \'xalancbmk\', \'gamess\', \'soplex\', \'GemsFDTD\', \'omnetpp\', \'mcf\', \'cactusADM\' ]\n\ncolocationList = [ \'colocating with libquantum\', \'colocating with mcf\',  \'colocating with sphinx3\']\ncolocationListBaseline = [ \'colocating with libquantum\', \'colocating with mcf\', \'colocating with sphinx3\' ]\n\n\nrunningList = [  \'perlbench\', \'colocating with libquantum\', \'mcf\', \'colocating with libquantum\', \'leslie3d\', \'colocating with libquantum\', \'povray\', \'colocating with libquantum\', \'libquantum\', \'colocating with libquantum\', \'astar\', \'colocating with libquantum\', \'bzip2\', \'colocating with libquantum\', \'milc\', \'colocating with libquantum\', \'namd\', \'colocating with libquantum\', \'calculix\', \'colocating with libquantum\', \'h264ref\', \'colocating with libquantum\', \'gobmk\', \'colocating with libquantum\', \'hmmer\', \'colocating with libquantum\', \'tonto\', \'colocating with libquantum\', \'sphinx3\', \'colocating with libquantum\', \'bwaves\', \'colocating with libquantum\', \'gromacs\', \'colocating with libquantum\', \'dealII\', \'colocating with libquantum\', \'sjeng\', \'colocating with libquantum\', \'lbm\', \'colocating with libquantum\', \'xalancbmk\', \'colocating with libquantum\', \'gamess\', \'colocating with libquantum\', \'soplex\', \'colocating with libquantum\', \'cactusADM\', \'colocating with libquantum\', \'GemsFDTD\', \'colocating with libquantum\', \'omnetpp\', \'colocating with libquantum\' ]\n\ndef autolabel(rects):\n    # attach some text labels\n    for rect in rects:\n        height = rect.get_height()\n        plt.text(rect.get_x()+rect.get_width()/2., 1.05*height, \'%.2f\'%float(height), fontsize=8 )\n\ndef autolabel2(rects):\n    # attach some text labels\n    for rect in rects:\n        height = rect.get_height()\n        plt.text(rect.get_x()+rect.get_width()/2., -1.25*height, \'%.2f\'%float(height),\n                ha=\'center\', va=\'top\', fontsize=8)\n        #plt.text(rect.get_x()+rect.get_width()/2., 1.05*height, \'%.2f\'%float(height))\n\n\nfilename = \'execution_time_1000\'\nfList1 = [s.strip() for s in open(\'../../papergraphs/accuracy/libquantumcorunner/degradation2/%s.txt\' % filename).readlines()]  #degradation\nfList2 = [s.strip() for s in open(\'../../papergraphs/accuracy/libquantumcorunner/snapshot/phase_change_5.txt\').readlines()]\nfList3 = [s.strip() for s in open(\'../../papergraphs/accuracy/libquantumcorunner/priorwork/execution_time_5.txt\').readlines()] #prior work\n\n\n\nexecution_time_shutter = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter = defaultdict(lambda  : defaultdict(list))\navg_execution_time_shutter = defaultdict(dict)\nexecution_time_shutter2 = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter2 = defaultdict(lambda  : defaultdict(list))\navg_execution_time_shutter2 = defaultdict(dict)\ndictList_phase_change = defaultdict(lambda  : defaultdict(list))\ndictList_phase_change2 = defaultdict(lambda  : defaultdict(list))\n\nstd_execution_time = defaultdict(dict)\n\ndef print_elapsed_time_shutter(time_shutter):\n    for j in colocationList:\n        for i in benchList:\n            print \'%s ||||  %s\'%(j,i)\n            print time_shutter[j][i]\n\n\nsep = \'u\'\nfor (b,a) in enumerate(fList1):\n    #print a\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            execution_time_shutter[index][a].append((fList1[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_shutter[\'colocating with mcf\'][\'perlbench\']\n#print((s.split(start))[1].split(end)[0])\n\nfor j in colocationList:\n    for i in benchList:\n        for k in execution_time_shutter[j][i]:\n            m,s = [float (var) for var in k.split(\':\')]\n            temp = m*60 + s\n            execution_time_sec_shutter[j][i].append(temp)\n\nfor (b,a) in enumerate(fList3):\n    #print a\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            #print index\n            #print a\n            execution_time_shutter2[index][a].append((fList3[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_shutter[\'colocating with mcf\'][\'perlbench\']\n#print((s.split(start))[1].split(end)[0])\n\nfor j in colocationList:\n    for i in benchList:\n        for k in execution_time_shutter2[j][i]:\n            #print k\n            m,s = [float (var) for var in k.split(\':\')]\n            temp = m*60 + s\n            execution_time_sec_shutter2[j][i].append(temp)\n\nfor (b,a) in enumerate(fList2):\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            dictList_phase_change[index][a].append(fList2[b+1])\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    #print j,i\n    for elem in dictList_phase_change[j][i]:\n        dictList_phase_change2[j][i].extend(elem.strip().split(\'\\t\'))\n    #print dictList_phase_change2[j][i]\n\nyaxis = ()\nyaxis2= ()\nyaxis_abs = ()\nerror = ()\nxaxis = ()\n#print dictList_phase_change2[\'colocating with mcf\'][\'perlbench\']\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    print j,i\n    print dictList_phase_change2[j][i]\n    #print i,j\n    shutter_temp_list = []\n    colo_temp_list = []\n    for (count,item) in enumerate(dictList_phase_change2[j][i]):\n        if count%2==1:\n            colo_temp_list.append(float(item))\n        if count%2==0:\n            shutter_temp_list.append(float(item))\n    #print shutter_temp_list\n    shutter_avg = sum(shutter_temp_list)/len(shutter_temp_list)\n    colocation_avg = sum(colo_temp_list)/len(colo_temp_list)\n    del shutter_temp_list\n    del colo_temp_list\n\n    pause_period = ((colocation_avg ) + ((shutter_avg + (colocation_avg * 2)/3) * 3))/4\n    xaxis = xaxis + (i,)\n    #print (pause_period/np.mean(execution_time_sec_shutter[j][i]))*10\n    yaxis = yaxis + ( (pause_period/np.mean(execution_time_sec_shutter[j][i]))*7.5  ,)\n    yaxis2 = yaxis2 + ( (((np.mean(execution_time_sec_shutter2[j][i])/np.mean(execution_time_sec_shutter[j][i])) - 1)*100), )\n    print np.mean(execution_time_sec_shutter2[j][i])\n    print np.mean(execution_time_sec_shutter[j][i])\n    #print \'---------------------\'\n\nprint yaxis2\n#print np.mean(yaxis)\n\n\nwidth = 0.25\nx = np.arange(len(yaxis))\nfig = plt.figure(figsize=(28, 5))\nbar2 = plt.bar( x, yaxis2, width, color="k", label=\'Shuttering  (mean: %.2f)\' %(np.mean(yaxis2)))\nbar1 = plt.bar( x+width, yaxis, width, color="lightgrey", label=\'Snapshot (mean: %.2f)\' %(np.mean(yaxis) ))\n\n\nplt.ylabel( \'Execution time \\n overhead (%)\',fontsize=\'23\' )\n#plt.title(\'Overhead due to Prediction of degradation while co-running with LIBQUANTUM\')\nplt.xticks(x + width/2.0, xaxis, rotation=\'30\', size=\'23\', ha=\'center\')\n#plt.yticks((-5,0,10,20,30,40,50,60),(\'\',\'0\',\'10\',\'20\',\'30\',\'40\',\'50\',\'60\'),size=\'25\')\nplt.yticks((0,5,10,15),(\'0\',\'5\',\'10\',\'15\'),size=\'25\')\n#plt.yticks(np.arange(-10, 60, 10),size=\'25\')\nplt.xlim(-1,26)\nplt.grid()\nplt.legend(loc=9, ncol=2, prop={\'size\':28})\n#leg.get_frame().set_alpha(0.1)\nplt.tight_layout()\n#plt.savefig(\'phase_chagnge_overheadmaybe.png\', dpi=125)'
p0
.I0
.S'$graph:overheadmcf:co-running with 3 instances of \\texttt{mcf}:1'
p0
.S'from collections import defaultdict\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\nbenchList = [ \'gcc\', \'perlbench\', \'leslie3d\', \'povray\', \'libquantum\', \'astar\', \'bzip2\', \'milc\', \'namd\', \'calculix\', \'h264ref\', \'sphinx3\', \'zeusmp\', \'gobmk\', \'hmmer\', \'tonto\', \'bwaves\', \'gromacs\', \'dealII\', \'sjeng\', \'lbm\', \'xalancbmk\', \'gamess\', \'soplex\', \'GemsFDTD\', \'omnetpp\', \'mcf\', \'cactusADM\' ]\n\ncolocationList = [ \'colocating with libquantum\', \'colocating with mcf\',  \'colocating with sphinx3\']\ncolocationListBaseline = [ \'colocating with libquantum\', \'colocating with mcf\', \'colocating with sphinx3\' ]\n\n\nrunningList = [  \'perlbench\', \'colocating with mcf\', \'mcf\', \'colocating with mcf\', \'leslie3d\', \'colocating with mcf\', \'povray\', \'colocating with mcf\', \'libquantum\', \'colocating with mcf\', \'astar\', \'colocating with mcf\', \'bzip2\', \'colocating with mcf\', \'milc\', \'colocating with mcf\', \'namd\', \'colocating with mcf\', \'calculix\', \'colocating with mcf\', \'h264ref\', \'colocating with mcf\', \'gobmk\', \'colocating with mcf\', \'hmmer\', \'colocating with mcf\', \'tonto\', \'colocating with mcf\', \'sphinx3\', \'colocating with mcf\', \'zeusmp\', \'colocating with mcf\', \'bwaves\', \'colocating with mcf\', \'gromacs\', \'colocating with mcf\', \'dealII\', \'colocating with mcf\', \'sjeng\', \'colocating with mcf\', \'lbm\', \'colocating with mcf\', \'xalancbmk\', \'colocating with mcf\', \'gamess\', \'colocating with mcf\', \'cactusADM\', \'colocating with mcf\', \'soplex\', \'colocating with mcf\', \'GemsFDTD\', \'colocating with mcf\', \'omnetpp\', \'colocating with mcf\' ]\n\ndef autolabel(rects):\n    # attach some text labels\n    for rect in rects:\n        height = rect.get_height()\n        plt.text(rect.get_x()+rect.get_width()/2., 1.05*height, \'%.2f\'%float(height), fontsize=8 )\n\ndef autolabel2(rects):\n    # attach some text labels\n    for rect in rects:\n        height = rect.get_height()\n        plt.text(rect.get_x()+rect.get_width()/2., -1.25*height, \'%.2f\'%float(height),\n                ha=\'center\', va=\'top\', fontsize=8)\n        #plt.text(rect.get_x()+rect.get_width()/2., 1.05*height, \'%.2f\'%float(height))\n\n\nfilename = \'execution_time_1000\'\nfList1 = [s.strip() for s in open(\'../../papergraphs/accuracy/mcfcorunner/degradation/%s.txt\' % filename).readlines()]  #degradation\nfList2 = [s.strip() for s in open(\'../../papergraphs/accuracy/mcfcorunner/snapshot/phase_change_70.txt\').readlines()]\nfList3 = [s.strip() for s in open(\'../../papergraphs/accuracy/mcfcorunner/priorwork/execution_time_5.txt\').readlines()] #prior work\n\n\n\nexecution_time_shutter = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter = defaultdict(lambda  : defaultdict(list))\navg_execution_time_shutter = defaultdict(dict)\nexecution_time_shutter2 = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter2 = defaultdict(lambda  : defaultdict(list))\navg_execution_time_shutter2 = defaultdict(dict)\ndictList_phase_change = defaultdict(lambda  : defaultdict(list))\ndictList_phase_change2 = defaultdict(lambda  : defaultdict(list))\n\nstd_execution_time = defaultdict(dict)\n\ndef print_elapsed_time_shutter(time_shutter):\n    for j in colocationList:\n        for i in benchList:\n            print \'%s ||||  %s\'%(j,i)\n            print time_shutter[j][i]\n\n\nsep = \'u\'\nfor (b,a) in enumerate(fList1):\n    #print a\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            execution_time_shutter[index][a].append((fList1[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_shutter[\'colocating with mcf\'][\'perlbench\']\n#print((s.split(start))[1].split(end)[0])\n\nfor j in colocationList:\n    for i in benchList:\n        for k in execution_time_shutter[j][i]:\n            m,s = [float (var) for var in k.split(\':\')]\n            temp = m*60 + s\n            execution_time_sec_shutter[j][i].append(temp)\n\nfor (b,a) in enumerate(fList3):\n    #print a\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            #print index\n            #print a\n            execution_time_shutter2[index][a].append((fList3[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_shutter[\'colocating with mcf\'][\'perlbench\']\n#print((s.split(start))[1].split(end)[0])\n\nfor j in colocationList:\n    for i in benchList:\n        for k in execution_time_shutter2[j][i]:\n            #print k\n            m,s = [float (var) for var in k.split(\':\')]\n            temp = m*60 + s\n            execution_time_sec_shutter2[j][i].append(temp)\n\nfor (b,a) in enumerate(fList2):\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            dictList_phase_change[index][a].append(fList2[b+1])\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    #print j,i\n    for elem in dictList_phase_change[j][i]:\n        dictList_phase_change2[j][i].extend(elem.strip().split(\'\\t\'))\n    #print dictList_phase_change2[j][i]\n\nyaxis = ()\nyaxis2= ()\nyaxis_abs = ()\nerror = ()\nxaxis = ()\n#print dictList_phase_change2[\'colocating with mcf\'][\'perlbench\']\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    print j,i\n    print dictList_phase_change2[j][i]\n    #print i,j\n    shutter_temp_list = []\n    colo_temp_list = []\n    for (count,item) in enumerate(dictList_phase_change2[j][i]):\n        if count%2==1:\n            colo_temp_list.append(float(item))\n        if count%2==0:\n            shutter_temp_list.append(float(item))\n    #print shutter_temp_list\n    shutter_avg = sum(shutter_temp_list)/len(shutter_temp_list)\n    colocation_avg = sum(colo_temp_list)/len(colo_temp_list)\n    del shutter_temp_list\n    del colo_temp_list\n\n    pause_period = ((colocation_avg ) + ((shutter_avg + (colocation_avg * 2)/3) * 3))/4\n    xaxis = xaxis + (i,)\n    #print (pause_period/np.mean(execution_time_sec_shutter[j][i]))*10\n    yaxis = yaxis + ( (pause_period/np.mean(execution_time_sec_shutter[j][i]))*7.5  ,)\n    yaxis2 = yaxis2 + ( abs(((np.mean(execution_time_sec_shutter2[j][i])/np.mean(execution_time_sec_shutter[j][i])) - 1)*100), )\n    #print \'---------------------\'\n\nprint yaxis2\n#print np.mean(yaxis)\n\n\nwidth = 0.25\nx = np.arange(len(yaxis))\nfig = plt.figure(figsize=(28, 5))\nbar2 = plt.bar( x, yaxis2, width, color="k", label=\'Shuttering  (mean: %.2f)\' %(np.mean(yaxis2)))\nbar1 = plt.bar( x+width, yaxis, width, color="lightgrey", label=\'Snapshot (mean: %.2f)\' %(np.mean(yaxis) ))\n\nplt.ylabel( \'Execution time \\n overhead(%)\',fontsize=23)\n#plt.title(\'Overhead due to Prediction of degradation while co-running with MCF\')\nplt.xticks(x + width/2.0, xaxis, rotation=\'30\', size=\'23\', ha=\'center\')\n#plt.yticks((-5,0,10,20,30,40,50,60),(\'\',\'0\',\'10\',\'20\',\'30\',\'40\',\'50\',\'60\'),size=\'25\')\nplt.yticks((0,5,10,15),(\'0\',\'5\',\'10\',\'15\'),size=\'25\')\nplt.xlim(-1,27)\nplt.grid()\nplt.legend(loc=9, ncol=2, prop={\'size\':28})\nplt.tight_layout()\n#plt.savefig(\'phase_chagnge_overheadmaybe.png\', dpi=125)'
p0
.I0
.S'$graph:overheadmilc:co-running with 3 instances of \\texttt{milc}:1'
p0
.S'from collections import defaultdict\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n#benchList = [ \'gcc\', \'perlbench\', \'leslie3d\', \'povray\', \'libquantum\', \'astar\', \'bzip2\', \'milc\', \'namd\', \'calculix\', \'h264ref\', \'sphinx3\', \'zeusmp\', \'gobmk\', \'hmmer\', \'tonto\', \'bwaves\', \'gromacs\', \'dealII\', \'sjeng\', \'lbm\', \'xalancbmk\', \'gamess\', \'cactusADM\', \'soplex\', \'GemsFDTD\', \'omnetpp\' ]\n#benchList = [ \'gcc\', \'perlbench\', \'sjeng\', \'soplex\', \'astar\', \'libquantum\', \'tonto\', \'milc\', \'dealII\', \'xalancbmk\' ]\n#colocationList = [ \'colocating with milc\', \'colocating with libquantum\', \'colocating with astar\' ]\n#benchList = [ \'gcc\', \'perlbench\', \'sjeng\', \'soplex\', \'astar\', \'libquantum\' ]\n#benchList = [ \'perlbench\', \'sjeng\', \'soplex\', \'astar\', \'libquantum\' ]\n#benchList = [ \'gcc\', \'mcf\', \'perlbench\', \'astar\', \'libquantum\', \'povray\', \'omnetpp\', \'bzip2\' ]\n#colocationList = [ \'colocating with libquantum\', \'colocating with astar\' ]\n#colocationListBaseline = [ \'colocating with milc\', \'colocating with libquantum\', \'colocating with astar\' ]\n\nbenchList = [ \'gcc\', \'perlbench\', \'leslie3d\', \'povray\', \'libquantum\', \'astar\', \'bzip2\', \'milc\', \'namd\', \'calculix\', \'h264ref\', \'sphinx3\', \'zeusmp\', \'gobmk\', \'hmmer\', \'tonto\', \'bwaves\', \'gromacs\', \'dealII\', \'sjeng\', \'lbm\', \'xalancbmk\', \'gamess\', \'soplex\', \'GemsFDTD\', \'omnetpp\', \'mcf\', \'cactusADM\' ]\n#benchList = [ \'gcc\', \'perlbench\', \'leslie3d\', \'povray\', \'libquantum\', \'astar\', \'bzip2\', \'milc\', \'namd\', \'calculix\', \'h264ref\', \'sphinx3\', \'zeusmp\', \'gobmk\', \'hmmer\', \'tonto\', \'bwaves\', \'gromacs\', \'dealII\', \'sjeng\', \'lbm\', \'xalancbmk\', \'gamess\', \'cactusADM\', \'soplex\', \'GemsFDTD\', \'omnetpp\', \'mcf\' ]\n#benchList2 = [ \'gcc\', \'perlbench\', \'leslie3d\', \'povray\', \'libquantum\', \'astar\', \'bzip2\', \'milc\', \'namd\', \'calculix\', \'h264ref\', \'sphinx3\', \'zeusmp\', \'gobmk\', \'hmmer\', \'tonto\', \'bwaves\', \'gromacs\', \'dealII\', \'sjeng\', \'lbm\', \'xalancbmk\', \'gamess\', \'cactusADM\', \'soplex\', \'GemsFDTD\', \'omnetpp\', \'mcf\' ]\n#benchList2 = [ \'gcc\', \'mcf\', \'perlbench\', \'astar\', \'libquantum\', \'povray\', \'bzip2\' ]\ncolocationList = [ \'colocating with libquantum\', \'colocating with mcf\',  \'colocating with milc\']\ncolocationListBaseline = [ \'colocating with libquantum\', \'colocating with mcf\', \'colocating with milc\' ]\n\n#runningList = [  \'gcc\', \'colocating with libquantum\', \'perlbench\', \'colocating with libquantum\', \'mcf\', \'colocating with libquantum\', \'leslie3d\', \'colocating with libquantum\', \'povray\', \'colocating with libquantum\', \'libquantum\', \'colocating with libquantum\', \'astar\', \'colocating with libquantum\', \'bzip2\', \'colocating with libquantum\', \'milc\', \'colocating with libquantum\', \'namd\', \'colocating with libquantum\', \'calculix\', \'colocating with libquantum\', \'h264ref\', \'colocating with libquantum\', \'gobmk\', \'colocating with libquantum\', \'hmmer\', \'colocating with libquantum\', \'tonto\', \'colocating with libquantum\', \'sphinx3\', \'colocating with libquantum\', \'bwaves\', \'colocating with libquantum\', \'gromacs\', \'colocating with libquantum\', \'dealII\', \'colocating with libquantum\', \'sjeng\', \'colocating with libquantum\', \'lbm\', \'colocating with libquantum\', \'xalancbmk\', \'colocating with libquantum\', \'gamess\', \'colocating with libquantum\', \'cactusADM\', \'colocating with libquantum\', \'soplex\', \'colocating with libquantum\', \'GemsFDTD\', \'colocating with libquantum\', \'omnetpp\', \'colocating with libquantum\' ]\n#runningList = [  \'perlbench\', \'colocating with libquantum\', \'mcf\', \'colocating with libquantum\', \'leslie3d\', \'colocating with libquantum\', \'povray\', \'colocating with libquantum\', \'libquantum\', \'colocating with libquantum\', \'astar\', \'colocating with libquantum\', \'bzip2\', \'colocating with libquantum\', \'milc\', \'colocating with libquantum\', \'namd\', \'colocating with libquantum\', \'calculix\', \'colocating with libquantum\', \'h264ref\', \'colocating with libquantum\', \'gobmk\', \'colocating with libquantum\', \'hmmer\', \'colocating with libquantum\', \'tonto\', \'colocating with libquantum\', \'sphinx3\', \'colocating with libquantum\', \'bwaves\', \'colocating with libquantum\', \'gromacs\', \'colocating with libquantum\', \'dealII\', \'colocating with libquantum\', \'sjeng\', \'colocating with libquantum\', \'lbm\', \'colocating with libquantum\', \'xalancbmk\', \'colocating with libquantum\', \'gamess\', \'colocating with libquantum\', \'soplex\', \'colocating with libquantum\', \'GemsFDTD\', \'colocating with libquantum\', \'omnetpp\', \'colocating with libquantum\' ]\n#runningList = [  \'perlbench\', \'colocating with mcf\', \'mcf\', \'colocating with mcf\', \'leslie3d\', \'colocating with mcf\', \'povray\', \'colocating with mcf\', \'libquantum\', \'colocating with mcf\', \'astar\', \'colocating with mcf\', \'bzip2\', \'colocating with mcf\', \'milc\', \'colocating with mcf\', \'namd\', \'colocating with mcf\', \'calculix\', \'colocating with mcf\', \'h264ref\', \'colocating with mcf\', \'gobmk\', \'colocating with mcf\', \'hmmer\', \'colocating with mcf\', \'tonto\', \'colocating with mcf\', \'sphinx3\', \'colocating with mcf\', \'bwaves\', \'colocating with mcf\', \'gromacs\', \'colocating with mcf\', \'dealII\', \'colocating with mcf\', \'sjeng\', \'colocating with mcf\', \'lbm\', \'colocating with mcf\', \'xalancbmk\', \'colocating with mcf\', \'gamess\', \'colocating with mcf\', \'cactusADM\', \'colocating with mcf\', \'soplex\', \'colocating with mcf\', \'GemsFDTD\', \'colocating with mcf\', \'omnetpp\', \'colocating with mcf\' ]\nrunningList = [  \'perlbench\', \'colocating with milc\', \'mcf\', \'colocating with milc\', \'leslie3d\', \'colocating with milc\', \'povray\', \'colocating with milc\', \'libquantum\', \'colocating with milc\', \'astar\', \'colocating with milc\', \'bzip2\', \'colocating with milc\', \'milc\', \'colocating with milc\', \'namd\', \'colocating with milc\', \'calculix\', \'colocating with milc\', \'h264ref\', \'colocating with milc\', \'gobmk\', \'colocating with milc\', \'hmmer\', \'colocating with milc\', \'tonto\', \'colocating with milc\', \'sphinx3\', \'colocating with milc\', \'zeusmp\', \'colocating with milc\', \'bwaves\', \'colocating with milc\', \'gromacs\', \'colocating with milc\', \'dealII\', \'colocating with milc\', \'sjeng\', \'colocating with milc\', \'lbm\', \'colocating with milc\', \'xalancbmk\', \'colocating with milc\', \'gamess\', \'colocating with milc\', \'cactusADM\', \'colocating with milc\', \'soplex\', \'colocating with milc\', \'GemsFDTD\', \'colocating with milc\', \'omnetpp\', \'colocating with milc\' ]\n#runningList3 = [  \'perlbench\', \'colocating with sphinx3\', \'mcf\', \'colocating with sphinx3\', \'leslie3d\', \'colocating with sphinx3\', \'povray\', \'colocating with sphinx3\', \'libquantum\', \'colocating with sphinx3\', \'astar\', \'colocating with sphinx3\', \'bzip2\', \'colocating with sphinx3\', \'milc\', \'colocating with sphinx3\', \'namd\', \'colocating with sphinx3\', \'calculix\', \'colocating with sphinx3\', \'h264ref\', \'colocating with sphinx3\', \'gobmk\', \'colocating with sphinx3\', \'hmmer\', \'colocating with sphinx3\', \'tonto\', \'colocating with sphinx3\', \'sphinx3\', \'colocating with sphinx3\', \'bwaves\', \'colocating with sphinx3\', \'gromacs\', \'colocating with sphinx3\', \'dealII\', \'colocating with sphinx3\', \'sjeng\', \'colocating with sphinx3\', \'lbm\', \'colocating with sphinx3\', \'xalancbmk\', \'colocating with sphinx3\', \'gamess\', \'colocating with sphinx3\', \'cactusADM\', \'colocating with sphinx3\', \'soplex\', \'colocating with sphinx3\', \'GemsFDTD\', \'colocating with sphinx3\', \'omnetpp\', \'colocating with sphinx3\' ]\n\n#colocationListBaseline = [ \'colocating with gcc\', \'colocating with mcf\', \'colocating with perlbench\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with lbm\' ]\ndef autolabel(rects):\n    # attach some text labels\n    for rect in rects:\n        height = rect.get_height()\n        plt.text(rect.get_x()+rect.get_width()/2., 1.05*height, \'%.2f\'%float(height), fontsize=8 )\n\ndef autolabel2(rects):\n    # attach some text labels\n    for rect in rects:\n        height = rect.get_height()\n        plt.text(rect.get_x()+rect.get_width()/2., -1.25*height, \'%.2f\'%float(height),\n                ha=\'center\', va=\'top\', fontsize=8)\n        #plt.text(rect.get_x()+rect.get_width()/2., 1.05*height, \'%.2f\'%float(height))\n\n\nfilename = \'execution_time_1000\'\nfList1 = [s.strip() for s in open(\'../../papergraphs/accuracy/milccorunner/degradation/%s.txt\' % filename).readlines()]  #degradation\nfList2 = [s.strip() for s in open(\'../../papergraphs/accuracy/milccorunner/snapshot/phase_change_70.txt\').readlines()]\nfList3 = [s.strip() for s in open(\'../../papergraphs/accuracy/milccorunner/priorwork/execution_time_5.txt\').readlines()] #prior work\n#fList3 = [s.strip() for s in open(\'experiment_libquantum/phase_changes_5.txt\').readlines()]\n##fList3 = [s.strip() for s in open(\'../../papergraphs/2.fullspec/overhead/experiment_mcf/%s.txt\' % filename).readlines()]\n##fList4 = [s.strip() for s in open(\'../../papergraphs/2.fullspec/overhead/experiment_mcf/phase_changes_5.txt\').readlines()]\n##fList5 = [s.strip() for s in open(\'../../papergraphs/2.fullspec/overhead/experiment_sphinx3/%s.txt\' % filename).readlines()]\n##fList6 = [s.strip() for s in open(\'../../papergraphs/2.fullspec/overhead/experiment_sphinx3/phase_changes_5.txt\').readlines()]\n#print fList1\n\n\nexecution_time_shutter = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter = defaultdict(lambda  : defaultdict(list))\navg_execution_time_shutter = defaultdict(dict)\nexecution_time_shutter2 = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter2 = defaultdict(lambda  : defaultdict(list))\navg_execution_time_shutter2 = defaultdict(dict)\ndictList_phase_change = defaultdict(lambda  : defaultdict(list))\ndictList_phase_change2 = defaultdict(lambda  : defaultdict(list))\n\nstd_execution_time = defaultdict(dict)\n\ndef print_elapsed_time_shutter(time_shutter):\n    for j in colocationList:\n        for i in benchList:\n            print \'%s ||||  %s\'%(j,i)\n            print time_shutter[j][i]\n\n\nsep = \'u\'\nfor (b,a) in enumerate(fList1):\n    #print a\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            execution_time_shutter[index][a].append((fList1[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_shutter[\'colocating with mcf\'][\'perlbench\']\n#print((s.split(start))[1].split(end)[0])\n\nfor j in colocationList:\n    for i in benchList:\n        for k in execution_time_shutter[j][i]:\n            m,s = [float (var) for var in k.split(\':\')]\n            temp = m*60 + s\n            execution_time_sec_shutter[j][i].append(temp)\n\nfor (b,a) in enumerate(fList3):\n    #print a\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            #print index\n            #print a\n            execution_time_shutter2[index][a].append((fList3[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_shutter[\'colocating with mcf\'][\'perlbench\']\n#print((s.split(start))[1].split(end)[0])\n\nfor j in colocationList:\n    for i in benchList:\n        for k in execution_time_shutter2[j][i]:\n            #print k\n            m,s = [float (var) for var in k.split(\':\')]\n            temp = m*60 + s\n            execution_time_sec_shutter2[j][i].append(temp)\n\nfor (b,a) in enumerate(fList2):\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            dictList_phase_change[index][a].append(fList2[b+1])\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    #print j,i\n    for elem in dictList_phase_change[j][i]:\n        dictList_phase_change2[j][i].extend(elem.strip().split(\'\\t\'))\n    #print dictList_phase_change2[j][i]\n\nyaxis = ()\nyaxis2= ()\nyaxis_abs = ()\nerror = ()\nxaxis = ()\n#print dictList_phase_change2[\'colocating with mcf\'][\'perlbench\']\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    print j,i\n    print dictList_phase_change2[j][i]\n    #print i,j\n    shutter_temp_list = []\n    colo_temp_list = []\n    for (count,item) in enumerate(dictList_phase_change2[j][i]):\n        if count%2==1:\n            colo_temp_list.append(float(item))\n        if count%2==0:\n            shutter_temp_list.append(float(item))\n    #print shutter_temp_list\n    shutter_avg = sum(shutter_temp_list)/len(shutter_temp_list)\n    colocation_avg = sum(colo_temp_list)/len(colo_temp_list)\n    del shutter_temp_list\n    del colo_temp_list\n\n    pause_period = ((colocation_avg ) + ((shutter_avg + (colocation_avg * 2)/3) * 3))/4\n    xaxis = xaxis + (i,)\n    #print (pause_period/np.mean(execution_time_sec_shutter[j][i]))*10\n    yaxis = yaxis + ( (pause_period/np.mean(execution_time_sec_shutter[j][i]))*7.5  ,)\n    yaxis2 = yaxis2 + ( abs(((np.mean(execution_time_sec_shutter2[j][i])/np.mean(execution_time_sec_shutter[j][i])) - 1)*100), )\n    #print \'---------------------\'\n\nprint yaxis2\n#print np.mean(yaxis)\n\n\nwidth = 0.25\nx = np.arange(len(yaxis))\nfig = plt.figure(figsize=(28, 5))\nbar2 = plt.bar( x, yaxis2, width, color="k", label=\'Shuttering  (mean: %.2f)\' %(np.mean(yaxis2)))\nbar1 = plt.bar( x+width, yaxis, width, color="lightgrey", label=\'Snapshot (mean: %.2f)\' %(np.mean(yaxis) ))\n#bar3 = plt.bar( x+width+width, yaxis3, width, color="g", label=\' colocating with sphinx3 (avg = %.1f)\' %(np.mean(yaxis3)))\n##bar3 = plt.bar( x+width+width, yaxis3, width, color="g", label=\'4 corunners (avg is %.1f)\' %(np.mean(yaxis3) ))\n##autolabel2(bar1)\n##autolabel(bar2)\n##autolabel2(bar3)\nplt.ylabel( \'Execution time \\n overhead(%)\',fontsize=23)\n#plt.title(\'Overhead due to Prediction of degradation while co-running with milc\')\nplt.xticks(x + width/2.0, xaxis, rotation=\'30\', size=\'23\', ha=\'center\')\n#plt.yticks((-5,0,10,20,30,40,50,60),(\'\',\'0\',\'10\',\'20\',\'30\',\'40\',\'50\',\'60\'),size=\'25\')\nplt.yticks((0,5,10,15),(\'0\',\'5\',\'10\',\'15\'),size=\'25\')\nplt.xlim(-1,27)\nplt.grid()\nplt.legend(loc=9, ncol=2, prop={\'size\':28})\nplt.tight_layout()\n#plt.savefig(\'phase_chagnge_overheadmaybe.png\', dpi=125)'
p0
.I0
.S'$graph_fig:lbmsnapshotlib:Phase behavior of \\texttt{lbm} (error 2.59\\%) \\vspace{-0.1in}:1'
p0
.S"import matplotlib.pyplot as plt\nimport numpy as np\nfrom collections import defaultdict\n\nfilename = '5'\nf1 = [s.strip() for s in open('../../papergraphs/phases/phasedetection/single.txt').readlines()]\nf3 = [s.strip() for s in open('../../papergraphs/phases/phasedetection/shutter_phase_%s.txt' % filename).readlines()]\n\n\nbenchListBaseline = [ 'gcc', 'perlbench', 'mcf', 'leslie3d', 'povray', 'libquantum', 'astar', 'bzip2', 'milc', 'namd', 'calculix', 'h264ref', 'zeusmp', 'gobmk', 'hmmer', 'tonto', 'sphinx3', 'bwaves', 'gromacs', 'dealII', 'sjeng', 'lbm', 'xalancbmk', 'gamess', 'cactusADM', 'soplex', 'GemsFDTD', 'omnetpp' ]\nbenchListExperiments = [ 'gcc', 'perlbench', 'mcf', 'leslie3d', 'povray', 'libquantum', 'astar', 'bzip2', 'milc', 'namd', 'calculix', 'h264ref', 'zeusmp', 'gobmk', 'hmmer', 'tonto', 'sphinx3', 'bwaves', 'gromacs', 'dealII', 'sjeng', 'lbm', 'xalancbmk', 'gamess', 'cactusADM', 'soplex', 'GemsFDTD', 'omnetpp' ]\n#benchListExperiments = [ 'perlbench', 'astar', 'soplex', 'xalancbmk', 'omnetpp', 'bzip2','povray']\n#benchListExperiments = [ 'gcc', 'perlbench', 'astar', 'soplex', 'xalancbmk', 'omnetpp']\ncolocationListBaseline = [ 'colocating with mcf', 'colocating with povray', 'colocating with astar', 'colocating with astar', 'colocating with libquantum', 'colocating with povray', 'colocating with omnetpp', 'colocating with bzip2' ]\ncolocationListExperiments = [ 'colocating with mcf', 'colocating with povray', 'colocating with perlbench', 'colocating with astar', 'colocating with libquantum', 'colocating with povray', 'colocating with omnetpp', 'colocating with bzip2' ]\n\nrunningList = [ 'lbm' ,'colocating with libquantum']\n\n\nphaseList_single = defaultdict(list)\nphaseList_degradation = defaultdict(lambda  : defaultdict(list))\nphaseList_shutter = defaultdict(lambda  : defaultdict(list))\nphaseList_colocation = defaultdict(lambda  : defaultdict(list))\n\n\nllc_miss_phaseList_single = defaultdict(list)\nllc_miss_phaseList_degradation = defaultdict(lambda  : defaultdict(list))\nllc_miss_phaseList_shutter = defaultdict(lambda  : defaultdict(list))\nllc_miss_phaseList_colocation = defaultdict(lambda  : defaultdict(list))\n\nfirstList1 = []\nsecondList1 = []\nthirdList1 = []\nfourthList1 = []\nfifthList1 = []\nsixthList1 = []\nseventhList1 = []\neighthList1 = []\n\nfor line in f1:\n    firstList1.append(line)\n\n#for line in f2:\n #   secondList1.append(line)\n\nfor line in f3:\n    thirdList1.append(line)\n\n\n\n#print sixthList1\n#print firstList1\nglobal index\nglobal index2\n\nfor (j,i) in enumerate(firstList1):\n    #print i\n    if i in benchListBaseline:\n        index = i\n    else:\n        phaseList_single[index].append(i.split())\n\n\n#for (j,i) in enumerate(fifthList1):\n#    if i in benchListExperiments:\n#        index = i\n#    else:\n#        llc_miss_phaseList_single[index].append(i.split())\n\n#print len(phaseList_single['gcc'])\n#print len(llc_miss_phaseList_single['gcc'])\n\nfor (j,i) in enumerate(secondList1):\n    if i in colocationListExperiments:\n        index2=i\n    elif i in benchListExperiments:\n        index=i\n    else:\n        phaseList_degradation[index2][index].append(i.split())\n\n\n#for (j,i) in enumerate(sixthList1):\n#    if i in colocationListExperiments:\n#        index2=i\n#    elif i in benchListExperiments:\n#        index=i\n#    else:\n#        llc_miss_phaseList_degradation[index2][index].append(i.split())\n\n#print len(phaseList_degradation['colocating with libquantum']['gcc'])\n#print len(llc_miss_phaseList_degradation['colocating with libquantum']['gcc'])\n\nfor (j,i) in enumerate(thirdList1):\n    if i in colocationListExperiments:\n        index2=i\n    elif i in benchListExperiments:\n        index=i\n    else:\n        phaseList_shutter[index2][index].append(i.split())\n\n\n#for (j,i) in enumerate(seventhList1):\n#    if i in colocationListExperiments:\n#        index2=i\n#    elif i in benchListExperiments:\n#        index=i\n#    else:\n#        llc_miss_phaseList_shutter[index2][index].append(i.split())\n#print len(phaseList_shutter['colocating with libquantum']['gcc'])\n#print len(llc_miss_phaseList_shutter['colocating with libquantum']['gcc'])\n\n#for (j,i) in enumerate(fourthList1):\n#    if i in colocationListExperiments:\n#        index2=i\n#    elif i in benchListExperiments:\n#        index=i\n#    else:\n#        phaseList_colocation[index2][index].append(i.split())\n\n\n#for (j,i) in enumerate(eighthList1):\n#    if i in colocationListExperiments:\n#        index2=i\n#    elif i in benchListExperiments:\n#        index=i\n#    else:\n#        llc_miss_phaseList_colocation[index2][index].append(i.split())\n\n#print len(phaseList_colocation['colocating with libquantum']['gcc'])\n#print len(llc_miss_phaseList_colocation['colocating with libquantum']['gcc'])\n##############place to get the lists to plot #############\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    print i\n    instruction_list1=[]\n    cpi_list1=[]\n    instruction_list2=[]\n    cpi_list2=[]\n    instruction_list3=[]\n    cpi_list3=[]\n    for (b,a) in enumerate(phaseList_shutter[j][i]):\n        if a[0][0] == '-':\n            break\n        else:\n            instruction_list1.append(float(a[1]))\n            cpi_list1.append(a[2])\n\n    for (b,a) in enumerate(phaseList_single[i]):\n        if a[0][0] == '-':\n            break\n        else:\n            instruction_list2.append(float(a[1])*1.25)\n            cpi_list2.append(a[2])\n\n    for (b,a) in enumerate(phaseList_degradation[j][i]):\n        if a[0][0] == '-':\n            break\n        else:\n            instruction_list3.append(float(a[1]))\n            cpi_list3.append(float(a[14])/10)\n\n    #print instruction_list\n    #print cpi_list\n\n    f, ax = plt.subplots(figsize=(15,5))\n    #ax.plot(instruction_list1,miss_list1, color='b', label='ground truth degradation when %s is colocating with %s' %(i,j[16:]))\n    #ax.plot(instruction_list2,cpi_list2, color='g',  label='phase L3 cache miss rate (per thousand cycles) of %s during when 3 corunners (%s) are running ' %(i,j[16:]))\n    #ax.plot(instruction_list2,miss_list2, color='c', label='ground truth L3 cache miss rate (per thousand cycles) of %s when colocating with %s  ' %(i,j[16:]))\n\n\n\n    ax.plot(instruction_list1,cpi_list1, color='r', label='w/ libquantum')\n    ax.plot(instruction_list2,cpi_list2, color='g',  label= 'w/o libquantum')\n    #ax.plot(instruction_list2,miss_list2, color='c', label='ground truth L3 cache miss rate (per thousand cycles) of %s running alone' %(i))\n    #ax.set_title('Phase of lone execution of %s VS phase of %s running with %s'%(i,i,j))\n    ax.set_xlabel('Executed instructions', fontsize=25)\n    ax.set_ylabel('CPI', fontsize=25)\n    #ax.set_ylabel('LLC store misses')\n    #ax.set_ylabel('L1 Dcache load misses')\n    ax.set_yticks(np.arange(0.6,1.6,0.15))\n    ax.tick_params(axis='both', labelsize=25)\n    ax.set_ylim(0.65,1.5)\n    ax.legend(loc=1,prop={'size':23})\n    #plt.savefig('%s_and_libquantum.pdf'%(i),bbox_inches='tight' ,dpi=200)\n    del instruction_list1\n    del cpi_list1\n"
p0
.I0
.S'Explanation'
p0
.S'$p:  In this sub-section, we evaluate the accuracy of our \\textit{snapshot} technique in estimating the degradation. To make a scenario similar to that present in public clouds, we run four virtual machines, where each virtual machine has 1 virtual CPU, on a quad-core machine and run SPEC applications on each VM. In this experiments, we measure the accuracy for a single SPEC application when running with three contentious co-runners. The reason why we choose contentious co-runners is that estimating performance degradation is very difficult due to their heavy impact on the shared last level cache and memory bandwidth.'
p0
.I0
.S'Graphs explanation'
p0
.S'$p: Figure \\ref{fig:Accuracy} shows the accuracy of shuttering and \\textit{snapshot} techniques in co-located environment. The x-axis shows SPEC 2006 applications and the y-axis presents the error in estimating performance degradation. We evaluate the accuracy for predicting performance degradation of SPEC applications when running with each of the following three co-runners, \\texttt{libquantum}, \\texttt{mcf}, and \\texttt{milc}, respectively. From many prior studies, these applications are well known to highly incur resource contention in shared  architectural resources. The black bar indicates the prior work, and the gray bar represents our \\textit{snapshot} technique. We calculate the error for each technique by comparing the estimated performance degradation using both the runtime systems with the actual performance degradation. We run each benchmark three times and take the mean to minimize minor variability that exits while running SPEC applications. The legend in figures shows the mean error rate of all applications.'
p0
.I0
.S'Contentiousness'
p0
.S'$p: Through these experiments, we can see that the estimation error is much lower for \\textit{snapshot} technique than shuttering. When running with three instances of \\texttt{libquantum} in Figure~\\ref{fig:accuracylibquantum}, the mean error of prior technique is 14.5\\%. On the other hand, our \\textit{snapshotting} technique shows the estimation error of 4.38\\%. For \\texttt{perlbench}, \\texttt{bzip2}, \\texttt{sphinx3}, \\texttt{xalancbmk}, and \\texttt{omnetpp}, the improvements are remarkable. When co-locating three instances of mcf and milc the error due to \\textit{snapshot} technique is 3.79\\% and 4.12\\%, respectively as shown by Figures ~\\ref{fig:accuracymcf} and ~\\ref{fig:accuracymilc} .\n\nIt is challenging to estimate the performance degradation when running with contentious co-runners as they quickly pollute the shared last level cache and excessively use the shared memory bandwidth. Such cases require more pausing time to bring its working set into the cache. If there is not enough time to warm up the architectural resources especially the cache, estimating solo performance of the application would be less accurate. We already know that the pausing time used in prior technique is not enough. Since they pause at regular time intervals, increasing the pausing time will cause significant execution time overheads of applications. On the other hand, our \\textit{snapshot} technique could increase the pausing time because it pauses the co-runners only at phase changes instead  at regular intervals as being done by the prior technique.\n\\\\\n\n'
p0
.I0
.S'Phase Level behavior'
p0
.S'$s:Phase Level Evaluation for Accuracy'
p0
.I3
.S'astar'
p0
.S'$p: \nTo see the behavior of \\textit{snapshot} in more details, we evaluate our technique phase by phase. As a case study, we choose \\texttt{astar} as a target application and run 3 instances of \\texttt{libquantum} as co-runners. Figure~\\ref{fig:astarsnapshotlib} and \\ref{fig:astarpriorlib} present how \\textit{snapshot} and shuttering estimate the solo execution of \\texttt{astar}, respectively. The green line depicts the phase of CPI for \\texttt{astar} when running without any co-runners and the red line shows how each technique estimates the phase of CPI when running with 3 instances of \\texttt{libquantum}. The closer the red line is to the green line, the lesser the error. Figure~\\ref{fig:astarsnapshotlib} shows that \\textit{snapshot} not only detects phase changes accurately, but also traces steady state periods of solo execution while minimizing the false positives. On the other hand,  shuttering shows high error rate even within steady states because the pausing time is not enough to accurately estimate the solo execution. This is can be observed from the high variation during estimation as shown in Figure \\ref{fig:astarpriorlib}. \n'
p0
.I0
.S'mcf and milc'
p0
.S'$p: \nFigure~\\ref{fig:mcfphase} shows how \\textit{snapshot} techinque efficiently traces the phase changes for \\texttt{mcf} and \\texttt{milc}. When running with \\texttt{libquantum}, Figure~\\ref{fig:mcfsnapshotlib} and~\\ref{fig:milcsnapshotlib} show that the red line shadows the green line. The error rates are 0.51\\% and 1.23\\%, respectively. We also run same application with \\texttt{mcf} as a co-runner. Figure~\\ref{fig:mcfsnapshotmcf} and ~\\ref{fig:milcsnapshotmcf} exhibit that \\textit{snapshot} efficiently detects phase changes with low error rate when having \\texttt{mcf} as a co-runner.'
p0
.I0
.S'$fig:lbmsnapshotlib,1:'
p0
.S''
p0
.I0
.S'Overhead'
p0
.S'$s:Overhead of Fair Pricing Runtime Engine'
p0
.I6
.S'$sub_fig*:mixcorunners:Accuracy and overheads of snapshot when running with co-runners \\texttt{libquantum, mcf} and \\texttt{milc} :accuracymix,2:nl:overheadmix,2:'
p0
.S''
p0
.I0
.S'$graph:accuracymix: Accuracy:1'
p0
.S'from collections import defaultdict\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nbenchListBaseline = [ \'gcc\', \'perlbench\', \'leslie3d\', \'povray\', \'libquantum\', \'astar\', \'bzip2\', \'milc\', \'namd\', \'calculix\', \'h264ref\', \'sphinx3\', \'zeusmp\', \'gobmk\', \'hmmer\', \'tonto\', \'bwaves\', \'gromacs\', \'dealII\', \'sjeng\', \'lbm\', \'xalancbmk\', \'gamess\', \'cactusADM\', \'soplex\', \'GemsFDTD\', \'omnetpp\', \'mcf\' ]\nbenchListExperiments = [ \'gcc\', \'perlbench\', \'leslie3d\', \'povray\', \'libquantum\', \'astar\', \'bzip2\', \'milc\', \'namd\', \'calculix\', \'h264ref\', \'sphinx3\', \'zeusmp\', \'gobmk\', \'hmmer\', \'tonto\', \'bwaves\', \'gromacs\', \'dealII\', \'sjeng\', \'lbm\', \'xalancbmk\', \'gamess\', \'cactusADM\', \'soplex\', \'GemsFDTD\', \'omnetpp\', \'mcf\' ]\ncolocationListBaseline = [ \'colocating with lbm\', \'colocating with milc\', \'colocating with astar\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with mcf\' ]\ncolocationListExperiments = [ \'colocating with lbm\', \'colocating with milc\', \'colocating with perlbench\', \'colocating with astar\', \'colocating with libquantum\', \'colocating with povray\', \'colocating with omnetpp\', \'colocating with mcf\' ]\nrunningList = [  \'perlbench\', \'colocating with milc\', \'mcf\', \'colocating with milc\', \'leslie3d\', \'colocating with milc\', \'povray\', \'colocating with milc\', \'libquantum\', \'colocating with milc\', \'astar\', \'colocating with milc\', \'bzip2\', \'colocating with milc\', \'milc\', \'colocating with milc\', \'namd\', \'colocating with milc\', \'calculix\', \'colocating with milc\', \'h264ref\', \'colocating with milc\', \'gobmk\', \'colocating with milc\', \'hmmer\', \'colocating with milc\', \'tonto\', \'colocating with milc\', \'sphinx3\', \'colocating with milc\', \'bwaves\', \'colocating with milc\', \'gromacs\', \'colocating with milc\', \'dealII\', \'colocating with milc\', \'sjeng\', \'colocating with milc\', \'lbm\', \'colocating with milc\', \'xalancbmk\', \'colocating with milc\', \'gamess\', \'colocating with milc\', \'cactusADM\', \'colocating with milc\', \'soplex\', \'colocating with milc\', \'GemsFDTD\', \'colocating with milc\', \'omnetpp\', \'colocating with milc\' ]\nrunningList2 = [  \'leslie3d\', \'colocating with milc\', \'milc\', \'colocating with milc\', \'namd\', \'colocating with milc\', \'calculix\', \'colocating with milc\', \'gobmk\', \'colocating with milc\', \'hmmer\', \'colocating with milc\', \'tonto\', \'colocating with milc\', \'sphinx3\', \'colocating with milc\', \'bwaves\', \'colocating with milc\', \'gromacs\', \'colocating with milc\', \'dealII\', \'colocating with milc\', \'sjeng\', \'colocating with milc\', \'gamess\', \'colocating with milc\', \'cactusADM\', \'colocating with milc\', \'soplex\', \'colocating with milc\', \'GemsFDTD\', \'colocating with milc\' ]\nrunningList3 = [  \'perlbench\', \'colocating with milc\', \'mcf\', \'colocating with milc\', \'povray\', \'colocating with milc\', \'libquantum\', \'colocating with milc\', \'astar\', \'colocating with milc\', \'bzip2\', \'colocating with milc\', \'h264ref\', \'colocating with milc\',  \'lbm\', \'colocating with milc\', \'xalancbmk\', \'colocating with milc\', \'omnetpp\', \'colocating with milc\' ]\n\n\ndef autolabel(rects):\n    # attach some text labels\n    for rect in rects:\n        height = rect.get_height()\n        plt.text(rect.get_x()+rect.get_width()/2., 1.05*height, \'%.2f\'%float(height))\n\ndef autolabel2(rects):\n    # attach some text labels\n    for rect in rects:\n        height = rect.get_height()\n        plt.text(rect.get_x()+rect.get_width()/2., 1.05*height, \'%.2f\'%float(height))\n\nfilename = \'shutter_cpi_10\'\n\nfList3= [s.strip() for s in open(\'../../papergraphs/mixcorunner/priorwork/shutter_cpi_4.txt\').readlines()]\n\nfList4 = [s.strip() for s in open(\'../../papergraphs/mixcorunner/singlevm/shutter_cpi_1000.txt\').readlines()]\nfList5 = [s.strip() for s in open(\'../../papergraphs/mixcorunner/degradation/shutter_cpi_1000.txt\').readlines()]\nfList6 = [s.strip() for s in open(\'../../papergraphs/mixcorunner/snapshot/%s.txt\' % filename).readlines()]\nfList7 = [s.strip() for s in open(\'../../papergraphs/mixcorunner/degradation/shutter_cpi_100.txt\').readlines()]\n\n\ndictList_single_vm = defaultdict(list)\ndictList_degradation_colocation = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter2 = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter3 = defaultdict(lambda  : defaultdict(list))\ndictList_degradation_shutter4 = defaultdict(lambda  : defaultdict(list))\nplot_degradation = defaultdict(dict)\nplot_degradation2 = defaultdict(dict)\nplot_degradation_error = defaultdict(dict)\nplot_degradation_error2 = defaultdict(dict)\nplot_degradation_abs = defaultdict(dict)\nplot_degradation_abs2 = defaultdict(dict)\n\nfor (b,a) in enumerate(fList4):\n    if a in benchListBaseline:\n        dictList_single_vm[a].append(fList4[b+1])\n\n#SORTING LIST CONTAING VALUES OF SINGLE SPEC RUNS INSIDE VMs\nfor i in benchListBaseline:\n    dictList_single_vm[i].sort()\n    #print i,dictList_single_vm[i]\n\nfor (b,a) in enumerate(fList5):\n    #print a\n    if a in colocationListBaseline:\n       #print a\n       index = a\n    else:\n        if a in benchListExperiments:\n            #print a\n            dictList_degradation_colocation[index][a].append(fList5[b+1])\n\n#sorting the ground truth values\nfor a in xrange(0,len(runningList2),2):\n    j = runningList2[a+1]\n    i = runningList2[a]\n    dictList_degradation_colocation[j][i].sort()\n    #print j,i,dictList_degradation_colocation[j][i]\n\n\n#APPENDING DEGRADATION SHUTTER\nfor (b,a) in enumerate(fList6):\n    if a in colocationListExperiments:\n        index = a\n    else:\n        if a in benchListExperiments:\n            dictList_degradation_shutter[index][a].append(fList6[b+1])\n\nfor (b,a) in enumerate(fList3):\n    if a in colocationListExperiments:\n        index = a\n    else:\n        if a in benchListExperiments:\n            dictList_degradation_shutter3[index][a].append(fList3[b+1])\n\nfor a in xrange(0,len(runningList2),2):\n    j = runningList2[a+1]\n    i = runningList2[a]\n    #print i,j,dictList_degradation_shutter[j][i]\n#APPENDING DEGRADATION SHUTTER2 as shutter and colocation values are tab separated\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    for elem in dictList_degradation_shutter[j][i]:\n        dictList_degradation_shutter2[j][i].extend(elem.strip().split(\'\\t\'))\n\n    for elem in dictList_degradation_shutter3[j][i]:\n        dictList_degradation_shutter4[j][i].extend(elem.strip().split(\'\\t\'))\n    #print dictList_degradation_shutter2[j][i]\n\nyaxis2 = ()\nyaxis3 = ()\nyaxis_abs2 = ()\nyaxis_abs3 = ()\nerror2 = ()\nerror3 = ()\nxaxis2 = ()\nfor a in xrange(0,len(runningList2),2):\n    j = runningList2[a+1]\n    i = runningList2[a]\n    #print i,j\n    #print dictList_single_vm[i]\n    #print dictList_degradation_colocation[j][i]\n    #print dictList_degradation_shutter2[j][i]\n    denominator1 = sum(float(n) for (m,n) in enumerate(dictList_single_vm[i]) if m!=0 and m!=len(dictList_single_vm[i])-1)/(len(dictList_single_vm[i])-2)\n    numerator1 = sum(float(n) for (m,n) in enumerate(dictList_degradation_colocation[j][i]))/(len(dictList_degradation_colocation[j][i]))\n    shutter_temp_list = []\n    shutter_temp_list2 = []\n    colo_temp_list = []\n    colo_temp_list2 = []\n    degradation_temp_list = []\n    degradation_temp_list2 = []\n    error_temp_list = []\n    error_temp_list2 = []\n    #print numerator1\n    #print denominator1\n    for (count,item) in enumerate(dictList_degradation_shutter2[j][i]):\n        if count%2==0:\n            colo_temp_list.append(item)\n        if count%2==1:\n            shutter_temp_list.append(item)\n\n    for (count,item) in enumerate(dictList_degradation_shutter4[j][i]):\n        if count%2==0:\n            colo_temp_list2.append(item)\n        if count%2==1:\n            shutter_temp_list2.append(item)\n\n    for (count,item) in enumerate(shutter_temp_list):\n        degradation_temp_list.append(abs((((float(shutter_temp_list[count])/float(colo_temp_list[count]))-(numerator1/denominator1))/(float(shutter_temp_list[count])/float(colo_temp_list[count])))*100))\n\n    shutter_temp_list.sort()\n    shutter_temp_list2.sort()\n    colo_temp_list.sort()\n    colo_temp_list2.sort()\n    #print shutter_temp_list\n    #print colo_temp_list\n    #print dictList_degradation_shutter2[j][i]\n    denominator2 = sum(float(n) for (m,n) in enumerate(shutter_temp_list))/len(shutter_temp_list)\n    numerator2 = sum(float(n) for (m,n) in enumerate(colo_temp_list))/len(colo_temp_list)\n    for (m,n) in enumerate(shutter_temp_list):\n        ratio=float(n)/float(colo_temp_list[m])\n        error_temp_list.append(abs((((ratio)-(numerator1/denominator1))/(numerator1/denominator1))*100))\n    plot_degradation_error[j][i]=np.std(error_temp_list)\n\n    denominator3 = sum(float(n) for (m,n) in enumerate(shutter_temp_list2))/(len(shutter_temp_list2))\n    numerator3 = sum(float(n) for (m,n) in enumerate(colo_temp_list2))/(len(colo_temp_list2))\n    for (m,n) in enumerate(shutter_temp_list2):\n        ratio=float(n)/float(colo_temp_list2[m])\n        error_temp_list2.append(abs((((ratio)-(numerator3/denominator3))/(numerator1/denominator1))*100))\n    plot_degradation_error2[j][i]=np.std(error_temp_list2)\n\n    #print numerator2\n    #print denominator2\n    del shutter_temp_list\n    del colo_temp_list\n    del degradation_temp_list\n    del shutter_temp_list2\n    del colo_temp_list2\n    del degradation_temp_list2\n    plot_degradation[j][i] = (((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100\n    plot_degradation_abs[j][i] = abs((((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100)\n    plot_degradation2[j][i] = (((numerator3/denominator3)-(numerator1/denominator1))/(numerator1/denominator1))*100\n    plot_degradation_abs2[j][i] = abs((((numerator3/denominator3)-(numerator1/denominator1))/(numerator1/denominator1))*100)\n    #print j,i,plot_degradation[j][i]\n    #print plot_degradation_error[j][i]\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    #xaxis2 = xaxis2 + (i,)\n    #yaxis2 = yaxis2 + (plot_degradation[j][i],)\n    #yaxis3 = yaxis3 + (plot_degradation2[j][i],)\n    #yaxis_abs2 = yaxis_abs2 + (plot_degradation_abs[j][i],)\n    #yaxis_abs3 = yaxis_abs3 + (plot_degradation_abs2[j][i],)\n    #error2 = error2 + (plot_degradation_error[j][i],)\n    #error3 = error3 + (plot_degradation_error2[j][i],)\n    #print numerator2,denominator2,numerator2/denominator2\n    #print denominator2/numerator2\n    #print j,i,plot_degradation[j][i]\n            #print (((numerator2/denominator2)-(numerator1/denominator1))/(numerator2/denominator2))*100\n#print np.mean(yaxis2)\n\n\ndel dictList_degradation_colocation\ndictList_degradation_colocation = defaultdict(lambda  : defaultdict(list))\n\nfor (b,a) in enumerate(fList5):\n    #print a\n    if a in colocationListBaseline:\n       #print a\n       index = a\n    else:\n        if a in benchListExperiments:\n            #print index,a\n            dictList_degradation_colocation[index][a].append(fList5[b+1])\n            #print dictList_degradation_colocation[index][a]\n\n#sorting the ground truth values\nfor a in xrange(0,len(runningList3),2):\n    j = runningList3[a+1]\n    i = runningList3[a]\n    dictList_degradation_colocation[j][i].sort()\n    #print j,i,dictList_degradation_colocation[j][i]\n\n\nfor a in xrange(0,len(runningList3),2):\n    j = runningList3[a+1]\n    i = runningList3[a]\n    print i,j\n    #print dictList_single_vm[i]\n    #print dictList_degradation_colocation[j][i]\n    #print dictList_degradation_shutter2[j][i]\n    denominator1 = sum(float(n) for (m,n) in enumerate(dictList_single_vm[i]) if m!=0 and m!=len(dictList_single_vm[i])-1)/(len(dictList_single_vm[i])-2)\n    numerator1 = sum(float(n) for (m,n) in enumerate(dictList_degradation_colocation[j][i]))/(len(dictList_degradation_colocation[j][i]))\n    shutter_temp_list = []\n    shutter_temp_list2 = []\n    colo_temp_list = []\n    colo_temp_list2 = []\n    degradation_temp_list = []\n    degradation_temp_list2 = []\n    error_temp_list = []\n    error_temp_list2 = []\n    #print numerator1\n    #print denominator1\n    #for (count,item) in enumerate(dictList_degradation_shutter2[j][i]):\n    #    if count%2==0:\n    #        colo_temp_list.append(item)\n    #    if count%2==1:\n    #        shutter_temp_list.append(item)\n\n    for (count,item) in enumerate(dictList_degradation_shutter4[j][i]):\n        if count%2==0:\n            colo_temp_list2.append(item)\n        if count%2==1:\n            shutter_temp_list2.append(item)\n\n    #for (count,item) in enumerate(shutter_temp_list):\n    #    degradation_temp_list.append(abs((((float(shutter_temp_list[count])/float(colo_temp_list[count]))-(numerator1/denominator1))/(float(shutter_temp_list[count])/float(colo_temp_list[count])))*100))\n\n    #shutter_temp_list.sort()\n    shutter_temp_list2.sort()\n    #colo_temp_list.sort()\n    colo_temp_list2.sort()\n\n    denominator3 = sum(float(n) for (m,n) in enumerate(shutter_temp_list2))/(len(shutter_temp_list2))\n    numerator3 = sum(float(n) for (m,n) in enumerate(colo_temp_list2))/(len(colo_temp_list2))\n    for (m,n) in enumerate(shutter_temp_list2):\n        ratio=float(n)/float(colo_temp_list2[m])\n        error_temp_list2.append(abs((((ratio)-(numerator3/denominator3))/(numerator1/denominator1))*100))\n    plot_degradation_error2[j][i]=np.std(error_temp_list2)\n\n    #print numerator2\n    #print denominator2\n    #del shutter_temp_list\n    #del colo_temp_list\n    #del degradation_temp_list\n    del shutter_temp_list2\n    del colo_temp_list2\n    del degradation_temp_list2\n    #plot_degradation[j][i] = (((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100\n    #plot_degradation_abs[j][i] = abs((((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100)\n    plot_degradation2[j][i] = (((numerator3/denominator3)-(numerator1/denominator1))/(numerator1/denominator1))*100\n    plot_degradation_abs2[j][i] = abs((((numerator3/denominator3)-(numerator1/denominator1))/(numerator1/denominator1))*100)\n    #print j,i,plot_degradation[j][i]\n    #print plot_degradation_error[j][i]\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    #xaxis2 = xaxis2 + (i,)\n    #yaxis2 = yaxis2 + (plot_degradation[j][i],)\n    #yaxis3 = yaxis3 + (plot_degradation2[j][i],)\n    #yaxis_abs2 = yaxis_abs2 + (plot_degradation_abs[j][i],)\n    #yaxis_abs3 = yaxis_abs3 + (plot_degradation_abs2[j][i],)\n    #error2 = error2 + (plot_degradation_error[j][i],)\n    #error3 = error3 + (plot_degradation_error2[j][i],)\n    #print numerator2,denominator2,numerator2/denominator2\n    #print denominator2/numerator2\n    #print j,i,plot_degradation[j][i]\n            #print (((numerator2/denominator2)-(numerator1/denominator1))/(numerator2/denominator2))*100\n\ndel dictList_degradation_colocation\ndictList_degradation_colocation = defaultdict(lambda  : defaultdict(list))\n\nfor (b,a) in enumerate(fList7):\n    #print a\n    if a in colocationListBaseline:\n       #print a\n       index = a\n    else:\n        if a in benchListExperiments:\n            #print index,a\n            dictList_degradation_colocation[index][a].append(fList7[b+1])\n            #print dictList_degradation_colocation[index][a]\n\n#sorting the ground truth values\nfor a in xrange(0,len(runningList3),2):\n    j = runningList3[a+1]\n    i = runningList3[a]\n    dictList_degradation_colocation[j][i].sort()\n    #print j,i,dictList_degradation_colocation[j][i]\n\n\nfor a in xrange(0,len(runningList3),2):\n    j = runningList3[a+1]\n    i = runningList3[a]\n    #print i,j\n    #print dictList_single_vm[i]\n    #print dictList_degradation_colocation[j][i]\n    #print dictList_degradation_shutter2[j][i]\n    denominator1 = sum(float(n) for (m,n) in enumerate(dictList_single_vm[i]) if m!=0 and m!=len(dictList_single_vm[i])-1)/(len(dictList_single_vm[i])-2)\n    numerator1 = sum(float(n) for (m,n) in enumerate(dictList_degradation_colocation[j][i]))/(len(dictList_degradation_colocation[j][i]))\n    shutter_temp_list = []\n    shutter_temp_list2 = []\n    colo_temp_list = []\n    colo_temp_list2 = []\n    degradation_temp_list = []\n    degradation_temp_list2 = []\n    error_temp_list = []\n    error_temp_list2 = []\n    #print numerator1\n    #print denominator1\n    for (count,item) in enumerate(dictList_degradation_shutter2[j][i]):\n        if count%2==0:\n            colo_temp_list.append(item)\n        if count%2==1:\n            shutter_temp_list.append(item)\n\n    #for (count,item) in enumerate(dictList_degradation_shutter4[j][i]):\n    #    if count%2==0:\n    #        colo_temp_list2.append(item)\n    #    if count%2==1:\n    #        shutter_temp_list2.append(item)\n\n    #for (count,item) in enumerate(shutter_temp_list):\n    #    degradation_temp_list.append(abs((((float(shutter_temp_list[count])/float(colo_temp_list[count]))-(numerator1/denominator1))/(float(shutter_temp_list[count])/float(colo_temp_list[count])))*100))\n\n    shutter_temp_list.sort()\n    #shutter_temp_list2.sort()\n    colo_temp_list.sort()\n    #colo_temp_list2.sort()\n    #print shutter_temp_list\n    #print colo_temp_list\n    #print dictList_degradation_shutter2[j][i]\n    denominator2 = sum(float(n) for (m,n) in enumerate(shutter_temp_list))/len(shutter_temp_list)\n    numerator2 = sum(float(n) for (m,n) in enumerate(colo_temp_list))/len(colo_temp_list)\n    for (m,n) in enumerate(shutter_temp_list):\n        ratio=float(n)/float(colo_temp_list[m])\n        error_temp_list.append(abs((((ratio)-(numerator1/denominator1))/(numerator1/denominator1))*100))\n    plot_degradation_error[j][i]=np.std(error_temp_list)\n\n    #denominator3 = sum(float(n) for (m,n) in enumerate(shutter_temp_list2))/(len(shutter_temp_list2))\n    #numerator3 = sum(float(n) for (m,n) in enumerate(colo_temp_list2))/(len(colo_temp_list2))\n    #for (m,n) in enumerate(shutter_temp_list2):\n    #    ratio=float(n)/float(colo_temp_list2[m])\n    #    error_temp_list2.append(abs((((ratio)-(numerator3/denominator3))/(numerator1/denominator1))*100))\n    #plot_degradation_error2[j][i]=np.std(error_temp_list2)\n\n    #print numerator2\n    #print denominator2\n    del shutter_temp_list\n    del colo_temp_list\n    del degradation_temp_list\n    #del shutter_temp_list2\n    #del colo_temp_list2\n    #del degradation_temp_list2\n    plot_degradation[j][i] = (((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100\n    plot_degradation_abs[j][i] = abs((((numerator2/denominator2)-(numerator1/denominator1))/(numerator1/denominator1))*100)\n    #plot_degradation2[j][i] = (((numerator3/denominator3)-(numerator1/denominator1))/(numerator1/denominator1))*100\n    #plot_degradation_abs2[j][i] = abs((((numerator3/denominator3)-(numerator1/denominator1))/(numerator1/denominator1))*100)\n    #print j,i,plot_degradation[j][i]\n    #print plot_degradation_error[j][i]\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    #xaxis = xaxis + (\'%s \\n %s\' %(i,j[16:]),)\n    #xaxis2 = xaxis2 + (i,)\n    #yaxis2 = yaxis2 + (plot_degradation[j][i],)\n    #yaxis3 = yaxis3 + (plot_degradation2[j][i],)\n    #yaxis_abs2 = yaxis_abs2 + (plot_degradation_abs[j][i],)\n    #yaxis_abs3 = yaxis_abs3 + (plot_degradation_abs2[j][i],)\n    #error2 = error2 + (plot_degradation_error[j][i],)\n    #error3 = error3 + (plot_degradation_error2[j][i],)\n    #print numerator2,denominator2,numerator2/denominator2\n    #print denominator2/numerator2\n    #print j,i,plot_degradation[j][i]\n            #print (((numerator2/denominator2)-(numerator1/denominator1))/(numerator2/denominator2))*100\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    xaxis2 = xaxis2 + (i,)\n    yaxis2 = yaxis2 + (plot_degradation[j][i],)\n    yaxis3 = yaxis3 + (plot_degradation2[j][i],)\n    yaxis_abs2 = yaxis_abs2 + (plot_degradation_abs[j][i],)\n    yaxis_abs3 = yaxis_abs3 + (plot_degradation_abs2[j][i],)\n    error2 = error2 + (plot_degradation_error[j][i],)\n    error3 = error3 + (plot_degradation_error2[j][i],)\n\n\nwidth=0.25\nx = np.arange(len(yaxis2))\nfig = plt.figure(figsize=(28, 5))\n#bar1 = plt.bar( x, yaxis, width, color="r", label=\'colocating with libquatum (avg = %.2f)\' %(np.mean(yaxis_abs)))\nbar1 = plt.bar( x, yaxis_abs3, width, color="k", yerr=error3, label=\'Shuttering (mean: %.2f)\' %(np.mean(yaxis_abs3)))\nbar2 = plt.bar( x+width, yaxis_abs2, width, color="lightgrey", yerr=error2, label=\'Snapshot (mean: %.2f)\' %(np.mean(yaxis_abs2)))\n#bar3 = plt.bar( x+width+width, yaxis3, width, color="g", label=\'colocating with sphinx  (avg = %.2f)\' %(np.mean(yaxis_abs3)))\n#autolabel(bar1)\n#autolabel(bar2)\nplt.ylabel( \'Estimation error (%)\' ,fontsize=\'25\')\n#plt.title(\'Error in predicting degradation when co-locating with libquantum\')\nplt.xticks(x + width/2.0, xaxis2, rotation=\'30\', size=\'23\',  ha=\'center\', va=\'top\')\n#plt.yticks((-0.5,0,1,2,3,4),(\'\',\'0\',\'1\',\'2\',\'3\',\'4\'),size=\'23\')\nplt.yticks(np.arange(0,50,10),size=\'25\')\nplt.ylim(0,40)\nplt.xlim(-1,26)\nplt.grid()\nplt.tight_layout()\nplt.legend(loc=9, ncol=2, prop={\'size\':28})\n#plt.savefig(\'mix_error.pdf\', dpi=125)'
p0
.I0
.S'$graph:overheadmix:Overheads :1'
p0
.S'from collections import defaultdict\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\nbenchList = [ \'gcc\', \'perlbench\', \'leslie3d\', \'povray\', \'libquantum\', \'astar\', \'bzip2\', \'milc\', \'namd\', \'calculix\', \'h264ref\', \'sphinx3\', \'zeusmp\', \'gobmk\', \'hmmer\', \'tonto\', \'bwaves\', \'gromacs\', \'dealII\', \'sjeng\', \'lbm\', \'xalancbmk\', \'gamess\', \'soplex\', \'GemsFDTD\', \'omnetpp\', \'mcf\', \'cactusADM\' ]\n\ncolocationList = [ \'colocating with libquantum\', \'colocating with mcf\',  \'colocating with milc\']\ncolocationListBaseline = [ \'colocating with libquantum\', \'colocating with mcf\', \'colocating with milc\' ]\n\nrunningList = [  \'perlbench\', \'colocating with milc\', \'mcf\', \'colocating with milc\', \'leslie3d\', \'colocating with milc\', \'povray\', \'colocating with milc\', \'libquantum\', \'colocating with milc\', \'astar\', \'colocating with milc\', \'bzip2\', \'colocating with milc\', \'milc\', \'colocating with milc\', \'namd\', \'colocating with milc\', \'calculix\', \'colocating with milc\', \'h264ref\', \'colocating with milc\', \'gobmk\', \'colocating with milc\', \'hmmer\', \'colocating with milc\', \'tonto\', \'colocating with milc\', \'sphinx3\', \'colocating with milc\', \'zeusmp\', \'colocating with milc\',    \'bwaves\', \'colocating with milc\', \'gromacs\', \'colocating with milc\', \'dealII\', \'colocating with milc\', \'sjeng\', \'colocating with milc\', \'lbm\', \'colocating with milc\', \'xalancbmk\', \'colocating with milc\', \'gamess\', \'colocating with milc\', \'cactusADM\', \'colocating with milc\', \'soplex\', \'colocating with milc\', \'GemsFDTD\', \'colocating with milc\', \'omnetpp\', \'colocating with milc\' ]\nrunningList2 = [  \'leslie3d\', \'colocating with milc\', \'milc\', \'colocating with milc\', \'namd\', \'colocating with milc\', \'calculix\', \'colocating with milc\', \'gobmk\', \'colocating with milc\', \'hmmer\', \'colocating with milc\', \'tonto\', \'colocating with milc\', \'sphinx3\', \'colocating with milc\', \'zeusmp\', \'colocating with milc\', \'bwaves\', \'colocating with milc\', \'gromacs\', \'colocating with milc\', \'dealII\', \'colocating with milc\', \'sjeng\', \'colocating with milc\', \'gamess\', \'colocating with milc\', \'cactusADM\', \'colocating with milc\', \'soplex\', \'colocating with milc\', \'GemsFDTD\', \'colocating with milc\' ]\nrunningList3 = [  \'perlbench\', \'colocating with milc\', \'mcf\', \'colocating with milc\', \'povray\', \'colocating with milc\', \'libquantum\', \'colocating with milc\', \'astar\', \'colocating with milc\', \'bzip2\', \'colocating with milc\', \'h264ref\', \'colocating with milc\',  \'lbm\', \'colocating with milc\', \'xalancbmk\', \'colocating with milc\', \'omnetpp\', \'colocating with milc\' ]\n\ndef autolabel(rects):\n    # attach some text labels\n    for rect in rects:\n        height = rect.get_height()\n        plt.text(rect.get_x()+rect.get_width()/2., 1.05*height, \'%.2f\'%float(height), fontsize=8 )\n\ndef autolabel2(rects):\n    # attach some text labels\n    for rect in rects:\n        height = rect.get_height()\n        plt.text(rect.get_x()+rect.get_width()/2., -1.25*height, \'%.2f\'%float(height),\n                ha=\'center\', va=\'top\', fontsize=8)\n        #plt.text(rect.get_x()+rect.get_width()/2., 1.05*height, \'%.2f\'%float(height))\n\n\nfilename = \'execution_time_1000\'\nfList1 = [s.strip() for s in open(\'../../papergraphs/mixcorunner/degradation/%s.txt\' % filename).readlines()]  #degradation\nfList2 = [s.strip() for s in open(\'../../papergraphs/mixcorunner/snapshot/phase_change_10.txt\').readlines()]\nfList3 = [s.strip() for s in open(\'../../papergraphs/mixcorunner/priorwork/execution_time_4.txt\').readlines()] #prior work\nfList4 = [s.strip() for s in open(\'../../papergraphs/mixcorunner/degradation/execution_time_100.txt\').readlines()]  #degradation\n#fList3 = [s.strip() for s in open(\'experiment_libquantum/phase_changes_5.txt\').readlines()]\n##fList3 = [s.strip() for s in open(\'../../papergraphs/2.fullspec/overhead/experiment_mcf/%s.txt\' % filename).readlines()]\n##fList4 = [s.strip() for s in open(\'../../papergraphs/2.fullspec/overhead/experiment_mcf/phase_changes_5.txt\').readlines()]\n##fList5 = [s.strip() for s in open(\'../../papergraphs/2.fullspec/overhead/experiment_sphinx3/%s.txt\' % filename).readlines()]\n##fList6 = [s.strip() for s in open(\'../../papergraphs/2.fullspec/overhead/experiment_sphinx3/phase_changes_5.txt\').readlines()]\n#print fList1\n\n\nexecution_time_shutter = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter = defaultdict(lambda  : defaultdict(list))\navg_execution_time_shutter = defaultdict(dict)\nexecution_time_shutter2 = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter2 = defaultdict(lambda  : defaultdict(list))\navg_execution_time_shutter2 = defaultdict(dict)\ndictList_phase_change = defaultdict(lambda  : defaultdict(list))\ndictList_phase_change2 = defaultdict(lambda  : defaultdict(list))\noverhead_snapshot = defaultdict(lambda  : defaultdict(list))\noverhead_shutter = defaultdict(lambda  : defaultdict(list))\n\nstd_execution_time = defaultdict(dict)\n\ndef print_elapsed_time_shutter(time_shutter):\n    for j in colocationList:\n        for i in benchList:\n            print \'%s ||||  %s\'%(j,i)\n            print time_shutter[j][i]\n\n\nsep = \'u\'\nfor (b,a) in enumerate(fList1):\n    #print a\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            execution_time_shutter[index][a].append((fList1[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_shutter[\'colocating with mcf\'][\'perlbench\']\n#print((s.split(start))[1].split(end)[0])\n\nfor j in colocationList:\n    for i in benchList:\n        #print i\n        for k in execution_time_shutter[j][i]:\n            try:\n                #print k\n                m,s = [float (var) for var in k.split(\':\')]\n                temp = m*60 + s\n            except:\n                h,m,s = [float (var) for var in k.split(\':\')]\n                temp = h*3600 + m*60 + s\n            execution_time_sec_shutter[j][i].append(temp)\n\nfor (b,a) in enumerate(fList3):\n    #print a\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            #print index\n            #print a\n            execution_time_shutter2[index][a].append((fList3[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_shutter[\'colocating with mcf\'][\'perlbench\']\n#print((s.split(start))[1].split(end)[0])\n\nfor j in colocationList:\n    for i in benchList:\n        for k in execution_time_shutter2[j][i]:\n            #print k\n            try:\n                m,s = [float (var) for var in k.split(\':\')]\n                temp = m*60 + s\n            except:\n                h,m,s = [float (var) for var in k.split(\':\')]\n                temp = h*3600 + m*60 + s\n            execution_time_sec_shutter2[j][i].append(temp)\n\nfor (b,a) in enumerate(fList2):\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            dictList_phase_change[index][a].append(fList2[b+1])\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    #print j,i\n    for elem in dictList_phase_change[j][i]:\n        dictList_phase_change2[j][i].extend(elem.strip().split(\'\\t\'))\n    #print dictList_phase_change2[j][i]\n\nyaxis = ()\nyaxis2= ()\nyaxis_abs = ()\nerror = ()\nxaxis = ()\n#print dictList_phase_change2[\'colocating with mcf\'][\'perlbench\']\nfor a in xrange(0,len(runningList2),2):\n    j = runningList2[a+1]\n    i = runningList2[a]\n    #print j,i\n    #print dictList_phase_change2[j][i]\n    #print i,j\n    shutter_temp_list = []\n    colo_temp_list = []\n    for (count,item) in enumerate(dictList_phase_change2[j][i]):\n        if count%2==1:\n            colo_temp_list.append(float(item))\n        if count%2==0:\n            shutter_temp_list.append(float(item))\n    #print shutter_temp_list\n    shutter_avg = sum(shutter_temp_list)/len(shutter_temp_list)\n    colocation_avg = sum(colo_temp_list)/len(colo_temp_list)\n    del shutter_temp_list\n    del colo_temp_list\n\n    pause_period = ((colocation_avg ) + ((shutter_avg + (colocation_avg * 2)/3) * 3))/4\n    #xaxis = xaxis + (i,)\n    #print (pause_period/np.mean(execution_time_sec_shutter[j][i]))*10\n    overhead_snapshot[j][i] = (pause_period/np.mean(execution_time_sec_shutter[j][i]))*7.5\n    overhead_shutter[j][i] = abs(((np.mean(execution_time_sec_shutter2[j][i])/np.mean(execution_time_sec_shutter[j][i])) - 1)*100)\n    #yaxis = yaxis + ( (pause_period/np.mean(execution_time_sec_shutter[j][i]))*7.5  ,)\n    #yaxis2 = yaxis2 + ( abs(((np.mean(execution_time_sec_shutter2[j][i])/np.mean(execution_time_sec_shutter[j][i])) - 1)*100), )\n    #print \'---------------------\'\n\n\nfor a in xrange(0,len(runningList3),2):\n    j = runningList3[a+1]\n    i = runningList3[a]\n    #print j,i,execution_time_sec_shutter2[j][i],execution_time_sec_shutter[j][i]\n\n    #pause_period = ((colocation_avg ) + ((shutter_avg + (colocation_avg * 2)/3) * 3))/4\n    #xaxis = xaxis + (i,)\n    #print (pause_period/np.mean(execution_time_sec_shutter[j][i]))*10\n    #yaxis = yaxis + ( (pause_period/np.mean(execution_time_sec_shutter[j][i]))*7.5  ,)\n    overhead_shutter[j][i] = abs(((np.mean(execution_time_sec_shutter2[j][i])/np.mean(execution_time_sec_shutter[j][i])) - 1)*100)\n    #yaxis2 = yaxis2 + ( abs(((np.mean(execution_time_sec_shutter2[j][i])/np.mean(execution_time_sec_shutter[j][i])) - 1)*100), )\n#print np.mean(yaxis)\n\ndel execution_time_shutter\ndel execution_time_sec_shutter\n\nexecution_time_shutter = defaultdict(lambda  : defaultdict(list))\nexecution_time_sec_shutter = defaultdict(lambda  : defaultdict(list))\n\n\nsep = \'u\'\nfor (b,a) in enumerate(fList4):\n    #print a\n    if a in colocationList:\n        index = a\n    else:\n        if a in benchList:\n            execution_time_shutter[index][a].append((fList4[b+4].split(\'system \'))[1].split(\'elapsed\')[0])\n\n#print execution_time_shutter[\'colocating with mcf\'][\'perlbench\']\n#print((s.split(start))[1].split(end)[0])\n\nfor j in colocationList:\n    for i in benchList:\n        #print i\n        for k in execution_time_shutter[j][i]:\n            try:\n                #print k\n                m,s = [float (var) for var in k.split(\':\')]\n                temp = m*60 + s\n            except:\n                h,m,s = [float (var) for var in k.split(\':\')]\n                temp = h*3600 + m*60 + s\n            execution_time_sec_shutter[j][i].append(temp)\n\nfor a in xrange(0,len(runningList3),2):\n    j = runningList3[a+1]\n    i = runningList3[a]\n    #print j,i\n    #print dictList_phase_change2[j][i]\n    #print i,j\n    shutter_temp_list = []\n    colo_temp_list = []\n    for (count,item) in enumerate(dictList_phase_change2[j][i]):\n        if count%2==1:\n            colo_temp_list.append(float(item))\n        if count%2==0:\n            shutter_temp_list.append(float(item))\n    #print shutter_temp_list\n    shutter_avg = sum(shutter_temp_list)/len(shutter_temp_list)\n    colocation_avg = sum(colo_temp_list)/len(colo_temp_list)\n    del shutter_temp_list\n    del colo_temp_list\n\n    pause_period = ((colocation_avg ) + ((shutter_avg + (colocation_avg * 2)/3) * 3))/4\n    #xaxis = xaxis + (i,)\n    #print (pause_period/np.mean(execution_time_sec_shutter[j][i]))*10\n    #yaxis = yaxis + ( (pause_period/np.mean(execution_time_sec_shutter[j][i]))*7.5  ,)\n    overhead_snapshot[j][i] = (pause_period/np.mean(execution_time_sec_shutter[j][i]))*7.5\n    #yaxis2 = yaxis2 + ( abs(((np.mean(execution_time_sec_shutter2[j][i])/np.mean(execution_time_sec_shutter[j][i])) - 1)*100), )\n\nfor a in xrange(0,len(runningList),2):\n    j = runningList[a+1]\n    i = runningList[a]\n    xaxis = xaxis + (i,)\n    yaxis = yaxis + ( overhead_snapshot[j][i]  ,)\n    yaxis2 = yaxis2 + ( overhead_shutter[j][i], )\n\nprint yaxis\nprint yaxis2\n\n\nwidth = 0.25\nx = np.arange(len(yaxis))\nfig = plt.figure(figsize=(28, 5))\nbar2 = plt.bar( x, yaxis2, width, color="k", label=\'Shuttering  (mean: %.2f)\' %(np.mean(yaxis2)))\nbar1 = plt.bar( x+width, yaxis, width, color="lightgrey", label=\'Snapshot (mean: %.2f)\' %(np.mean(yaxis) ))\n#bar3 = plt.bar( x+width+width, yaxis3, width, color="g", label=\' colocating with sphinx3 (avg = %.1f)\' %(np.mean(yaxis3)))\n##bar3 = plt.bar( x+width+width, yaxis3, width, color="g", label=\'4 corunners (avg is %.1f)\' %(np.mean(yaxis3) ))\n##autolabel2(bar1)\n##autolabel(bar2)\n##autolabel2(bar3)\nplt.ylabel( \'Execution time \\n overhead(%)\',fontsize=23)\n#plt.title(\'Overhead due to Prediction of degradation while co-running with milc\')\nplt.xticks(x + width/2.0, xaxis, rotation=\'30\', size=\'23\', ha=\'center\')\n#plt.yticks((-5,0,10,20,30,40,50,60),(\'\',\'0\',\'10\',\'20\',\'30\',\'40\',\'50\',\'60\'),size=\'25\')\nplt.yticks((0,5,10,15),(\'0\',\'5\',\'10\',\'15\'),size=\'25\')\nplt.xlim(-1,27)\nplt.grid()\nplt.legend(loc=9, ncol=2, prop={\'size\':28})\nplt.tight_layout()\n#plt.savefig(\'milc_overhead.pdf\', dpi=125)\n'
p0
.I0
.S'Explanation'
p0
.S'$p: \nIn this section, we evaluate the execution time overhead incurred by our runtime system. Figure~\\ref{fig:Overhead} compares the overhead estimating performance degradation in co-located environments when using shuttering and \\textit{snapshots}. Each sub figure indicates the different co-runners, \\texttt{libquantum}, \\texttt{mcf}, and \\texttt{milc}, respectively. We can see that the overhead of our \\textit{snapshot} technique is negligible. Even with \\texttt{libquantum}, which is known to be highly contentious, the average across all applications is 0.34\\%. Even though shuttering has low overhead for quite a few applications, some of them such as \\texttt{mcf}, \\texttt{lbm}, \\texttt{cactusADM}, \\texttt{GemsFDTD}, and \\texttt{omnetpp} exhibit high execution time overhead. The reason why the overhead is high in shuttering is that the number of cache misses increases due to the frequent pausing of co-runners. When running with \\texttt{mcf} or \\texttt{milc}, which is known to be less cache contentious than \\texttt{libquantum}, Figure~\\ref{fig:overheadmcf} and ~\\ref{fig:overheadmilc} show the decreased overhead of shuttering.\n\n\n%In this section, we evaluate the overhead in execution time due to our runtime system when it tries to estimate performance degradation in co-located environments. Figure \\ref{fig:Overhead} shows the overhead in the execution time while estimating degradation in to co-located environments due to our runtime system. We are able to clearly see that the overhead here is negligible. The overhead due to our mechanism is much lesser in most of the cases compared to the prior technique. In \\textit{precise shuttering}, the average overhead when the applications are co-located with libquantum is 3.62\\%. This is 7x more than the average overhead due to snapshot shuttering technique with the same co-runner. Most of this overhead is due to the cache misses incurred due to the frequent pausing of co-runners. This can be clearly seen from Figures \\ref{fig:overheadlibquantum} and \\ref{fig:overheadmcf}. As mcf is much less cache contentious than libquantum the overheads of \\textit{precise shuttering} is much lesser for mcf than for libquantum. '
p0
.I0
.S'mcf'
p0
.S'$p:\nOn the other hand, the overhead of \\textit{snapshot} is slightly higher than the overhead of shuttering when running with \\texttt{mcf}. This is due to the fact that \\texttt{mcf} has a lot of inherent phase changes. As a result, three instances of \\texttt{mcf} as co-runners will lead towards frequently pausing the co-runners. We also observe that for applications such as \\texttt{calculix} and \\texttt{dealII}, the overhead of \\textit{snapshot} is slightly higher than other applications. The reason behind this is the fact that both applications exhibit highly irregular phases and the number of false positives is high.'
p0
.I0
.S'libquantum and milc'
p0
.S'$p: \nWhen running with \\texttt{libquantum} and \\texttt{milc}, most applications show the overhead less than 0.5\\% because these applications have a single phase throughout their execution. Therefore, the total pausing time while executing these applications is negligible.  Figure~\\ref{fig:lbmsnapshotlib} shows that \\texttt{lbm} has a single phase. Our runtime only pauses the co-runners at its initial execution period to obtain solo CPI of \\texttt{lbm}. There is no subsequent shuttering because of the absence of phase changes. Such a case incurs an extremely low overhead of around 0.1\\%.'
p0
.I0
.S'Accuracy and overhead of different co-runners'
p0
.S'$s:Accuracy and Overheads of Different Types of Multiple Co-runners'
p0
.I2
.S'$omit!Mixed co-runners'
p0
.S'$p: Figure \\ref{fig:accuracymix} and \\ref{fig:overheadmix} shows the accuracy of a subset of SPEC applications when it is executed with different co-runners in different VMs. From those figures, we can clearly see that, accuracy remains unaffected when we are executing different application on different VMs. To stress test the overheads for the worst possible scenario, we executed 4 applications from SPEC which has the most frequent phase changes. From the figure we are able to see that even when there are frequent phase changes, the overhead due to our runtime is less than 8 \\% in any situation. '
p0
.I0
.S'Mixed co-runners'
p0
.S'$p: To see the effectiveness when running with multiple different co-runners, we evaluate the accuracy and overheads of every individual application present in SPEC when running along with 3 different co-runners \\texttt{libquantum, milc} and \\texttt{m}cf respectively in 3 different VMs on the same server. These 3 co-runners are selected based on covering a range of properties like contentiousness and sensitivity towards the last level cache and the number of inherent phase changes present in the co-running applications. Figure~\\ref{fig:mixcorunners} shows the accuracy and overheads of SPEC applications when running with multiple different co-runners. Even with three different co-runners, we can see that our \\textit{snapshot} achieves high accuracy with negligible overhead. \n'
p0
.I0
.S'Related Work'
p0
.S'$s: Related Work'
p0
.I3
.S'Summary'
p0
.S'$p:There have been many prior studies to detect performance interference in a variety aspects of architectural resources. We categorize the prior work into two broad types. We look first into the system and OS level approaches and then address the architectural supports for detecting the interference. \n'
p0
.I0
.S'System and OS'
p0
.S'$p: {\\bf System/OS  approaches: } There are many efforts introducing software frameworks and proposing the new designs of operating systems~\\cite{Govindan:2011:CQE:2038916.2038938,bubbleup,Yang:2013:BPO:2485922.2485974,Tang:2013:RRS:2451116.2451126,Nathuji:2010:QMP:1755913.1755938, Park:2013:RCH:2451116.2451137, Liu:2014:GVM:2665671.2665698}. \nQ-Cloud measures the resource capacity for satisfying QoS in a dedicated server called staging server and then decides the placement which server will be profitable to minimize the interference. Nevertheless, the QoS could be violated by allowing co-location. To avoid this situation, the system provides additional resources from head-room by reserving presubscribed amount of resources. If the placement meets the target QoS, the head-room would be utilized in a best-effort manner~\\cite{Nathuji:2010:QMP:1755913.1755938}. To  precisely estimate the performance interferences without profiling on a dedicated server, Bubble-up~\\cite{bubbleup} and Cuanta~\\cite{Govindan:2011:CQE:2038916.2038938} designed the synthetic workloads to understand the degree of interference when co-locating applications. Bubble-up probes the interference by using synthetic workloads and determines whether to allow co-location or not so as to meet the QoS of latency critical applications running on datacenters. POPPA~\\cite{fairpricing} and QualityTime~\\cite{6844481} proposed similar runtime approaches to measure performance of each application in co-located environment. The most accurate way of measuring performance for an individual application is to observe its solo execution. They perceived this concept by pausing other co-runners during a small amount of time. Then, the target application can monopolize resources without any interference. Meanwhile, Soares et al. studied the concept of pollute buffer in shared last level caches to prevent filling the shared caches as non-reusable data. It focused on improving the utilization of shared caches through OS-level page allocation~\\cite{Soares:2008:RHE:1521747.1521800}. Zhuravlev et al. extended the CPU scheduler to alleviate the degree of interferences in a native system. The goal of this work is to schedule the threads by evenly distributing the load intensity to caches~\\cite{Zhuravlev:2010:ASR:1736020.1736036}. Blagodurov et al. proposed that the scheduler needs to consider the effects of NUMA~\\cite{Blagodurov:2011:CNC:2002181.2002182}. Also, there are many prior studies to solve the contention problems such as shared last level cache and NUMA by scheduling virtual machines~\\cite{Ahn:2012:DVM:2342763.2342782,6522328,Liu:2014:OVM:2665671.2665720}.'
p0
.I0
.S'Architectural supports'
p0
.S'$p: {\\bf Architectural Supports: } There are various approaches mitigating performance interference and guaranteeing fairness in shared caches, memory controller and bandwidth. \nNesbit et al. employed the network fair queuing model in the memory scheduler to meet the fairness~\\cite{Nesbit:2006:FQM}. Mutlu and Moscibroda focused on DRAM specific architectures such as row buffers and multi banks~\\cite{stfm}. They pointed out that modern DRAM controllers only consider maximizing throughputs instead of fairness. To alleviate the problem, they introduced the memory scheduling technique to ensure the fairness between threads. Ebrahimi et al. extended the fairness problem in memory subsystems by including shared last level cache and memory bandwidth~\\cite{fst}. This work focused on the source incurring performance interference and proposed throttling mechanism by controlling injection rates of requests to alleviate the contention of shared resources. \nSuh et al. firstly discussed the cache partitioning scheme to efficiently use the shared resources~\\cite{Suh:2002:NMM:874076.876484}. Qureshi et al. proposed utility based cache partitioning technique to achieve high performance~\\cite{Qureshi:2006:UCP:1194816.1194855}. They developed utility monitors to track the efficiency of caches for each application and then decided the degree of cache partitioning to minimize the total cache misses from all applications. Rafique et al. studied the cache and bandwidth managements by cooperating operating system and hardware~\\cite{Rafique:2006:ASO:1152154.1152160,Rafique:2007:EMD:1299042.1299052 }. To prevent the replacement from other applications, the pinning way in cache was introduced~\\cite{Srikantaiah:2008:ASP:1346281.1346299}. Recently, to minimize the effects of cache pollutions, virtualization-aware prefetching techniques are introduced~\\cite{Daly,ReCap,Ahn:2014:MVP:2742155.2742195}.'
p0
.I0
.S'Conclusion'
p0
.S'$s: Conclusion '
p0
.I1
.S'conclusion'
p0
.S'$p:\nIn public clouds, the application performance of users can be easily affected by other applications belonging to different users. \nNevertheless, public cloud providers do not control the unintended performance degradation. It leads to a biased pricing scenario. \nThis work presented Fair Pricing Runtime, a novel approach to estimate performance degradation of each application in co-located environments and then we reflect the amount of unintended performance degradation on their price. \nFair Pricing Runtime has negligible performance overhead and operates without any special hardware or programmer supports. Using this mechanism, we could estimate performance degradation with 4\\% mean absolute error with a very low overhead of around 1\\%. \n'
p0
.I0
.S'Bibliography'
p0
.S'$bib:\n@article{Barroso:2007:CEC:1339817.1339894,\n author = {Barroso, Luiz Andr{\\\'e} and H\\"{o}lzle, Urs},\n title = {The Case for Energy-Proportional Computing},\n journal = {Computer},\n issue_date = {December 2007},\n volume = {40},\n number = {12},\n month = dec,\n year = {2007},\n issn = {0018-9162},\n pages = {33--37},\n numpages = {5},\n url = {http://dx.doi.org/10.1109/MC.2007.443},\n doi = {10.1109/MC.2007.443},\n acmid = {1339894},\n publisher = {IEEE Computer Society Press},\n address = {Los Alamitos, CA, USA},\n keywords = {energy-proportional computing, green computing, green computing, energy-proportional computing},\n} \n\n@inproceedings{Farley:2012:MYM:2391229.2391249,\n author = {Farley, Benjamin and Juels, Ari and Varadarajan, Venkatanathan and Ristenpart, Thomas and Bowers, Kevin D. and Swift, Michael M.},\n title = {More for Your Money: Exploiting Performance Heterogeneity in Public Clouds},\n booktitle = {Proceedings of the Third ACM Symposium on Cloud Computing},\n series = {SoCC \'12},\n year = {2012},\n isbn = {978-1-4503-1761-0},\n location = {San Jose, California},\n pages = {20:1--20:14},\n articleno = {20},\n numpages = {14},\n url = {http://doi.acm.org/10.1145/2391229.2391249},\n doi = {10.1145/2391229.2391249},\n acmid = {2391249},\n publisher = {ACM},\n address = {New York, NY, USA},\n keywords = {cloud computing, heterogeneity, virtual machine migration},\n} \n\n@article{Henning:2006:SCB:1186736.1186737,\n author = {Henning, John L.},\n title = {SPEC CPU2006 Benchmark Descriptions},\n journal = {SIGARCH Comput. Archit. News},\n issue_date = {September 2006},\n volume = {34},\n number = {4},\n month = sep,\n year = {2006},\n issn = {0163-5964},\n pages = {1--17},\n numpages = {17},\n url = {http://doi.acm.org/10.1145/1186736.1186737},\n doi = {10.1145/1186736.1186737},\n acmid = {1186737},\n publisher = {ACM},\n address = {New York, NY, USA},\n}\n\n@inproceedings{Brankovic:2014:AOP:2597917.2597937,\n author = {Brankovi\\\'{c}, Aleksandar and Stavrou, Kyriakos and Gibert, Enric and Gonz\\\'{a}lez, Antonio},\n title = {Accurate Off-line Phase Classification for HW/SW Co-designed Processors},\n booktitle = {Proceedings of the 11th ACM Conference on Computing Frontiers},\n series = {CF \'14},\n year = {2014},\n isbn = {978-1-4503-2870-8},\n location = {Cagliari, Italy},\n pages = {5:1--5:10},\n articleno = {5},\n numpages = {10},\n url = {http://doi.acm.org/10.1145/2597917.2597937},\n doi = {10.1145/2597917.2597937},\n acmid = {2597937},\n publisher = {ACM},\n address = {New York, NY, USA},\n keywords = {HW/SW co-designed processors, dynamic binary translation, simulation, warm-up methodology},\n} \n\n@article{DBLP:journals/corr/abs-0909-1784,\n  author    = {Stavros Harizopoulos and\n               Mehul A. Shah and\n               Justin Meza and\n               Parthasarathy Ranganathan},\n  title     = {Energy Efficiency: The New Holy Grail of Data Management Systems Research},\n  journal   = {CoRR},\n  volume    = {abs/0909.1784},\n  year      = {2009},\n  url       = {http://arxiv.org/abs/0909.1784},\n  timestamp = {Mon, 05 Dec 2011 18:05:25 +0100},\n  biburl    = {http://dblp.uni-trier.de/rec/bib/journals/corr/abs-0909-1784},\n  bibsource = {dblp computer science bibliography, http://dblp.org}\n}\n\n@inproceedings{Balasubramonian:2000:MHR:360128.360153,\n author = {Balasubramonian, Rajeev and Albonesi, David and Buyuktosunoglu, Alper and Dwarkadas, Sandhya},\n title = {Memory Hierarchy Reconfiguration for Energy and Performance in General-purpose Processor Architectures},\n booktitle = {Proceedings of the 33rd Annual ACM/IEEE International Symposium on Microarchitecture},\n series = {MICRO 33},\n year = {2000},\n isbn = {1-58113-196-8},\n location = {Monterey, California, USA},\n pages = {245--257},\n numpages = {13},\n url = {http://doi.acm.org/10.1145/360128.360153},\n doi = {10.1145/360128.360153},\n acmid = {360153},\n publisher = {ACM},\n address = {New York, NY, USA},\n} \n\n@INPROCEEDINGS{1402088, \nauthor={Nagpurkar, P. and Krintz, C. and Sherwood, T.}, \nbooktitle={Code Generation and Optimization, 2005. CGO 2005. International Symposium on}, \ntitle={Phase-aware remote profiling}, \nyear={2005}, \nmonth={March}, \npages={191-202}, \nkeywords={Internet;embedded systems;optimising compilers;ubiquitous computing;Internet;Web-enabled mobile phone;battery-powered device;embedded device technology;energy consumption;hardware-software scheme;intelligent online sampling;meta information;personal digital assistants;phase-aware remote profiling;ubiquitous computing;Computer science;Energy consumption;IP networks;Information analysis;Mobile handsets;Optimizing compilers;Personal digital assistants;Programming;Sampling methods;Ubiquitous computing}, \ndoi={10.1109/CGO.2005.26},}\n\n\n@TECHREPORT{Qumranet2007,\n  author = {Qumranet},\n  title = {KVM: Kernel-based Virtualization Machine},\n  institution = {Qumranet},\n  year = {2007},\n  url = {http://www.qumranet.com/files/Qumranet_WhitePaper_03.pdf}\n}\n\n@INPROCEEDINGS{6114207, \nauthor={Sembrant, A. and Eklov, D. and Hagersten, E.}, \nbooktitle={Workload Characterization (IISWC), 2011 IEEE International Symposium on}, \ntitle={Efficient software-based online phase classification}, \nyear={2011}, \nmonth={Nov}, \npages={104-115}, \nkeywords={program diagnostics;sampling methods;ScarPhase;hardware-assisted phase detection;low overhead phase detection;online phase detection library;runtime data collection;runtime phases;sample-based analysis;sample-based classification;software-based online phase classification;time-varying behavior;Benchmark testing;Hardware;Phase detection;Radiation detectors;Runtime;Support vector machine classification;Vectors}, \ndoi={10.1109/IISWC.2011.6114207},}\n\n\n@INPROCEEDINGS{6522315, \nauthor={Sandberg, A. and Sembrant, A. and Hagersten, E. and Black-Schaffer, D.}, \nbooktitle={High Performance Computer Architecture (HPCA2013), 2013 IEEE 19th International Symposium on}, \ntitle={Modeling performance variation due to cache sharing}, \nyear={2013}, \nmonth={Feb}, \npages={155-166}, \nkeywords={bandwidth allocation;cache storage;multiprocessing systems;performance evaluation;application phases;average relative error;bandwidth consumption;bandwidth demands;cache sharing;cache sharing performance model;contemporary multicore machine;corunning application bandwidth demands;performance interactions;performance variability effects;performance variation modeling;phase-aware isolation;shared cache contention;Bandwidth;Benchmark testing;Data models;Hardware;Interference;Phase detection;Vectors}, \ndoi={10.1109/HPCA.2013.6522315}, \nISSN={1530-0897},}\n\n@ARTICLE{1528455, \nauthor={Isci, C. and Buyuktosunoglu, A. and Martonosi, M.}, \njournal={Micro, IEEE}, \ntitle={Long-term workload phases: duration predictions and applications to DVFS}, \nyear={2005}, \nmonth={Sept}, \nvolume={25}, \nnumber={5}, \npages={39-51}, \nkeywords={resource allocation;system monitoring;DVFS;adaptive dynamic management;computer systems;duration predictions;hardware performance counters;long-term workload phases;server-class systems;system response prediction;workload behavior prediction;Adaptive systems;Benchmark testing;Costs;Dynamic voltage scaling;Extrapolation;Frequency;Large-scale systems;Load management;Prediction methods;Stability criteria;Adaptive dynamic management;DVFS;duration predictions;performance counters;prediction techniques;workload behavior}, \ndoi={10.1109/MM.2005.93}, \nISSN={0272-1732},}\n\n@INPROCEEDINGS{1238018, \nauthor={Duesterwald, E. and Torrellas, J. and Dwarkadas, S.}, \nbooktitle={Parallel Architectures and Compilation Techniques, 2003. PACT 2003. Proceedings. 12th International Conference on}, \ntitle={Characterizing and predicting program behavior and its variability}, \nyear={2003}, \nmonth={Sept}, \npages={220-231}, \nkeywords={adaptive systems;software metrics;system monitoring;SPECcpu 2000;adaptive systems;cross-metric predictors;hardware counters;instructions;microarchitectures;optimization;program time-varying behavior prediction;statistical predictors;table-based predictors;Adaptive systems;Aggregates;Application software;Computer architecture;Counting circuits;Energy efficiency;Hardware;Optimizing compilers;Resource management;Software systems}, \ndoi={10.1109/PACT.2003.1238018}, \nISSN={1089-795X},}\n\n@inproceedings{37124,\ntitle = {The Impact of Memory Subsystem Resource Sharing on Datacenter Applications},\nauthor  = {Lingjia Tang and Jason Mars and Neil Vachharajani and Robert Hundt and Mary-Lou Soffa},\nyear  = 2011,\nbooktitle = {ISCA}\n}\n\n@inproceedings{reqos,\nauthor = {Tang, Lingjia and Mars, Jason and Wang, Wei and Dey, Tanima and Soffa, Mary Lou},\ntitle = {ReQoS: Reactive Static/Dynamic Compilation for QoS in Warehouse Scale Computers},\nbooktitle = {Proceedings of the Eighteenth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS)},\nseries = {ASPLOS \'13},\nyear = {2013},\nisbn = {978-1-4503-1870-9},\nlocation = {Houston, Texas, USA},\npages = {89--100},\nnumpages = {12},\nurl = {http://doi.acm.org/10.1145/2451116.2451126},\ndoi = {10.1145/2451116.2451126},\nacmid = {2451126},\npublisher = {ACM},\naddress = {New York, NY, USA},\nkeywords = {compiler, contention, cross-core interference, datacenter, dynamic techniques, multicore, online adaptation, quality of service, runtime systems, warehouse scale computers},\nnote = {Acceptance Rate: 23%},\n}\n\n@inproceedings{mars13isca,\nauthor = {Mars, Jason and Tang, Lingjia},\ntitle = {Whare-map: Heterogeneity in "Homogeneous" Warehouse-scale Computers},\nbooktitle = {Proceedings of the 40th Annual International Symposium on Computer Architecture (ISCA)},\nseries = {ISCA \'13},\nyear = {2013},\nisbn = {978-1-4503-2079-5},\nlocation = {Tel-Aviv, Israel},\npages = {619--630},\nnumpages = {12},\nurl = {http://doi.acm.org/10.1145/2485922.2485975},\ndoi = {10.1145/2485922.2485975},\nacmid = {2485975},\npublisher = {ACM},\naddress = {New York, NY, USA},\nnote = {Acceptance Rate: 19% - Featured in Wired Magazine!},\n}\n\n@article{percycle,\n author = {Du Bois, Kristof and Eyerman, Stijn and Eeckhout, Lieven},\n title = {Per-thread Cycle Accounting in Multicore Processors},\n journal = {ACM Trans. Archit. Code Optim.},\n issue_date = {January 2013},\n volume = {9},\n number = {4},\n month = jan,\n year = {2013},\n issn = {1544-3566},\n pages = {29:1--29:22},\n articleno = {29},\n numpages = {22},\n url = {http://doi.acm.org/10.1145/2400682.2400688},\n doi = {10.1145/2400682.2400688},\n acmid = {2400688},\n publisher = {ACM},\n address = {New York, NY, USA},\n keywords = {Multicore processors, hardware/software interface, interference, performance analysis, resource sharing, scheduling},\n} \n\n\n\n\n\n\n@inproceedings{mise,\n author = {Subramanian, Lavanya and Seshadri, Vivek and Kim, Yoongu and Jaiyen, Ben and Mutlu, Onur},\n title = {MISE: Providing Performance Predictability and Improving Fairness in Shared Main Memory Systems},\n booktitle = {Proceedings of the 2013 IEEE 19th International Symposium on High Performance Computer Architecture (HPCA)},\n series = {HPCA \'13},\n year = {2013},\n isbn = {978-1-4673-5585-8},\n pages = {639--650},\n numpages = {12},\n url = {http://dx.doi.org/10.1109/HPCA.2013.6522356},\n doi = {10.1109/HPCA.2013.6522356},\n acmid = {2495485},\n publisher = {IEEE Computer Society},\n address = {Washington, DC, USA},\n} \n\n\n\n\n@inproceedings{Bellard:2005:QFP:1247360.1247401,\n author = {Bellard, Fabrice},\n title = {QEMU, a Fast and Portable Dynamic Translator},\n booktitle = {Proceedings of the Annual Conference on USENIX Annual Technical Conference},\n series = {ATEC \'05},\n year = {2005},\n location = {Anaheim, CA},\n pages = {41--41},\n numpages = {1},\n url = {http://dl.acm.org/citation.cfm?id=1247360.1247401},\n acmid = {1247401},\n publisher = {USENIX Association},\n address = {Berkeley, CA, USA},\n} \n\n@INPROCEEDINGS{6621127, \nauthor={Gupta, A. and Sampson, J. and Taylor, M.B.}, \nbooktitle={Embedded Computer Systems: Architectures, Modeling, and Simulation (SAMOS XIII), 2013 International Conference on}, \ntitle={TimeCube: A manycore embedded processor with interference-agnostic progress tracking}, \nyear={2013}, \nmonth={July}, \npages={227-236}, \nkeywords={cloud computing;embedded systems;interference;microprocessor chips;multiprocessing systems;resource allocation;48-core SCC;CPU-time decorrelation;Progress Time;Tilera Tile Gx100;TimeCube processor;cloud services;dynamic execution isolation;embedded computing;interference-agnostic progress tracking;low-power embedded processors;manycore chips;manycore embedded processor;microarchitectural resources;microarchitectural structures;multicore processors;online architectural resource management;shadow performance modeling;space-multiplexed systems;throughput improvement;Bandwidth;Channel allocation;Embedded systems;Interference;Prefetching;Random access memory;Resource management}, \ndoi={10.1109/SAMOS.2013.6621127},}\n\n@inproceedings{Solihin:1999:SPQ:331532.331549,\n author = {Solihin, Yan and Lam, Vinh and Torrellas, Josep},\n title = {Scal-Tool: Pinpointing and Quantifying Scalability Bottlenecks in DSM Multiprocessors},\n booktitle = {Proceedings of the 1999 ACM/IEEE Conference on Supercomputing},\n series = {SC \'99},\n year = {1999},\n isbn = {1-58113-091-0},\n location = {Portland, Oregon, USA},\n articleno = {17},\n url = {http://doi.acm.org/10.1145/331532.331549},\n doi = {10.1145/331532.331549},\n acmid = {331549},\n publisher = {ACM},\n address = {New York, NY, USA},\n} \n\n\n@article{denew,\n  title={The New Linux perf Tools},\n  author={de Melo, Arnaldo Carvalho}\n}\n\n\n\n@ARTICLE{6133267, \nauthor={Ki-Woong Park and Jaesun Han and JaeWoong Chung and Kyu Ho Park}, \njournal={Services Computing, IEEE Transactions on}, \ntitle={THEMIS: A Mutually Verifiable Billing System for the Cloud Computing Environment}, \nyear={2013}, \nmonth={July}, \nvolume={6}, \nnumber={3}, \npages={300-313}, \nkeywords={cloud computing;security of data;software performance evaluation;system monitoring;trusted computing;PKI;S-Mon;THEMIS billing transaction;TPM;cloud computing environment;cloud computing service;cloud notary authority;computational overhead;forgery-resistive SLA monitoring mechanism;iCubeCloud;nonobstructive billing system;performance evaluation;security capability;service level agreement monitoring;trusted platform module;verifiable billing system;Cloud computing;Computer architecture;Digital signatures;Grid computing;Monitoring;Protocols;Records;and resource allocation;pricing;transaction processing;verification}, \ndoi={10.1109/TSC.2012.1}, \nISSN={1939-1374},}\n\n@INPROCEEDINGS{5279594, \nauthor={Elmroth, E. and Marquez, F.G. and Henriksson, D. and Ferrera, D.P.}, \nbooktitle={Grid and Cooperative Computing, 2009. GCC \'09. Eighth International Conference on}, \ntitle={Accounting and Billing for Federated Cloud Infrastructures}, \nyear={2009}, \nmonth={Aug}, \npages={268-275}, \nkeywords={resource allocation;virtual machines;RESERVOIR project;data center;federated cloud computing infrastructure;postpaid payment scheme;prepaid payment scheme;resources-services virtualization;service level agreement;usage scenario;Cloud computing;Collaboration;Computer architecture;Grid computing;Reservoirs;Resource virtualization;Subcontracting;Technology management;Time factors;Virtual machining;RESERVOIR;SGAS;accounting;billing;cloud computing;grid computing}, \ndoi={10.1109/GCC.2009.37},}\n\n\n\n\n@inproceedings{Isci:2006:LRP:1194816.1194851,\n author = {Isci, Canturk and Contreras, Gilberto and Martonosi, Margaret},\n title = {Live, Runtime Phase Monitoring and Prediction on Real Systems with Application to Dynamic Power Management},\n booktitle = {Proceedings of the 39th Annual IEEE/ACM International Symposium on Microarchitecture},\n series = {MICRO 39},\n year = {2006},\n isbn = {0-7695-2732-9},\n pages = {359--370},\n numpages = {12},\n url = {http://dx.doi.org/10.1109/MICRO.2006.30},\n doi = {10.1109/MICRO.2006.30},\n acmid = {1194851},\n publisher = {IEEE Computer Society},\n address = {Washington, DC, USA},\n} \n@INPROCEEDINGS{1598119, \nauthor={Isci, C. and Martonosi, M.}, \nbooktitle={High-Performance Computer Architecture, 2006. The Twelfth International Symposium on}, \ntitle={Phase characterization for power: evaluating control-flow-based and event-counter-based techniques}, \nyear={2006}, \nmonth={Feb}, \npages={121-132}, \nkeywords={benchmark testing;computer architecture;performance evaluation;power consumption;SPEC2000 benchmark;basic block vector;code-oriented technique;control-flow sampling;event counter;mainstream desktop application;performance counter;power consumption;power phase characterization;real-system power measurement;Counting circuits;Energy consumption;Hardware;Performance analysis;Phase measurement;Power measurement;Power system management;Runtime;Sampling methods;Software systems}, \ndoi={10.1109/HPCA.2006.1598119}, \nISSN={1530-0897},}\n\n@inproceedings{consen,\nauthor = {Tang, Lingjia and Mars, Jason and Soffa, Mary Lou},\ntitle = {Contentiousness vs. sensitivity: improving contention aware runtime systems on multicore architectures},\nbooktitle = {Proceedings of the 1st International Workshop on Adaptive Self-Tuning Computing Systems for the Exaflop Era (co-located with PLDI 2011)},\nyear = {2011},\nisbn = {978-1-4503-0708-6},\nlocation = {San Jose, California},\npages = {12--21},\nnumpages = {10},\nurl = {http://doi.acm.org/10.1145/2000417.2000419},\ndoi = {http://doi.acm.org/10.1145/2000417.2000419},\nacmid = {2000419},\npublisher = {ACM},\naddress = {New York, NY, USA},\nkeywords = {contention aware runtimes, contentiousness vs sensitivity, memory subsystems, multicore processors, scheduling},\n}\n\n'
p0
.I29
.S'Q-clouds'
p0
.S"$bib:\n@inproceedings{Nathuji:2010:QMP:1755913.1755938,\n author = {Nathuji, Ripal and Kansal, Aman and Ghaffarkhah, Alireza},\n title = {Q-clouds: Managing Performance Interference Effects for QoS-aware Clouds},\n booktitle = {Proceedings of the 5th European Conference on Computer Systems},\n series = {EuroSys '10},\n year = {2010},\n isbn = {978-1-60558-577-2},\n location = {Paris, France},\n pages = {237--250},\n numpages = {14},\n url = {http://doi.acm.org/10.1145/1755913.1755938},\n doi = {10.1145/1755913.1755938},\n acmid = {1755938},\n publisher = {ACM},\n address = {New York, NY, USA},\n keywords = {cloud computing, resource management, virtualization},\n} "
p0
.I0
.S'Cuanta'
p0
.S"$bib:\n@inproceedings{Govindan:2011:CQE:2038916.2038938,\n author = {Govindan, Sriram and Liu, Jie and Kansal, Aman and Sivasubramaniam, Anand},\n title = {Cuanta: Quantifying Effects of Shared On-chip Resource Interference for Consolidated Virtual Machines},\n booktitle = {Proceedings of the 2Nd ACM Symposium on Cloud Computing},\n series = {SOCC '11},\n year = {2011},\n isbn = {978-1-4503-0976-9},\n location = {Cascais, Portugal},\n pages = {22:1--22:14},\n articleno = {22},\n numpages = {14},\n url = {http://doi.acm.org/10.1145/2038916.2038938},\n doi = {10.1145/2038916.2038938},\n acmid = {2038938},\n publisher = {ACM},\n address = {New York, NY, USA},\n keywords = {cache pressure clone, last-level cache, memory subsystem interference, performance estimation, resource contention, workload consolidation},\n} "
p0
.I0
.S'Bubble-up'
p0
.S'$bib:\n@inproceedings{bubbleup,\nauthor = {Mars, Jason and Tang, Lingjia and Hundt, Robert and Skadron, Kevin and Soffa, Mary Lou},\ntitle = {Bubble-Up: Increasing Utilization in Modern Warehouse Scale Computers via Sensible Co-locations},\nbooktitle = {Proceedings of the 44th Annual IEEE/ACM International Symposium on Microarchitecture (MICRO)},\nseries = {MICRO-44},\nyear = {2011},\nisbn = {978-1-4503-1053-6},\nlocation = {Porto Alegre, Brazil},\npages = {248--259},\nnumpages = {12},\nurl = {http://doi.acm.org/10.1145/2155620.2155650},\ndoi = {10.1145/2155620.2155650},\nacmid = {2155650},\npublisher = {ACM},\naddress = {New York, NY, USA},\nnote = {Acceptance Rate: 21% - Selected for IEEE MICRO TOP PICKS},\n}\n'
p0
.I0
.S'STM'
p0
.S'$bib:\n@inproceedings{stfm,\n author = {Mutlu, Onur and Moscibroda, Thomas},\n title = {Stall-Time Fair Memory Access Scheduling for Chip Multiprocessors},\n booktitle = {Proceedings of the 40th Annual IEEE/ACM International Symposium on Microarchitecture},\n series = {MICRO 40},\n year = {2007},\n isbn = {0-7695-3047-8},\n pages = {146--160},\n numpages = {15},\n url = {http://dx.doi.org/10.1109/MICRO.2007.40},\n doi = {10.1109/MICRO.2007.40},\n acmid = {1331715},\n publisher = {IEEE Computer Society},\n address = {Washington, DC, USA},\n} '
p0
.I0
.S'FST'
p0
.S'$bib:\n@inproceedings{fst,\n author = {Ebrahimi, Eiman and Lee, Chang Joo and Mutlu, Onur and Patt, Yale N.},\n title = {Fairness via Source Throttling: A Configurable and High-performance Fairness Substrate for Multi-core Memory Systems},\n booktitle = {Proceedings of the Fifteenth Edition of ASPLOS on Architectural Support for Programming Languages and Operating Systems},\n series = {ASPLOS XV},\n year = {2010},\n isbn = {978-1-60558-839-1},\n location = {Pittsburgh, Pennsylvania, USA},\n pages = {335--346},\n numpages = {12},\n url = {http://doi.acm.org/10.1145/1736020.1736058},\n doi = {10.1145/1736020.1736058},\n acmid = {1736058},\n publisher = {ACM},\n address = {New York, NY, USA},\n keywords = {fairness, multi-core systems, shared memory systems, system performance},\n} '
p0
.I0
.S'QualityTime'
p0
.S'$bib:\n@INPROCEEDINGS{6844481, \nauthor={Gupta, A. and Sampson, J. and Taylor, M.B.}, \nbooktitle={Performance Analysis of Systems and Software (ISPASS), 2014 IEEE International Symposium on}, \ntitle={Quality Time: A simple online technique for quantifying multicore execution efficiency}, \nyear={2014}, \nmonth={March}, \npages={169-179}, \nkeywords={multiprocessing systems;performance evaluation;quality of service;shared memory systems;CPU time;QoS;Qplacer;Qtime;Qtop;memory interference;memory resources;multicore execution efficiency;multicore processors;online technique;quality time;user-space tools;Hardware;Instruction sets;Interference;Libraries;Multicore processing;Radiation detectors;Time measurement}, \ndoi={10.1109/ISPASS.2014.6844481},}'
p0
.I0
.S'Zhuravlev:2010:ASR'
p0
.S'$bib:\n@inproceedings{Zhuravlev:2010:ASR:1736020.1736036,\n author = {Zhuravlev, Sergey and Blagodurov, Sergey and Fedorova, Alexandra},\n title = {Addressing Shared Resource Contention in Multicore Processors via Scheduling},\n booktitle = {Proceedings of the Fifteenth Edition of ASPLOS on Architectural Support for Programming Languages and Operating Systems},\n series = {ASPLOS XV},\n year = {2010},\n isbn = {978-1-60558-839-1},\n location = {Pittsburgh, Pennsylvania, USA},\n pages = {129--142},\n numpages = {14},\n url = {http://doi.acm.org/10.1145/1736020.1736036},\n doi = {10.1145/1736020.1736036},\n acmid = {1736036},\n publisher = {ACM},\n address = {New York, NY, USA},\n keywords = {multicore processors, scheduling, shared resource contention},\n} '
p0
.I0
.S'fairpricing'
p0
.S'$bib:\n@article{fairpricing,\nauthor = {Alex D. Breslow and\nAnanta Tiwari and\nMartin Schulz and\nLaura Carrington and\nLingjia Tang and\nJason Mars},\ntitle = {Enabling fair pricing on high performance computer systems with node sharing},\njournal = {Scientific Programming},\nyear = {2014},\nvolume = {22},\nnumber = {2},\npages = {59--74},\nurl = {http://dx.doi.org/10.3233/SPR-140387},\ndoi = {10.3233/SPR-140387},\ntimestamp = {Fri, 05 Sep 2014 13:19:44 +0200},\nbiburl = {http://dblp.uni-trier.de/rec/bib/journals/sp/BreslowTSCTM14},\nbibsource = {dblp computer science bibliography, http://dblp.org}\n}'
p0
.I0
.S'Pollute Buffer'
p0
.S'$bib:\n@inproceedings{Soares:2008:RHE:1521747.1521800,\n author = {Soares, Livio and Tam, David and Stumm, Michael},\n title = {Reducing the Harmful Effects of Last-level Cache Polluters with an OS-level, Software-only Pollute Buffer},\n booktitle = {Proceedings of the 41st Annual IEEE/ACM International Symposium on Microarchitecture},\n series = {MICRO 41},\n year = {2008},\n isbn = {978-1-4244-2836-6},\n pages = {258--269},\n numpages = {12},\n url = {http://dx.doi.org/10.1109/MICRO.2008.4771796},\n doi = {10.1109/MICRO.2008.4771796},\n acmid = {1521800},\n publisher = {IEEE Computer Society},\n address = {Washington, DC, USA},\n} \n'
p0
.I0
.S'NUMA-aware contention'
p0
.S"$bib:\n@inproceedings{Blagodurov:2011:CNC:2002181.2002182,\n author = {Blagodurov, Sergey and Zhuravlev, Sergey and Dashti, Mohammad and Fedorova, Alexandra},\n title = {A Case for NUMA-aware Contention Management on Multicore Systems},\n booktitle = {Proceedings of the 2011 USENIX Conference on USENIX Annual Technical Conference},\n series = {USENIXATC'11},\n year = {2011},\n location = {Portland, OR},\n pages = {1--1},\n numpages = {1},\n url = {http://dl.acm.org/citation.cfm?id=2002181.2002182},\n acmid = {2002182},\n publisher = {USENIX Association},\n address = {Berkeley, CA, USA},\n} \n"
p0
.I0
.S'cache-partitioning'
p0
.S"$bib:\n@inproceedings{Suh:2002:NMM:874076.876484,\n author = {Suh, G. Edward and Devadas, Srinivas and Rudolph, Larry},\n title = {A New Memory Monitoring Scheme for Memory-Aware Scheduling and Partitioning},\n booktitle = {Proceedings of the 8th International Symposium on High-Performance Computer Architecture},\n series = {HPCA '02},\n year = {2002},\n pages = {117--},\n url = {http://dl.acm.org/citation.cfm?id=874076.876484},\n acmid = {876484},\n publisher = {IEEE Computer Society},\n address = {Washington, DC, USA},\n} \n"
p0
.I0
.S'utility-partitioning'
p0
.S'$bib:\n@inproceedings{Qureshi:2006:UCP:1194816.1194855,\n author = {Qureshi, Moinuddin K. and Patt, Yale N.},\n title = {Utility-Based Cache Partitioning: A Low-Overhead, High-Performance, Runtime Mechanism to Partition Shared Caches},\n booktitle = {Proceedings of the 39th Annual IEEE/ACM International Symposium on Microarchitecture},\n series = {MICRO 39},\n year = {2006},\n isbn = {0-7695-2732-9},\n pages = {423--432},\n numpages = {10},\n url = {http://dx.doi.org/10.1109/MICRO.2006.49},\n doi = {10.1109/MICRO.2006.49},\n acmid = {1194855},\n publisher = {IEEE Computer Society},\n address = {Washington, DC, USA},\n} '
p0
.I0
.S'Rafique et al'
p0
.S"$bib:\n@inproceedings{Rafique:2006:ASO:1152154.1152160,\n author = {Rafique, Nauman and Lim, Won-Taek and Thottethodi, Mithuna},\n title = {Architectural Support for Operating System-driven CMP Cache Management},\n booktitle = {Proceedings of the 15th International Conference on Parallel Architectures and Compilation Techniques},\n series = {PACT '06},\n year = {2006},\n isbn = {1-59593-264-X},\n location = {Seattle, Washington, USA},\n pages = {2--12},\n numpages = {11},\n url = {http://doi.acm.org/10.1145/1152154.1152160},\n doi = {10.1145/1152154.1152160},\n acmid = {1152160},\n publisher = {ACM},\n address = {New York, NY, USA},\n keywords = {CMP, OS, QoS, SLAs, cache, fairness, interface, quotas},\n} \n\n@inproceedings{Rafique:2007:EMD:1299042.1299052,\n author = {Rafique, Nauman and Lim, Won-Taek and Thottethodi, Mithuna},\n title = {Effective Management of DRAM Bandwidth in Multicore Processors},\n booktitle = {Proceedings of the 16th International Conference on Parallel Architecture and Compilation Techniques},\n series = {PACT '07},\n year = {2007},\n isbn = {0-7695-2944-5},\n pages = {245--258},\n numpages = {14},\n url = {http://dx.doi.org/10.1109/PACT.2007.29},\n doi = {10.1109/PACT.2007.29},\n acmid = {1299052},\n publisher = {IEEE Computer Society},\n address = {Washington, DC, USA},\n} \n"
p0
.I0
.S'Srikantaiah et al'
p0
.S"$bib:\n@inproceedings{Srikantaiah:2008:ASP:1346281.1346299,\n author = {Srikantaiah, Shekhar and Kandemir, Mahmut and Irwin, Mary Jane},\n title = {Adaptive Set Pinning: Managing Shared Caches in Chip Multiprocessors},\n booktitle = {Proceedings of the 13th International Conference on Architectural Support for Programming Languages and Operating Systems},\n series = {ASPLOS XIII},\n year = {2008},\n isbn = {978-1-59593-958-6},\n location = {Seattle, WA, USA},\n pages = {135--144},\n numpages = {10},\n url = {http://doi.acm.org/10.1145/1346281.1346299},\n doi = {10.1145/1346281.1346299},\n acmid = {1346299},\n publisher = {ACM},\n address = {New York, NY, USA},\n keywords = {CMP, inter-processor, intra-processor, set pinning, shared cache},\n} \n\n@inproceedings{Srikantaiah:2009:CIP:1654059.1654066,\n author = {Srikantaiah, Shekhar and Das, Reetuparna and Mishra, Asit K. and Das, Chita R. and Kandemir, Mahmut},\n title = {A Case for Integrated Processor-cache Partitioning in Chip Multiprocessors},\n booktitle = {Proceedings of the Conference on High Performance Computing Networking, Storage and Analysis},\n series = {SC '09},\n year = {2009},\n isbn = {978-1-60558-744-8},\n location = {Portland, Oregon},\n pages = {6:1--6:12},\n articleno = {6},\n numpages = {12},\n url = {http://doi.acm.org/10.1145/1654059.1654066},\n doi = {10.1145/1654059.1654066},\n acmid = {1654066},\n publisher = {ACM},\n address = {New York, NY, USA},\n} "
p0
.I0
.S'VM-contention'
p0
.S"$bib:\n@inproceedings{Ahn:2012:DVM:2342763.2342782,\n author = {Ahn, Jeongseob and Kim, Changdae and Han, Jaeung and Choi, Young-Ri and Huh, Jaehyuk},\n title = {Dynamic Virtual Machine Scheduling in Clouds for Architectural Shared Resources},\n booktitle = {Proceedings of the 4th USENIX Conference on Hot Topics in Cloud Ccomputing},\n series = {HotCloud'12},\n year = {2012},\n location = {Boston, MA},\n pages = {19--19},\n numpages = {1},\n url = {http://dl.acm.org/citation.cfm?id=2342763.2342782},\n acmid = {2342782},\n publisher = {USENIX Association},\n address = {Berkeley, CA, USA},\n} "
p0
.I0
.S'Bubble flux'
p0
.S"$bib:\n@inproceedings{bubbleflux,\n author = {Yang, Hailong and Breslow, Alex and Mars, Jason and Tang, Lingjia},\n title = {Bubble-flux: Precise Online QoS Management for Increased Utilization in Warehouse Scale Computers},\n booktitle = {Proceedings of the 40th Annual International Symposium on Computer Architecture},\n series = {ISCA '13},\n year = {2013},\n isbn = {978-1-4503-2079-5},\n location = {Tel-Aviv, Israel},\n pages = {607--618},\n numpages = {12},\n url = {http://doi.acm.org/10.1145/2485922.2485974},\n doi = {10.1145/2485922.2485974},\n acmid = {2485974},\n publisher = {ACM},\n address = {New York, NY, USA},\n} \n"
p0
.I0
.S'paragon'
p0
.S"$bib:\n@inproceedings{Delimitrou:2013:PQS:2451116.2451125,\n author = {Delimitrou, Christina and Kozyrakis, Christos},\n title = {Paragon: QoS-aware Scheduling for Heterogeneous Datacenters},\n booktitle = {Proceedings of the Eighteenth International Conference on Architectural Support for Programming Languages and Operating Systems},\n series = {ASPLOS '13},\n year = {2013},\n isbn = {978-1-4503-1870-9},\n location = {Houston, Texas, USA},\n pages = {77--88},\n numpages = {12},\n url = {http://doi.acm.org/10.1145/2451116.2451125},\n doi = {10.1145/2451116.2451125},\n acmid = {2451125},\n publisher = {ACM},\n address = {New York, NY, USA},\n keywords = {cloud computing, datacenter, heterogeneity, interference, qos, scheduling},\n} \n"
p0
.I0
.S'FairQueuing'
p0
.S'$bib:\n@inproceedings{Nesbit:2006:FQM,\n author = {Nesbit, Kyle J. and Aggarwal, Nidhi and Laudon, James and Smith, James E.},\n title = {Fair Queuing Memory Systems},\n booktitle = {Proceedings of the 39th Annual IEEE/ACM International Symposium on Microarchitecture},\n series = {MICRO 39},\n year = {2006},\n isbn = {0-7695-2732-9},\n pages = {208--222},\n numpages = {15},\n url = {http://dx.doi.org/10.1109/MICRO.2006.24},\n doi = {10.1109/MICRO.2006.24},\n acmid = {1194839},\n publisher = {IEEE Computer Society},\n address = {Washington, DC, USA},\n} \n'
p0
.I0
.S'DeepDive'
p0
.S"$bib:\n@inproceedings{Novakovic:2013:DTI:2535461.2535489,\n author = {Novakovi\\'{c}, Dejan and Vasi\\'{c}, Nedeljko and Novakovi\\'{c}, Stanko and Kosti\\'{c}, Dejan and Bianchini, Ricardo},\n title = {DeepDive: Transparently Identifying and Managing Performance Interference in Virtualized Environments},\n booktitle = {Proceedings of the 2013 USENIX Conference on Annual Technical Conference},\n series = {USENIX ATC'13},\n year = {2013},\n location = {San Jose, CA},\n pages = {219--230},\n numpages = {12},\n url = {http://dl.acm.org/citation.cfm?id=2535461.2535489},\n acmid = {2535489},\n publisher = {USENIX Association},\n address = {Berkeley, CA, USA},\n} "
p0
.I0
.S'Amazon'
p0
.S'$bib:\n@misc{amazon,\nannote = {$\\backslash$url\\{http://aws.amazon.com/ec2/purchasing-options/}},\nauthor = {{Amazon Inc.}},\nmonth = nov,\npublisher = {Amazon},\ntitle = {{Amazon Elastic Compute Cloud(EC2)}},\nyear = {2008}\n}'
p0
.I0
.S'PARD'
p0
.S"$bib:\n@inproceedings{Ma:2015:SDS:2694344.2694382,\n author = {Ma, Jiuyue and Sui, Xiufeng and Sun, Ninghui and Li, Yupeng and Yu, Zihao and Huang, Bowen and Xu, Tianni and Yao, Zhicheng and Chen, Yun and Wang, Haibin and Zhang, Lixin and Bao, Yungang},\n title = {Supporting Differentiated Services in Computers via Programmable Architecture for Resourcing-on-Demand (PARD)},\n booktitle = {Proceedings of the Twentieth International Conference on Architectural Support for Programming Languages and Operating Systems},\n series = {ASPLOS '15},\n year = {2015},\n isbn = {978-1-4503-2835-7},\n location = {Istanbul, Turkey},\n pages = {131--143},\n numpages = {13},\n url = {http://doi.acm.org/10.1145/2694344.2694382},\n doi = {10.1145/2694344.2694382},\n acmid = {2694382},\n publisher = {ACM},\n address = {New York, NY, USA},\n keywords = {QoS, data center, hardware/software interface},\n} \n"
p0
.I0
.S'RFA'
p0
.S"$bib:\n@inproceedings{Varadarajan:2012:RAI:2382196.2382228,\n author = {Varadarajan, Venkatanathan and Kooburat, Thawan and Farley, Benjamin and Ristenpart, Thomas and Swift, Michael M.},\n title = {Resource-freeing Attacks: Improve Your Cloud Performance (at Your Neighbor's Expense)},\n booktitle = {Proceedings of the 2012 ACM Conference on Computer and Communications Security},\n series = {CCS '12},\n year = {2012},\n isbn = {978-1-4503-1651-4},\n location = {Raleigh, North Carolina, USA},\n pages = {281--292},\n numpages = {12},\n url = {http://doi.acm.org/10.1145/2382196.2382228},\n doi = {10.1145/2382196.2382228},\n acmid = {2382228},\n publisher = {ACM},\n address = {New York, NY, USA},\n keywords = {cloud computing, resource-freeing attacks, scheduling, security, virtualization},\n} \n"
p0
.I0
.S'cache-vm'
p0
.S"$bib:\n@inproceedings{Ahn:2014:MVP:2742155.2742195,\n author = {Ahn, Jeongseob and Park, Chang Hyun and Huh, Jaehyuk},\n title = {Micro-Sliced Virtual Processors to Hide the Effect of Discontinuous CPU Availability for Consolidated Systems},\n booktitle = {Proceedings of the 47th Annual IEEE/ACM International Symposium on Microarchitecture},\n series = {MICRO-47},\n year = {2014},\n isbn = {978-1-4799-6998-2},\n location = {Cambridge, United Kingdom},\n pages = {394--405},\n numpages = {12},\n url = {http://dx.doi.org/10.1109/MICRO.2014.49},\n doi = {10.1109/MICRO.2014.49},\n acmid = {2742195},\n publisher = {IEEE Computer Society},\n address = {Washington, DC, USA},\n keywords = {context prefetch, context preservation, virtual time discontinuity, virtualization},\n} \n\n@INPROCEEDINGS{Daly, \n    author={Daly, D. and Cain, H.W.}, \n    booktitle={Proceedings of the 18th International Symposium on High Performance Computer Architecture (HPCA) }, \n    title={Cache restoration for highly partitioned virtualized systems}, \n    year={2012}, \n    keywords={cache storage;memory architecture;multiprogramming;scheduling;virtual machines;virtualisation;POWER7 system;cache restoration;cycle-accurate simulation;hardware-based prefetching mechanism;highly partitioned virtualized systems;microarchitectural state;multiple virtual machines;multiprogrammed virtualization;per-core L3 last-level cache;performance improvement;server consolidation;server-class systems;virtualization features;virtualization software;Bandwidth;Hardware;Operating systems;Prefetching;Registers;Servers;Switches}, \n    doi={10.1109/HPCA.2012.6169029}, \n    ISSN={1530-0897},\n}\n\n\n@INPROCEEDINGS{ReCap, \n    author={Zebchuk, J. and Cain, H.W. and Xin Tong and Srinivasan, V. and Moshovos, A.}, \n    booktitle={Proceedings of the 19th International Symposium on High Performance Computer Architecture (HPCA) }, \n    title={{RECAP}: A region-based cure for the common cold (cache)}, \n    year={2013}, \n    keywords={cache storage;data compression;multiprogramming;power aware computing;processor scheduling;supervisory programs;virtual machines;virtualisation;L2 cache;RECAP;bandwidth overhead reduction;block reuse-based filtering;cache blocks;coarse-grain memory regions;cold cache effect reduction;compression technique;energy-delay product reduction;fine-grain sharing;hypervisor;management overhead reduction;metadata reading;metadata writing;multiprogrammed virtualization;performance improvement;processor scheduling;region-based cache restoration prefetcher;single processor core time-share;spatial locality;virtual machines}, \n    doi={10.1109/HPCA.2013.6522309}, \n    ISSN={1530-0897},\n}\n\n@inproceedings{Liu:2014:OVM:2665671.2665720,\n author = {Liu, Ming and Li, Tao},\n title = {Optimizing Virtual Machine Consolidation Performance on NUMA Server Architecture for Cloud Workloads},\n booktitle = {Proceeding of the 41st Annual International Symposium on Computer Architecuture},\n series = {ISCA '14},\n year = {2014},\n isbn = {978-1-4799-4394-4},\n location = {Minneapolis, Minnesota, USA},\n pages = {325--336},\n numpages = {12},\n url = {http://dl.acm.org/citation.cfm?id=2665671.2665720},\n acmid = {2665720},\n publisher = {IEEE Press},\n address = {Piscataway, NJ, USA},\n} \n\n@INPROCEEDINGS{6522328,\nauthor={Jia Rao and Kun Wang and Xiaobo Zhou and Cheng-zhong Xu},\nbooktitle={High Performance Computer Architecture (HPCA2013), 2013 IEEE 19th International Symposium on},\ntitle={Optimizing virtual machine scheduling in NUMA multicore systems},\nyear={2013},\nmonth={Feb},\npages={306-317},\nkeywords={memory architecture;multiprocessing systems;performance evaluation;processor scheduling;virtual machines;BRM algorithm;Xen credit scheduler;Xen virtual machine monitor;bias random vCPU migration algorithm;complex interplay;cross-node data sharing overhead;data locality;machine hardware;memory subsystem;nonuniform memory access architecture;optimal program performance;predictable program performance;scalable memory performance;shared on-chip memory resources;system-level optimizations;system-wide uncore penalty;two-way Intel NUMA multicore system;virtual hardware;virtual machine scheduling optimization;Benchmark testing;Hardware;Instruction sets;Multicore processing;Sockets;Topology},\ndoi={10.1109/HPCA.2013.6522328},\nISSN={1530-0897},}\n"
p0
.I0
.S'Dejavu'
p0
.S"$bib:\n@article{Vasic:2012:DAR:2248487.2151021,\n author = {Vasi\\'{c}, Nedeljko and Novakovi\\'{c}, Dejan and Miu\\v{c}in, Svetozar and Kosti\\'{c}, Dejan and Bianchini, Ricardo},\n title = {DejaVu: Accelerating Resource Allocation in Virtualized Environments},\n journal = {SIGPLAN Not.},\n issue_date = {April 2012},\n volume = {47},\n number = {4},\n month = mar,\n year = {2012},\n issn = {0362-1340},\n pages = {423--436},\n numpages = {14},\n url = {http://doi.acm.org/10.1145/2248487.2151021},\n doi = {10.1145/2248487.2151021},\n acmid = {2151021},\n publisher = {ACM},\n address = {New York, NY, USA},\n keywords = {data center, resource management, virtualization},\n} \n"
p0
.I0
.S'ReQoS'
p0
.S"$bib:\n@inproceedings{Tang:2013:RRS:2451116.2451126,\n author = {Tang, Lingjia and Mars, Jason and Wang, Wei and Dey, Tanima and Soffa, Mary Lou},\n title = {ReQoS: Reactive Static/Dynamic Compilation for QoS in Warehouse Scale Computers},\n booktitle = {Proceedings of the Eighteenth International Conference on Architectural Support for Programming Languages and Operating Systems},\n series = {ASPLOS '13},\n year = {2013},\n isbn = {978-1-4503-1870-9},\n location = {Houston, Texas, USA},\n pages = {89--100},\n numpages = {12},\n url = {http://doi.acm.org/10.1145/2451116.2451126},\n doi = {10.1145/2451116.2451126},\n acmid = {2451126},\n publisher = {ACM},\n address = {New York, NY, USA},\n keywords = {compiler, contention, cross-core interference, datacenter, dynamic techniques, multicore, online adaptation, quality of service, runtime systems, warehouse scale computers},\n} \n\n"
p0
.I0
.S'Whare-map'
p0
.S'$bib:\n@inproceedings{Mars:2013:WHH:2485922.2485975,\n author = {Mars, Jason and Tang, Lingjia},\n title = {Whare-map: Heterogeneity in "Homogeneous" Warehouse-scale Computers},\n booktitle = {Proceedings of the 40th Annual International Symposium on Computer Architecture},\n series = {ISCA \'13},\n year = {2013},\n isbn = {978-1-4503-2079-5},\n location = {Tel-Aviv, Israel},\n pages = {619--630},\n numpages = {12},\n url = {http://doi.acm.org/10.1145/2485922.2485975},\n doi = {10.1145/2485922.2485975},\n acmid = {2485975},\n publisher = {ACM},\n address = {New York, NY, USA},\n} '
p0
.I0
.S'Bubble-Flux'
p0
.S"$bib:\n@inproceedings{Yang:2013:BPO:2485922.2485974,\n author = {Yang, Hailong and Breslow, Alex and Mars, Jason and Tang, Lingjia},\n title = {Bubble-flux: Precise Online QoS Management for Increased Utilization in Warehouse Scale Computers},\n booktitle = {Proceedings of the 40th Annual International Symposium on Computer Architecture},\n series = {ISCA '13},\n year = {2013},\n isbn = {978-1-4503-2079-5},\n location = {Tel-Aviv, Israel},\n pages = {607--618},\n numpages = {12},\n url = {http://doi.acm.org/10.1145/2485922.2485974},\n doi = {10.1145/2485922.2485974},\n acmid = {2485974},\n publisher = {ACM},\n address = {New York, NY, USA},\n} "
p0
.I0
.S'RCH'
p0
.S"$bib:\n@inproceedings{Park:2013:RCH:2451116.2451137,\n author = {Park, Heekwon and Baek, Seungjae and Choi, Jongmoo and Lee, Donghee and Noh, Sam H.},\n title = {Regularities Considered Harmful: Forcing Randomness to Memory Accesses to Reduce Row Buffer Conflicts for Multi-core, Multi-bank Systems},\n booktitle = {Proceedings of the Eighteenth International Conference on Architectural Support for Programming Languages and Operating Systems},\n series = {ASPLOS '13},\n year = {2013},\n isbn = {978-1-4503-1870-9},\n location = {Houston, Texas, USA},\n pages = {181--192},\n numpages = {12},\n url = {http://doi.acm.org/10.1145/2451116.2451137},\n doi = {10.1145/2451116.2451137},\n acmid = {2451137},\n publisher = {ACM},\n address = {New York, NY, USA},\n keywords = {analysis tool, memory container, memory management, randomized algorithm, row-buffer conflict},\n} "
p0
.I0
.S'GVM'
p0
.S"$bib:\n@inproceedings{Liu:2014:GVM:2665671.2665698,\n author = {Liu, Lei and Li, Yong and Cui, Zehan and Bao, Yungang and Chen, Mingyu and Wu, Chengyong},\n title = {Going Vertical in Memory Management: Handling Multiplicity by Multi-policy},\n booktitle = {Proceeding of the 41st Annual International Symposium on Computer Architecuture},\n series = {ISCA '14},\n year = {2014},\n isbn = {978-1-4799-4394-4},\n location = {Minneapolis, Minnesota, USA},\n pages = {169--180},\n numpages = {12},\n url = {http://dl.acm.org/citation.cfm?id=2665671.2665698},\n acmid = {2665698},\n publisher = {IEEE Press},\n address = {Piscataway, NJ, USA},\n} "
p0
.I0
.S'Latex config'
p0
.S''
p0
.I4
.S'Style'
p0
.S''
p0
.I0
.S'Classfile'
p0
.S'You can add your custom classfile here.'
p0
.I1
.S'sig-alternate'
p0
.S'$class: sig-alternate\n\n%rabi SIG-ALTERNATE.CLS - VERSION 2.5\n% "COMPATIBLE" WITH THE "ACM_PROC_ARTICLE-SP.CLS" V3.2SP\n% Gerald Murray - May 23rd 2012\n%\n% ---- Start of \'updates\'  ----\n% Changed $10 fee to $15 -- May 2012  --  Gerry\n% Changed $5 fee to $10 --  April 2009 -- Gerry\n% April 22nd. 2009 - Fixed \'Natbib\' incompatibility problem - Gerry\n% April 22nd. 2009 - Fixed \'Babel\' incompatibility problem - Gerry\n% April 22nd. 2009 - Inserted various bug-fixes and improvements - Gerry\n%\n% To produce Type 1 fonts in the document plus allow for \'normal LaTeX accenting\' in the critical areas;\n% title, author block, section-heads, confname, etc. etc. \n% i.e. the whole purpose of this version update is to NOT resort to \'inelegant accent patches\'.\n% After much research, three extra .sty packages were added to the the tail (ae, aecompl, aeguill) to solve,\n% in particular, the accenting problem(s). We _could_ ask authors (via instructions/sample file) to \'include\' these in\n% the source .tex file - in the preamble - but if everything is already provided (\'behind the scenes\' - embedded IN the .cls)\n% then this is less work for authors and also makes everything appear \'vanilla\'.\n% NOTE: all \'patchwork accenting" has been commented out (here) and is no longer \'used\' in the sample .tex file (either).\n% Gerry June 2007\n%\n% Patch for accenting in conference name/location. Gerry May 3rd. 2007\n% Rule widths changed to .5, author count (>6) fixed, roll-back for Type 3 problem. Gerry March 20th. 2007\n% Changes made to \'modernize\' the fontnames but esp. for MikTeX users V2.4/2.5 - Nov. 30th. 2006\n% Updated the \\email definition to allow for its use inside of \'shared affiliations\' - Nov. 30th. 2006\n% Fixed the \'section number depth value\' - Nov. 30th. 2006\n%\n% Footnotes inside table cells using \\minipage (Oct. 2002)\n% Georgia fixed bug in sub-sub-section numbering in paragraphs (July 29th. 2002)\n% JS/GM fix to vertical spacing before Proofs (July 30th. 2002)\n%\n% Made the Permission Statement / Conference Info / Copyright Info\n% \'user definable\' in the source .tex file OR automatic if\n% not specified.\n%\n% Allowance made to switch default fonts between those systems using\n% normal/modern font names and those using \'Type 1\' or \'Truetype\' fonts.\n% See LINE NUMBER 255 for details.\n% Also provided for enumerated/annotated Corollaries \'surrounded\' by\n% enumerated Theorems (line 848).\n% Gerry November 11th. 1999\n%\n% ---- End of \'updates\' ----\n%\n\\def\\fileversion{v2.5}          % for ACM\'s tracking purposes\n\\def\\filedate{May 23, 2012}    % Gerry Murray\'s tracking data\n\\def\\docdate {Wednesday 23rd. May 2012} % Gerry Murray (with deltas to doc}\n\\usepackage{epsfig}\n\\usepackage{amssymb}\n\\usepackage{amsmath}\n\\usepackage{amsfonts}\n% Need this for accents in Arial/Helvetica\n%\\usepackage[T1]{fontenc}  % Gerry March 12, 2007 - causes Type 3 problems (body text)\n%\\usepackage{textcomp}\n%\n% SIG-ALTERNATE DOCUMENT STYLE\n% G.K.M. Tobin August-October 1999\n%    adapted from ARTICLE document style by Ken Traub, Olin Shivers\n%    also using elements of esub2acm.cls\n% HEAVILY MODIFIED, SUBSEQUENTLY, BY GERRY MURRAY 2000\n% ARTICLE DOCUMENT STYLE -- Released 16 March 1988\n%    for LaTeX version 2.09\n% Copyright (C) 1988 by Leslie Lamport\n%\n%\n%%% sig-alternate.cls is an \'ALTERNATE\' document style for producing\n%%% two-column camera-ready pages for ACM conferences.\n%%% THIS FILE DOES NOT STRICTLY ADHERE TO THE SIGS (BOARD-ENDORSED)\n%%% PROCEEDINGS STYLE. It has been designed to produce a \'tighter\'\n%%% paper in response to concerns over page budgets.\n%%% The main features of this style are:\n%%%\n%%% 1)  Two columns.\n%%% 2)  Side and top margins of 4.5pc, bottom margin of 6pc, column gutter of\n%%%     2pc, hence columns are 20pc wide and 55.5pc tall.  (6pc =3D 1in, approx)\n%%% 3)  First page has title information, and an extra 6pc of space at the\n%%%     bottom of the first column for the ACM copyright notice.\n%%% 4)  Text is 9pt on 10pt baselines; titles (except main) are 9pt bold.\n%%%\n%%%\n%%% There are a few restrictions you must observe:\n%%%\n%%% 1)  You cannot change the font size; ACM wants you to use 9pt.\n%%% 3)  You must start your paper with the \\maketitle command.  Prior to the\n%%%     \\maketitle you must have \\title and \\author commands.  If you have a\n%%%     \\date command it will be ignored; no date appears on the paper, since\n%%%     the proceedings will have a date on the front cover.\n%%% 4)  Marginal paragraphs, tables of contents, lists of figures and tables,\n%%%     and page headings are all forbidden.\n%%% 5)  The `figure\' environment will produce a figure one column wide; if you\n%%%     want one that is two columns wide, use `figure*\'.\n%%%\n%\n%%% Copyright Space:\n%%% This style automatically reserves 1" blank space at the bottom of page 1/\n%%% column 1.  This space can optionally be filled with some text using the\n%%% \\toappear{...} command.  If used, this command must be BEFORE the \\maketitle\n%%% command.  If this command is defined AND [preprint] is on, then the\n%%% space is filled with the {...} text (at the bottom); otherwise, it is\n%%% blank.  If you use \\toappearbox{...} instead of \\toappear{...} then a\n%%% box will be drawn around the text (if [preprint] is on).\n%%%\n%%% A typical usage looks like this:\n%%%     \\toappear{To appear in the Ninth AES Conference on Medievil Lithuanian\n%%%               Embalming Technique, June 1991, Alfaretta, Georgia.}\n%%% This will be included in the preprint, and left out of the conference\n%%% version.\n%%%\n%%% WARNING:\n%%% Some dvi-ps converters heuristically allow chars to drift from their\n%%% true positions a few pixels. This may be noticeable with the 9pt sans-serif\n%%% bold font used for section headers.\n%%% You may turn this hackery off via the -e option:\n%%%     dvips -e 0 foo.dvi >foo.ps\n%%%\n\\typeout{Document Class \'sig-alternate\' <23rd. May \'12>.  Modified by G.K.M. Tobin/Gerry Murray}\n\\typeout{Based in part upon document Style `acmconf\' <22 May 89>. Hacked 4/91 by}\n\\typeout{shivers@cs.cmu.edu, 4/93 by theobald@cs.mcgill.ca}\n\\typeout{Excerpts were taken from (Journal Style) \'esub2acm.cls\'.}\n\\typeout{****** Bugs/comments/suggestions/technicalities to Gerry Murray -- murray@hq.acm.org ******}\n\\typeout{Questions on the style, SIGS policies, etc. to Adrienne Griscti griscti@acm.org}\n\\oddsidemargin 4.5pc\n\\evensidemargin 4.5pc\n\\advance\\oddsidemargin by -1in  % Correct for LaTeX gratuitousness\n\\advance\\evensidemargin by -1in % Correct for LaTeX gratuitousness\n\\marginparwidth 0pt             % Margin pars are not allowed.\n\\marginparsep 11pt              % Horizontal space between outer margin and\n                                % marginal note\n\n                                % Top of page:\n\\topmargin 4.5pc                % Nominal distance from top of page to top of\n                                % box containing running head.\n\\advance\\topmargin by -1in      % Correct for LaTeX gratuitousness\n\\headheight 0pt                 % Height of box containing running head.\n\\headsep 0pt                    % Space between running head and text.\n                                % Bottom of page:\n\\footskip 30pt                  % Distance from baseline of box containing foot\n                                % to baseline of last line of text.\n\\@ifundefined{footheight}{\\newdimen\\footheight}{}% this is for LaTeX2e\n\\footheight 12pt                % Height of box containing running foot.\n\n%% Must redefine the top margin so there\'s room for headers and\n%% page numbers if you are using the preprint option. Footers\n%% are OK as is. Olin.\n\\advance\\topmargin by -37pt     % Leave 37pt above text for headers\n\\headheight 12pt                % Height of box containing running head.\n\\headsep 25pt                   % Space between running head and text.\n\n\\textheight 666pt       % 9 1/4 column height\n\\textwidth 42pc         % Width of text line.\n                        % For two-column mode:\n\\columnsep 2pc          %    Space between columns\n\\columnseprule 0pt      %    Width of rule between columns.\n\\hfuzz 1pt              % Allow some variation in column width, otherwise it\'s\n                        % too hard to typeset in narrow columns.\n\n\\footnotesep 5.6pt      % Height of strut placed at the beginning of every\n                        % footnote =3D height of normal \\footnotesize strut,\n                        % so no extra space between footnotes.\n\n\\skip\\footins 8.1pt plus 4pt minus 2pt  % Space between last line of text and\n                                        % top of first footnote.\n\\floatsep 11pt plus 2pt minus 2pt       % Space between adjacent floats moved\n                                        % to top or bottom of text page.\n\\textfloatsep 18pt plus 2pt minus 4pt   % Space between main text and floats\n                                        % at top or bottom of page.\n\\intextsep 11pt plus 2pt minus 2pt      % Space between in-text figures and\n                                        % text.\n\\@ifundefined{@maxsep}{\\newdimen\\@maxsep}{}% this is for LaTeX2e\n\\@maxsep 18pt                           % The maximum of \\floatsep,\n                                        % \\textfloatsep and \\intextsep (minus\n                                        % the stretch and shrink).\n\\dblfloatsep 11pt plus 2pt minus 2pt    % Same as \\floatsep for double-column\n                                        % figures in two-column mode.\n\\dbltextfloatsep 18pt plus 2pt minus 4pt% \\textfloatsep for double-column\n                                        % floats.\n\\@ifundefined{@dblmaxsep}{\\newdimen\\@dblmaxsep}{}% this is for LaTeX2e\n\\@dblmaxsep 18pt                        % The maximum of \\dblfloatsep and\n                                        % \\dbltexfloatsep.\n\\@fptop 0pt plus 1fil    % Stretch at top of float page/column. (Must be\n                         % 0pt plus ...)\n\\@fpsep 8pt plus 2fil    % Space between floats on float page/column.\n\\@fpbot 0pt plus 1fil    % Stretch at bottom of float page/column. (Must be\n                         % 0pt plus ... )\n\\@dblfptop 0pt plus 1fil % Stretch at top of float page. (Must be 0pt plus ...)\n\\@dblfpsep 8pt plus 2fil % Space between floats on float page.\n\\@dblfpbot 0pt plus 1fil % Stretch at bottom of float page. (Must be\n                         % 0pt plus ... )\n\\marginparpush 5pt       % Minimum vertical separation between two marginal\n                         % notes.\n\n\\parskip 0pt plus 1pt            % Extra vertical space between paragraphs.\n\\parindent 10pt  % GM July 2000 / was 0pt - width of paragraph indentation.\n\\partopsep 2pt plus 1pt minus 1pt% Extra vertical space, in addition to\n                                 % \\parskip and \\topsep, added when user\n                                 % leaves blank line before environment.\n\n\\@lowpenalty   51       % Produced by \\nopagebreak[1] or \\nolinebreak[1]\n\\@medpenalty  151       % Produced by \\nopagebreak[2] or \\nolinebreak[2]\n\\@highpenalty 301       % Produced by \\nopagebreak[3] or \\nolinebreak[3]\n\n\\@beginparpenalty -\\@lowpenalty % Before a list or paragraph environment.\n\\@endparpenalty   -\\@lowpenalty % After a list or paragraph environment.\n\\@itempenalty     -\\@lowpenalty % Between list items.\n\n%\\@namedef{ds@10pt}{\\@latexerr{The `10pt\' option is not allowed in the `acmconf\'\n%\\@namedef{ds@10pt}{\\ClassError{The `10pt\' option is not allowed in the `acmconf\'\t% January 2008\n%  document style.}\\@eha}\n%\\@namedef{ds@11pt}{\\@latexerr{The `11pt\' option is not allowed in the `acmconf\'\n\\@namedef{ds@11pt}{\\ClassError{The `11pt\' option is not allowed in the `acmconf\'\t% January 2008\n  document style.}\\@eha}\n%\\@namedef{ds@12pt}{\\@latexerr{The `12pt\' option is not allowed in the `acmconf\'\n\\@namedef{ds@12pt}{\\ClassError{The `12pt\' option is not allowed in the `acmconf\'\t% January 2008\n  document style.}\\@eha}\n\n\\@options\n\n\\lineskip 2pt           % \\lineskip is 1pt for all font sizes.\n\\normallineskip 2pt\n\\def\\baselinestretch{1}\n\n\\abovedisplayskip 10pt plus2pt minus4.5pt%\n\\belowdisplayskip \\abovedisplayskip\n\\abovedisplayshortskip  \\z@ plus3pt%\n\\belowdisplayshortskip  5.4pt plus3pt minus3pt%\n\\let\\@listi\\@listI     % Setting of \\@listi added 9 Jun 87\n\n\\def\\small{\\@setsize\\small{9pt}\\viiipt\\@viiipt\n\\abovedisplayskip 7.6pt plus 3pt minus 4pt%\n\\belowdisplayskip \\abovedisplayskip\n\\abovedisplayshortskip \\z@ plus2pt%\n\\belowdisplayshortskip 3.6pt plus2pt minus 2pt\n\\def\\@listi{\\leftmargin\\leftmargini %% Added 22 Dec 87\n\\topsep 4pt plus 2pt minus 2pt\\parsep 2pt plus 1pt minus 1pt\n\\itemsep \\parsep}}\n\n\\def\\refsmall{\\@setsize\\small{8pt}\\viiipt\\@viiipt\n\\abovedisplayskip 7.6pt plus 3pt minus 4pt%\n\\belowdisplayskip \\abovedisplayskip\n\\abovedisplayshortskip \\z@ plus2pt%\n\\belowdisplayshortskip 3.6pt plus2pt minus 2pt\n\\def\\@listi{\\leftmargin\\leftmargini %% Added 22 Dec 87\n\\topsep 4pt plus 2pt minus 2pt\\parsep 2pt plus 1pt minus 1pt\n\\itemsep \\parsep}}\n\n\\def\\footnotesize{\\@setsize\\footnotesize{9pt}\\ixpt\\@ixpt\n\\abovedisplayskip 6.4pt plus 2pt minus 4pt%\n\\belowdisplayskip \\abovedisplayskip\n\\abovedisplayshortskip \\z@ plus 1pt%\n\\belowdisplayshortskip 2.7pt plus 1pt minus 2pt\n\\def\\@listi{\\leftmargin\\leftmargini %% Added 22 Dec 87\n\\topsep 3pt plus 1pt minus 1pt\\parsep 2pt plus 1pt minus 1pt\n\\itemsep \\parsep}}\n\n\\newcount\\aucount\n\\newcount\\originalaucount\n\\newdimen\\auwidth\n\\auwidth=\\textwidth\n\\newdimen\\auskip\n\\newcount\\auskipcount\n\\newdimen\\auskip\n\\global\\auskip=1pc\n\\newdimen\\allauboxes\n\\allauboxes=\\auwidth\n\\newtoks\\addauthors\n\\newcount\\addauflag\n\\global\\addauflag=0 %Haven\'t shown additional authors yet\n\n\\newtoks\\subtitletext\n\\gdef\\subtitle#1{\\subtitletext={#1}}\n\n\\gdef\\additionalauthors#1{\\addauthors={#1}}\n\n\\gdef\\numberofauthors#1{\\global\\aucount=#1\n\\ifnum\\aucount>3\\global\\originalaucount=\\aucount \\global\\aucount=3\\fi %g}  % 3 OK - Gerry March 2007\n\\global\\auskipcount=\\aucount\\global\\advance\\auskipcount by 1\n\\global\\multiply\\auskipcount by 2\n\\global\\multiply\\auskip by \\auskipcount\n\\global\\advance\\auwidth by -\\auskip\n\\global\\divide\\auwidth by \\aucount}\n\n% \\and was modified to count the number of authors.  GKMT 12 Aug 1999\n\\def\\alignauthor{%                  % \\begin{tabular}\n\\end{tabular}%\n  \\begin{tabular}[t]{p{\\auwidth}}\\centering}%\n\n%  *** NOTE *** NOTE *** NOTE *** NOTE ***\n%  If you have \'font problems\' then you may need\n%  to change these, e.g. \'arialb\' instead of "arialbd".\n%  Gerry Murray 11/11/1999\n%  *** OR ** comment out block A and activate block B or vice versa.\n% **********************************************\n%\n%  -- Start of block A -- (Type 1 or Truetype fonts)\n%\\newfont{\\secfnt}{timesbd at 12pt} % was timenrb originally - now is timesbd\n%\\newfont{\\secit}{timesbi at 12pt}   %13 Jan 00 gkmt\n%\\newfont{\\subsecfnt}{timesi at 11pt} % was timenrri originally - now is timesi\n%\\newfont{\\subsecit}{timesbi at 11pt} % 13 Jan 00 gkmt -- was times changed to timesbi gm 2/4/2000\n%                         % because "normal" is italic, "italic" is Roman\n%\\newfont{\\ttlfnt}{arialbd at 18pt} % was arialb originally - now is arialbd\n%\\newfont{\\ttlit}{arialbi at 18pt}    % 13 Jan 00 gkmt\n%\\newfont{\\subttlfnt}{arial at 14pt} % was arialr originally - now is arial\n%\\newfont{\\subttlit}{ariali at 14pt} % 13 Jan 00 gkmt\n%\\newfont{\\subttlbf}{arialbd at 14pt}  % 13 Jan 00 gkmt\n%\\newfont{\\aufnt}{arial at 12pt} % was arialr originally - now is arial\n%\\newfont{\\auit}{ariali at 12pt} % 13 Jan 00 gkmt\n%\\newfont{\\affaddr}{arial at 10pt} % was arialr originally - now is arial\n%\\newfont{\\affaddrit}{ariali at 10pt} %13 Jan 00 gkmt\n%\\newfont{\\eaddfnt}{arial at 12pt} % was arialr originally - now is arial\n%\\newfont{\\ixpt}{times at 9pt} % was timenrr originally - now is times\n%\\newfont{\\confname}{timesi at 8pt} % was timenrri - now is timesi\n%\\newfont{\\crnotice}{times at 8pt} % was timenrr originally - now is times\n%\\newfont{\\ninept}{times at 9pt} % was timenrr originally - now is times\n\n% *********************************************\n%  -- End of block A --\n%\n%\n% -- Start of block B -- UPDATED FONT NAMES\n% *********************************************\n% Gerry Murray 11/30/2006\n% *********************************************\n\\newfont{\\secfnt}{ptmb8t at 12pt}\n\\newfont{\\secit}{ptmbi8t at 12pt}    %13 Jan 00 gkmt\n\\newfont{\\subsecfnt}{ptmri8t at 11pt}\n\\newfont{\\subsecit}{ptmbi8t at 11pt}  % \n\\newfont{\\ttlfnt}{phvb8t at 18pt}\n\\newfont{\\ttlit}{phvbo8t at 18pt}    % GM 2/4/2000\n\\newfont{\\subttlfnt}{phvr8t at 14pt}\n\\newfont{\\subttlit}{phvro8t at 14pt} % GM 2/4/2000\n\\newfont{\\subttlbf}{phvb8t at 14pt}  % 13 Jan 00 gkmt\n\\newfont{\\aufnt}{phvr8t at 12pt}\n\\newfont{\\auit}{phvro8t at 12pt}     % GM 2/4/2000\n\\newfont{\\affaddr}{phvr8t at 10pt}\n\\newfont{\\affaddrit}{phvro8t at 10pt} % GM 2/4/2000\n\\newfont{\\eaddfnt}{phvr8t at 12pt}\n\\newfont{\\ixpt}{ptmr8t at 9pt}\n\\newfont{\\confname}{ptmri8t at 8pt}\n\\newfont{\\crnotice}{ptmr8t at 8pt}\n\\newfont{\\ninept}{ptmr8t at 9pt}\n% +++++++++++++++++++++++++++++++++++++++++++++\n% -- End of block B --\n\n%\\def\\email#1{{{\\eaddfnt{\\vskip 4pt#1}}}}\n% If we have an email, inside a "shared affiliation" then we need the following instead\n\\def\\email#1{{{\\eaddfnt{\\par #1}}}}       % revised  - GM - 11/30/2006\n\n\\def\\addauthorsection{\\ifnum\\originalaucount>6  % was 3 - Gerry March 2007\n    \\section{Additional Authors}\\the\\addauthors\n  \\fi}\n\n\\newcount\\savesection\n\\newcount\\sectioncntr\n\\global\\sectioncntr=1\n\n\\setcounter{secnumdepth}{3}\n\n\\def\\appendix{\\par\n\\section*{APPENDIX}\n\\setcounter{section}{0}\n \\setcounter{subsection}{0}\n \\def\\thesection{\\Alph{section}} }\n\n\\leftmargini 22.5pt\n\\leftmarginii 19.8pt    % > \\labelsep + width of \'(m)\'\n\\leftmarginiii 16.8pt   % > \\labelsep + width of \'vii.\'\n\\leftmarginiv 15.3pt    % > \\labelsep + width of \'M.\'\n\\leftmarginv 9pt\n\\leftmarginvi 9pt\n\n\\leftmargin\\leftmargini\n\\labelsep 4.5pt\n\\labelwidth\\leftmargini\\advance\\labelwidth-\\labelsep\n\n\\def\\@listI{\\leftmargin\\leftmargini \\parsep 3.6pt plus 2pt minus 1pt%\n\\topsep 7.2pt plus 2pt minus 4pt%\n\\itemsep 3.6pt plus 2pt minus 1pt}\n\n\\let\\@listi\\@listI\n\\@listi\n\n\\def\\@listii{\\leftmargin\\leftmarginii\n   \\labelwidth\\leftmarginii\\advance\\labelwidth-\\labelsep\n   \\topsep 3.6pt plus 2pt minus 1pt\n   \\parsep 1.8pt plus 0.9pt minus 0.9pt\n   \\itemsep \\parsep}\n\n\\def\\@listiii{\\leftmargin\\leftmarginiii\n    \\labelwidth\\leftmarginiii\\advance\\labelwidth-\\labelsep\n    \\topsep 1.8pt plus 0.9pt minus 0.9pt\n    \\parsep \\z@ \\partopsep 1pt plus 0pt minus 1pt\n    \\itemsep \\topsep}\n\n\\def\\@listiv{\\leftmargin\\leftmarginiv\n     \\labelwidth\\leftmarginiv\\advance\\labelwidth-\\labelsep}\n\n\\def\\@listv{\\leftmargin\\leftmarginv\n     \\labelwidth\\leftmarginv\\advance\\labelwidth-\\labelsep}\n\n\\def\\@listvi{\\leftmargin\\leftmarginvi\n     \\labelwidth\\leftmarginvi\\advance\\labelwidth-\\labelsep}\n\n\\def\\labelenumi{\\theenumi.}\n\\def\\theenumi{\\arabic{enumi}}\n\n\\def\\labelenumii{(\\theenumii)}\n\\def\\theenumii{\\alph{enumii}}\n\\def\\p@enumii{\\theenumi}\n\n\\def\\labelenumiii{\\theenumiii.}\n\\def\\theenumiii{\\roman{enumiii}}\n\\def\\p@enumiii{\\theenumi(\\theenumii)}\n\n\\def\\labelenumiv{\\theenumiv.}\n\\def\\theenumiv{\\Alph{enumiv}}\n\\def\\p@enumiv{\\p@enumiii\\theenumiii}\n\n\\def\\labelitemi{$\\bullet$}\n\\def\\labelitemii{\\bf --}\n\\def\\labelitemiii{$\\ast$}\n\\def\\labelitemiv{$\\cdot$}\n\n\\def\\verse{\\let\\\\=\\@centercr\n  \\list{}{\\itemsep\\z@ \\itemindent -1.5em\\listparindent \\itemindent\n          \\rightmargin\\leftmargin\\advance\\leftmargin 1.5em}\\item[]}\n\\let\\endverse\\endlist\n\n\\def\\quotation{\\list{}{\\listparindent 1.5em\n    \\itemindent\\listparindent\n    \\rightmargin\\leftmargin \\parsep 0pt plus 1pt}\\item[]}\n\\let\\endquotation=\\endlist\n\n\\def\\quote{\\list{}{\\rightmargin\\leftmargin}\\item[]}\n\\let\\endquote=\\endlist\n\n\\def\\descriptionlabel#1{\\hspace\\labelsep \\bf #1}\n\\def\\description{\\list{}{\\labelwidth\\z@ \\itemindent-\\leftmargin\n       \\let\\makelabel\\descriptionlabel}}\n\n\\let\\enddescription\\endlist\n\n\\def\\theequation{\\arabic{equation}}\n\n\\arraycolsep 4.5pt   % Half the space between columns in an array environment.\n\\tabcolsep 5.4pt    % Half the space between columns in a tabular environment.\n\\arrayrulewidth .5pt % Width of rules in array and tabular environment. % (was .4) updated Gerry March 20 2007\n\\doublerulesep 1.8pt % Space between adjacent rules in array or tabular env.\n\n\\tabbingsep \\labelsep   % Space used by the \\\' command.  (See LaTeX manual.)\n\n\\skip\\@mpfootins =\\skip\\footins\n\n\\fboxsep =2.7pt      % Space left between box and text by \\fbox and \\framebox.\n\\fboxrule =.5pt      % Width of rules in box made by \\fbox and \\framebox. % (was .4) updated Gerry March 20 2007\n\n\\def\\thepart{\\Roman{part}} % Roman numeral part numbers.\n\\def\\thesection       {\\arabic{section}}\n\\def\\thesubsection    {\\thesection.\\arabic{subsection}}\n%\\def\\thesubsubsection {\\thesubsection.\\arabic{subsubsection}} % GM 7/30/2002\n%\\def\\theparagraph     {\\thesubsubsection.\\arabic{paragraph}}  % GM 7/30/2002\n\\def\\thesubparagraph  {\\theparagraph.\\arabic{subparagraph}}\n\n\\def\\@pnumwidth{1.55em}\n\\def\\@tocrmarg {2.55em}\n\\def\\@dotsep{4.5}\n\\setcounter{tocdepth}{3}\n\n%\\def\\tableofcontents{\\@latexerr{\\tableofcontents: Tables of contents are not\n%  allowed in the `acmconf\' document style.}\\@eha}\n\n\\def\\tableofcontents{\\ClassError{%\n    \\string\\tableofcontents\\space is not allowed in the `acmconf\' document\t% January 2008\n    style}\\@eha}\n\n\\def\\l@part#1#2{\\addpenalty{\\@secpenalty}\n   \\addvspace{2.25em plus 1pt}  % space above part line\n   \\begingroup\n   \\@tempdima 3em       % width of box holding part number, used by\n     \\parindent \\z@ \\rightskip \\@pnumwidth      %% \\numberline\n     \\parfillskip -\\@pnumwidth\n     {\\large \\bf        % set line in \\large boldface\n     \\leavevmode        % TeX command to enter horizontal mode.\n     #1\\hfil \\hbox to\\@pnumwidth{\\hss #2}}\\par\n     \\nobreak           % Never break after part entry\n   \\endgroup}\n\n\\def\\l@section#1#2{\\addpenalty{\\@secpenalty} % good place for page break\n   \\addvspace{1.0em plus 1pt}   % space above toc entry\n   \\@tempdima 1.5em             % width of box holding section number\n   \\begingroup\n    \\parindent  \\z@ \\rightskip \\@pnumwidth\n     \\parfillskip -\\@pnumwidth\n     \\bf                        % Boldface.\n     \\leavevmode                % TeX command to enter horizontal mode.\n      \\advance\\leftskip\\@tempdima %% added 5 Feb 88 to conform to\n      \\hskip -\\leftskip           %% 25 Jan 88 change to \\numberline\n     #1\\nobreak\\hfil \\nobreak\\hbox to\\@pnumwidth{\\hss #2}\\par\n   \\endgroup}\n\n\n\\def\\l@subsection{\\@dottedtocline{2}{1.5em}{2.3em}}\n\\def\\l@subsubsection{\\@dottedtocline{3}{3.8em}{3.2em}}\n\\def\\l@paragraph{\\@dottedtocline{4}{7.0em}{4.1em}}\n\\def\\l@subparagraph{\\@dottedtocline{5}{10em}{5em}}\n\n%\\def\\listoffigures{\\@latexerr{\\listoffigures: Lists of figures are not\n%  allowed in the `acmconf\' document style.}\\@eha}\n\n\\def\\listoffigures{\\ClassError{%\n    \\string\\listoffigures\\space is not allowed in the `acmconf\' document\t% January 2008\n    style}\\@eha}\n\n\\def\\l@figure{\\@dottedtocline{1}{1.5em}{2.3em}}\n\n%\\def\\listoftables{\\@latexerr{\\listoftables: Lists of tables are not\n%  allowed in the `acmconf\' document style.}\\@eha}\n%\\let\\l@table\\l@figure\n\n\\def\\listoftables{\\ClassError{%\n    \\string\\listoftables\\space is not allowed in the `acmconf\' document\t\t% January 2008\n    style}\\@eha}\n \\let\\l@table\\l@figure\n\n\\def\\footnoterule{\\kern-3\\p@\n  \\hrule width .5\\columnwidth   % (was .4) updated Gerry March 20 2007\n  \\kern 2.6\\p@}                 % The \\hrule has default height of .4pt % (was .4) updated Gerry March 20 2007\n% ------\n\\long\\def\\@makefntext#1{\\noindent \n%\\hbox to .5em{\\hss$^{\\@thefnmark}$}#1}   % original\n\\hbox to .5em{\\hss\\textsuperscript{\\@thefnmark}}#1}  % C. Clifton / GM Oct. 2nd. 2002\n% -------\n\n\\long\\def\\@maketntext#1{\\noindent\n#1}\n\n\\long\\def\\@maketitlenotetext#1#2{\\noindent\n            \\hbox to 1.8em{\\hss$^{#1}$}#2}\n\n\\setcounter{topnumber}{2}\n\\def\\topfraction{.7}\n\\setcounter{bottomnumber}{1}\n\\def\\bottomfraction{.3}\n\\setcounter{totalnumber}{3}\n\\def\\textfraction{.2}\n\\def\\floatpagefraction{.5}\n\\setcounter{dbltopnumber}{2}\n\\def\\dbltopfraction{.7}\n\\def\\dblfloatpagefraction{.5}\n\n%\n\\long\\def\\@makecaption#1#2{\n   \\vskip \\baselineskip\n   \\setbox\\@tempboxa\\hbox{\\textbf{#1: #2}}\n   \\ifdim \\wd\\@tempboxa >\\hsize % IF longer than one line:\n       \\textbf{#1: #2}\\par               %   THEN set as ordinary paragraph.\n     \\else                      %   ELSE  center.\n       \\hbox to\\hsize{\\hfil\\box\\@tempboxa\\hfil}\\par\n   \\fi}\n\n%\n\n\\long\\def\\@makecaption#1#2{\n   \\vskip 10pt\n   \\setbox\\@tempboxa\\hbox{\\textbf{#1: #2}}\n   \\ifdim \\wd\\@tempboxa >\\hsize % IF longer than one line:\n       \\textbf{#1: #2}\\par                %   THEN set as ordinary paragraph.\n     \\else                      %   ELSE  center.\n       \\hbox to\\hsize{\\hfil\\box\\@tempboxa\\hfil}\n   \\fi}\n\n\\@ifundefined{figure}{\\newcounter {figure}} % this is for LaTeX2e\n\n\\def\\fps@figure{tbp}\n\\def\\ftype@figure{1}\n\\def\\ext@figure{lof}\n\\def\\fnum@figure{Figure \\thefigure}\n\\def\\figure{\\@float{figure}}\n%\\let\\endfigure\\end@float\n\\def\\endfigure{\\end@float} \t\t% Gerry January 2008\n\\@namedef{figure*}{\\@dblfloat{figure}}\n\\@namedef{endfigure*}{\\end@dblfloat}\n\n\\@ifundefined{table}{\\newcounter {table}} % this is for LaTeX2e\n\n\\def\\fps@table{tbp}\n\\def\\ftype@table{2}\n\\def\\ext@table{lot}\n\\def\\fnum@table{Table \\thetable}\n\\def\\table{\\@float{table}}\n%\\let\\endtable\\end@float\n\\def\\endtable{\\end@float}\t\t% Gerry January 2008\n\\@namedef{table*}{\\@dblfloat{table}}\n\\@namedef{endtable*}{\\end@dblfloat}\n\n\\newtoks\\titleboxnotes\n\\newcount\\titleboxnoteflag\n\n\\def\\maketitle{\\par\n \\begingroup\n   \\def\\thefootnote{\\fnsymbol{footnote}}\n   \\def\\@makefnmark{\\hbox\n       to 0pt{$^{\\@thefnmark}$\\hss}}\n     \\twocolumn[\\@maketitle]\n\\@thanks\n \\endgroup\n \\setcounter{footnote}{0}\n \\let\\maketitle\\relax\n \\let\\@maketitle\\relax\n \\gdef\\@thanks{}\\gdef\\@author{}\\gdef\\@title{}\\gdef\\@subtitle{}\\let\\thanks\\relax\n \\@copyrightspace}\n\n%% CHANGES ON NEXT LINES\n\\newif\\if@ll % to record which version of LaTeX is in use\n\n\\expandafter\\ifx\\csname LaTeXe\\endcsname\\relax % LaTeX2.09 is used\n\\else% LaTeX2e is used, so set ll to true\n\\global\\@lltrue\n\\fi\n\n\\if@ll\n  \\NeedsTeXFormat{LaTeX2e}\n  \\ProvidesClass{sig-alternate} [2012/05/23 - V2.5 - based on acmproc.cls V1.3 <Nov. 30 \'99>]\n  \\RequirePackage{latexsym}% QUERY: are these two really needed?\n  \\let\\dooptions\\ProcessOptions\n\\else\n  \\let\\dooptions\\@options\n\\fi\n%% END CHANGES\n\n\\def\\@height{height}\n\\def\\@width{width}\n\\def\\@minus{minus}\n\\def\\@plus{plus}\n\\def\\hb@xt@{\\hbox to}\n\\newif\\if@faircopy\n\\@faircopyfalse\n\\def\\ds@faircopy{\\@faircopytrue}\n\n\\def\\ds@preprint{\\@faircopyfalse}\n\n\\@twosidetrue\n\\@mparswitchtrue\n\\def\\ds@draft{\\overfullrule 5\\p@}\n%% CHANGE ON NEXT LINE\n\\dooptions\n\n\\lineskip \\p@\n\\normallineskip \\p@\n\\def\\baselinestretch{1}\n\\def\\@ptsize{0} %needed for amssymbols.sty\n\n%% CHANGES ON NEXT LINES\n\\if@ll% allow use of old-style font change commands in LaTeX2e\n\\@maxdepth\\maxdepth\n%\n\\DeclareOldFontCommand{\\rm}{\\ninept\\rmfamily}{\\mathrm}\n\\DeclareOldFontCommand{\\sf}{\\normalfont\\sffamily}{\\mathsf}\n\\DeclareOldFontCommand{\\tt}{\\normalfont\\ttfamily}{\\mathtt}\n\\DeclareOldFontCommand{\\bf}{\\normalfont\\bfseries}{\\mathbf}\n\\DeclareOldFontCommand{\\it}{\\normalfont\\itshape}{\\mathit}\n\\DeclareOldFontCommand{\\sl}{\\normalfont\\slshape}{\\@nomath\\sl}\n\\DeclareOldFontCommand{\\sc}{\\normalfont\\scshape}{\\@nomath\\sc}\n\\DeclareRobustCommand*{\\cal}{\\@fontswitch{\\relax}{\\mathcal}}\n\\DeclareRobustCommand*{\\mit}{\\@fontswitch{\\relax}{\\mathnormal}}\n\\fi\n%\n\\if@ll\n \\renewcommand{\\rmdefault}{cmr}  % was \'ttm\'\n% Note! I have also found \'mvr\' to work ESPECIALLY well.\n% Gerry - October 1999\n% You may need to change your LV1times.fd file so that sc is\n% mapped to cmcsc - -for smallcaps -- that is if you decide\n% to change {cmr} to {times} above. (Not recommended)\n  \\renewcommand{\\@ptsize}{}\n  \\renewcommand{\\normalsize}{%\n    %\\@setfontsize\\normalsize\\@ixpt{10.5\\p@}%\\ninept%\n    \\@setfontsize\\normalsize\\@xpt{11\\p@}%\\tenpt% %% Adjusted for 10pt\n    \\abovedisplayskip 6\\p@ \\@plus2\\p@ \\@minus\\p@\n    \\belowdisplayskip \\abovedisplayskip\n    \\abovedisplayshortskip 6\\p@ \\@minus 3\\p@\n    \\belowdisplayshortskip 6\\p@ \\@minus 3\\p@\n    \\let\\@listi\\@listI\n  }\n\\else\n  \\def\\@normalsize{%changed next to 9 from 10\n    \\@setsize\\normalsize{10\\p@}\\ixpt\\@ixpt\n   \\abovedisplayskip 6\\p@ \\@plus2\\p@ \\@minus\\p@\n    \\belowdisplayskip \\abovedisplayskip\n    \\abovedisplayshortskip 6\\p@ \\@minus 3\\p@\n    \\belowdisplayshortskip 6\\p@ \\@minus 3\\p@\n    \\let\\@listi\\@listI\n  }%\n\\fi\n\\if@ll\n  \\newcommand\\scriptsize{\\@setfontsize\\scriptsize\\@viipt{8\\p@}}\n  \\newcommand\\tiny{\\@setfontsize\\tiny\\@vpt{6\\p@}}\n  \\newcommand\\large{\\@setfontsize\\large\\@xiipt{14\\p@}}\n  \\newcommand\\Large{\\@setfontsize\\Large\\@xivpt{18\\p@}}\n  \\newcommand\\LARGE{\\@setfontsize\\LARGE\\@xviipt{20\\p@}}\n  \\newcommand\\huge{\\@setfontsize\\huge\\@xxpt{25\\p@}}\n  \\newcommand\\Huge{\\@setfontsize\\Huge\\@xxvpt{30\\p@}}\n\\else\n  \\def\\scriptsize{\\@setsize\\scriptsize{8\\p@}\\viipt\\@viipt}\n  \\def\\tiny{\\@setsize\\tiny{6\\p@}\\vpt\\@vpt}\n  \\def\\large{\\@setsize\\large{14\\p@}\\xiipt\\@xiipt}\n  \\def\\Large{\\@setsize\\Large{18\\p@}\\xivpt\\@xivpt}\n  \\def\\LARGE{\\@setsize\\LARGE{20\\p@}\\xviipt\\@xviipt}\n  \\def\\huge{\\@setsize\\huge{25\\p@}\\xxpt\\@xxpt}\n  \\def\\Huge{\\@setsize\\Huge{30\\p@}\\xxvpt\\@xxvpt}\n\\fi\n\\normalsize\n\n% make aubox hsize/number of authors up to 3, less gutter\n% then showbox gutter showbox gutter showbox -- GKMT Aug 99\n\\newbox\\@acmtitlebox\n\\def\\@maketitle{\\newpage\n \\null\n \\setbox\\@acmtitlebox\\vbox{%\n\\baselineskip 20pt\n\\vskip 3em                   % Vertical space above title.\n   \\begin{center}\n    {\\ttlfnt \\@title\\par}       % Title set in 18pt Helvetica (Arial) bold size.\n    \\vskip 4em                % Vertical space after title.\n%This should be the subtitle.\n{\\subttlfnt \\the\\subtitletext\\par}\\vskip 1.25em%\\fi\n    {\\baselineskip 16pt\\aufnt   % each author set in \\12 pt Arial, in a\n     \\lineskip .5em             % tabular environment\n     \\begin{tabular}[t]{c}\\@author\n     \\end{tabular}\\par}\n    \\vskip 1.5em               % Vertical space after author.\n   \\end{center}}\n \\dimen0=\\ht\\@acmtitlebox\n \\advance\\dimen0 by -12.75pc\\relax % Increased space for title box -- KBT\n \\unvbox\\@acmtitlebox\n \\ifdim\\dimen0<0.0pt\\relax\\vskip-\\dimen0\\fi}\n\n\n\\newcount\\titlenotecount\n\\global\\titlenotecount=0\n\\newtoks\\tntoks\n\\newtoks\\tntokstwo\n\\newtoks\\tntoksthree\n\\newtoks\\tntoksfour\n\\newtoks\\tntoksfive\n\n\\def\\abstract{\n\\ifnum\\titlenotecount>0 % was =1\n    \\insert\\footins{%\n    \\reset@font\\footnotesize\n        \\interlinepenalty\\interfootnotelinepenalty\n        \\splittopskip\\footnotesep\n        \\splitmaxdepth \\dp\\strutbox \\floatingpenalty \\@MM\n        \\hsize\\columnwidth \\@parboxrestore\n        \\protected@edef\\@currentlabel{%\n        }%\n        \\color@begingroup\n\\ifnum\\titlenotecount=1\n      \\@maketntext{%\n         \\raisebox{4pt}{$\\ast$}\\rule\\z@\\footnotesep\\ignorespaces\\the\\tntoks\\@finalstrut\\strutbox}%\n\\fi\n\\ifnum\\titlenotecount=2\n      \\@maketntext{%\n      \\raisebox{4pt}{$\\ast$}\\rule\\z@\\footnotesep\\ignorespaces\\the\\tntoks\\par\\@finalstrut\\strutbox}%\n\\@maketntext{%\n         \\raisebox{4pt}{$\\dagger$}\\rule\\z@\\footnotesep\\ignorespaces\\the\\tntokstwo\\@finalstrut\\strutbox}%\n\\fi\n\\ifnum\\titlenotecount=3\n      \\@maketntext{%\n         \\raisebox{4pt}{$\\ast$}\\rule\\z@\\footnotesep\\ignorespaces\\the\\tntoks\\par\\@finalstrut\\strutbox}%\n\\@maketntext{%\n         \\raisebox{4pt}{$\\dagger$}\\rule\\z@\\footnotesep\\ignorespaces\\the\\tntokstwo\\par\\@finalstrut\\strutbox}%\n\\@maketntext{%\n         \\raisebox{4pt}{$\\ddagger$}\\rule\\z@\\footnotesep\\ignorespaces\\the\\tntoksthree\\@finalstrut\\strutbox}%\n\\fi\n\\ifnum\\titlenotecount=4\n      \\@maketntext{%\n         \\raisebox{4pt}{$\\ast$}\\rule\\z@\\footnotesep\\ignorespaces\\the\\tntoks\\par\\@finalstrut\\strutbox}%\n\\@maketntext{%\n         \\raisebox{4pt}{$\\dagger$}\\rule\\z@\\footnotesep\\ignorespaces\\the\\tntokstwo\\par\\@finalstrut\\strutbox}%\n\\@maketntext{%\n         \\raisebox{4pt}{$\\ddagger$}\\rule\\z@\\footnotesep\\ignorespaces\\the\\tntoksthree\\par\\@finalstrut\\strutbox}%\n\\@maketntext{%\n         \\raisebox{4pt}{$\\S$}\\rule\\z@\\footnotesep\\ignorespaces\\the\\tntoksfour\\@finalstrut\\strutbox}%\n\\fi\n\\ifnum\\titlenotecount=5\n      \\@maketntext{%\n         \\raisebox{4pt}{$\\ast$}\\rule\\z@\\footnotesep\\ignorespaces\\the\\tntoks\\par\\@finalstrut\\strutbox}%\n\\@maketntext{%\n         \\raisebox{4pt}{$\\dagger$}\\rule\\z@\\footnotesep\\ignorespaces\\the\\tntokstwo\\par\\@finalstrut\\strutbox}%\n\\@maketntext{%\n         \\raisebox{4pt}{$\\ddagger$}\\rule\\z@\\footnotesep\\ignorespaces\\the\\tntoksthree\\par\\@finalstrut\\strutbox}%\n\\@maketntext{%\n         \\raisebox{4pt}{$\\S$}\\rule\\z@\\footnotesep\\ignorespaces\\the\\tntoksfour\\par\\@finalstrut\\strutbox}%\n\\@maketntext{%\n         \\raisebox{4pt}{$\\P$}\\rule\\z@\\footnotesep\\ignorespaces\\the\\tntoksfive\\@finalstrut\\strutbox}%\n\\fi\n   \\color@endgroup} %g}\n\\fi\n\\setcounter{footnote}{0}\n\\section*{ABSTRACT}\\normalsize%\\ninept\n}\n\n\\def\\endabstract{\\if@twocolumn\\else\\endquotation\\fi}\n\n\n% \\def\\keywords{\\if@twocolumn\n% \\section*{Keywords}\n% \\else \\small\n% \\quotation\n% \\fi}\n\n\n\\def\\terms{\\if@twocolumn\n\\section*{General Terms}\n\\else \\small\n\\quotation\n\\fi}\n\n% -- Classification needs to be a bit smart due to optionals - Gerry/Georgia November 2nd. 1999\n\\newcount\\catcount\n\\global\\catcount=1\n\n\\def\\category#1#2#3{%\n\\ifnum\\catcount=1\n\\section*{Categories and Subject Descriptors}\n\\advance\\catcount by 1\\else{\\unskip; }\\fi\n    \\@ifnextchar [{\\@category{#1}{#2}{#3}}{\\@category{#1}{#2}{#3}[]}%\n}\n\n\\def\\@category#1#2#3[#4]{%\n    \\begingroup\n        \\let\\and\\relax\n            #1 [\\textbf{#2}]%\n            \\if!#4!%\n                \\if!#3!\\else : #3\\fi\n            \\else\n                :\\space\n                \\if!#3!\\else #3\\kern\\z@---\\hskip\\z@\\fi\n                \\textit{#4}%\n            \\fi\n    \\endgroup\n}\n%\n\n%%% This section (written by KBT) handles the 1" box in the lower left\n%%% corner of the left column of the first page by creating a picture,\n%%% and inserting the predefined string at the bottom (with a negative\n%%% displacement to offset the space allocated for a non-existent\n%%% caption).\n%%%\n\\newtoks\\copyrightnotice\n\\def\\ftype@copyrightbox{8}\n\\def\\@copyrightspace{\n%\\@float{copyrightbox}[b]\n%\\begin{center}\n%\\setlength{\\unitlength}{1pc}\n%\\begin{picture}(20,6) %Space for copyright notice\n%\\put(0,-0.95){\\crnotice{\\@toappear}}\n%\\end{picture}\n%\\end{center}\n%\\end@float\n}\n\n%\\def\\@toappear{} % Default setting blank - commands below change this.\n%\\long\\def\\toappear#1{\\def\\@toappear{\\parbox[b]{20pc}{\\baselineskip 9pt%#1}}}\n%\\def\\toappearbox#1{\\def\\@toappear{\\raisebox{5pt}{\\framebox[20pc]{\\parb%ox[b]{19pc}{#1}}}}}\n\n%\\newtoks\\conf\n%\\newtoks\\confinfo\n%\\def\\conferenceinfo#1#2{\\global\\conf={#1}\\global\\confinfo{#2}}\n\n\n%\\def\\marginpar{\\@latexerr{The \\marginpar command is not allowed in the\n%  `acmconf\' document style.}\\@eha}\n\n\\def\\marginpar{\\ClassError{%\n    \\string\\marginpar\\space is not allowed in the `acmconf\' document\t\t% January 2008\n    style}\\@eha}\n\n\\mark{{}{}}     % Initializes TeX\'s marks\n\n\\def\\today{\\ifcase\\month\\or\n  January\\or February\\or March\\or April\\or May\\or June\\or\n  July\\or August\\or September\\or October\\or November\\or December\\fi\n  \\space\\number\\day, \\number\\year}\n\n\\def\\@begintheorem#1#2{%\n    \\parskip 0pt % GM July 2000 (for tighter spacing)\n    \\trivlist\n    \\item[%\n        \\hskip 10\\p@\n        \\hskip \\labelsep\n        {{\\sc #1}\\hskip 5\\p@\\relax#2.}%\n    ]\n    \\it\n}\n\\def\\@opargbegintheorem#1#2#3{%\n    \\parskip 0pt % GM July 2000 (for tighter spacing)\n    \\trivlist\n    \\item[%\n        \\hskip 10\\p@\n        \\hskip \\labelsep\n        {\\sc #1\\ #2\\             % This mod by Gerry to enumerate corollaries\n   \\setbox\\@tempboxa\\hbox{(#3)}  % and bracket the \'corollary title\'\n        \\ifdim \\wd\\@tempboxa>\\z@ % and retain the correct numbering of e.g. theorems\n            \\hskip 5\\p@\\relax    % if they occur \'around\' said corollaries.\n            \\box\\@tempboxa       % Gerry - Nov. 1999.\n        \\fi.}%\n    ]\n    \\it\n}\n\\newif\\if@qeded\n\\global\\@qededfalse\n\n% -- original\n%\\def\\proof{%\n%  \\vspace{-\\parskip} % GM July 2000 (for tighter spacing)\n%    \\global\\@qededfalse\n%    \\@ifnextchar[{\\@xproof}{\\@proof}%\n%}\n% -- end of original\n\n% (JSS) Fix for vertical spacing bug - Gerry Murray July 30th. 2002\n\\def\\proof{%\n\\vspace{-\\lastskip}\\vspace{-\\parsep}\\penalty-51%\n\\global\\@qededfalse\n\\@ifnextchar[{\\@xproof}{\\@proof}%\n}\n\n\\def\\endproof{%\n    \\if@qeded\\else\\qed\\fi\n    \\endtrivlist\n}\n\\def\\@proof{%\n    \\trivlist\n    \\item[%\n        \\hskip 10\\p@\n        \\hskip \\labelsep\n        {\\sc Proof.}%\n    ]\n    \\ignorespaces\n}\n\\def\\@xproof[#1]{%\n    \\trivlist\n    \\item[\\hskip 10\\p@\\hskip \\labelsep{\\sc Proof #1.}]%\n    \\ignorespaces\n}\n\\def\\qed{%\n    \\unskip\n    \\kern 10\\p@\n    \\begingroup\n        \\unitlength\\p@\n        \\linethickness{.4\\p@}%\n        \\framebox(6,6){}%\n    \\endgroup\n    \\global\\@qededtrue\n}\n\n\\def\\newdef#1#2{%\n    \\expandafter\\@ifdefinable\\csname #1\\endcsname\n        {\\@definecounter{#1}%\n         \\expandafter\\xdef\\csname the#1\\endcsname{\\@thmcounter{#1}}%\n         \\global\\@namedef{#1}{\\@defthm{#1}{#2}}%\n         \\global\\@namedef{end#1}{\\@endtheorem}%\n    }%\n}\n\\def\\@defthm#1#2{%\n    \\refstepcounter{#1}%\n    \\@ifnextchar[{\\@ydefthm{#1}{#2}}{\\@xdefthm{#1}{#2}}%\n}\n\\def\\@xdefthm#1#2{%\n    \\@begindef{#2}{\\csname the#1\\endcsname}%\n    \\ignorespaces\n}\n\\def\\@ydefthm#1#2[#3]{%\n    \\trivlist\n    \\item[%\n        \\hskip 10\\p@\n        \\hskip \\labelsep\n        {\\it #2%\n%         \\savebox\\@tempboxa{#3}%\n         \\saveb@x\\@tempboxa{#3}%\t\t% January 2008\n         \\ifdim \\wd\\@tempboxa>\\z@\n            \\ \\box\\@tempboxa\n         \\fi.%\n        }]%\n    \\ignorespaces\n}\n\\def\\@begindef#1#2{%\n    \\trivlist\n    \\item[%\n        \\hskip 10\\p@\n        \\hskip \\labelsep\n        {\\it #1\\ \\rm #2.}%\n    ]%\n}\n\\def\\theequation{\\arabic{equation}}\n\n\\newcounter{part}\n\\newcounter{section}\n\\newcounter{subsection}[section]\n\\newcounter{subsubsection}[subsection]\n\\newcounter{paragraph}[subsubsection]\n\\def\\thepart{\\Roman{part}}\n\\def\\thesection{\\arabic{section}}\n\\def\\thesubsection{\\thesection.\\arabic{subsection}}\n\\def\\thesubsubsection{\\thesubsection.\\arabic{subsubsection}} %removed \\subsecfnt 29 July 2002 gkmt\n\\def\\theparagraph{\\thesubsubsection.\\arabic{paragraph}} %removed \\subsecfnt 29 July 2002 gkmt\n\\newif\\if@uchead\n\\@ucheadfalse\n\n%% CHANGES: NEW NOTE\n%% NOTE: OK to use old-style font commands below, since they were\n%% suitably redefined for LaTeX2e\n%% END CHANGES\n\\setcounter{secnumdepth}{3}\n\\def\\part{%\n    \\@startsection{part}{9}{\\z@}{-10\\p@ \\@plus -4\\p@ \\@minus -2\\p@}\n        {4\\p@}{\\normalsize\\@ucheadtrue}%\n}\n\\def\\section{%\n    \\@startsection{section}{1}{\\z@}{-10\\p@ \\@plus -4\\p@ \\@minus -2\\p@}% GM\n    {4\\p@}{\\baselineskip 14pt\\secfnt\\@ucheadtrue}%\n}\n\n\\def\\subsection{%\n    \\@startsection{subsection}{2}{\\z@}{-8\\p@ \\@plus -2\\p@ \\@minus -\\p@}\n    {4\\p@}{\\secfnt}%\n}\n\\def\\subsubsection{%\n    \\@startsection{subsubsection}{3}{\\z@}{-8\\p@ \\@plus -2\\p@ \\@minus -\\p@}%\n    {4\\p@}{\\subsecfnt}%\n}\n%\\def\\paragraph{%\n%    \\vskip 12pt\\@startsection{paragraph}{3}{\\z@}{6\\p@ \\@plus \\p@}% original\n%    {-5\\p@}{\\subsecfnt}%\n%}\n%  If one wants sections, subsections and subsubsections numbered,\n%  but not paragraphs, one usually sets secnumepth to 3.\n%  For that, the "depth" of paragraphs must be given correctly\n%  in the definition (``4\'\' instead of ``3\'\' as second argument\n%  of @startsection):\n\\def\\paragraph{%\n    \\vskip 12pt\\@startsection{paragraph}{4}{\\z@}{6\\p@ \\@plus \\p@}%    % GM and Wolfgang May - 11/30/06\n    {-5\\p@}{\\subsecfnt}%\n}\n\\let\\@period=.\n\\def\\@startsection#1#2#3#4#5#6{%\n        \\if@noskipsec  %gkmt, 11 aug 99\n        \\global\\let\\@period\\@empty\n        \\leavevmode\n        \\global\\let\\@period.%\n    \\fi\n      \\par %\n    \\@tempskipa #4\\relax\n    \\@afterindenttrue\n    \\ifdim \\@tempskipa <\\z@\n        \\@tempskipa -\\@tempskipa\n        \\@afterindentfalse\n    \\fi\n    \\if@nobreak\n    \\everypar{}%\n    \\else\n        \\addpenalty\\@secpenalty\n        \\addvspace\\@tempskipa\n    \\fi\n\\parskip=0pt % GM July 2000 (non numbered) section heads\n    \\@ifstar\n        {\\@ssect{#3}{#4}{#5}{#6}}\n        {\\@dblarg{\\@sect{#1}{#2}{#3}{#4}{#5}{#6}}}%\n}\n\\def\\@sect#1#2#3#4#5#6[#7]#8{%\n    \\ifnum #2>\\c@secnumdepth\n        \\let\\@svsec\\@empty\n    \\else\n        \\refstepcounter{#1}%\n        \\edef\\@svsec{%\n            \\begingroup\n                %\\ifnum#2>2 \\noexpand\\rm \\fi % changed to next 29 July 2002 gkmt\n            \\ifnum#2>2 \\noexpand#6 \\fi\n                \\csname the#1\\endcsname\n            \\endgroup\n            \\ifnum #2=1\\relax .\\fi\n            \\hskip 1em\n        }%\n    \\fi\n    \\@tempskipa #5\\relax\n    \\ifdim \\@tempskipa>\\z@\n        \\begingroup\n            #6\\relax\n            \\@hangfrom{\\hskip #3\\relax\\@svsec}%\n            \\begingroup\n                \\interlinepenalty \\@M\n                \\if@uchead\n                    \\uppercase{#8}%\n                \\else\n                    #8%\n                \\fi\n                \\par\n            \\endgroup\n        \\endgroup\n        \\csname #1mark\\endcsname{#7}%\n        \\vskip -12pt  %gkmt, 11 aug 99 and GM July 2000 (was -14) - numbered section head spacing\n\\addcontentsline{toc}{#1}{%\n            \\ifnum #2>\\c@secnumdepth \\else\n                \\protect\\numberline{\\csname the#1\\endcsname}%\n            \\fi\n            #7%\n        }%\n    \\else\n        \\def\\@svsechd{%\n            #6%\n            \\hskip #3\\relax\n            \\@svsec\n            \\if@uchead\n                \\uppercase{#8}%\n            \\else\n                #8%\n            \\fi\n            \\csname #1mark\\endcsname{#7}%\n            \\addcontentsline{toc}{#1}{%\n                \\ifnum #2>\\c@secnumdepth \\else\n                    \\protect\\numberline{\\csname the#1\\endcsname}%\n                \\fi\n                #7%\n            }%\n        }%\n    \\fi\n    \\@xsect{#5}\\hskip 1pt\n    \\par\n}\n\\def\\@xsect#1{%\n    \\@tempskipa #1\\relax\n    \\ifdim \\@tempskipa>\\z@\n        \\par\n        \\nobreak\n        \\vskip \\@tempskipa\n        \\@afterheading\n    \\else\n        \\global\\@nobreakfalse\n        \\global\\@noskipsectrue\n        \\everypar{%\n            \\if@noskipsec\n                \\global\\@noskipsecfalse\n                \\clubpenalty\\@M\n                \\hskip -\\parindent\n                \\begingroup\n                    \\@svsechd\n                    \\@period\n                \\endgroup\n                \\unskip\n                \\@tempskipa #1\\relax\n                \\hskip -\\@tempskipa\n            \\else\n                \\clubpenalty \\@clubpenalty\n                \\everypar{}%\n            \\fi\n        }%\n    \\fi\n    \\ignorespaces\n}\n\\def\\@trivlist{%\n    \\@topsepadd\\topsep\n    \\if@noskipsec\n        \\global\\let\\@period\\@empty\n        \\leavevmode\n        \\global\\let\\@period.%\n    \\fi\n    \\ifvmode\n        \\advance\\@topsepadd\\partopsep\n    \\else\n        \\unskip\n        \\par\n    \\fi\n    \\if@inlabel\n        \\@noparitemtrue\n        \\@noparlisttrue\n    \\else\n        \\@noparlistfalse\n        \\@topsep\\@topsepadd\n    \\fi\n    \\advance\\@topsep \\parskip\n    \\leftskip\\z@skip\n    \\rightskip\\@rightskip\n    \\parfillskip\\@flushglue\n    \\@setpar{\\if@newlist\\else{\\@@par}\\fi}\n    \\global\\@newlisttrue\n    \\@outerparskip\\parskip\n}\n\n%%% Actually, \'abbrev\' works just fine as the default\n%%% Bibliography style.\n\n\\typeout{Using \'Abbrev\' bibliography style}\n\\newcommand\\bibyear[2]{%\n    \\unskip\\quad\\ignorespaces#1\\unskip\n    \\if#2..\\quad \\else \\quad#2 \\fi\n}\n\\newcommand{\\bibemph}[1]{{\\em#1}}\n\\newcommand{\\bibemphic}[1]{{\\em#1\\/}}\n\\newcommand{\\bibsc}[1]{{\\sc#1}}\n\\def\\@normalcite{%\n    \\def\\@cite##1##2{[##1\\if@tempswa , ##2\\fi]}%\n}\n\\def\\@citeNB{%\n    \\def\\@cite##1##2{##1\\if@tempswa , ##2\\fi}%\n}\n\\def\\@citeRB{%\n    \\def\\@cite##1##2{##1\\if@tempswa , ##2\\fi]}%\n}\n\\def\\start@cite#1#2{%\n    \\edef\\citeauthoryear##1##2##3{%\n        ###1%\n        \\ifnum#2=\\z@ \\else\\ ###2\\fi\n    }%\n    \\ifnum#1=\\thr@@\n        \\let\\@@cite\\@citeyear\n    \\else\n        \\let\\@@cite\\@citenormal\n    \\fi\n    \\@ifstar{\\@citeNB\\@@cite}{\\@normalcite\\@@cite}%\n}\n%\\def\\cite{\\start@cite23}\n\\DeclareRobustCommand\\cite{\\start@cite23}\t\t% January 2008\n\\def\\citeNP{\\cite*}\t\t\t\t\t% No Parentheses e.g. 5\n%\\def\\citeA{\\start@cite10}\n\\DeclareRobustCommand\\citeA{\\start@cite10}\t\t% January 2008\n\\def\\citeANP{\\citeA*}\n%\\def\\shortcite{\\start@cite23}\t\t\t\t\n\\DeclareRobustCommand\\shortcite{\\start@cite23}\t\t% January 2008\n\\def\\shortciteNP{\\shortcite*}\n%\\def\\shortciteA{\\start@cite20}\n\\DeclareRobustCommand\\shortciteA{\\start@cite20}\t\t% January 2008\n\\def\\shortciteANP{\\shortciteA*}\n%\\def\\citeyear{\\start@cite30}\n\\DeclareRobustCommand\\citeyear{\\start@cite30}\t\t% January 2008\n\\def\\citeyearNP{\\citeyear*}\n%\\def\\citeN{%\n\\DeclareRobustCommand\\citeN{%\t\t\t\t% January 2008\n    \\@citeRB\n    \\def\\citeauthoryear##1##2##3{##1\\ [##3%\n        \\def\\reserved@a{##1}%\n        \\def\\citeauthoryear####1####2####3{%\n            \\def\\reserved@b{####1}%\n            \\ifx\\reserved@a\\reserved@b\n                ####3%\n            \\else\n                \\errmessage{Package acmart Error: author mismatch\n                         in \\string\\citeN^^J^^J%\n                    See the acmart package documentation for explanation}%\n            \\fi\n        }%\n    }%\n    \\@ifstar\\@citeyear\\@citeyear\n}\n%\\def\\shortciteN{%\n\\DeclareRobustCommand\\shortciteN{%\t\t\t% January 2008\n    \\@citeRB\n    \\def\\citeauthoryear##1##2##3{##2\\ [##3%\n        \\def\\reserved@a{##2}%\n        \\def\\citeauthoryear####1####2####3{%\n            \\def\\reserved@b{####2}%\n            \\ifx\\reserved@a\\reserved@b\n                ####3%\n            \\else\n                \\errmessage{Package acmart Error: author mismatch\n                         in \\string\\shortciteN^^J^^J%\n                    See the acmart package documentation for explanation}%\n            \\fi\n        }%\n    }%\n    \\@ifstar\\@citeyear\\@citeyear  % GM July 2000\n}\n\n\\def\\@citenormal{%\n    \\@ifnextchar [{\\@tempswatrue\\@citex;}%\n% original                 {\\@tempswafalse\\@citex,[]}% was ; Gerry 2/24/00\n{\\@tempswafalse\\@citex[]}%  \t% GERRY FIX FOR BABEL 3/20/2009\n}\n\n\\def\\@citeyear{%\n    \\@ifnextchar [{\\@tempswatrue\\@citex,}%\n% original                  {\\@tempswafalse\\@citex,[]}%\n{\\@tempswafalse\\@citex[]}%\t%  GERRY FIX FOR BABEL 3/20/2009\n}\n\n\\def\\@citex#1[#2]#3{%\n    \\let\\@citea\\@empty\n    \\@cite{%\n        \\@for\\@citeb:=#3\\do{%\n            \\@citea\n% original            \\def\\@citea{#1 }%\n            \\def\\@citea{#1, }% \t% GERRY FIX FOR BABEL 3/20/2009 -- SO THAT YOU GET [1, 2] IN THE BODY TEXT\n            \\edef\\@citeb{\\expandafter\\@iden\\@citeb}%\n            \\if@filesw\n                \\immediate\\write\\@auxout{\\string\\citation{\\@citeb}}%\n            \\fi\n            \\@ifundefined{b@\\@citeb}{%\n                {\\bf ?}%\n                \\@warning{%\n                    Citation `\\@citeb\' on page \\thepage\\space undefined%\n                }%\n            }%\n            {\\csname b@\\@citeb\\endcsname}%\n        }%\n    }{#2}%\n}\n%\\let\\@biblabel\\@gobble   % Dec. 2008 - Gerry\n% ----\n\\def\\@biblabelnum#1{[#1]} % Gerry\'s solution #1 - for Natbib -- April 2009\n\\let\\@biblabel=\\@biblabelnum  % Gerry\'s solution #1 - for Natbib -- April 2009\n\\def\\newblock{\\relax} % Gerry Dec. 2008\n% ---\n\\newdimen\\bibindent\n\\setcounter{enumi}{1}\n\\bibindent=0em\n\\def\\thebibliography#1{% \n\\ifnum\\addauflag=0\\addauthorsection\\global\\addauflag=1\\fi\n     \\section[References]{%    <=== OPTIONAL ARGUMENT ADDED HERE\n        {References} % was uppercased but this affects pdf bookmarks (SP/GM October 2004)\n          {\\vskip -2pt plus 1pt} % GM Nov. 2006 / GM July 2000 (for somewhat tighter spacing) \n         \\@mkboth{{\\refname}}{{\\refname}}%\n     }%\n     \\refsmall\n     \\list{[\\arabic{enumi}]}{%\n         \\settowidth\\labelwidth{[#1]}%\n         \\leftmargin\\labelwidth\n         \\advance\\leftmargin\\labelsep\n         \\advance\\leftmargin\\bibindent\n         \\parsep=0pt\\itemsep=5pt % GM July 2000\n         \\itemindent -\\bibindent\n         \\listparindent \\itemindent\n         \\usecounter{enumi}\n     }%\n     \\let\\newblock\\@empty\n     \\raggedright % GM July 2000\n     \\sloppy\n     \\sfcode`\\.=1000\\relax\n}\n\n\n\\gdef\\balancecolumns\n{\\vfill\\eject\n\\global\\@colht=\\textheight\n\\global\\ht\\@cclv=\\textheight\n}\n\n\\newcount\\colcntr\n\\global\\colcntr=0\n%\\newbox\\savebox\n\\newbox\\saveb@x\t\t\t\t% January 2008\n\n\\gdef \\@makecol {%\n\\global\\advance\\colcntr by 1\n\\ifnum\\colcntr>2 \\global\\colcntr=1\\fi\n   \\ifvoid\\footins\n     \\setbox\\@outputbox \\box\\@cclv\n   \\else\n     \\setbox\\@outputbox \\vbox{%\n\\boxmaxdepth \\@maxdepth\n       \\@tempdima\\dp\\@cclv\n       \\unvbox \\@cclv\n       \\vskip-\\@tempdima\n       \\vskip \\skip\\footins\n       \\color@begingroup\n         \\normalcolor\n         \\footnoterule\n         \\unvbox \\footins\n       \\color@endgroup\n       }%\n   \\fi\n   \\xdef\\@freelist{\\@freelist\\@midlist}%\n   \\global \\let \\@midlist \\@empty\n   \\@combinefloats\n   \\ifvbox\\@kludgeins\n     \\@makespecialcolbox\n   \\else\n     \\setbox\\@outputbox \\vbox to\\@colht {%\n\\@texttop\n       \\dimen@ \\dp\\@outputbox\n       \\unvbox \\@outputbox\n   \\vskip -\\dimen@\n       \\@textbottom\n       }%\n   \\fi\n   \\global \\maxdepth \\@maxdepth\n}\n\\def\\titlenote{\\@ifnextchar[\\@xtitlenote{\\stepcounter\\@mpfn\n\\global\\advance\\titlenotecount by 1\n\\ifnum\\titlenotecount=1\n    \\raisebox{9pt}{$\\ast$}\n\\fi\n\\ifnum\\titlenotecount=2\n    \\raisebox{9pt}{$\\dagger$}\n\\fi\n\\ifnum\\titlenotecount=3\n    \\raisebox{9pt}{$\\ddagger$}\n\\fi\n\\ifnum\\titlenotecount=4\n\\raisebox{9pt}{$\\S$}\n\\fi\n\\ifnum\\titlenotecount=5\n\\raisebox{9pt}{$\\P$}\n\\fi\n         \\@titlenotetext\n}}\n\n\\long\\def\\@titlenotetext#1{\\insert\\footins{%\n\\ifnum\\titlenotecount=1\\global\\tntoks={#1}\\fi\n\\ifnum\\titlenotecount=2\\global\\tntokstwo={#1}\\fi\n\\ifnum\\titlenotecount=3\\global\\tntoksthree={#1}\\fi\n\\ifnum\\titlenotecount=4\\global\\tntoksfour={#1}\\fi\n\\ifnum\\titlenotecount=5\\global\\tntoksfive={#1}\\fi\n    \\reset@font\\footnotesize\n    \\interlinepenalty\\interfootnotelinepenalty\n    \\splittopskip\\footnotesep\n    \\splitmaxdepth \\dp\\strutbox \\floatingpenalty \\@MM\n    \\hsize\\columnwidth \\@parboxrestore\n    \\protected@edef\\@currentlabel{%\n    }%\n    \\color@begingroup\n   \\color@endgroup}}\n\n%%%%%%%%%%%%%%%%%%%%%%%%%\n\\ps@plain\n\\baselineskip=11pt\n\\let\\thepage\\relax % For NO page numbers - GM Nov. 30th. 1999 and July 2000\n\\def\\setpagenumber#1{\\global\\setcounter{page}{#1}}\n%\\pagenumbering{arabic}  % Arabic page numbers GM July 2000\n\\twocolumn             % Double column.\n\\flushbottom           % Even bottom -- alas, does not balance columns at end of document\n\\pagestyle{plain}\n\n% Need Copyright Year and Copyright Data to be user definable (in .tex file).\n% Gerry Nov. 30th. 1999\n\\newtoks\\copyrtyr\n\\newtoks\\acmcopyr\n\\newtoks\\boilerplate\n\\global\\acmcopyr={X-XXXXX-XX-X/XX/XX}  % Default - 5/11/2001 *** Gerry\n\\global\\copyrtyr={20XX}                % Default - 3/3/2003 *** Gerry\n\\def\\CopyrightYear#1{\\global\\copyrtyr{#1}}\n\\def\\crdata#1{\\global\\acmcopyr{#1}}\n\\def\\permission#1{\\global\\boilerplate{#1}}\n%\n\\global\\boilerplate={}\n\\newtoks\\copyrightetc\n\\global\\copyrightetc{} % Gerry changed to 15 May 2012\n%\\toappear{\\the\\boilerplate\\par\n%{\\confname{\\the\\conf}} \\the\\confinfo\\par \\the\\copyrightetc.}\n%\\DeclareFixedFont{\\altcrnotice}{OT1}{tmr}{m}{n}{8}  % << patch needed for accenting e.g. Montreal - Gerry, May 2007\n%\\DeclareFixedFont{\\altconfname}{OT1}{tmr}{m}{it}{8}  % << patch needed for accenting in italicized confname - Gerry, May 2007\n%\n%{\\altconfname{{\\the\\conf}}} {\\altcrnotice\\the\\confinfo\\par} \\the\\copyrightetc.}  % << Gerry, May 2007\n%\n% The following section (i.e. 3 .sty inclusions) was added in May 2007 so as to fix the problems that many\n% authors were having with accents. Sometimes accents would occur, but the letter-character would be of a different\n% font. Conversely the letter-character font would be correct but, e.g. a \'bar\' would appear superimposed on the\n% character instead of, say, an unlaut/diaresis. Sometimes the letter-character would NOT appear at all.\n% Using [T1]{fontenc} outright was not an option as this caused 99% of the authors to \'produce\' a Type-3 (bitmapped)\n% PDF file - useless for production. \n%\n% For proper (font) accenting we NEED these packages to be part of the .cls file i.e. \'ae\', \'aecompl\' and \'aeguil\' \n% ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n%% This is file `ae.sty\' \n\\def\\fileversion{1.3}\n\\def\\filedate{2001/02/12}\n\\NeedsTeXFormat{LaTeX2e}\n%\\ProvidesPackage{ae}[\\filedate\\space\\fileversion\\space  % GM\n% Almost European Computer Modern]                       % GM - keeping the log file clean(er)\n\\newif\\if@ae@slides \\@ae@slidesfalse\n\\DeclareOption{slides}{\\@ae@slidestrue}\n\\ProcessOptions\n\\fontfamily{aer}\n\\RequirePackage[T1]{fontenc}\n\\if@ae@slides\n    \\renewcommand{\\sfdefault}{laess}\n    \\renewcommand{\\rmdefault}{laess} % no roman\n    \\renewcommand{\\ttdefault}{laett}\n\\else\n    \\renewcommand{\\sfdefault}{aess}\n    \\renewcommand{\\rmdefault}{aer}\n    \\renewcommand{\\ttdefault}{aett}\n\\fi\n\\endinput\n%% \n%% End of file `ae.sty\'.\n%\n%\n\\def\\fileversion{0.9}\n\\def\\filedate{1998/07/23}\n\\NeedsTeXFormat{LaTeX2e}\n%\\ProvidesPackage{aecompl}[\\filedate\\space\\fileversion\\space   % GM\n%T1 Complements for AE fonts (D. Roegel)]                      % GM -- keeping the log file clean(er)\n \n\\def\\@ae@compl#1{{\\fontencoding{T1}\\fontfamily{cmr}\\selectfont\\symbol{#1}}}\n\\def\\guillemotleft{\\@ae@compl{19}}\n\\def\\guillemotright{\\@ae@compl{20}}\n\\def\\guilsinglleft{\\@ae@compl{14}}\n\\def\\guilsinglright{\\@ae@compl{15}}\n\\def\\TH{\\@ae@compl{222}}\n\\def\\NG{\\@ae@compl{141}}\n\\def\\ng{\\@ae@compl{173}}\n\\def\\th{\\@ae@compl{254}}\n\\def\\DJ{\\@ae@compl{208}}\n\\def\\dj{\\@ae@compl{158}}\n\\def\\DH{\\@ae@compl{208}}\n\\def\\dh{\\@ae@compl{240}}\n\\def\\@perthousandzero{\\@ae@compl{24}}\n\\def\\textperthousand{\\%\\@perthousandzero}\n\\def\\textpertenthousand{\\%\\@perthousandzero\\@perthousandzero}\n\\endinput\n%\n%\n%% This is file `aeguill.sty\' \n% This file gives french guillemets (and not guillemots!)\n% built with the Polish CMR fonts (default), WNCYR fonts, the LASY fonts \n% or with the EC fonts. \n% This is useful in conjunction with the ae package\n% (this package loads the ae package in case it has not been loaded)\n%  and with or without the french(le) package.\n%\n% In order to get the guillemets, it is necessary to either type\n% \\guillemotleft and \\guillemotright, or to use an 8 bit encoding\n% (such as ISO-Latin1) which selects these two commands, \n% or, if you use the french package (but not the frenchle package), \n% to type << or >>.\n%\n% By default, you get the Polish CMR guillemets; if this package is loaded\n% with the `cm\' option, you get the LASY guillemets; with `ec,\' you\n% get the EC guillemets, and with `cyr,\' you get the cyrillic guillemets.\n%\n% In verbatim mode, you always get the EC/TT guillemets.\n%\n% The default option is interesting in conjunction with PDF,\n% because there is a Type 1 version of the Polish CMR fonts\n% and these guillemets are very close in shape to the EC guillemets.\n% There are no free Type 1 versions of the EC fonts.\n%\n% Support for Polish CMR guillemets was kindly provided by \n% Rolf Niepraschk <niepraschk@ptb.de> in version 0.99 (2000/05/22).\n% Bernd Raichle provided extensive simplifications to the code\n% for version 1.00.\n%\n% This package is released under the LPPL.\n%\n% Changes:\n%   Date        version\n%   2001/04/12  1.01    the frenchle and french package are now distinguished.\n%\n\\def\\fileversion{1.01}\n\\def\\filedate{2001/04/12}\n\\NeedsTeXFormat{LaTeX2e}\n%\\ProvidesPackage{aeguill}[2001/04/12 1.01 %    % GM\n%AE fonts with french guillemets (D. Roegel)]   % GM - keeping the log file clean(er)\n%\\RequirePackage{ae}  % GM May 2007 - already embedded here\n\n\\newcommand{\\@ae@switch}[4]{#4}\n\\DeclareOption{ec}{\\renewcommand\\@ae@switch[4]{#1}}\n\\DeclareOption{cm}{\\renewcommand\\@ae@switch[4]{#2}}\n\\DeclareOption{cyr}{\\renewcommand\\@ae@switch[4]{#3}}\n\\DeclareOption{pl}{\\renewcommand\\@ae@switch[4]{#4}}\n\\ExecuteOptions{pl}\n\\ProcessOptions\n\n%\n% Load necessary packages\n%\n\\@ae@switch{% ec\n  % do nothing\n}{% cm\n  \\RequirePackage{latexsym}%  GM - May 2007 - already \'mentioned as required\' up above\n}{% cyr\n  \\RequirePackage[OT2,T1]{fontenc}%\n}{% pl\n  \\RequirePackage[OT4,T1]{fontenc}%\n}\n\n% The following command will be compared to \\frenchname,\n% as defined in french.sty and frenchle.sty.\n\\def\\aeguillfrenchdefault{french}%\n\n\\let\\guill@verbatim@font\\verbatim@font\n\\def\\verbatim@font{\\guill@verbatim@font\\ecguills{cmtt}%\n                   \\let\\guillemotleft\\@oguills\\let\\guillemotright\\@fguills}\n\n\\begingroup \\catcode`\\<=13 \\catcode`\\>=13\n\\def\\x{\\endgroup\n \\def\\ae@lfguill{<<}%\n \\def\\ae@rfguill{>>}%\n}\\x\n\n\\newcommand{\\ecguills}[1]{%\n  \\def\\selectguillfont{\\fontencoding{T1}\\fontfamily{#1}\\selectfont}%\n  \\def\\@oguills{{\\selectguillfont\\symbol{19}}}%\n  \\def\\@fguills{{\\selectguillfont\\symbol{20}}}%\n  } \n\n\\newcommand{\\aeguills}{%\n  \\ae@guills\n  % We redefine \\guillemotleft and \\guillemotright\n  % in order to catch them when they are used \n  % with \\DeclareInputText (in latin1.def for instance)\n  % We use \\auxWARNINGi as a safe indicator that french.sty is used.\n  \\gdef\\guillemotleft{\\ifx\\auxWARNINGi\\undefined\n                         \\@oguills % neither french.sty nor frenchle.sty\n                      \\else\n                         \\ifx\\aeguillfrenchdefault\\frenchname\n                           \\ae@lfguill  % french.sty\n                         \\else\n                           \\@oguills    % frenchle.sty\n                         \\fi\n                      \\fi}%\n  \\gdef\\guillemotright{\\ifx\\auxWARNINGi\\undefined\n                         \\@fguills % neither french.sty nor frenchle.sty\n                       \\else\n                         \\ifx\\aeguillfrenchdefault\\frenchname\n                           \\ae@rfguill  % french.sty\n                         \\else\n                           \\@fguills    % frenchle.sty\n                         \\fi\n                       \\fi}%\n  }\n\n%\n% Depending on the class option\n% define the internal command \\ae@guills\n\\@ae@switch{% ec\n  \\newcommand{\\ae@guills}{%\n    \\ecguills{cmr}}%\n}{% cm\n  \\newcommand{\\ae@guills}{%\n    \\def\\selectguillfont{\\fontencoding{U}\\fontfamily{lasy}%\n            \\fontseries{m}\\fontshape{n}\\selectfont}%\n    \\def\\@oguills{\\leavevmode\\nobreak\n                \\hbox{\\selectguillfont (\\kern-.20em(\\kern.20em}\\nobreak}%\n    \\def\\@fguills{\\leavevmode\\nobreak\n                \\hbox{\\selectguillfont \\kern.20em)\\kern-.2em)}%\n                \\ifdim\\fontdimen\\@ne\\font>\\z@\\/\\fi}}%\n}{% cyr\n  \\newcommand{\\ae@guills}{%\n    \\def\\selectguillfont{\\fontencoding{OT2}\\fontfamily{wncyr}\\selectfont}%\n    \\def\\@oguills{{\\selectguillfont\\symbol{60}}}%\n    \\def\\@fguills{{\\selectguillfont\\symbol{62}}}}\n}{% pl\n  \\newcommand{\\ae@guills}{%\n    \\def\\selectguillfont{\\fontencoding{OT4}\\fontfamily{cmr}\\selectfont}%\n    \\def\\@oguills{{\\selectguillfont\\symbol{174}}}%\n    \\def\\@fguills{{\\selectguillfont\\symbol{175}}}}\n}\n\n\n\\AtBeginDocument{%\n  \\ifx\\GOfrench\\undefined\n    \\aeguills\n  \\else\n    \\let\\aeguill@GOfrench\\GOfrench\n    \\gdef\\GOfrench{\\aeguill@GOfrench \\aeguills}%\n  \\fi\n  }\n\n\\endinput\n%\n\n'
p0
.I0
.S'Head'
p0
.S''
p0
.I6
.S'Doc class'
p0
.S'$head: \\documentclass{sig-alternate}'
p0
.I0
.S'Prereqs'
p0
.S'$head:\n\\usepackage{epsfig}\n\\usepackage{amsmath,environ}\n\\usepackage{color}\n\\usepackage{graphicx}\n\\usepackage{listings}\n\\usepackage{pdfsync}\n%\\usepackage{caption}\n\\usepackage[format=plain,font={bf,footnotesize},skip=3mm]{caption}\n\\usepackage{algorithm}\n\\usepackage{algpseudocode}\n\\usepackage{subcaption}\n\\usepackage{todonotes}\n\\newcommand{\\redcomment}[1]{\\todo[inline,color=red!40,size=\\small]{#1}}\n\\newcommand{\\greencomment}[1]{\\todo[inline,color=green!40,size=\\small]{#1}}\n\\newcommand{\\bluecomment}[1]{\\todo[inline,color=blue!40,size=\\small]{#1}}\n\\newcommand{\\yellowcomment}[1]{\\todo[inline,color=yellow!40,size=\\small]{#1}}\n\\lstset{language=C++, basicstyle=\\footnotesize}\n\\usepackage{etoolbox}'
p0
.I0
.S'Recommended'
p0
.S'$head:\n\\usepackage{balance}\n\\usepackage{cite}'
p0
.I0
.S'Your stuff'
p0
.S'$head:\n\n\\newcommand{\\ignore}[1]{}\n\\usepackage{fancyhdr}\n\\usepackage[normalem]{ulem}\n\\usepackage[hyphens]{url}\n\\usepackage{hyperref}\n\n%%%%%%%%%%%---SETME-----%%%%%%%%%%%%%\n\\newcommand{\\microsubmissionnumber}{043}\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n\\fancypagestyle{firstpage}{\n  \\fancyhf{}\n\\setlength{\\headheight}{50pt}\n\\renewcommand{\\headrulewidth}{0pt}\n  \\fancyhead[C]{\\normalsize{MICRO 2015 Submission\n      \\textbf{\\#\\microsubmissionnumber} -- Confidential Draft -- Do NOT Distribute!!}} \n  \\pagenumbering{arabic}\n}\n\n% To improve the table/figure captions'
p0
.I0
.S'Start doc'
p0
.S'$head: \n\\date{}\n\\begin{document}\n\\thispagestyle{firstpage}\n\\pagestyle{plain}'
p0
.I0
.S'Authors'
p0
.S'\\author{Jason Mars ~~ Lingjia Tang\\\\\nAdvanced Computer Architecture Laboratory\\\\\nUniversity of Michigan - Ann Arbor, MI\\\\\n\\texttt{\\{profmars, lingjia\\}@umich.edu}\n}'
p0
.I0
.S'Tail'
p0
.S''
p0
.I1
.S'Standard Tail'
p0
.S'$tail:\n\\bibliographystyle{ieeetr}\n%\\singlespacing\n%\\scriptsize\n\\balance\n\\bibliography{bib}\n\\end{document}'
p0
.I0
.